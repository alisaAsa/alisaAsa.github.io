<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>常见安全算法</title>
    <link href="/2020/05/25/%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E7%AE%97%E6%B3%95/"/>
    <url>/2020/05/25/%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>本文整理了常见的安全算法，包括MD5、SHA、DES、AES、RSA等，并写了完整的工具类（Java 版），工具类包含测试。 </p><h2 id="一、数字摘要算法"><a href="#一、数字摘要算法" class="headerlink" title="一、数字摘要算法"></a>一、数字摘要算法</h2><blockquote><p>数字摘要也称为消息摘要，它是一个唯一对应一个消息或文本的固定长度的值，它由一个单向Hash函数对消息进行计算而产生。如果消息在传递的途中改变了，接收者通过对收到消息采用相同的Hash重新计算，新产生的摘要与原摘要进行比较，就可知道消息是否被篡改了，因此消息摘要能够验证消息的完整性。消息摘要采用单向Hash函数将需要计算的内容”摘要”成固定长度的串，这个串亦称为数字指纹。这个串有固定的长度，且不同的明文摘要成密文，其结果总是不同的(相对的)，而同样的明文其摘要必定一致。这样这串摘要便可成为验证明文是否是”真身”的”指纹”了。     </p></blockquote><h3 id="1-Md5"><a href="#1-Md5" class="headerlink" title="1. Md5"></a>1. Md5</h3><p>MD5即Message Digest Algorithm 5(信息摘要算法5)，是数字摘要算法一种实现，用于确保信息传输完整性和一致性，摘要长度为128位。 MD5由MD4、 MD3、 MD2改进而来，主要增强算法复杂度和不可逆性，该算法因其普遍、稳定、快速的特点，在产业界得到了极为广泛的使用，目前主流的编程语言普遍都已有MD5算法实现。 </p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.security.MessageDigest;<span class="hljs-keyword">import</span> java.security.NoSuchAlgorithmException;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Message Digest Algorithm 5(信息摘要算法5)</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MD5Util</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Constructs the MD5Util object and sets the string whose MD5Util is to be</span><span class="hljs-comment">     * computed.</span><span class="hljs-comment">     * </span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> inStr</span><span class="hljs-comment">     *    the &lt;code&gt;String&lt;/code&gt; whose MD5Util is to be computed</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String COMMON_KEY=<span class="hljs-string">"zhongzhuoxin#@!321"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MD5Util</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">str2MD5</span><span class="hljs-params">(String inStr)</span> </span>&#123;        <span class="hljs-keyword">char</span> hexDigits[] = &#123; <span class="hljs-string">'0'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'4'</span>, <span class="hljs-string">'5'</span>, <span class="hljs-string">'6'</span>, <span class="hljs-string">'7'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'9'</span>,                <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'f'</span> &#125;;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">byte</span>[] strTemp = inStr.getBytes(<span class="hljs-string">"UTF-8"</span>);            MessageDigest mdTemp = MessageDigest.getInstance(<span class="hljs-string">"MD5"</span>);            mdTemp.update(strTemp);            <span class="hljs-keyword">byte</span>[] md = mdTemp.digest();            <span class="hljs-keyword">int</span> j = md.length;            <span class="hljs-keyword">char</span> str[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[j * <span class="hljs-number">2</span>];            <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; j; i++) &#123;                <span class="hljs-keyword">byte</span> byte0 = md[i];                str[k++] = hexDigits[byte0 &gt;&gt;&gt; <span class="hljs-number">4</span> &amp; <span class="hljs-number">0xf</span>];                str[k++] = hexDigits[byte0 &amp; <span class="hljs-number">0xf</span>];            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(str);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;    <span class="hljs-comment">//--MD5Util</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> HEX_DIGITS[] = &#123; <span class="hljs-string">'0'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'4'</span>, <span class="hljs-string">'5'</span>,            <span class="hljs-string">'6'</span>, <span class="hljs-string">'7'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'9'</span>, <span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'F'</span> &#125;;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">toHexString</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] b)</span> </span>&#123; <span class="hljs-comment">// String to byte</span>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(b.length * <span class="hljs-number">2</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; b.length; i++) &#123;            sb.append(HEX_DIGITS[(b[i] &amp; <span class="hljs-number">0xf0</span>) &gt;&gt;&gt; <span class="hljs-number">4</span>]);            sb.append(HEX_DIGITS[b[i] &amp; <span class="hljs-number">0x0f</span>]);        &#125;        <span class="hljs-keyword">return</span> sb.toString();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">AndroidMd5</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// Create MD5Util Hash</span>            MessageDigest digest = MessageDigest                    .getInstance(<span class="hljs-string">"MD5"</span>);            digest.update(s.getBytes());            <span class="hljs-keyword">byte</span> messageDigest[] = digest.digest();            <span class="hljs-keyword">return</span> toHexString(messageDigest);        &#125; <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String m = MD5Util.str2MD5(<span class="hljs-string">"swwwwwwwwwwdkinner"</span>);        System.out.print(m.length() + <span class="hljs-string">"    "</span>);        System.out.println(m);    &#125;&#125;</code></pre><h3 id="2-SHA"><a href="#2-SHA" class="headerlink" title="2.SHA"></a>2.SHA</h3><p>SHA的全称是Secure Hash Algorithm，即安全散列算法。 1993年，安全散列算法(SHA)由美国国家标准和技术协会（NIST)提出，并作为联邦信息处理标准(FIPS PUB 180)公布， 1995年又发布了一个修订版FIPS PUB 180-1，通常称之为SHA-1。 SHA-1是基于MD4算法的，现在已成为公认的最安全的散列算法之一，并被广泛使用。SHA-1算法生成的摘要信息的长度为160位，由于生成的摘要信息更长，运算的过程更加复杂，在相同的硬件上， SHA-1的运行速度比MD5更慢，但是也更为安全。 </p><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.google.common.base.Strings;<span class="hljs-keyword">import</span> java.security.MessageDigest;<span class="hljs-comment">/**</span><span class="hljs-comment"> * SHA的全称是Secure Hash Algorithm，即安全散列算法</span><span class="hljs-comment"> * Created by fangzhipeng on 2017/3/21.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SHAUtil</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 定义加密方式</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String KEY_SHA = <span class="hljs-string">"SHA"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String KEY_SHA1 = <span class="hljs-string">"SHA-1"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 全局数组</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String[] hexDigits = &#123; <span class="hljs-string">"0"</span>, <span class="hljs-string">"1"</span>, <span class="hljs-string">"2"</span>, <span class="hljs-string">"3"</span>, <span class="hljs-string">"4"</span>, <span class="hljs-string">"5"</span>,            <span class="hljs-string">"6"</span>, <span class="hljs-string">"7"</span>, <span class="hljs-string">"8"</span>, <span class="hljs-string">"9"</span>, <span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>, <span class="hljs-string">"d"</span>, <span class="hljs-string">"e"</span>, <span class="hljs-string">"f"</span> &#125;;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 构造函数</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SHAUtil</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * SHA 加密</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 需要加密的字节数组</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 加密之后的字节数组</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] encryptSHA(<span class="hljs-keyword">byte</span>[] data) <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-comment">// 创建具有指定算法名称的信息摘要</span><span class="hljs-comment">//        MessageDigest sha = MessageDigest.getInstance(KEY_SHA);</span>        MessageDigest sha = MessageDigest.getInstance(KEY_SHA1);        <span class="hljs-comment">// 使用指定的字节数组对摘要进行最后更新</span>        sha.update(data);        <span class="hljs-comment">// 完成摘要计算并返回</span>        <span class="hljs-keyword">return</span> sha.digest();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * SHA 加密</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 需要加密的字符串</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 加密之后的字符串</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">encryptSHA</span><span class="hljs-params">(String data)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 验证传入的字符串</span>        <span class="hljs-keyword">if</span> (Strings.isNullOrEmpty(data)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;        &#125;        <span class="hljs-comment">// 创建具有指定算法名称的信息摘要</span>        MessageDigest sha = MessageDigest.getInstance(KEY_SHA);        <span class="hljs-comment">// 使用指定的字节数组对摘要进行最后更新</span>        sha.update(data.getBytes());        <span class="hljs-comment">// 完成摘要计算</span>        <span class="hljs-keyword">byte</span>[] bytes = sha.digest();        <span class="hljs-comment">// 将得到的字节数组变成字符串返回</span>        <span class="hljs-keyword">return</span> byteArrayToHexString(bytes);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将一个字节转化成十六进制形式的字符串</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> b 字节数组</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 字符串</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">byteToHexString</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> b)</span> </span>&#123;        <span class="hljs-keyword">int</span> ret = b;        <span class="hljs-comment">//System.out.println("ret = " + ret);</span>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;            ret += <span class="hljs-number">256</span>;        &#125;        <span class="hljs-keyword">int</span> m = ret / <span class="hljs-number">16</span>;        <span class="hljs-keyword">int</span> n = ret % <span class="hljs-number">16</span>;        <span class="hljs-keyword">return</span> hexDigits[m] + hexDigits[n];    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 转换字节数组为十六进制字符串</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bytes 字节数组</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 十六进制字符串</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">byteArrayToHexString</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] bytes)</span> </span>&#123;        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; bytes.length; i++) &#123;            sb.append(byteToHexString(bytes[i]));        &#125;        <span class="hljs-keyword">return</span> sb.toString();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 测试方法</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        String key = <span class="hljs-string">"123"</span>;        System.out.println(encryptSHA(key));    &#125;&#125;</code></pre><h2 id="二、对称加密"><a href="#二、对称加密" class="headerlink" title="二、对称加密"></a>二、对称加密</h2><blockquote><p>对称加密算法是应用较早的加密算法，技术成熟。在对称加密算法中，数据发送方将明文(原始数据)和加密密钥一起经过特殊加密算法处理后，生成复杂的加密密文进行发送，数据接收方收到密文后，若想读取原文，则需要使用加密使用的密钥及相同算法的逆算法对加密的密文进行解密，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发送和接收双方都使用这个密钥对数据进行加密和解密，这就要求加密和解密方事先都必须知道加密的密钥。     </p></blockquote><h3 id="1-DES算法"><a href="#1-DES算法" class="headerlink" title="1. DES算法"></a>1. DES算法</h3><p>1973 年，美国国家标准局(NBS)在认识到建立数据保护标准既明显又急迫的情况下，开始征集联邦数据加密标准的方案。 1975 年3月17日， NBS公布了IBM公司提供的密码算法，以标准建议的形式在全国范围内征求意见。经过两年多的公开讨论之后， 1977 年7月15日， NBS宣布接受这建议，作为联邦信息处理标准46 号数据加密标准(Data Encryptin Standard)，即DES正式颁布，供商业界和非国防性政府部门使用。DES算法属于对称加密算法，明文按64位进行分组，密钥长64位，但事实上只有56位参与DES<br>运算(第8、 16、 24、 32、 40、 48、 56、 64位是校验位，使得每个密钥都有奇数个1),分组后的明文和56位的密钥按位替代或交换的方法形成密文。由于计算机运算能力的增强，原版DES密码的密钥长度变得容易被暴力破解，因此演变出了3DES算法。 3DES是DES向AES过渡的加密算法，它使用3条56位的密钥对数据进行三次加密，是DES的一个更安全的变形。</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.security.SecureRandom;<span class="hljs-keyword">import</span> javax.crypto.Cipher;<span class="hljs-keyword">import</span> javax.crypto.SecretKey;<span class="hljs-keyword">import</span> javax.crypto.SecretKeyFactory;<span class="hljs-keyword">import</span> javax.crypto.spec.DESKeySpec;<span class="hljs-keyword">import</span> sun.misc.BASE64Decoder;<span class="hljs-keyword">import</span> sun.misc.BASE64Encoder;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Data Encryptin Standard</span><span class="hljs-comment"> * 数据加密标准</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DESUtil</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String DES = <span class="hljs-string">"DES"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Description 根据键值进行加密</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  加密键byte数组</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">encrypt</span><span class="hljs-params">(String data, String key)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">byte</span>[] bt = encrypt(data.getBytes(), key.getBytes());        String strs = <span class="hljs-keyword">new</span> BASE64Encoder().encode(bt);        <span class="hljs-keyword">return</span> strs;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Description 根据键值进行解密</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  加密键byte数组</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">decrypt</span><span class="hljs-params">(String data, String key)</span> <span class="hljs-keyword">throws</span> Exception,</span><span class="hljs-function">            Exception </span>&#123;        <span class="hljs-keyword">if</span> (data == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        BASE64Decoder decoder = <span class="hljs-keyword">new</span> BASE64Decoder();        <span class="hljs-keyword">byte</span>[] buf = decoder.decodeBuffer(data);        <span class="hljs-keyword">byte</span>[] bt = decrypt(buf, key.getBytes());        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(bt);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Description 根据键值进行加密</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  加密键byte数组</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] encrypt(<span class="hljs-keyword">byte</span>[] data, <span class="hljs-keyword">byte</span>[] key) <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-comment">// 生成一个可信任的随机数源</span>        SecureRandom sr = <span class="hljs-keyword">new</span> SecureRandom();        <span class="hljs-comment">// 从原始密钥数据创建DESKeySpec对象</span>        DESKeySpec dks = <span class="hljs-keyword">new</span> DESKeySpec(key);        <span class="hljs-comment">// 创建一个密钥工厂，然后用它把DESKeySpec转换成SecretKey对象</span>        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(DES);        SecretKey securekey = keyFactory.generateSecret(dks);        <span class="hljs-comment">// Cipher对象实际完成加密操作</span>        Cipher cipher = Cipher.getInstance(DES);        <span class="hljs-comment">// 用密钥初始化Cipher对象</span>        cipher.init(Cipher.ENCRYPT_MODE, securekey, sr);        <span class="hljs-keyword">return</span> cipher.doFinal(data);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Description 根据键值进行解密</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key  加密键byte数组</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] decrypt(<span class="hljs-keyword">byte</span>[] data, <span class="hljs-keyword">byte</span>[] key) <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-comment">// 生成一个可信任的随机数源</span>        SecureRandom sr = <span class="hljs-keyword">new</span> SecureRandom();        <span class="hljs-comment">// 从原始密钥数据创建DESKeySpec对象</span>        DESKeySpec dks = <span class="hljs-keyword">new</span> DESKeySpec(key);        <span class="hljs-comment">// 创建一个密钥工厂，然后用它把DESKeySpec转换成SecretKey对象</span>        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(DES);        SecretKey securekey = keyFactory.generateSecret(dks);        <span class="hljs-comment">// Cipher对象实际完成解密操作</span>        Cipher cipher = Cipher.getInstance(DES);        <span class="hljs-comment">// 用密钥初始化Cipher对象</span>        cipher.init(Cipher.DECRYPT_MODE, securekey, sr);        <span class="hljs-keyword">return</span> cipher.doFinal(data);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[]args)</span><span class="hljs-keyword">throws</span> Exception</span>&#123;       String  sStr=encrypt(<span class="hljs-string">"122222112222:12343232323:jajwwwwslwskwkkwksk"</span>,<span class="hljs-string">"wew2323w233321ws233w"</span>);       System.out.println(sStr);       String mStr=decrypt(sStr,<span class="hljs-string">"wew2323w233321ws233w"</span>);       System.out.println(mStr);    &#125;&#125;</code></pre><h3 id="2-AES"><a href="#2-AES" class="headerlink" title="2. AES"></a>2. AES</h3><p>AES的全称是Advanced Encryption Standard，即高级加密标准，该算法由比利时密码学家Joan Daemen和Vincent Rijmen所设计，结合两位作者的名字，又称Rijndael加密算法，是美国联邦政府采用的一种对称加密标准，这个标准用来替代原先的DES算法，已经广为全世界所使用，已然成为对称加密算法中最流行的算法之一。AES算法作为新一代的数据加密标准汇聚了强安全性、高性能、高效率、易用和灵活等优<br>点，设计有三个密钥长度:128,192,256位，比DES算法的加密强度更高，更为安全。 </p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.UnsupportedEncodingException;<span class="hljs-keyword">import</span> java.security.InvalidKeyException;<span class="hljs-keyword">import</span> java.security.NoSuchAlgorithmException;<span class="hljs-keyword">import</span> java.security.SecureRandom;<span class="hljs-keyword">import</span> java.util.Base64;<span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">import</span> javax.crypto.BadPaddingException;<span class="hljs-keyword">import</span> javax.crypto.Cipher;<span class="hljs-keyword">import</span> javax.crypto.IllegalBlockSizeException;<span class="hljs-keyword">import</span> javax.crypto.KeyGenerator;<span class="hljs-keyword">import</span> javax.crypto.NoSuchPaddingException;<span class="hljs-keyword">import</span> javax.crypto.SecretKey;<span class="hljs-keyword">import</span> javax.crypto.spec.SecretKeySpec;<span class="hljs-keyword">import</span> sun.misc.BASE64Decoder;<span class="hljs-keyword">import</span> sun.misc.BASE64Encoder;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Created by fangzhipeng on 2017/3/21.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AESUtil</span> </span>&#123;    <span class="hljs-keyword">static</span>  <span class="hljs-keyword">byte</span>[]  key = <span class="hljs-string">"w@#$4@#$s^&amp;3*&amp;^4"</span>.getBytes();    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String algorithm=<span class="hljs-string">"AES"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">encrypt</span><span class="hljs-params">(String data)</span></span>&#123;        <span class="hljs-keyword">byte</span>[] dataToSend = data.getBytes();        Cipher c = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            c = Cipher.getInstance(algorithm);        &#125; <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) &#123;            <span class="hljs-comment">// TODO Auto-generated catch block</span>            e.printStackTrace();        &#125; <span class="hljs-keyword">catch</span> (NoSuchPaddingException e) &#123;            <span class="hljs-comment">// TODO Auto-generated catch block</span>            e.printStackTrace();        &#125;        SecretKeySpec k =  <span class="hljs-keyword">new</span> SecretKeySpec(key, algorithm);        <span class="hljs-keyword">try</span> &#123;            c.init(Cipher.ENCRYPT_MODE, k);        &#125; <span class="hljs-keyword">catch</span> (InvalidKeyException e) &#123;            <span class="hljs-comment">// TODO Auto-generated catch block</span>            e.printStackTrace();        &#125;        <span class="hljs-keyword">byte</span>[] encryptedData = <span class="hljs-string">""</span>.getBytes();        <span class="hljs-keyword">try</span> &#123;            encryptedData = c.doFinal(dataToSend);        &#125; <span class="hljs-keyword">catch</span> (IllegalBlockSizeException e) &#123;            <span class="hljs-comment">// TODO Auto-generated catch block</span>            e.printStackTrace();        &#125; <span class="hljs-keyword">catch</span> (BadPaddingException e) &#123;            <span class="hljs-comment">// TODO Auto-generated catch block</span>            e.printStackTrace();        &#125;        <span class="hljs-keyword">byte</span>[] encryptedByteValue =     Base64.getEncoder().encode(encryptedData);        <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> String(encryptedByteValue);<span class="hljs-comment">//.toString();</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">decrypt</span><span class="hljs-params">(String data)</span></span>&#123;        <span class="hljs-keyword">byte</span>[] encryptedData  =  Base64.getDecoder().decode(data);        Cipher c = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            c = Cipher.getInstance(algorithm);        &#125; <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) &#123;            <span class="hljs-comment">// TODO Auto-generated catch block</span>            e.printStackTrace();        &#125; <span class="hljs-keyword">catch</span> (NoSuchPaddingException e) &#123;            <span class="hljs-comment">// TODO Auto-generated catch block</span>            e.printStackTrace();        &#125;        SecretKeySpec k =                <span class="hljs-keyword">new</span> SecretKeySpec(key, algorithm);        <span class="hljs-keyword">try</span> &#123;            c.init(Cipher.DECRYPT_MODE, k);        &#125; <span class="hljs-keyword">catch</span> (InvalidKeyException e1) &#123;            <span class="hljs-comment">// TODO Auto-generated catch block</span>            e1.printStackTrace();        &#125;        <span class="hljs-keyword">byte</span>[] decrypted = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            decrypted = c.doFinal(encryptedData);        &#125; <span class="hljs-keyword">catch</span> (IllegalBlockSizeException e) &#123;            <span class="hljs-comment">// TODO Auto-generated catch block</span>            e.printStackTrace();        &#125; <span class="hljs-keyword">catch</span> (BadPaddingException e) &#123;            <span class="hljs-comment">// TODO Auto-generated catch block</span>            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(decrypted);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        String password=encrypt(<span class="hljs-string">"12233440988:1239874389888:dd333"</span>);        System.out.println(password);        System.out.println(decrypt(password));    &#125;&#125;</code></pre><h2 id="三、非对称加密"><a href="#三、非对称加密" class="headerlink" title="三、非对称加密"></a>三、非对称加密</h2><blockquote><p>非对称加密算法又称为公开密钥加密算法，它需要两个密钥，一个称为公开密钥(public key)，即公钥，另一个称为私有密钥(private key)，即私钥。公钥与私钥需要配对使用，如果用公钥对数据进行加密，只有用对应的私钥才能进行解密，而如果使用私钥对数据进行加密，那么只有用对应的公钥才能进行解密。因为加密和解密使用的是两个不同的密钥，所以这种算法称为非对称加密算法。非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公钥向其它人公开，得到该公钥的乙方使用该密钥对机密信息进行加密后再发送给甲方，甲方再使用自己保存的另一把专用密钥，即私钥，对加密后的信息进行解密。     </p></blockquote><h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p>RSA非对称加密算法是1977年由Ron Rivest、 Adi Shamirh和LenAdleman开发的， RSA取名来自开发他们三者的名字。 RSA是目前最有影响力的非对称加密算法，它能够抵抗到目前为止已知的所有密码攻击，已被ISO推荐为公钥数据加密标准。 RSA算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但反过来想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。 </p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Created by fangzhipeng on 2017/3/21.</span><span class="hljs-comment"> * RSA ：RSA非对称加密算法是1977年由Ron Rivest、 Adi Shamirh和LenAdleman开发   *  的， RSA取名来</span><span class="hljs-comment"> *  自开发他们三者的名字。</span><span class="hljs-comment"> * 参考：http://blog.csdn.net/wangqiuyun/article/details/42143957</span><span class="hljs-comment"> */</span><span class="hljs-keyword">import</span> java.io.*;<span class="hljs-keyword">import</span> java.security.InvalidKeyException;<span class="hljs-keyword">import</span> java.security.KeyFactory;<span class="hljs-keyword">import</span> java.security.KeyPair;<span class="hljs-keyword">import</span> java.security.KeyPairGenerator;<span class="hljs-keyword">import</span> java.security.NoSuchAlgorithmException;<span class="hljs-keyword">import</span> java.security.SecureRandom;<span class="hljs-keyword">import</span> java.security.interfaces.RSAPrivateKey;<span class="hljs-keyword">import</span> java.security.interfaces.RSAPublicKey;<span class="hljs-keyword">import</span> java.security.spec.InvalidKeySpecException;<span class="hljs-keyword">import</span> java.security.spec.PKCS8EncodedKeySpec;<span class="hljs-keyword">import</span> java.security.spec.X509EncodedKeySpec;<span class="hljs-keyword">import</span> java.util.Base64;<span class="hljs-keyword">import</span> javax.crypto.BadPaddingException;<span class="hljs-keyword">import</span> javax.crypto.Cipher;<span class="hljs-keyword">import</span> javax.crypto.IllegalBlockSizeException;<span class="hljs-keyword">import</span> javax.crypto.NoSuchPaddingException;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RSAUtil</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 字节数据转字符串专用集合</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[] HEX_CHAR = &#123; <span class="hljs-string">'0'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'4'</span>, <span class="hljs-string">'5'</span>, <span class="hljs-string">'6'</span>,            <span class="hljs-string">'7'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'9'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'f'</span> &#125;;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 随机生成密钥对</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">genKeyPair</span><span class="hljs-params">(String filePath)</span> </span>&#123;        <span class="hljs-comment">// KeyPairGenerator类用于生成公钥和私钥对，基于RSA算法生成对象</span>        KeyPairGenerator keyPairGen = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            keyPairGen = KeyPairGenerator.getInstance(<span class="hljs-string">"RSA"</span>);        &#125; <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) &#123;            <span class="hljs-comment">// TODO Auto-generated catch block</span>            e.printStackTrace();        &#125;        <span class="hljs-comment">// 初始化密钥对生成器，密钥大小为96-1024位</span>        keyPairGen.initialize(<span class="hljs-number">1024</span>,<span class="hljs-keyword">new</span> SecureRandom());        <span class="hljs-comment">// 生成一个密钥对，保存在keyPair中</span>        KeyPair keyPair = keyPairGen.generateKeyPair();        <span class="hljs-comment">// 得到私钥</span>        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();        <span class="hljs-comment">// 得到公钥</span>        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 得到公钥字符串</span>            <span class="hljs-comment">// 得到私钥字符串</span>            String privateKeyString =<span class="hljs-keyword">new</span> String( Base64.getEncoder().encode(privateKey.getEncoded()));            String publicKeyString =<span class="hljs-keyword">new</span> String( Base64.getEncoder().encode(publicKey.getEncoded()));            <span class="hljs-comment">// 将密钥对写入到文件</span>            File file1=<span class="hljs-keyword">new</span> File(filePath + <span class="hljs-string">"publicKey.keystore"</span>);            File file2=<span class="hljs-keyword">new</span> File(filePath + <span class="hljs-string">"privateKey.keystore"</span>);            <span class="hljs-keyword">if</span>(!file1.exists()) &#123;                file1.createNewFile();            &#125;            <span class="hljs-keyword">if</span>(!file2.exists()) &#123;                file2.createNewFile();            &#125;            FileWriter pubfw = <span class="hljs-keyword">new</span> FileWriter(filePath + <span class="hljs-string">"/publicKey.keystore"</span>);            FileWriter prifw = <span class="hljs-keyword">new</span> FileWriter(filePath + <span class="hljs-string">"/privateKey.keystore"</span>);            BufferedWriter pubbw = <span class="hljs-keyword">new</span> BufferedWriter(pubfw);            BufferedWriter pribw = <span class="hljs-keyword">new</span> BufferedWriter(prifw);            pubbw.write(publicKeyString);            pribw.write(privateKeyString);            pubbw.flush();            pubbw.close();            pubfw.close();            pribw.flush();            pribw.close();            prifw.close();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 从文件中输入流中加载公钥</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     *             加载公钥时产生的异常</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">loadPublicKeyByFile</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">try</span> &#123;            BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(path                    + <span class="hljs-string">"/publicKey.keystore"</span>));            String readLine = <span class="hljs-keyword">null</span>;            StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();            <span class="hljs-keyword">while</span> ((readLine = br.readLine()) != <span class="hljs-keyword">null</span>) &#123;                sb.append(readLine);            &#125;            br.close();            <span class="hljs-keyword">return</span> sb.toString();        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"公钥数据流读取错误"</span>);        &#125; <span class="hljs-keyword">catch</span> (NullPointerException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"公钥输入流为空"</span>);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 从字符串中加载公钥</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> publicKeyStr</span><span class="hljs-comment">     *            公钥数据字符串</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     *             加载公钥时产生的异常</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RSAPublicKey <span class="hljs-title">loadPublicKeyByStr</span><span class="hljs-params">(String publicKeyStr)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">byte</span>[] buffer = Base64.getDecoder().decode(publicKeyStr);            KeyFactory keyFactory = KeyFactory.getInstance(<span class="hljs-string">"RSA"</span>);            X509EncodedKeySpec keySpec = <span class="hljs-keyword">new</span> X509EncodedKeySpec(buffer);            <span class="hljs-keyword">return</span> (RSAPublicKey) keyFactory.generatePublic(keySpec);        &#125; <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"无此算法"</span>);        &#125; <span class="hljs-keyword">catch</span> (InvalidKeySpecException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"公钥非法"</span>);        &#125; <span class="hljs-keyword">catch</span> (NullPointerException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"公钥数据为空"</span>);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 从文件中加载私钥</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否成功</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">loadPrivateKeyByFile</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">try</span> &#123;            BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(path                    + <span class="hljs-string">"/privateKey.keystore"</span>));            String readLine = <span class="hljs-keyword">null</span>;            StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();            <span class="hljs-keyword">while</span> ((readLine = br.readLine()) != <span class="hljs-keyword">null</span>) &#123;                sb.append(readLine);            &#125;            br.close();            <span class="hljs-keyword">return</span> sb.toString();        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"私钥数据读取错误"</span>);        &#125; <span class="hljs-keyword">catch</span> (NullPointerException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"私钥输入流为空"</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RSAPrivateKey <span class="hljs-title">loadPrivateKeyByStr</span><span class="hljs-params">(String privateKeyStr)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">byte</span>[] buffer = Base64.getDecoder().decode(privateKeyStr);            PKCS8EncodedKeySpec keySpec = <span class="hljs-keyword">new</span> PKCS8EncodedKeySpec(buffer);            KeyFactory keyFactory = KeyFactory.getInstance(<span class="hljs-string">"RSA"</span>);            <span class="hljs-keyword">return</span> (RSAPrivateKey) keyFactory.generatePrivate(keySpec);        &#125; <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"无此算法"</span>);        &#125; <span class="hljs-keyword">catch</span> (InvalidKeySpecException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"私钥非法"</span>);        &#125; <span class="hljs-keyword">catch</span> (NullPointerException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"私钥数据为空"</span>);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 公钥加密过程</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> publicKey</span><span class="hljs-comment">     *            公钥</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> plainTextData</span><span class="hljs-comment">     *            明文数据</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     *             加密过程中的异常信息</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] encrypt(RSAPublicKey publicKey, <span class="hljs-keyword">byte</span>[] plainTextData)            <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-keyword">if</span> (publicKey == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"加密公钥为空, 请设置"</span>);        &#125;        Cipher cipher = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 使用默认RSA</span>            cipher = Cipher.getInstance(<span class="hljs-string">"RSA"</span>);            <span class="hljs-comment">// cipher= Cipher.getInstance("RSA", new BouncyCastleProvider());</span>            cipher.init(Cipher.ENCRYPT_MODE, publicKey);            <span class="hljs-keyword">byte</span>[] output = cipher.doFinal(plainTextData);            <span class="hljs-keyword">return</span> output;        &#125; <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"无此加密算法"</span>);        &#125; <span class="hljs-keyword">catch</span> (NoSuchPaddingException e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125; <span class="hljs-keyword">catch</span> (InvalidKeyException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"加密公钥非法,请检查"</span>);        &#125; <span class="hljs-keyword">catch</span> (IllegalBlockSizeException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"明文长度非法"</span>);        &#125; <span class="hljs-keyword">catch</span> (BadPaddingException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"明文数据已损坏"</span>);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 私钥加密过程</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> privateKey</span><span class="hljs-comment">     *            私钥</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> plainTextData</span><span class="hljs-comment">     *            明文数据</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     *             加密过程中的异常信息</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] encrypt(RSAPrivateKey privateKey, <span class="hljs-keyword">byte</span>[] plainTextData)            <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-keyword">if</span> (privateKey == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"加密私钥为空, 请设置"</span>);        &#125;        Cipher cipher = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 使用默认RSA</span>            cipher = Cipher.getInstance(<span class="hljs-string">"RSA"</span>);            cipher.init(Cipher.ENCRYPT_MODE, privateKey);            <span class="hljs-keyword">byte</span>[] output = cipher.doFinal(plainTextData);            <span class="hljs-keyword">return</span> output;        &#125; <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"无此加密算法"</span>);        &#125; <span class="hljs-keyword">catch</span> (NoSuchPaddingException e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125; <span class="hljs-keyword">catch</span> (InvalidKeyException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"加密私钥非法,请检查"</span>);        &#125; <span class="hljs-keyword">catch</span> (IllegalBlockSizeException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"明文长度非法"</span>);        &#125; <span class="hljs-keyword">catch</span> (BadPaddingException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"明文数据已损坏"</span>);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 私钥解密过程</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> privateKey</span><span class="hljs-comment">     *            私钥</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cipherData</span><span class="hljs-comment">     *            密文数据</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 明文</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     *             解密过程中的异常信息</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] decrypt(RSAPrivateKey privateKey, <span class="hljs-keyword">byte</span>[] cipherData)            <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-keyword">if</span> (privateKey == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"解密私钥为空, 请设置"</span>);        &#125;        Cipher cipher = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 使用默认RSA</span>            cipher = Cipher.getInstance(<span class="hljs-string">"RSA"</span>);            <span class="hljs-comment">// cipher= Cipher.getInstance("RSA", new BouncyCastleProvider());</span>            cipher.init(Cipher.DECRYPT_MODE, privateKey);            <span class="hljs-keyword">byte</span>[] output = cipher.doFinal(cipherData);            <span class="hljs-keyword">return</span> output;        &#125; <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"无此解密算法"</span>);        &#125; <span class="hljs-keyword">catch</span> (NoSuchPaddingException e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125; <span class="hljs-keyword">catch</span> (InvalidKeyException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"解密私钥非法,请检查"</span>);        &#125; <span class="hljs-keyword">catch</span> (IllegalBlockSizeException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"密文长度非法"</span>);        &#125; <span class="hljs-keyword">catch</span> (BadPaddingException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"密文数据已损坏"</span>);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 公钥解密过程</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> publicKey</span><span class="hljs-comment">     *            公钥</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cipherData</span><span class="hljs-comment">     *            密文数据</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 明文</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     *             解密过程中的异常信息</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] decrypt(RSAPublicKey publicKey, <span class="hljs-keyword">byte</span>[] cipherData)            <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-keyword">if</span> (publicKey == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"解密公钥为空, 请设置"</span>);        &#125;        Cipher cipher = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 使用默认RSA</span>            cipher = Cipher.getInstance(<span class="hljs-string">"RSA"</span>);            <span class="hljs-comment">// cipher= Cipher.getInstance("RSA", new BouncyCastleProvider());</span>            cipher.init(Cipher.DECRYPT_MODE, publicKey);            <span class="hljs-keyword">byte</span>[] output = cipher.doFinal(cipherData);            <span class="hljs-keyword">return</span> output;        &#125; <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"无此解密算法"</span>);        &#125; <span class="hljs-keyword">catch</span> (NoSuchPaddingException e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125; <span class="hljs-keyword">catch</span> (InvalidKeyException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"解密公钥非法,请检查"</span>);        &#125; <span class="hljs-keyword">catch</span> (IllegalBlockSizeException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"密文长度非法"</span>);        &#125; <span class="hljs-keyword">catch</span> (BadPaddingException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"密文数据已损坏"</span>);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 字节数据转十六进制字符串</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data</span><span class="hljs-comment">     *            输入数据</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 十六进制内容</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">byteArrayToString</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] data)</span> </span>&#123;        StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; data.length; i++) &#123;            <span class="hljs-comment">// 取出字节的高四位 作为索引得到相应的十六进制标识符 注意无符号右移</span>            stringBuilder.append(HEX_CHAR[(data[i] &amp; <span class="hljs-number">0xf0</span>) &gt;&gt;&gt; <span class="hljs-number">4</span>]);            <span class="hljs-comment">// 取出字节的低四位 作为索引得到相应的十六进制标识符</span>            stringBuilder.append(HEX_CHAR[(data[i] &amp; <span class="hljs-number">0x0f</span>)]);            <span class="hljs-keyword">if</span> (i &lt; data.length - <span class="hljs-number">1</span>) &#123;                stringBuilder.append(<span class="hljs-string">' '</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> stringBuilder.toString();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        String filepath=<span class="hljs-string">"F:/temp/"</span>;        File file=<span class="hljs-keyword">new</span> File(filepath);        <span class="hljs-keyword">if</span>(!file.exists())&#123;            file.mkdir();        &#125;        genKeyPair(filepath);        System.out.println(<span class="hljs-string">"--------------公钥加密私钥解密过程-------------------"</span>);        String plainText=<span class="hljs-string">"1223333323:8783737321232:dewejj28i33e92hhsxxxx"</span>;        <span class="hljs-comment">//公钥加密过程</span>        <span class="hljs-keyword">byte</span>[] cipherData=encrypt(loadPublicKeyByStr(loadPublicKeyByFile(filepath)),plainText.getBytes());        String cipher=<span class="hljs-keyword">new</span> String(Base64.getEncoder().encode(cipherData));        <span class="hljs-comment">//私钥解密过程</span>        <span class="hljs-keyword">byte</span>[] res=decrypt(loadPrivateKeyByStr(loadPrivateKeyByFile(filepath)), Base64.getDecoder().decode(cipher));        String restr=<span class="hljs-keyword">new</span> String(res);        System.out.println(<span class="hljs-string">"原文："</span>+plainText);        System.out.println(<span class="hljs-string">"加密密文："</span>+cipher);        System.out.println(<span class="hljs-string">"解密："</span>+restr);        System.out.println();    &#125;&#125;</code></pre><p><strong>欢迎关注微信公众号 ：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java IDE中设置作者日期等Javadoc注释信息</title>
    <link href="/2020/04/09/Java-IDE%E4%B8%AD%E8%AE%BE%E7%BD%AE%E4%BD%9C%E8%80%85%E6%97%A5%E6%9C%9F%E7%AD%89Javadoc%E6%B3%A8%E9%87%8A%E4%BF%A1%E6%81%AF/"/>
    <url>/2020/04/09/Java-IDE%E4%B8%AD%E8%AE%BE%E7%BD%AE%E4%BD%9C%E8%80%85%E6%97%A5%E6%9C%9F%E7%AD%89Javadoc%E6%B3%A8%E9%87%8A%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<p><img src="https://images.unsplash.com/photo-1585595684482-984bf2cf8041" srcset="/img/loading.gif" alt="img"></p><p>在Java的IDE（Integrated Development Environment,集成开发环境）中，如Eclipse、Spring Tool Suite、IntelliJ IDEA等，都可以设置自动添加的Javadoc注释信息，可以添加@author 作者名、@version 版本标识、@date 日期等，新添加类或方法时会自动添加注释信息，很方便。/<em>*被注释语句</em>/ 就是专为Javadoc设计，可以被JDK内置的Javadoc工具支持和处理，下面就介绍下如何设置Javadoc注释信息和注释的规范。</p><h4 id="1、先来了解下Javadoc"><a href="#1、先来了解下Javadoc" class="headerlink" title="1、先来了解下Javadoc"></a>1、先来了解下Javadoc</h4><blockquote><p>Javadoc是Sun公司提供的一个技术，它从程序源代码中抽取类、方法、成员等注释形成一个和源代码配套的API帮助文档。也就是说，只要在编写程序时以一套特定的标签作注释，在程序编写完成后，通过Javadoc就可以同时形成程序的开发文档了。</p></blockquote><p>关键词列表：</p><ul><li>@author 作者名</li><li>@date 日期</li><li>@version 版本标识</li><li>@parameter 参数及其意义</li><li>@since 最早使用该方法/类/接口的JDK版本</li><li>@return 返回值</li><li>@throws 异常类及抛出条件</li><li>@deprecated 引起不推荐使用的警告</li><li>@see reference 查看引用</li><li>@override 重写</li></ul><p>更多Javadoc用法可以访问：<a href="http://baike.baidu.com/view/975838.htm" target="_blank" rel="noopener">百度百科</a>、<a href="http://www.oracle.com/technetwork/java/javase/documentation/index-jsp-135444.html" target="_blank" rel="noopener">官方文档</a>。</p><h4 id="2、Javadoc注释的规范"><a href="#2、Javadoc注释的规范" class="headerlink" title="2、Javadoc注释的规范"></a>2、Javadoc注释的规范</h4><p>附上Javadoc注释的规范，这才是本文的重点，${}的是变量，IDE会自动添加，当然也可以直接改为固定文字。</p><p>注释的规范如下：</p><p><strong>1、文件注释标签：</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* &lt;p&gt;Title: $&#123;file_name&#125;&lt;/p&gt;</span><span class="hljs-comment">* &lt;p&gt;Description: &lt;/p&gt;</span><span class="hljs-comment">* &lt;p&gt;Copyright: Copyright (c) 2013&lt;/p&gt;</span><span class="hljs-comment">* &lt;p&gt;Company: www.izhangheng.com&lt;/p&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@author</span> zhangheng</span><span class="hljs-comment">* <span class="hljs-doctag">@date</span> $&#123;date&#125;</span><span class="hljs-comment">* <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment">*/</span></code></pre><p><strong>2、类型注释标签（类的注释）：</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* &lt;p&gt;Title: $&#123;type_name&#125;&lt;/p&gt;</span><span class="hljs-comment">* &lt;p&gt;Description: &lt;/p&gt;</span><span class="hljs-comment">* &lt;p&gt;Company: www.izhangheng.com&lt;/p&gt;</span><span class="hljs-comment">* <span class="hljs-doctag">@author</span> zhangheng</span><span class="hljs-comment">* <span class="hljs-doctag">@date</span> $&#123;date&#125;</span><span class="hljs-comment">*/</span></code></pre><p><strong>3、字段注释标签：</strong></p><pre><code class="hljs java"><span class="hljs-comment">/** </span><span class="hljs-comment">* $&#123;field&#125;</span><span class="hljs-comment">*/</span></code></pre><p><strong>4、构造函数标签：</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* &lt;p&gt;Title: &lt;/p&gt;</span><span class="hljs-comment">* &lt;p&gt;Description: &lt;/p&gt;</span><span class="hljs-comment">* $&#123;tags&#125;</span><span class="hljs-comment">*/</span></code></pre><p><strong>5、方法标签：</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* &lt;p&gt;Title: $&#123;enclosing_method&#125;&lt;/p&gt;</span><span class="hljs-comment">* &lt;p&gt;Description: &lt;/p&gt;</span><span class="hljs-comment">* $&#123;tags&#125;</span><span class="hljs-comment">*/</span></code></pre><p><strong>6、重写方法标签：</strong></p><pre><code class="hljs java"><span class="hljs-comment">/** （非 Javadoc）</span><span class="hljs-comment">* &lt;p&gt;Title: $&#123;enclosing_method&#125;&lt;/p&gt;</span><span class="hljs-comment">* &lt;p&gt;Description: &lt;/p&gt;</span><span class="hljs-comment">* $&#123;tags&#125;</span><span class="hljs-comment">* $&#123;see_to_overridden&#125;</span><span class="hljs-comment">*/</span></code></pre><p><strong>7、代表方法标签：</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* $&#123;tags&#125;</span><span class="hljs-comment">* $&#123;see_to_target&#125;</span><span class="hljs-comment">*/</span></code></pre><p><strong>8、getter方法标签：</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* <span class="hljs-doctag">@return</span> $&#123;bare_field_name&#125;</span><span class="hljs-comment">*/</span></code></pre><p><strong>9、setter方法标签：</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> $&#123;param&#125; 要设置的 $&#123;bare_field_name&#125;</span><span class="hljs-comment">*/</span></code></pre><p><strong>欢迎关注微信公众号 ：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>JavaDoc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaDoc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IntelliJIDEA生成JavaDoc</title>
    <link href="/2020/04/09/IntelliJIDEA%E7%94%9F%E6%88%90JavaDoc/"/>
    <url>/2020/04/09/IntelliJIDEA%E7%94%9F%E6%88%90JavaDoc/</url>
    
    <content type="html"><![CDATA[<p>IntelliJ IDEA，本身提供了很好的 JavaDoc 生成功能，以及标准 JavaDoc 注释转换功能，其实质是在代码编写过程中，按照标准 JavaDoc 的注释要求，为需要暴露给使用者的类、方法以及其他成员编写注释。然后使用 IDEA 的功能自动调用 javadoc（JDK 自带的工具）根据源代码中的注释内容自动生成 JavaDoc 文档（超文本格式）。</p><ol><li><p>IDEA 的 JavaDoc 生成功能在菜单 Tools -&gt; Generate JavaDoc 项里面。</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/09/image-20200409111759947.png" srcset="/img/loading.gif" alt="image-20200409111759947"></p></li><li><p>点击上述菜单项后，会出现生成 JavaDoc 的对话框，一般的选项都很直观，不必细说。但是要注意生成 JavaDoc 的源代码对象的选择，一般以模块（Module）为主，必要时可以单独选择必要的 Java 源代码文件</p></li><li><p>里面有一个 Locale 可选填项，表示的是需要生成的 JavaDoc 以何种语言版本展示，根据 javadoc 的帮助说明，这其实对应的就是 javadoc 的 -locale 参数，如果不填，默认可能是英文或者是当前操作系统的语言，既然是国人，建议在此填写 zh_CN，这样生成的 JavaDoc 就是中文版本的，当然指的是 JavaDoc 的框架中各种通用的固定显示区域都是中文的。你自己编写的注释转换的内容还是根据你注释的内容来。</p></li><li><p>还有一个 “Other command line arguments:” 可选填项，非常重要，是填写直接向 javadoc 传递的参数内容。因为有一些重要的设置，只能通过直接参数形式向 javadoc 传递。这里必须要填写如下参数：</p><p><code>-encoding UTF-8 -charset UTF-8 -windowtitle&quot;YKXClouds Docs&quot;-link http://docs.Oracle.com/javase/8/docs/api</code></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/09/image-20200409112213039.png" srcset="/img/loading.gif" alt="image-20200409112213039"></p></li><li><p>第一个参数 <code>-encoding UTF-8</code>  表示你的源代码（含有符合 JavaDoc 标准的注释）是基于 UTF-8 编码的，以免处理过程中出现中文等非英语字符乱码；第二个参数 -charset UTF-8 表示在处理并生成 JavaDoc 超文本时使用的字符集也是以 UTF-8 为编码，目前所有浏览器都支持 UTF-8，这样最具有通用性，支持中文非常好；第三个参数 -windowtitle 表示生成的 JavaDoc 超文本在浏览器中打开时，浏览器窗口标题栏显示的文字内容；第四个参数 -link 很重要，它表示你生成的 JavaDoc 中涉及到很多对其他外部 Java 类的引用，是使用全限定名称还是带有超链接的短名称，举个例子，我创建了一个方法 public void func (String arg)，这个方法在生成 JavaDoc 时如果不指定 -link 参数，则 JavaDoc 中对该方法的表述就会自动变为 public void func (java.lang.String arg)，因为 String 这个类对我自己实现的类来讲就是外部引用的类，虽然它是 Java 标准库的类。</p></li><li><p>如果指定了 <code>-link http://docs.oracle.com/javase/8/docs/api</code> 参数，则 javadoc 在生成 JavaDoc 时，会使用 String 这样的短名称而非全限定名称 java.lang.String，同时自动为 String 短名称生成一个超链接，指向官方 JavaSE 标准文档 <a href="http://docs.oracle.com/javase/8/docs/api" target="_blank" rel="noopener">http://docs.oracle.com/javase/8/docs/api</a> 中对 String 类的详细文档地址。-link 实质上是告诉 javadoc 根据提供的外部引用类的 JavaDoc 地址去找一个叫 package-list 的文本文件，在这个文本文件中包含了所有外部引用类的全限定名称，因此生成的新 JavaDoc 不必使用外部引用类的全限定名，只需要使用短名称，同时可以自动创建指向其外部引用 JavaDoc 中的详细文档超链接。每个 JavaDoc 都会在根目录下有一个 package-list 文件，包括我们自己生成的 JavaDoc。如果指定了 -link <a href="http://docs.oracle.com/javase/8/docs/api" target="_blank" rel="noopener">http://docs.oracle.com/javase/8/docs/api</a> 参数，则 javadoc 在生成 JavaDoc 时，会使用 String 这样的短名称而非全限定名称 java.lang.String，同时自动为 String 短名称生成一个超链接，指向官方 JavaSE 标准文档 <a href="http://docs.oracle.com/javase/8/docs/api" target="_blank" rel="noopener">http://docs.oracle.com/javase/8/docs/api</a> 中对 String 类的详细文档地址。-link 实质上是告诉 javadoc 根据提供的外部引用类的 JavaDoc 地址去找一个叫 package-list 的文本文件，在这个文本文件中包含了所有外部引用类的全限定名称，因此生成的新 JavaDoc 不必使用外部引用类的全限定名，只需要使用短名称，同时可以自动创建指向其外部引用 JavaDoc 中的详细文档超链接。每个 JavaDoc 都会在根目录下有一个 package-list 文件，包括我们自己生成的 JavaDoc。</p></li><li><p>JavaDoc 生成完毕，即可在其根目录下找到 index.html 文件，打开它就可以看到我们自己的标准 JavaDoc API 文档啦。</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/09/image-20200409112314666.png" srcset="/img/loading.gif" alt="image-20200409112314666"></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/09/image-20200409112442451.png" srcset="/img/loading.gif" alt="image-20200409112442451"></p></li><li><p><code>使用鼠标 + CTRL 选择多个模块，再去点击 Tools-&gt;Generate JavaDoc，生成的文档只会是你选择的多个模块，而不是单个模块，也不是这个项目源码的文档。</code></p></li></ol><p><strong>欢迎关注微信公众号：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>JavaDoc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaDoc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用线程</title>
    <link href="/2020/04/02/%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B/"/>
    <url>/2020/04/02/%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="一、使用线程"><a href="#一、使用线程" class="headerlink" title="一、使用线程"></a>一、使用线程</h1><p>有三种使用线程的方法：</p><ul><li>实现 Runnable 接口；</li><li>实现 Callable 接口；</li><li>继承 Thread 类。</li></ul><p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动从而执行的。</p><h2 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h2><p>需要实现接口中的 run() 方法。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// ...</span>    &#125;&#125;</code></pre><p>使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    MyRunnable instance = <span class="hljs-keyword">new</span> MyRunnable();    Thread thread = <span class="hljs-keyword">new</span> Thread(instance);    thread.start();&#125;</code></pre><h2 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h2><p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;    MyCallable mc = <span class="hljs-keyword">new</span> MyCallable();    FutureTask&lt;Integer&gt; ft = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(mc);    Thread thread = <span class="hljs-keyword">new</span> Thread(ft);    thread.start();    System.out.println(ft.get());&#125;</code></pre><h2 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h2><p>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。</p><p>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// ...</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    MyThread mt = <span class="hljs-keyword">new</span> MyThread();    mt.start();&#125;</code></pre><h2 id="实现接口-VS-继承-Thread"><a href="#实现接口-VS-继承-Thread" class="headerlink" title="实现接口 VS 继承 Thread"></a>实现接口 VS 继承 Thread</h2><p>实现接口会更好一些，因为：</p><ul><li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li><li>类可能只要求可执行就行，继承整个 Thread 类开销过大。</li></ul><h1 id="二、基础线程机制"><a href="#二、基础线程机制" class="headerlink" title="二、基础线程机制"></a>二、基础线程机制</h1><h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p><p>主要有三种 Executor：</p><ul><li>CachedThreadPool：一个任务创建一个线程；</li><li>FixedThreadPool：所有任务只能使用固定大小的线程；</li><li>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    ExecutorService executorService = Executors.newCachedThreadPool();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;        executorService.execute(<span class="hljs-keyword">new</span> MyRunnable());    &#125;    executorService.shutdown();&#125;</code></pre><h2 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h2><p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p><p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。</p><p>main() 属于非守护线程。</p><p>在线程启动之前使用 setDaemon() 方法可以将一个线程设置为守护线程。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Thread thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyRunnable());    thread.setDaemon(<span class="hljs-keyword">true</span>);&#125;</code></pre><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h2><p>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。</p><p>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        Thread.sleep(<span class="hljs-number">3000</span>);    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><h2 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h2><p>对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    Thread.yield();&#125;</code></pre><h1 id="三、中断"><a href="#三、中断" class="headerlink" title="三、中断"></a>三、中断</h1><p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</p><h2 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h2><p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p><p>对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterruptExample</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">2000</span>);                System.out.println(<span class="hljs-string">"Thread run"</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    Thread thread1 = <span class="hljs-keyword">new</span> MyThread1();    thread1.start();    thread1.interrupt();    System.out.println(<span class="hljs-string">"Main run"</span>);&#125;Main runjava.lang.InterruptedException: sleep interrupted    at java.lang.Thread.sleep(Native Method)    at InterruptExample.lambda$main$<span class="hljs-number">0</span>(InterruptExample.java:<span class="hljs-number">5</span>)    at InterruptExample$$Lambda$<span class="hljs-number">1</span>/<span class="hljs-number">713338599</span>.run(Unknown Source)    at java.lang.Thread.run(Thread.java:<span class="hljs-number">745</span>)</code></pre><h2 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h2><p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。</p><p>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterruptExample</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">while</span> (!interrupted()) &#123;                <span class="hljs-comment">// ..</span>            &#125;            System.out.println(<span class="hljs-string">"Thread end"</span>);        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    Thread thread2 = <span class="hljs-keyword">new</span> MyThread2();    thread2.start();    thread2.interrupt();&#125;Thread end</code></pre><h2 id="Executor-的中断操作"><a href="#Executor-的中断操作" class="headerlink" title="Executor 的中断操作"></a>Executor 的中断操作</h2><p>调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。</p><p>以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    ExecutorService executorService = Executors.newCachedThreadPool();    executorService.execute(() -&gt; &#123;        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">2000</span>);            System.out.println(<span class="hljs-string">"Thread run"</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;);    executorService.shutdownNow();    System.out.println(<span class="hljs-string">"Main run"</span>);&#125;Main runjava.lang.InterruptedException: sleep interrupted    at java.lang.Thread.sleep(Native Method)    at ExecutorInterruptExample.lambda$main$<span class="hljs-number">0</span>(ExecutorInterruptExample.java:<span class="hljs-number">9</span>)    at ExecutorInterruptExample$$Lambda$<span class="hljs-number">1</span>/<span class="hljs-number">1160460865</span>.run(Unknown Source)    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="hljs-number">1142</span>)    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="hljs-number">617</span>)    at java.lang.Thread.run(Thread.java:<span class="hljs-number">745</span>)</code></pre><p>如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。</p><pre><code class="hljs java">Future&lt;?&gt; future = executorService.submit(() -&gt; &#123;    <span class="hljs-comment">// ..</span>&#125;);future.cancel(<span class="hljs-keyword">true</span>);</code></pre><h1 id="四、互斥同步"><a href="#四、互斥同步" class="headerlink" title="四、互斥同步"></a>四、互斥同步</h1><p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p><strong>1. 同步一个代码块</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;        <span class="hljs-comment">// ...</span>    &#125;&#125;</code></pre><p>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</p><p>对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedExample</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;                System.out.print(i + <span class="hljs-string">" "</span>);            &#125;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    SynchronizedExample e1 = <span class="hljs-keyword">new</span> SynchronizedExample();    ExecutorService executorService = Executors.newCachedThreadPool();    executorService.execute(() -&gt; e1.func1());    executorService.execute(() -&gt; e1.func1());&#125;<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span></code></pre><p>对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    SynchronizedExample e1 = <span class="hljs-keyword">new</span> SynchronizedExample();    SynchronizedExample e2 = <span class="hljs-keyword">new</span> SynchronizedExample();    ExecutorService executorService = Executors.newCachedThreadPool();    executorService.execute(() -&gt; e1.func1());    executorService.execute(() -&gt; e2.func1());&#125;<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">9</span></code></pre><p><strong>2. 同步一个方法</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span> <span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre><p>它和同步代码块一样，作用于同一个对象。</p><p><strong>3. 同步一个类</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">synchronized</span> (SynchronizedExample<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;        <span class="hljs-comment">// ...</span>    &#125;&#125;</code></pre><p>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedExample</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (SynchronizedExample<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;                System.out.print(i + <span class="hljs-string">" "</span>);            &#125;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    SynchronizedExample e1 = <span class="hljs-keyword">new</span> SynchronizedExample();    SynchronizedExample e2 = <span class="hljs-keyword">new</span> SynchronizedExample();    ExecutorService executorService = Executors.newCachedThreadPool();    executorService.execute(() -&gt; e1.func2());    executorService.execute(() -&gt; e2.func2());&#125;<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span></code></pre><p><strong>4. 同步一个静态方法</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// ...</span>&#125;</code></pre><p>作用于整个类。</p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockExample</span> </span>&#123;    <span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;                System.out.print(i + <span class="hljs-string">" "</span>);            &#125;        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock(); <span class="hljs-comment">// 确保释放锁，从而避免发生死锁。</span>        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    LockExample lockExample = <span class="hljs-keyword">new</span> LockExample();    ExecutorService executorService = Executors.newCachedThreadPool();    executorService.execute(() -&gt; lockExample.func());    executorService.execute(() -&gt; lockExample.func());&#125;<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span></code></pre><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p><strong>1. 锁的实现</strong></p><p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p><p><strong>2. 性能</strong></p><p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p><p><strong>3. 等待可中断</strong></p><p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p><p>ReentrantLock 可中断，而 synchronized 不行。</p><p><strong>4. 公平锁</strong></p><p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p><p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p><p><strong>5. 锁绑定多个条件</strong></p><p>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</p><h2 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h2><p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p><h1 id="五、线程之间的协作"><a href="#五、线程之间的协作" class="headerlink" title="五、线程之间的协作"></a>五、线程之间的协作</h1><p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。</p><h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p><p>对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JoinExample</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            System.out.println(<span class="hljs-string">"A"</span>);        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;        <span class="hljs-keyword">private</span> A a;        B(A a) &#123;            <span class="hljs-keyword">this</span>.a = a;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">try</span> &#123;                a.join();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(<span class="hljs-string">"B"</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        A a = <span class="hljs-keyword">new</span> A();        B b = <span class="hljs-keyword">new</span> B(a);        b.start();        a.start();    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    JoinExample example = <span class="hljs-keyword">new</span> JoinExample();    example.test();&#125;AB</code></pre><h2 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait() notify() notifyAll()"></a>wait() notify() notifyAll()</h2><p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。</p><p>它们都属于 Object 的一部分，而不属于 Thread。</p><p>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。</p><p>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WaitNotifyExample</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"before"</span>);        notifyAll();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            wait();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(<span class="hljs-string">"after"</span>);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    ExecutorService executorService = Executors.newCachedThreadPool();    WaitNotifyExample example = <span class="hljs-keyword">new</span> WaitNotifyExample();    executorService.execute(() -&gt; example.after());    executorService.execute(() -&gt; example.before());&#125;beforeafter</code></pre><p><strong>wait() 和 sleep() 的区别</strong></p><ul><li>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；</li><li>wait() 会释放锁，sleep() 不会。</li></ul><h2 id="await-signal-signalAll"><a href="#await-signal-signalAll" class="headerlink" title="await() signal() signalAll()"></a>await() signal() signalAll()</h2><p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。</p><p>相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p><p>使用 Lock 来获取一个 Condition 对象。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AwaitSignalExample</span> </span>&#123;    <span class="hljs-keyword">private</span> Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();    <span class="hljs-keyword">private</span> Condition condition = lock.newCondition();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            System.out.println(<span class="hljs-string">"before"</span>);            condition.signalAll();        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span> </span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            condition.await();            System.out.println(<span class="hljs-string">"after"</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    ExecutorService executorService = Executors.newCachedThreadPool();    AwaitSignalExample example = <span class="hljs-keyword">new</span> AwaitSignalExample();    executorService.execute(() -&gt; example.after());    executorService.execute(() -&gt; example.before());&#125;beforeafter</code></pre><h1 id="六、线程状态"><a href="#六、线程状态" class="headerlink" title="六、线程状态"></a>六、线程状态</h1><p>一个线程只能处于一种状态，并且这里的线程状态特指 Java 虚拟机的线程状态，不能反映线程在特定操作系统下的状态。</p><h2 id="新建（NEW）"><a href="#新建（NEW）" class="headerlink" title="新建（NEW）"></a>新建（NEW）</h2><p>创建后尚未启动。</p><h2 id="可运行（RUNABLE）"><a href="#可运行（RUNABLE）" class="headerlink" title="可运行（RUNABLE）"></a>可运行（RUNABLE）</h2><p>正在 Java 虚拟机中运行。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度（例如处理器资源），资源调度完成就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度。</p><h2 id="阻塞（BLOCKED）"><a href="#阻塞（BLOCKED）" class="headerlink" title="阻塞（BLOCKED）"></a>阻塞（BLOCKED）</h2><p>请求获取 monitor lock 从而进入 synchronized 函数或者代码块，但是其它线程已经占用了该 monitor lock，所以出于阻塞状态。要结束该状态进入从而 RUNABLE 需要其他线程释放 monitor lock。</p><h2 id="无限期等待（WAITING）"><a href="#无限期等待（WAITING）" class="headerlink" title="无限期等待（WAITING）"></a>无限期等待（WAITING）</h2><p>等待其它线程显式地唤醒。</p><p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 monitor lock。而等待是主动的，通过调用 Object.wait() 等方法进入。</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>没有设置 Timeout 参数的 Object.wait() 方法</td><td>Object.notify() / Object.notifyAll()</td></tr><tr><td>没有设置 Timeout 参数的 Thread.join() 方法</td><td>被调用的线程执行完毕</td></tr><tr><td>LockSupport.park() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table><h2 id="限期等待（TIMED-WAITING）"><a href="#限期等待（TIMED-WAITING）" class="headerlink" title="限期等待（TIMED_WAITING）"></a>限期等待（TIMED_WAITING）</h2><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>Thread.sleep() 方法</td><td>时间结束</td></tr><tr><td>设置了 Timeout 参数的 Object.wait() 方法</td><td>时间结束 / Object.notify() / Object.notifyAll()</td></tr><tr><td>设置了 Timeout 参数的 Thread.join() 方法</td><td>时间结束 / 被调用的线程执行完毕</td></tr><tr><td>LockSupport.parkNanos() 方法</td><td>LockSupport.unpark(Thread)</td></tr><tr><td>LockSupport.parkUntil() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table><p>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p><h2 id="死亡（TERMINATED）"><a href="#死亡（TERMINATED）" class="headerlink" title="死亡（TERMINATED）"></a>死亡（TERMINATED）</h2><p>可以是线程结束任务之后自己结束，或者产生了异常而结束。</p><p><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Thread.State.html" target="_blank" rel="noopener">Java SE 9 Enum Thread.State</a></p><h1 id="七、J-U-C-AQS"><a href="#七、J-U-C-AQS" class="headerlink" title="七、J.U.C - AQS"></a>七、J.U.C - AQS</h1><p>java.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心。</p><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>用来控制一个或者多个线程等待多个线程。</p><p>维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ba078291-791e-4378-b6d1-ece76c2f0b14.png" srcset="/img/loading.gif" alt="img"></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountdownLatchExample</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> totalThread = <span class="hljs-number">10</span>;        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(totalThread);        ExecutorService executorService = Executors.newCachedThreadPool();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; totalThread; i++) &#123;            executorService.execute(() -&gt; &#123;                System.out.print(<span class="hljs-string">"run.."</span>);                countDownLatch.countDown();            &#125;);        &#125;        countDownLatch.await();        System.out.println(<span class="hljs-string">"end"</span>);        executorService.shutdown();    &#125;&#125;run..run..run..run..run..run..run..run..run..run..end</code></pre><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</p><p>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。</p><p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。</p><p>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;    <span class="hljs-keyword">if</span> (parties &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();    <span class="hljs-keyword">this</span>.parties = parties;    <span class="hljs-keyword">this</span>.count = parties;    <span class="hljs-keyword">this</span>.barrierCommand = barrierAction;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-keyword">int</span> parties)</span> </span>&#123;    <span class="hljs-keyword">this</span>(parties, <span class="hljs-keyword">null</span>);&#125;</code></pre><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f71af66b-0d54-4399-a44b-f47b58321984.png" srcset="/img/loading.gif" alt="img"></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CyclicBarrierExample</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> totalThread = <span class="hljs-number">10</span>;        CyclicBarrier cyclicBarrier = <span class="hljs-keyword">new</span> CyclicBarrier(totalThread);        ExecutorService executorService = Executors.newCachedThreadPool();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; totalThread; i++) &#123;            executorService.execute(() -&gt; &#123;                System.out.print(<span class="hljs-string">"before.."</span>);                <span class="hljs-keyword">try</span> &#123;                    cyclicBarrier.await();                &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;                    e.printStackTrace();                &#125;                System.out.print(<span class="hljs-string">"after.."</span>);            &#125;);        &#125;        executorService.shutdown();    &#125;&#125;before..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after..after..after..after..</code></pre><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p><p>以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SemaphoreExample</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> clientCount = <span class="hljs-number">3</span>;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> totalRequestCount = <span class="hljs-number">10</span>;        Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(clientCount);        ExecutorService executorService = Executors.newCachedThreadPool();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; totalRequestCount; i++) &#123;            executorService.execute(()-&gt;&#123;                <span class="hljs-keyword">try</span> &#123;                    semaphore.acquire();                    System.out.print(semaphore.availablePermits() + <span class="hljs-string">" "</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125; <span class="hljs-keyword">finally</span> &#123;                    semaphore.release();                &#125;            &#125;);        &#125;        executorService.shutdown();    &#125;&#125;<span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span></code></pre><h1 id="八、J-U-C-其它组件"><a href="#八、J-U-C-其它组件" class="headerlink" title="八、J.U.C - 其它组件"></a>八、J.U.C - 其它组件</h1><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FutureTask</span>&lt;<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">RunnableFuture</span>&lt;<span class="hljs-title">V</span>&gt;</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">interface</span> <span class="hljs-title">RunnableFuture</span>&lt;<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Runnable</span>, <span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt;</span></code></pre><p>FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FutureTaskExample</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;        FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;Integer&gt;(<span class="hljs-keyword">new</span> Callable&lt;Integer&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;                    Thread.sleep(<span class="hljs-number">10</span>);                    result += i;                &#125;                <span class="hljs-keyword">return</span> result;            &#125;        &#125;);        Thread computeThread = <span class="hljs-keyword">new</span> Thread(futureTask);        computeThread.start();        Thread otherThread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            System.out.println(<span class="hljs-string">"other task is running..."</span>);            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">1000</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;);        otherThread.start();        System.out.println(futureTask.get());    &#125;&#125;other task is running...<span class="hljs-number">4950</span></code></pre><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：</p><ul><li><strong>FIFO 队列</strong> ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）</li><li><strong>优先级队列</strong> ：PriorityBlockingQueue</li></ul><p>提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。</p><p><strong>使用 BlockingQueue 实现生产者消费者问题</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerConsumer</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BlockingQueue&lt;String&gt; queue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">5</span>);    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">try</span> &#123;                queue.put(<span class="hljs-string">"product"</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.print(<span class="hljs-string">"produce.."</span>);        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">try</span> &#123;                String product = queue.take();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.print(<span class="hljs-string">"consume.."</span>);        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;        Producer producer = <span class="hljs-keyword">new</span> Producer();        producer.start();    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;        Consumer consumer = <span class="hljs-keyword">new</span> Consumer();        consumer.start();    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;        Producer producer = <span class="hljs-keyword">new</span> Producer();        producer.start();    &#125;&#125;produce..produce..consume..consume..produce..consume..produce..consume..produce..consume..</code></pre><h2 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h2><p>主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForkJoinExample</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecursiveTask</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> threshold = <span class="hljs-number">5</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> first;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> last;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ForkJoinExample</span><span class="hljs-params">(<span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last)</span> </span>&#123;        <span class="hljs-keyword">this</span>.first = first;        <span class="hljs-keyword">this</span>.last = last;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Integer <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (last - first &lt;= threshold) &#123;            <span class="hljs-comment">// 任务足够小则直接计算</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = first; i &lt;= last; i++) &#123;                result += i;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 拆分成小任务</span>            <span class="hljs-keyword">int</span> middle = first + (last - first) / <span class="hljs-number">2</span>;            ForkJoinExample leftTask = <span class="hljs-keyword">new</span> ForkJoinExample(first, middle);            ForkJoinExample rightTask = <span class="hljs-keyword">new</span> ForkJoinExample(middle + <span class="hljs-number">1</span>, last);            leftTask.fork();            rightTask.fork();            result = leftTask.join() + rightTask.join();        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;    ForkJoinExample example = <span class="hljs-keyword">new</span> ForkJoinExample(<span class="hljs-number">1</span>, <span class="hljs-number">10000</span>);    ForkJoinPool forkJoinPool = <span class="hljs-keyword">new</span> ForkJoinPool();    Future result = forkJoinPool.submit(example);    System.out.println(result.get());&#125;</code></pre><p>ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForkJoinPool</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractExecutorService</span></span></code></pre><p>ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e42f188f-f4a9-4e6f-88fc-45f4682072fb.png" srcset="/img/loading.gif" alt="img"></p><h1 id="九、线程不安全示例"><a href="#九、线程不安全示例" class="headerlink" title="九、线程不安全示例"></a>九、线程不安全示例</h1><p>如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。</p><p>以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadUnsafeExample</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;        cnt++;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> cnt;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> threadSize = <span class="hljs-number">1000</span>;    ThreadUnsafeExample example = <span class="hljs-keyword">new</span> ThreadUnsafeExample();    <span class="hljs-keyword">final</span> CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(threadSize);    ExecutorService executorService = Executors.newCachedThreadPool();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threadSize; i++) &#123;        executorService.execute(() -&gt; &#123;            example.add();            countDownLatch.countDown();        &#125;);    &#125;    countDownLatch.await();    executorService.shutdown();    System.out.println(example.get());&#125;<span class="hljs-number">997</span></code></pre><h1 id="十、Java-内存模型"><a href="#十、Java-内存模型" class="headerlink" title="十、Java 内存模型"></a>十、Java 内存模型</h1><p>Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p><h2 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h2><p>处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。</p><p>加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/942ca0d2-9d5c-45a4-89cb-5fd89b61913f.png" srcset="/img/loading.gif" alt="img"></p><p>所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。</p><p>线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/15851555-5abc-497d-ad34-efed10f43a6b.png" srcset="/img/loading.gif" alt="img"></p><h2 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h2><p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8b7ebbad-9604-4375-84e3-f412099d170c.png" srcset="/img/loading.gif" alt="img"></p><ul><li>read：把一个变量的值从主内存传输到工作内存中</li><li>load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</li><li>use：把工作内存中一个变量的值传递给执行引擎</li><li>assign：把一个从执行引擎接收到的值赋给工作内存的变量</li><li>store：把工作内存的一个变量的值传送到主内存中</li><li>write：在 store 之后执行，把 store 得到的值放入主内存的变量中</li><li>lock：作用于主内存的变量</li><li>unlock</li></ul><h2 id="内存模型三大特性"><a href="#内存模型三大特性" class="headerlink" title="内存模型三大特性"></a>内存模型三大特性</h2><h3 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1. 原子性"></a>1. 原子性</h3><p>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。</p><p>有一个错误认识就是，int 等原子性的类型在多线程环境中不会出现线程安全问题。前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。</p><p>为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。</p><p>下图演示了两个线程同时对 cnt 进行操作，load、assign、store 这一系列操作整体上看不具备原子性，那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。因此对 int 类型读写操作满足原子性只是说明 load、assign、store 这些单个操作具备原子性。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2797a609-68db-4d7b-8701-41ac9a34b14f.jpg" srcset="/img/loading.gif" alt="img"></p><p>AtomicInteger 能保证多个线程修改的原子性。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/dd563037-fcaa-4bd8-83b6-b39d93a12c77.jpg" srcset="/img/loading.gif" alt="img"></p><p>使用 AtomicInteger 重写之前线程不安全的代码之后得到以下线程安全实现：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicExample</span> </span>&#123;    <span class="hljs-keyword">private</span> AtomicInteger cnt = <span class="hljs-keyword">new</span> AtomicInteger();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;        cnt.incrementAndGet();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> cnt.get();    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> threadSize = <span class="hljs-number">1000</span>;    AtomicExample example = <span class="hljs-keyword">new</span> AtomicExample(); <span class="hljs-comment">// 只修改这条语句</span>    <span class="hljs-keyword">final</span> CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(threadSize);    ExecutorService executorService = Executors.newCachedThreadPool();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threadSize; i++) &#123;        executorService.execute(() -&gt; &#123;            example.add();            countDownLatch.countDown();        &#125;);    &#125;    countDownLatch.await();    executorService.shutdown();    System.out.println(example.get());&#125;<span class="hljs-number">1000</span></code></pre><p>除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicSynchronizedExample</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;        cnt++;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> cnt;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> threadSize = <span class="hljs-number">1000</span>;    AtomicSynchronizedExample example = <span class="hljs-keyword">new</span> AtomicSynchronizedExample();    <span class="hljs-keyword">final</span> CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(threadSize);    ExecutorService executorService = Executors.newCachedThreadPool();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threadSize; i++) &#123;        executorService.execute(() -&gt; &#123;            example.add();            countDownLatch.countDown();        &#125;);    &#125;    countDownLatch.await();    executorService.shutdown();    System.out.println(example.get());&#125;<span class="hljs-number">1000</span></code></pre><h3 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2. 可见性"></a>2. 可见性</h3><p>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。</p><p>主要有三种实现可见性的方式：</p><ul><li>volatile</li><li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。</li><li>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。</li></ul><p>对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。</p><h3 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3. 有序性"></a>3. 有序性</h3><p>有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p><p>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。</p><p>也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。</p><h2 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h2><p>上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。</p><h3 id="1-单一线程原则"><a href="#1-单一线程原则" class="headerlink" title="1. 单一线程原则"></a>1. 单一线程原则</h3><blockquote><p>Single Thread rule</p></blockquote><p>在一个线程内，在程序前面的操作先行发生于后面的操作。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/874b3ff7-7c5c-4e7a-b8ab-a82a3e038d20.png" srcset="/img/loading.gif" alt="img"></p><h3 id="2-管程锁定规则"><a href="#2-管程锁定规则" class="headerlink" title="2. 管程锁定规则"></a>2. 管程锁定规则</h3><blockquote><p>Monitor Lock Rule</p></blockquote><p>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8996a537-7c4a-4ec8-a3b7-7ef1798eae26.png" srcset="/img/loading.gif" alt="img"></p><h3 id="3-volatile-变量规则"><a href="#3-volatile-变量规则" class="headerlink" title="3. volatile 变量规则"></a>3. volatile 变量规则</h3><blockquote><p>Volatile Variable Rule</p></blockquote><p>对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/942f33c9-8ad9-4987-836f-007de4c21de0.png" srcset="/img/loading.gif" alt="img"></p><h3 id="4-线程启动规则"><a href="#4-线程启动规则" class="headerlink" title="4. 线程启动规则"></a>4. 线程启动规则</h3><blockquote><p>Thread Start Rule</p></blockquote><p>Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6270c216-7ec0-4db7-94de-0003bce37cd2.png" srcset="/img/loading.gif" alt="img"></p><h3 id="5-线程加入规则"><a href="#5-线程加入规则" class="headerlink" title="5. 线程加入规则"></a>5. 线程加入规则</h3><blockquote><p>Thread Join Rule</p></blockquote><p>Thread 对象的结束先行发生于 join() 方法返回。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/233f8d89-31d7-413f-9c02-042f19c46ba1.png" srcset="/img/loading.gif" alt="img"></p><h3 id="6-线程中断规则"><a href="#6-线程中断规则" class="headerlink" title="6. 线程中断规则"></a>6. 线程中断规则</h3><blockquote><p>Thread Interruption Rule</p></blockquote><p>对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</p><h3 id="7-对象终结规则"><a href="#7-对象终结规则" class="headerlink" title="7. 对象终结规则"></a>7. 对象终结规则</h3><blockquote><p>Finalizer Rule</p></blockquote><p>一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</p><h3 id="8-传递性"><a href="#8-传递性" class="headerlink" title="8. 传递性"></a>8. 传递性</h3><blockquote><p>Transitivity</p></blockquote><p>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。</p><h1 id="十一、线程安全"><a href="#十一、线程安全" class="headerlink" title="十一、线程安全"></a>十一、线程安全</h1><p>多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。</p><p>线程安全有以下几种实现方式：</p><h2 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h2><p>不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。</p><p>不可变的类型：</p><ul><li>final 关键字修饰的基本数据类型</li><li>String</li><li>枚举类型</li><li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。</li></ul><p>对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImmutableExample</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        Map&lt;String, Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map);        unmodifiableMap.put(<span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>);    &#125;&#125;Exception in thread <span class="hljs-string">"main"</span> java.lang.UnsupportedOperationException    at java.util.Collections$UnmodifiableMap.put(Collections.java:<span class="hljs-number">1457</span>)    at ImmutableExample.main(ImmutableExample.java:<span class="hljs-number">9</span>)</code></pre><p>Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();&#125;</code></pre><h2 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h2><p>synchronized 和 ReentrantLock。</p><h2 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h2><p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p><p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p><p>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p><h3 id="1-CAS"><a href="#1-CAS" class="headerlink" title="1. CAS"></a>1. CAS</h3><p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p><h3 id="2-AtomicInteger"><a href="#2-AtomicInteger" class="headerlink" title="2. AtomicInteger"></a>2. AtomicInteger</h3><p>J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。</p><p>以下代码使用了 AtomicInteger 执行了自增的操作。</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> AtomicInteger cnt = <span class="hljs-keyword">new</span> AtomicInteger();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;    cnt.incrementAndGet();&#125;</code></pre><p>以下代码是 incrementAndGet() 的源码，它调用了 Unsafe 的 getAndAddInt() 。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">incrementAndGet</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-keyword">this</span>, valueOffset, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;&#125;</code></pre><p>以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。</p><p>可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndAddInt</span><span class="hljs-params">(Object var1, <span class="hljs-keyword">long</span> var2, <span class="hljs-keyword">int</span> var4)</span> </span>&#123;    <span class="hljs-keyword">int</span> var5;    <span class="hljs-keyword">do</span> &#123;        var5 = <span class="hljs-keyword">this</span>.getIntVolatile(var1, var2);    &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));    <span class="hljs-keyword">return</span> var5;&#125;</code></pre><h3 id="3-ABA"><a href="#3-ABA" class="headerlink" title="3. ABA"></a>3. ABA</h3><p>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</p><p>J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p><h2 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h2><p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</p><h3 id="1-栈封闭"><a href="#1-栈封闭" class="headerlink" title="1. 栈封闭"></a>1. 栈封闭</h3><p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackClosedExample</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add100</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;            cnt++;        &#125;        System.out.println(cnt);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    StackClosedExample example = <span class="hljs-keyword">new</span> StackClosedExample();    ExecutorService executorService = Executors.newCachedThreadPool();    executorService.execute(() -&gt; example.add100());    executorService.execute(() -&gt; example.add100());    executorService.shutdown();&#125;<span class="hljs-number">100</span><span class="hljs-number">100</span></code></pre><h3 id="2-线程本地存储（Thread-Local-Storage）"><a href="#2-线程本地存储（Thread-Local-Storage）" class="headerlink" title="2. 线程本地存储（Thread Local Storage）"></a>2. 线程本地存储（Thread Local Storage）</h3><p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p><p>符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。</p><p>可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。</p><p>对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalExample</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ThreadLocal threadLocal = <span class="hljs-keyword">new</span> ThreadLocal();        Thread thread1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            threadLocal.set(<span class="hljs-number">1</span>);            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">1000</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(threadLocal.get());            threadLocal.remove();        &#125;);        Thread thread2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            threadLocal.set(<span class="hljs-number">2</span>);            threadLocal.remove();        &#125;);        thread1.start();        thread2.start();    &#125;&#125;<span class="hljs-number">1</span></code></pre><p>为了理解 ThreadLocal，先看以下代码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalExample1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ThreadLocal threadLocal1 = <span class="hljs-keyword">new</span> ThreadLocal();        ThreadLocal threadLocal2 = <span class="hljs-keyword">new</span> ThreadLocal();        Thread thread1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            threadLocal1.set(<span class="hljs-number">1</span>);            threadLocal2.set(<span class="hljs-number">1</span>);        &#125;);        Thread thread2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            threadLocal1.set(<span class="hljs-number">2</span>);            threadLocal2.set(<span class="hljs-number">2</span>);        &#125;);        thread1.start();        thread2.start();    &#125;&#125;</code></pre><p>它所对应的底层结构图为：</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6782674c-1bfe-4879-af39-e9d722a95d39.png" srcset="/img/loading.gif" alt="img"></p><p>每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。</p><pre><code class="hljs java"><span class="hljs-comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span><span class="hljs-comment"> * by the ThreadLocal class. */</span>ThreadLocal.ThreadLocalMap threadLocals = <span class="hljs-keyword">null</span>;</code></pre><p>当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)        map.set(<span class="hljs-keyword">this</span>, value);    <span class="hljs-keyword">else</span>        createMap(t, value);&#125;</code></pre><p>get() 方法类似。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;        ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)            T result = (T)e.value;            <span class="hljs-keyword">return</span> result;        &#125;    &#125;    <span class="hljs-keyword">return</span> setInitialValue();&#125;</code></pre><p>ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。</p><p>在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。</p><h3 id="3-可重入代码（Reentrant-Code）"><a href="#3-可重入代码（Reentrant-Code）" class="headerlink" title="3. 可重入代码（Reentrant Code）"></a>3. 可重入代码（Reentrant Code）</h3><p>这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。</p><p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</p><h1 id="十二、锁优化"><a href="#十二、锁优化" class="headerlink" title="十二、锁优化"></a>十二、锁优化</h1><p>这里的锁优化主要是指 JVM 对 synchronized 的优化。</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p><p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p><p>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。</p><p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p><p>对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">concatString</span><span class="hljs-params">(String s1, String s2, String s3)</span> </span>&#123;    <span class="hljs-keyword">return</span> s1 + s2 + s3;&#125;</code></pre><p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">concatString</span><span class="hljs-params">(String s1, String s2, String s3)</span> </span>&#123;    StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();    sb.append(s1);    sb.append(s2);    sb.append(s3);    <span class="hljs-keyword">return</span> sb.toString();&#125;</code></pre><p>每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。</p><h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p><p>上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。</p><p>以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 tag bits 对应了五个状态，这些状态在右侧的 state 表格中给出。除了 marked for gc 状态，其它四个状态已经在前面介绍过了。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/bb6a49be-00f2-4f27-a0ce-4ed764bc605c.png" srcset="/img/loading.gif" alt="img"></p><p>下图左侧是一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/051e436c-0e46-4c59-8f67-52d89d656182.png" srcset="/img/loading.gif" alt="img"></p><p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。</p><p>当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/baaa681f-7c52-4198-a5ae-303b9386cf47.png" srcset="/img/loading.gif" alt="img"></p><p>如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。</p><h2 id="偏向锁-https-cyc2018-github-io-CS-Notes-notes-Java-并发-id-偏向锁"><a href="#偏向锁-https-cyc2018-github-io-CS-Notes-notes-Java-并发-id-偏向锁" class="headerlink" title="[偏向锁](https://cyc2018.github.io/CS-Notes/#/notes/Java 并发?id=偏向锁)"></a>[偏向锁](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 并发?id=偏向锁)</h2><p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。</p><p>当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。</p><p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/390c913b-5f31-444f-bbdb-2b88b688e7ce.jpg" srcset="/img/loading.gif" alt="img"></p><h1 id="十三、多线程开发良好的实践"><a href="#十三、多线程开发良好的实践" class="headerlink" title="十三、多线程开发良好的实践"></a>十三、多线程开发良好的实践</h1><ul><li>给线程起个有意义的名字，这样可以方便找 Bug。</li><li>缩小同步范围，从而减少锁争用。例如对于 synchronized，应该尽量使用同步块而不是同步方法。</li><li>多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。</li><li>使用 BlockingQueue 实现生产者消费者问题。</li><li>多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。</li><li>使用本地变量和不可变类来保证线程安全。</li><li>使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>BruceEckel. Java 编程思想: 第 4 版 [M]. 机械工业出版社, 2007.</li><li>周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011.</li><li><a href="https://docs.oracle.com/javase/specs/jvms/se6/html/Threads.doc.html" target="_blank" rel="noopener">Threads and Locks</a></li><li><a href="http://ifeve.com/thread-signaling/#missed_signal" target="_blank" rel="noopener">线程通信</a></li><li><a href="http://www.importnew.com/12773.html" target="_blank" rel="noopener">Java 线程面试题 Top 50</a></li><li><a href="http://tutorials.jenkov.com/java-util-concurrent/blockingqueue.html" target="_blank" rel="noopener">BlockingQueue</a></li><li><a href="https://stackoverflow.com/questions/11265289/thread-state-java" target="_blank" rel="noopener">thread state java</a></li><li><a href="http://wiki.expertiza.ncsu.edu/index.php/CSC_456_Spring_2012/ch7_MN" target="_blank" rel="noopener">CSC 456 Spring 2012/ch7 MN</a></li><li><a href="https://www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/happens-before.html" target="_blank" rel="noopener">Java - Understanding Happens-before relationship</a></li><li><a href="https://www.slideshare.net/novathinker/6-thread-synchronization" target="_blank" rel="noopener">6장 Thread Synchronization</a></li><li><a href="https://stackoverflow.com/questions/1202444/how-is-javas-threadlocal-implemented-under-the-hood/15653015" target="_blank" rel="noopener">How is Java’s ThreadLocal implemented under the hood?</a></li><li><a href="https://sites.google.com/site/webdevelopart/21-compile/06-java/javase/concurrent?tmpl=%2Fsystem%2Fapp%2Ftemplates%2Fprint%2F&showPrintDialog=1" target="_blank" rel="noopener">Concurrent</a></li><li><a href="http://www.javacreed.com/java-fork-join-example/" target="_blank" rel="noopener">JAVA FORK JOIN EXAMPLE</a></li><li><a href="http://ifeve.com/talk-concurrency-forkjoin/" target="_blank" rel="noopener">聊聊并发（八）——Fork/Join 框架介绍</a></li><li><a href="http://www.oracle.com/technetwork/java/javase/tech/biasedlocking-oopsla2006-preso-150106.pdf" target="_blank" rel="noopener">Eliminating SynchronizationRelated Atomic Operations with Biased Locking and Bulk Rebiasing</a></li></ul><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Thread</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>YKXiao Cloud 接口文档</title>
    <link href="/2020/03/10/YKXiao%20Cloud%20%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/"/>
    <url>/2020/03/10/YKXiao%20Cloud%20%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<p><strong>YKXiao Cloud 接口文档</strong></p><p><strong>简介</strong>：<p>YKXiao SpringClouds</p></p><p><strong>HOST</strong>:192.168.1.250:9527</p><p><strong>联系人</strong>:alterem</p><p><strong>Version</strong>:1.0.1-SNAPSHOT</p><p><strong>接口路径</strong>：/quartz/v2/api-docs</p><h1 id="sys-job-controller"><a href="#sys-job-controller" class="headerlink" title="sys-job-controller"></a>sys-job-controller</h1><p>[TOC]</p><h2 id="jobSave"><a href="#jobSave" class="headerlink" title="jobSave"></a>jobSave</h2><p><strong>接口描述</strong>:新增保存调度</p><p><strong>接口地址</strong>:<code>/quartz/job/add</code></p><p><strong>请求方式</strong>：<code>POST</code></p><p><strong>consumes</strong>:<code>[&quot;application/json&quot;]</code></p><p><strong>produces</strong>:<code>[&quot;*/*&quot;]</code></p><p><strong>请求参数</strong>：</p><table><thead><tr><th>参数名称</th><th>参数说明</th><th>in</th><th>是否必须</th><th>数据类型</th><th>schema</th></tr></thead><tbody><tr><td>beginTime</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>concurrent</td><td>并发执行：0=允许,1=禁止</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>createBy</td><td></td><td>query</td><td>false</td><td>integer</td><td></td></tr><tr><td>createTime</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>cronExpression</td><td>执行表达式</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>endTime</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>invokeTarget</td><td>调用目标字符串</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>jobGroup</td><td>任务组名</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>jobId</td><td>任务序号</td><td>query</td><td>false</td><td>integer</td><td></td></tr><tr><td>jobName</td><td>任务名称</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>misfirePolicy</td><td>计划策略：0=默认,1=立即触发执行,2=触发一次执行,3=不触发立即执行</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>nextValidTime</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>params</td><td></td><td>query</td><td>false</td><td>object</td><td></td></tr><tr><td>remark</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>searchValue</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>status</td><td>任务状态：0=正常,1=暂停</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>tenantId</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>updateBy</td><td></td><td>query</td><td>false</td><td>integer</td><td></td></tr><tr><td>updateTime</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr></tbody></table><p><strong>响应示例</strong>:</p><pre><code class="hljs json"></code></pre><p><strong>响应参数</strong>:</p><p>暂无</p><p><strong>响应状态</strong>:</p><table><thead><tr><th>状态码</th><th>说明</th><th>schema</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td></td></tr><tr><td>201</td><td>Created</td><td></td></tr><tr><td>401</td><td>Unauthorized</td><td></td></tr><tr><td>403</td><td>Forbidden</td><td></td></tr><tr><td>404</td><td>Not Found</td><td></td></tr><tr><td>## jobChangeStatus</td><td></td><td></td></tr></tbody></table><p><strong>接口描述</strong>:按照id修改调度状态</p><p><strong>接口地址</strong>:<code>/quartz/job/changeStatus</code></p><p><strong>请求方式</strong>：<code>POST</code></p><p><strong>consumes</strong>:<code>[&quot;application/json&quot;]</code></p><p><strong>produces</strong>:<code>[&quot;*/*&quot;]</code></p><p><strong>请求参数</strong>：</p><table><thead><tr><th>参数名称</th><th>参数说明</th><th>in</th><th>是否必须</th><th>数据类型</th><th>schema</th></tr></thead><tbody><tr><td>beginTime</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>concurrent</td><td>并发执行：0=允许,1=禁止</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>createBy</td><td></td><td>query</td><td>false</td><td>integer</td><td></td></tr><tr><td>createTime</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>cronExpression</td><td>执行表达式</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>endTime</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>invokeTarget</td><td>调用目标字符串</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>jobGroup</td><td>任务组名</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>jobId</td><td></td><td>query</td><td>true</td><td>string</td><td></td></tr><tr><td>jobName</td><td>任务名称</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>misfirePolicy</td><td>计划策略：0=默认,1=立即触发执行,2=触发一次执行,3=不触发立即执行</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>nextValidTime</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>params</td><td></td><td>query</td><td>false</td><td>object</td><td></td></tr><tr><td>remark</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>searchValue</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>status</td><td>任务状态：0=正常,1=暂停</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>tenantId</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>updateBy</td><td></td><td>query</td><td>false</td><td>integer</td><td></td></tr><tr><td>updateTime</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr></tbody></table><p><strong>响应示例</strong>:</p><pre><code class="hljs json"></code></pre><p><strong>响应参数</strong>:</p><p>暂无</p><p><strong>响应状态</strong>:</p><table><thead><tr><th>状态码</th><th>说明</th><th>schema</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td></td></tr><tr><td>201</td><td>Created</td><td></td></tr><tr><td>401</td><td>Unauthorized</td><td></td></tr><tr><td>403</td><td>Forbidden</td><td></td></tr><tr><td>404</td><td>Not Found</td><td></td></tr><tr><td>## jobCheckCronExpressionIsValid</td><td></td><td></td></tr></tbody></table><p><strong>接口描述</strong>:校验cron表达式是否有效</p><p><strong>接口地址</strong>:<code>/quartz/job/checkCronExpressionIsValid</code></p><p><strong>请求方式</strong>：<code>POST</code></p><p><strong>consumes</strong>:<code>[&quot;application/json&quot;]</code></p><p><strong>produces</strong>:<code>[&quot;*/*&quot;]</code></p><p><strong>请求示例</strong>：</p><pre><code class="hljs json">&#123;<span class="hljs-attr">"beginTime"</span>: <span class="hljs-string">""</span>,<span class="hljs-attr">"concurrent"</span>: <span class="hljs-string">""</span>,<span class="hljs-attr">"createBy"</span>: <span class="hljs-number">0</span>,<span class="hljs-attr">"createTime"</span>: <span class="hljs-string">""</span>,<span class="hljs-attr">"cronExpression"</span>: <span class="hljs-string">""</span>,<span class="hljs-attr">"endTime"</span>: <span class="hljs-string">""</span>,<span class="hljs-attr">"invokeTarget"</span>: <span class="hljs-string">""</span>,<span class="hljs-attr">"jobGroup"</span>: <span class="hljs-string">""</span>,<span class="hljs-attr">"jobId"</span>: <span class="hljs-number">0</span>,<span class="hljs-attr">"jobName"</span>: <span class="hljs-string">""</span>,<span class="hljs-attr">"misfirePolicy"</span>: <span class="hljs-string">""</span>,<span class="hljs-attr">"nextValidTime"</span>: <span class="hljs-string">""</span>,<span class="hljs-attr">"params"</span>: &#123;&#125;,<span class="hljs-attr">"remark"</span>: <span class="hljs-string">""</span>,<span class="hljs-attr">"searchValue"</span>: <span class="hljs-string">""</span>,<span class="hljs-attr">"status"</span>: <span class="hljs-string">""</span>,<span class="hljs-attr">"tenantId"</span>: <span class="hljs-string">""</span>,<span class="hljs-attr">"updateBy"</span>: <span class="hljs-number">0</span>,<span class="hljs-attr">"updateTime"</span>: <span class="hljs-string">""</span>&#125;</code></pre><p><strong>请求参数</strong>：</p><table><thead><tr><th>参数名称</th><th>参数说明</th><th>in</th><th>是否必须</th><th>数据类型</th><th>schema</th></tr></thead><tbody><tr><td>job</td><td>job</td><td>body</td><td>true</td><td>SysJob</td><td>SysJob</td></tr></tbody></table><p><strong>schema属性说明</strong></p><p><strong>SysJob</strong></p><table><thead><tr><th>参数名称</th><th>参数说明</th><th>in</th><th>是否必须</th><th>数据类型</th><th>schema</th></tr></thead><tbody><tr><td>beginTime</td><td></td><td>body</td><td>false</td><td>string</td><td></td></tr><tr><td>concurrent</td><td></td><td>body</td><td>false</td><td>string</td><td></td></tr><tr><td>createBy</td><td></td><td>body</td><td>false</td><td>integer(int64)</td><td></td></tr><tr><td>createTime</td><td></td><td>body</td><td>false</td><td>string(date-time)</td><td></td></tr><tr><td>cronExpression</td><td></td><td>body</td><td>false</td><td>string</td><td></td></tr><tr><td>endTime</td><td></td><td>body</td><td>false</td><td>string</td><td></td></tr><tr><td>invokeTarget</td><td></td><td>body</td><td>false</td><td>string</td><td></td></tr><tr><td>jobGroup</td><td></td><td>body</td><td>false</td><td>string</td><td></td></tr><tr><td>jobId</td><td></td><td>body</td><td>false</td><td>integer(int64)</td><td></td></tr><tr><td>jobName</td><td></td><td>body</td><td>false</td><td>string</td><td></td></tr><tr><td>misfirePolicy</td><td></td><td>body</td><td>false</td><td>string</td><td></td></tr><tr><td>nextValidTime</td><td></td><td>body</td><td>false</td><td>string(date-time)</td><td></td></tr><tr><td>params</td><td></td><td>body</td><td>false</td><td>object</td><td></td></tr><tr><td>remark</td><td></td><td>body</td><td>false</td><td>string</td><td></td></tr><tr><td>searchValue</td><td></td><td>body</td><td>false</td><td>string</td><td></td></tr><tr><td>status</td><td></td><td>body</td><td>false</td><td>string</td><td></td></tr><tr><td>tenantId</td><td></td><td>body</td><td>false</td><td>string</td><td></td></tr><tr><td>updateBy</td><td></td><td>body</td><td>false</td><td>integer(int64)</td><td></td></tr><tr><td>updateTime</td><td></td><td>body</td><td>false</td><td>string(date-time)</td><td></td></tr></tbody></table><p><strong>响应示例</strong>:</p><pre><code class="hljs json"></code></pre><p><strong>响应参数</strong>:</p><p>暂无</p><p><strong>响应状态</strong>:</p><table><thead><tr><th>状态码</th><th>说明</th><th>schema</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td></td></tr><tr><td>201</td><td>Created</td><td></td></tr><tr><td>401</td><td>Unauthorized</td><td></td></tr><tr><td>403</td><td>Forbidden</td><td></td></tr><tr><td>404</td><td>Not Found</td><td></td></tr><tr><td>## jobEdit</td><td></td><td></td></tr></tbody></table><p><strong>接口描述</strong>:修改保存调度</p><p><strong>接口地址</strong>:<code>/quartz/job/edit</code></p><p><strong>请求方式</strong>：<code>POST</code></p><p><strong>consumes</strong>:<code>[&quot;application/json&quot;]</code></p><p><strong>produces</strong>:<code>[&quot;*/*&quot;]</code></p><p><strong>请求参数</strong>：</p><table><thead><tr><th>参数名称</th><th>参数说明</th><th>in</th><th>是否必须</th><th>数据类型</th><th>schema</th></tr></thead><tbody><tr><td>beginTime</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>concurrent</td><td>并发执行：0=允许,1=禁止</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>createBy</td><td></td><td>query</td><td>false</td><td>integer</td><td></td></tr><tr><td>createTime</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>cronExpression</td><td>执行表达式</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>endTime</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>invokeTarget</td><td>调用目标字符串</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>jobGroup</td><td>任务组名</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>jobId</td><td>任务序号</td><td>query</td><td>false</td><td>integer</td><td></td></tr><tr><td>jobName</td><td>任务名称</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>misfirePolicy</td><td>计划策略：0=默认,1=立即触发执行,2=触发一次执行,3=不触发立即执行</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>nextValidTime</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>params</td><td></td><td>query</td><td>false</td><td>object</td><td></td></tr><tr><td>remark</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>searchValue</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>status</td><td>任务状态：0=正常,1=暂停</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>tenantId</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>updateBy</td><td></td><td>query</td><td>false</td><td>integer</td><td></td></tr><tr><td>updateTime</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr></tbody></table><p><strong>响应示例</strong>:</p><pre><code class="hljs json"></code></pre><p><strong>响应参数</strong>:</p><p>暂无</p><p><strong>响应状态</strong>:</p><table><thead><tr><th>状态码</th><th>说明</th><th>schema</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td></td></tr><tr><td>201</td><td>Created</td><td></td></tr><tr><td>401</td><td>Unauthorized</td><td></td></tr><tr><td>403</td><td>Forbidden</td><td></td></tr><tr><td>404</td><td>Not Found</td><td></td></tr><tr><td>## jobExport</td><td></td><td></td></tr></tbody></table><p><strong>接口描述</strong>:导出定时任务列表到Excel</p><p><strong>接口地址</strong>:<code>/quartz/job/export</code></p><p><strong>请求方式</strong>：<code>POST</code></p><p><strong>consumes</strong>:<code>[&quot;application/json&quot;]</code></p><p><strong>produces</strong>:<code>[&quot;*/*&quot;]</code></p><p><strong>请求参数</strong>：</p><table><thead><tr><th>参数名称</th><th>参数说明</th><th>in</th><th>是否必须</th><th>数据类型</th><th>schema</th></tr></thead><tbody><tr><td>beginTime</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>concurrent</td><td>并发执行：0=允许,1=禁止</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>createBy</td><td></td><td>query</td><td>false</td><td>integer</td><td></td></tr><tr><td>createTime</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>cronExpression</td><td>执行表达式</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>endTime</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>invokeTarget</td><td>调用目标字符串</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>jobGroup</td><td>任务组名</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>jobId</td><td>任务序号</td><td>query</td><td>false</td><td>integer</td><td></td></tr><tr><td>jobName</td><td>任务名称</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>misfirePolicy</td><td>计划策略：0=默认,1=立即触发执行,2=触发一次执行,3=不触发立即执行</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>nextValidTime</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>params</td><td></td><td>query</td><td>false</td><td>object</td><td></td></tr><tr><td>remark</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>searchValue</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>status</td><td>任务状态：0=正常,1=暂停</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>tenantId</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>updateBy</td><td></td><td>query</td><td>false</td><td>integer</td><td></td></tr><tr><td>updateTime</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr></tbody></table><p><strong>响应示例</strong>:</p><pre><code class="hljs json"></code></pre><p><strong>响应参数</strong>:</p><p>暂无</p><p><strong>响应状态</strong>:</p><table><thead><tr><th>状态码</th><th>说明</th><th>schema</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td></td></tr><tr><td>201</td><td>Created</td><td></td></tr><tr><td>401</td><td>Unauthorized</td><td></td></tr><tr><td>403</td><td>Forbidden</td><td></td></tr><tr><td>404</td><td>Not Found</td><td></td></tr><tr><td>## jobList</td><td></td><td></td></tr></tbody></table><p><strong>接口描述</strong>:获取调度任务列表</p><p><strong>接口地址</strong>:<code>/quartz/job/list</code></p><p><strong>请求方式</strong>：<code>POST</code></p><p><strong>consumes</strong>:<code>[&quot;application/json&quot;]</code></p><p><strong>produces</strong>:<code>[&quot;*/*&quot;]</code></p><p><strong>请求参数</strong>：</p><table><thead><tr><th>参数名称</th><th>参数说明</th><th>in</th><th>是否必须</th><th>数据类型</th><th>schema</th></tr></thead><tbody><tr><td>beginTime</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>concurrent</td><td>并发执行：0=允许,1=禁止</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>createBy</td><td></td><td>query</td><td>false</td><td>integer</td><td></td></tr><tr><td>createTime</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>cronExpression</td><td>执行表达式</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>endTime</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>invokeTarget</td><td>调用目标字符串</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>jobGroup</td><td>任务组名</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>jobId</td><td>任务序号</td><td>query</td><td>false</td><td>integer</td><td></td></tr><tr><td>jobName</td><td>任务名称</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>misfirePolicy</td><td>计划策略：0=默认,1=立即触发执行,2=触发一次执行,3=不触发立即执行</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>nextValidTime</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>params</td><td></td><td>query</td><td>false</td><td>object</td><td></td></tr><tr><td>remark</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>searchValue</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>status</td><td>任务状态：0=正常,1=暂停</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>tenantId</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>updateBy</td><td></td><td>query</td><td>false</td><td>integer</td><td></td></tr><tr><td>updateTime</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr></tbody></table><p><strong>响应示例</strong>:</p><pre><code class="hljs json">&#123;<span class="hljs-attr">"code"</span>: <span class="hljs-number">0</span>,<span class="hljs-attr">"rows"</span>: [],<span class="hljs-attr">"total"</span>: <span class="hljs-number">0</span>&#125;</code></pre><p><strong>响应参数</strong>:</p><table><thead><tr><th>参数名称</th><th>参数说明</th><th>类型</th><th>schema</th></tr></thead><tbody><tr><td>code</td><td></td><td>integer(int32)</td><td>integer(int32)</td></tr><tr><td>rows</td><td></td><td>array</td><td></td></tr><tr><td>total</td><td></td><td>integer(int64)</td><td>integer(int64)</td></tr></tbody></table><p><strong>响应状态</strong>:</p><table><thead><tr><th>状态码</th><th>说明</th><th>schema</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>TableDataInfo</td></tr><tr><td>201</td><td>Created</td><td></td></tr><tr><td>401</td><td>Unauthorized</td><td></td></tr><tr><td>403</td><td>Forbidden</td><td></td></tr><tr><td>404</td><td>Not Found</td><td></td></tr><tr><td>## jobRemove</td><td></td><td></td></tr></tbody></table><p><strong>接口描述</strong>:按照id批量删除调度信息</p><p><strong>接口地址</strong>:<code>/quartz/job/remove</code></p><p><strong>请求方式</strong>：<code>POST</code></p><p><strong>consumes</strong>:<code>[&quot;application/json&quot;]</code></p><p><strong>produces</strong>:<code>[&quot;*/*&quot;]</code></p><p><strong>请求参数</strong>：</p><table><thead><tr><th>参数名称</th><th>参数说明</th><th>in</th><th>是否必须</th><th>数据类型</th><th>schema</th></tr></thead><tbody><tr><td>ids</td><td>ids</td><td>query</td><td>false</td><td>string</td><td></td></tr></tbody></table><p><strong>响应示例</strong>:</p><pre><code class="hljs json"></code></pre><p><strong>响应参数</strong>:</p><p>暂无</p><p><strong>响应状态</strong>:</p><table><thead><tr><th>状态码</th><th>说明</th><th>schema</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td></td></tr><tr><td>201</td><td>Created</td><td></td></tr><tr><td>401</td><td>Unauthorized</td><td></td></tr><tr><td>403</td><td>Forbidden</td><td></td></tr><tr><td>404</td><td>Not Found</td><td></td></tr><tr><td>## jobRun</td><td></td><td></td></tr></tbody></table><p><strong>接口描述</strong>:任务调度立即执行一次</p><p><strong>接口地址</strong>:<code>/quartz/job/run</code></p><p><strong>请求方式</strong>：<code>POST</code></p><p><strong>consumes</strong>:<code>[&quot;application/json&quot;]</code></p><p><strong>produces</strong>:<code>[&quot;*/*&quot;]</code></p><p><strong>请求参数</strong>：</p><table><thead><tr><th>参数名称</th><th>参数说明</th><th>in</th><th>是否必须</th><th>数据类型</th><th>schema</th></tr></thead><tbody><tr><td>beginTime</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>concurrent</td><td>并发执行：0=允许,1=禁止</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>createBy</td><td></td><td>query</td><td>false</td><td>integer</td><td></td></tr><tr><td>createTime</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>cronExpression</td><td>执行表达式</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>endTime</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>invokeTarget</td><td>调用目标字符串</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>jobGroup</td><td>任务组名</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>jobId</td><td>任务序号</td><td>query</td><td>false</td><td>integer</td><td></td></tr><tr><td>jobName</td><td>任务名称</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>misfirePolicy</td><td>计划策略：0=默认,1=立即触发执行,2=触发一次执行,3=不触发立即执行</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>nextValidTime</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>params</td><td></td><td>query</td><td>false</td><td>object</td><td></td></tr><tr><td>remark</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>searchValue</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>status</td><td>任务状态：0=正常,1=暂停</td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>tenantId</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr><tr><td>updateBy</td><td></td><td>query</td><td>false</td><td>integer</td><td></td></tr><tr><td>updateTime</td><td></td><td>query</td><td>false</td><td>string</td><td></td></tr></tbody></table><p><strong>响应示例</strong>:</p><pre><code class="hljs json"></code></pre><p><strong>响应参数</strong>:</p><p>暂无</p><p><strong>响应状态</strong>:</p><table><thead><tr><th>状态码</th><th>说明</th><th>schema</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td></td></tr><tr><td>201</td><td>Created</td><td></td></tr><tr><td>401</td><td>Unauthorized</td><td></td></tr><tr><td>403</td><td>Forbidden</td><td></td></tr><tr><td>404</td><td>Not Found</td><td></td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一些电子书分享</title>
    <link href="/2020/01/18/%E4%B8%80%E4%BA%9B%E7%94%B5%E5%AD%90%E4%B9%A6%E5%88%86%E4%BA%AB/"/>
    <url>/2020/01/18/%E4%B8%80%E4%BA%9B%E7%94%B5%E5%AD%90%E4%B9%A6%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/photo-1579198175390-62466fc79ea2" srcset="/img/loading.gif" alt="img"></p><p>中国古代文学发展史 上中下</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1JcLg7z33-QCgH4XGtcXoEg" target="_blank" rel="noopener">https://pan.baidu.com/s/1JcLg7z33-QCgH4XGtcXoEg</a> </p><p>提取码：jQ88</p></blockquote><p>11408114_中国传统伦理思想史 _作 者 ：朱贻庭主编华东师范大学出版社 . 2003.09</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1kEQHdIFkbq6vd-4uR7Zr-g" target="_blank" rel="noopener">https://pan.baidu.com/s/1kEQHdIFkbq6vd-4uR7Zr-g</a> </p><p>提取码：GwR1</p></blockquote><p>11718143_禅月集校注 _作 者 ：陆永峰著巴蜀书社 . 2006.08</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/17BAWnA0sbP6Zn4Fk1PHaEw" target="_blank" rel="noopener">https://pan.baidu.com/s/17BAWnA0sbP6Zn4Fk1PHaEw</a> </p><p>提取码：UxEW</p></blockquote><p>11248370_中国古代诗词曲史 _作 者 ：陈玉刚著百花洲文艺出版社 . 1995.02</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1rns2Fe78U63K4AbebjBTjw" target="_blank" rel="noopener">https://pan.baidu.com/s/1rns2Fe78U63K4AbebjBTjw</a> </p><p>提取码：62fX</p></blockquote><p>10462190_中西文化碰撞与近代文学 _作 者 ：郭延礼著山东教育出版社 . 1999.12</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/13Mx1JGE83mAnulXW7n8Csg" target="_blank" rel="noopener">https://pan.baidu.com/s/13Mx1JGE83mAnulXW7n8Csg</a> </p><p>提取码：X5U3</p></blockquote><p>10320473_张颔学术文集 _作 者 ：张颌著中华书局 . 1995.03</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1nQ5I_tyNfv1qFjpTMJee9w" target="_blank" rel="noopener">https://pan.baidu.com/s/1nQ5I_tyNfv1qFjpTMJee9w</a> </p><p>提取码：T6oU</p></blockquote><p>10404331_大航海时代_明清间的中西音乐交流 _作 者 ：陶亚兵著东方出版社 . 2001.08</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1K1rGSvekg234oMaDSsqt2g" target="_blank" rel="noopener">https://pan.baidu.com/s/1K1rGSvekg234oMaDSsqt2g</a> </p><p>提取码：6294</p></blockquote><p>10156344_二十世纪文库_文化的起源 _作 者 ：（美）哈里斯（Harris，M.）著；黄 晴译华夏出版社 . 1988.12</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/10F0enPLEQC2aQSVihhy_ow" target="_blank" rel="noopener">https://pan.baidu.com/s/10F0enPLEQC2aQSVihhy_ow</a> </p><p>提取码：J224</p></blockquote><p><strong>以上集合</strong></p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1BJ7Q6GGrW4KQdKShqrW8_Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1BJ7Q6GGrW4KQdKShqrW8_Q</a> </p><p>提取码：hkc5</p></blockquote><hr><p>《企鹅经典：小黑书》[第一辑] 成立80周年 </p><ol><li><a href="https://t00y.com/file/16058819-403645832" target="_blank" rel="noopener">https://t00y.com/file/16058819-403645832</a></li><li><a href="https://t00y.com/file/16058819-403645849" target="_blank" rel="noopener">https://t00y.com/file/16058819-403645849</a></li></ol><p>《企鹅经典：小黑书》[第二辑] 成立80周年 </p><ol><li><a href="https://t00y.com/file/16058819-403896643" target="_blank" rel="noopener">https://t00y.com/file/16058819-403896643</a></li><li><a href="https://t00y.com/file/16058819-403896659" target="_blank" rel="noopener">https://t00y.com/file/16058819-403896659</a></li></ol><p>三千佛塔烟云下：东南亚五国文化纪行 </p><ol><li><a href="https://t00y.com/file/16058819-242766079" target="_blank" rel="noopener">https://t00y.com/file/16058819-242766079</a></li><li><a href="https://t00y.com/file/16058819-242766089" target="_blank" rel="noopener">https://t00y.com/file/16058819-242766089</a></li></ol><p>印度，漂浮的次大陆 </p><p><a href="https://sn9.us/file/19794310-372441997" target="_blank" rel="noopener">https://sn9.us/file/19794310-372441997</a></p><p>穿越百年中东 </p><ol><li><a href="https://t00y.com/file/16058819-384996221" target="_blank" rel="noopener">https://t00y.com/file/16058819-384996221</a></li><li><a href="https://t00y.com/file/16058819-384996264" target="_blank" rel="noopener">https://t00y.com/file/16058819-384996264</a></li></ol><p>汴京之围 </p><ol><li><a href="https://t00y.com/file/16058819-394930450" target="_blank" rel="noopener">https://t00y.com/file/16058819-394930450</a></li><li><a href="https://t00y.com/file/16058819-394930467" target="_blank" rel="noopener">https://t00y.com/file/16058819-394930467</a></li></ol><p>骑车去元朝</p><ol><li><a href="https://t00y.com/file/16058819-404011754" target="_blank" rel="noopener">https://t00y.com/file/16058819-404011754</a></li><li><a href="https://t00y.com/file/16058819-404011720" target="_blank" rel="noopener">https://t00y.com/file/16058819-404011720</a></li></ol><p>帝国往事三部曲全3本 </p><ol><li>中央帝国的军事密码 <ol><li><a href="https://t00y.com/file/16058819-403645878" target="_blank" rel="noopener">https://t00y.com/file/16058819-403645878</a></li><li><a href="https://t00y.com/file/16058819-403645888" target="_blank" rel="noopener">https://t00y.com/file/16058819-403645888</a></li></ol></li><li>中央帝国的哲学密码 <ol><li><a href="http://libgen.is/book/index.php?md5=7CF901D832B815BF06CD096CDB5886F7" target="_blank" rel="noopener">http://libgen.is/book/index.php?md5=7CF901D832B815BF06CD096CDB5886F7</a></li><li><a href="https://b-ok.cc/book/3646315/6a49d2" target="_blank" rel="noopener">https://b-ok.cc/book/3646315/6a49d2</a></li></ol></li><li>中央帝国的财政密码 <ol><li><a href="https://t00y.com/file/16058819-296897601" target="_blank" rel="noopener">https://t00y.com/file/16058819-296897601</a></li><li><a href="https://t00y.com/file/16058819-296897607" target="_blank" rel="noopener">https://t00y.com/file/16058819-296897607</a></li><li><a href="https://b-ok.cc/book/3646286/aa8b51" target="_blank" rel="noopener">https://b-ok.cc/book/3646286/aa8b51</a></li></ol></li></ol><p>【卡斯特瑞阿迪斯】社会的想象性建构.pdf</p><blockquote><p><a href="https://545c.com/file/15169360-371566030" target="_blank" rel="noopener">https://545c.com/file/15169360-371566030</a></p></blockquote><p>《晚清民初南洋华人社群的文化建构》 epub</p><blockquote><p><a href="https://t00y.com/file/16058819-394931013" target="_blank" rel="noopener">https://t00y.com/file/16058819-394931013</a></p></blockquote><p>《道家易学建构》陈鼓应 epub</p><blockquote><p><a href="https://t00y.com/file/16058819-414574226" target="_blank" rel="noopener">https://t00y.com/file/16058819-414574226</a></p></blockquote><p>孙宝《儒学嬗变与魏晋文风建构》epub </p><blockquote><p><a href="https://t00y.com/file/16058819-294741013" target="_blank" rel="noopener">https://t00y.com/file/16058819-294741013</a></p></blockquote><p>马雅贞《刻画战勋:清朝帝国武功的文化建构》epub</p><blockquote><p><a href="https://t00y.com/file/16058819-298731477" target="_blank" rel="noopener">https://t00y.com/file/16058819-298731477</a></p></blockquote><h4 id="一、文学类1、历代诗文总集别集（589-81G）"><a href="#一、文学类1、历代诗文总集别集（589-81G）" class="headerlink" title="一、文学类1、历代诗文总集别集（589.81G）"></a>一、文学类1、历代诗文总集别集（589.81G）</h4><blockquote><p>链接：<a href="https://pan.baidu.com/s/1PfHuI4dZj2lrTC29HF9Y0A" target="_blank" rel="noopener">https://pan.baidu.com/s/1PfHuI4dZj2lrTC29HF9Y0A</a></p><p>提取码：1rgn</p></blockquote><p>2、宝卷（5.09G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/17EirJUssRKdh7VQxAax9rg" target="_blank" rel="noopener">https://pan.baidu.com/s/17EirJUssRKdh7VQxAax9rg</a></p><p>提取码：afxl</p></blockquote><p>3、文学史相关（14.72G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1adtUkdt9LtNEakZDl1y0nw" target="_blank" rel="noopener">https://pan.baidu.com/s/1adtUkdt9LtNEakZDl1y0nw</a></p><p>提取码：zyqt</p></blockquote><p>4、金圣叹全集（142M）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1LOsAGMd3Ec1DoLURYTcl_g" target="_blank" rel="noopener">https://pan.baidu.com/s/1LOsAGMd3Ec1DoLURYTcl_g</a></p><p>提取码：9ti1</p></blockquote><h4 id="二、历史地理类"><a href="#二、历史地理类" class="headerlink" title="二、历史地理类"></a>二、历史地理类</h4><p>1、方志、地理类（594.43G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1SJRFK19I_TdRKd-0PdaGig" target="_blank" rel="noopener">https://pan.baidu.com/s/1SJRFK19I_TdRKd-0PdaGig</a></p><p>提取码：tnq0</p></blockquote><p>2、历代史料笔记丛刊（2.21G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1Jt5NNGkAEI7Tiy4tKrL-qA" target="_blank" rel="noopener">https://pan.baidu.com/s/1Jt5NNGkAEI7Tiy4tKrL-qA</a></p><p>提取码：890f</p></blockquote><p>3、近代中国史料丛刊（53.91G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1tBUBSN7lsFBgEgTiVyjXuw" target="_blank" rel="noopener">https://pan.baidu.com/s/1tBUBSN7lsFBgEgTiVyjXuw</a></p><p>提取码：btsc</p></blockquote><p>4、民国史料丛刊（84.53G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1p1Q1TKK7TVFg59xa-7bxYQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1p1Q1TKK7TVFg59xa-7bxYQ</a></p><p>提取码：rlms</p></blockquote><p>5、中国史学基本典籍丛刊（2.49G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1CNWMmfW6EaVwEr6qjmZ1Kg" target="_blank" rel="noopener">https://pan.baidu.com/s/1CNWMmfW6EaVwEr6qjmZ1Kg</a></p><p>提取码：ou6h</p></blockquote><p>6、琉球王国汉文文献集成（7.60G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1wmfdUiV4G-PTpWoHk4R_Tw" target="_blank" rel="noopener">https://pan.baidu.com/s/1wmfdUiV4G-PTpWoHk4R_Tw</a></p><p>提取码：o15z</p></blockquote><p>7、北京图书馆藏中国历代石刻拓本汇编（101册全）_A（14.64G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1pA5izcmfTrZcbQ5nB1mmhQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1pA5izcmfTrZcbQ5nB1mmhQ</a></p><p>提取码：nsr6</p></blockquote><p>8、甲骨文獻集成（12.50G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1-LV0_6xKs4I_c9KOed9b3Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1-LV0_6xKs4I_c9KOed9b3Q</a></p><p>提取码：bjo8</p></blockquote><p>9、秦晋豫新出墓志搜佚续编（全5册）（赵文成，赵君平编）（国家图书馆出版社 , 2015.07）（3.34G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1jr-U8okTxfWGQ1m3vmgcOg" target="_blank" rel="noopener">https://pan.baidu.com/s/1jr-U8okTxfWGQ1m3vmgcOg</a></p><p>提取码：pgm9</p></blockquote><p>10、秦晋豫新出墓志蒐佚（总4册，仅有2,3册）（赵君平、赵文成）（北京图书馆出版社 2012）（825M）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/16J_ktWzvuZ0NJuo4A2bH-A" target="_blank" rel="noopener">https://pan.baidu.com/s/16J_ktWzvuZ0NJuo4A2bH-A</a></p><p>提取码：v5j4</p></blockquote><p>11、列国志_133 121册（9.18G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/19nLKAHRDf_9s1feTYnuBOQ" target="_blank" rel="noopener">https://pan.baidu.com/s/19nLKAHRDf_9s1feTYnuBOQ</a></p><p>提取码：917i</p></blockquote><h4 id="三、综合图书类"><a href="#三、综合图书类" class="headerlink" title="三、综合图书类"></a>三、综合图书类</h4><h5 id="（一）旧经籍类"><a href="#（一）旧经籍类" class="headerlink" title="（一）旧经籍类"></a>（一）旧经籍类</h5><p>1、早稻田10萬pdf壓縮版201705.zip（1663.11G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1kHSjYWycsvvjSQAKBV0cjg" target="_blank" rel="noopener">https://pan.baidu.com/s/1kHSjYWycsvvjSQAKBV0cjg</a></p><p>提取码：qhkw</p></blockquote><p>2、東大10975_4G.zip[44]（167.65G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1VTqQRnp06NBVpTZrZORiGQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1VTqQRnp06NBVpTZrZORiGQ</a></p><p>提取码：yye0</p></blockquote><p>3、各类珍本古籍、史料纪传、军事兵法、古代兵书战策、地理堪舆方志、非常稀少不外传的珍本收藏书籍（70.21G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1Ht58WTd3_c1Md3WcidvPDA" target="_blank" rel="noopener">https://pan.baidu.com/s/1Ht58WTd3_c1Md3WcidvPDA</a></p><p>提取码：9yme</p></blockquote><p>4、宋会要辑稿 校点本全16册 SPAN&gt; 上海古籍出版2014（2.71G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1m88qIKqXccFLv8pOxLW6Mw" target="_blank" rel="noopener">https://pan.baidu.com/s/1m88qIKqXccFLv8pOxLW6Mw</a></p><p>提取码：mjki</p></blockquote><p>5、十三经注疏十三经注疏（艺文印书馆影印）（1.51G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1-66pNjdLpLR4NQOa5OkRKA" target="_blank" rel="noopener">https://pan.baidu.com/s/1-66pNjdLpLR4NQOa5OkRKA</a></p><p>提取码：5kp1</p></blockquote><p>十三经注疏.三百三十五卷（10.17G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1tBmiCgQXekrs3DVbbB96dw" target="_blank" rel="noopener">https://pan.baidu.com/s/1tBmiCgQXekrs3DVbbB96dw</a></p><p>提取码：w19t</p></blockquote><p>十三经注疏 繁体竖排（2.45G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/15VfSp9fOyUk7V1gGzsw6eQ" target="_blank" rel="noopener">https://pan.baidu.com/s/15VfSp9fOyUk7V1gGzsw6eQ</a></p><p>提取码：0kqu</p></blockquote><p>十三经注疏（188M）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1bGuA1EJ611s0OKjYe-yXEA" target="_blank" rel="noopener">https://pan.baidu.com/s/1bGuA1EJ611s0OKjYe-yXEA</a></p><p>提取码：74xe</p></blockquote><h5 id="（二）丛书类"><a href="#（二）丛书类" class="headerlink" title="（二）丛书类"></a>（二）丛书类</h5><p>1、经典珍藏合集系列（490.91G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1cKEfaoFPv2qP-BUeEN8tIQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1cKEfaoFPv2qP-BUeEN8tIQ</a></p><p>提取码：gwqy</p></blockquote><p>2、中华大典（9.02G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/12AsHuJZ6zW2joUJnF7lkdw" target="_blank" rel="noopener">https://pan.baidu.com/s/12AsHuJZ6zW2joUJnF7lkdw</a></p><p>提取码：hibi</p></blockquote><p>3、Kindle伴侣电子书库，解压密码为sz520（30.61G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1eYsq4h_l-nJArHJiM_u-HA" target="_blank" rel="noopener">https://pan.baidu.com/s/1eYsq4h_l-nJArHJiM_u-HA</a></p><p>提取码：jpe8</p></blockquote><p>4、Kindle人电子书合集,解压密码为sz520（81.52G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1K7sanuh9SLAzyF8KxZA-bw" target="_blank" rel="noopener">https://pan.baidu.com/s/1K7sanuh9SLAzyF8KxZA-bw</a></p><p>提取码：73lm</p></blockquote><p>5、Kindle书库48208册（8.48）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1RU3z3YHEhoI0v6FuE4d1fA" target="_blank" rel="noopener">https://pan.baidu.com/s/1RU3z3YHEhoI0v6FuE4d1fA</a></p><p>提取码：wlcf</p></blockquote><p>6、Wode小书屋（125.11G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1B525W-jieQNv2nXcm6Sjgg" target="_blank" rel="noopener">https://pan.baidu.com/s/1B525W-jieQNv2nXcm6Sjgg</a></p><p>提取码：bcf8</p></blockquote><p>7、亚马逊Kindle商店12,000册原版英文书，解压密码为sz520（18.44G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1NAd_sckOhDGPgufxr3Qsig" target="_blank" rel="noopener">https://pan.baidu.com/s/1NAd_sckOhDGPgufxr3Qsig</a></p><p>提取码：sb0s</p></blockquote><h5 id="（三）期刊类申报影印本（160-03G）"><a href="#（三）期刊类申报影印本（160-03G）" class="headerlink" title="（三）期刊类申报影印本（160.03G）"></a>（三）期刊类申报影印本（160.03G）</h5><blockquote><p>链接：<a href="https://pan.baidu.com/s/1E_tw_pO_bQJAHbPke82ihg" target="_blank" rel="noopener">https://pan.baidu.com/s/1E_tw_pO_bQJAHbPke82ihg</a></p><p>提取码：a97b</p></blockquote><hr><p>私域流量.epub</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1NidWmrQycJiBmYUY2YLjrw" target="_blank" rel="noopener">https://pan.baidu.com/s/1NidWmrQycJiBmYUY2YLjrw</a> </p><p>提取码：fdqm </p></blockquote><p>2轴思维：问题简化的架构术.epub</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/11gauxZAFEs2LtKZMNd75ew" target="_blank" rel="noopener">https://pan.baidu.com/s/11gauxZAFEs2LtKZMNd75ew</a> </p><p>提取码：1l0q </p></blockquote><p>中国优势.epub</p><p>人民币战略：中国如何构建国际货币（巴曙松倾情作序“在全球贸易摩擦中重新思考人民币战略”）.epub</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1vfiYwO8-DcAMw-AC0a9YzQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1vfiYwO8-DcAMw-AC0a9YzQ</a> </p><p>提取码：2u56</p></blockquote><p>人，岁月，生活：全2册.epub</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1eLNBaEXUQe4kQCPSM0Vb3Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1eLNBaEXUQe4kQCPSM0Vb3Q</a> </p><p>提取码：o6io</p></blockquote><p>分享经济时代（套装6册）.epub</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1HbXOyab58P-nTZXAPhX-zQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1HbXOyab58P-nTZXAPhX-zQ</a> </p><p>提取码：6rj3 </p></blockquote><p>变量2</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1v_A8K3mZYkB1RAR4hZEWAw" target="_blank" rel="noopener">https://pan.baidu.com/s/1v_A8K3mZYkB1RAR4hZEWAw</a> </p><p>提取码：b56c</p></blockquote><p>学会如何学习.epub</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1SLByiAwOwzfU3cHfroprCQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1SLByiAwOwzfU3cHfroprCQ</a> </p><p>提取码：i7og</p></blockquote><p>布劳尔象限 epub</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1fzF_9aHHqgLx9quz1xRNtg" target="_blank" rel="noopener">https://pan.baidu.com/s/1fzF_9aHHqgLx9quz1xRNtg</a> </p><p>提取码：8idr</p></blockquote><p>情境影响力.epub</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1ydbnQ7aphCNicPFuQti4ew" target="_blank" rel="noopener">https://pan.baidu.com/s/1ydbnQ7aphCNicPFuQti4ew</a> </p><p>提取码：3itj</p></blockquote><p>技术垄断：文化向技术投降.epub</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1OnpcuE92TIZOeqorTLvMTQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1OnpcuE92TIZOeqorTLvMTQ</a> </p><p>提取码：o8zc</p></blockquote><p>摆脱共情（耶鲁大学公开课教授保罗·布卢姆颠覆之作，只有摆脱情绪共情，才能做出人生理性思维！）.epub</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/15uuJ2tAi-Wt2e5qND5q7SA" target="_blank" rel="noopener">https://pan.baidu.com/s/15uuJ2tAi-Wt2e5qND5q7SA</a> </p><p>提取码：n6yo </p></blockquote><p>数学、逻辑与现象学：论胡塞尔思想的发端.epub</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1xBbDRAVwYFKtGP1ViWuxIg" target="_blank" rel="noopener">https://pan.baidu.com/s/1xBbDRAVwYFKtGP1ViWuxIg</a> </p><p>提取码：a9ds </p></blockquote><p>斯坦福社会创新评论02（本书囊括前沿的实践与研究，能够指导和激励来自世界各地和社会各个部门的社会创新活动）.epub</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1Q13_0rPMdRwY-ZIsWVoZ1w" target="_blank" rel="noopener">https://pan.baidu.com/s/1Q13_0rPMdRwY-ZIsWVoZ1w</a> </p><p>提取码：8nau</p></blockquote><p>横越未知.epub</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1frA6ae2RjcDcOalCErb-Zw" target="_blank" rel="noopener">https://pan.baidu.com/s/1frA6ae2RjcDcOalCErb-Zw</a> </p><p>提取码：iug8.</p></blockquote><p>猎魔人套装［1-7］.epub</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1eroz8KEHVVQyoKCgz_pYKg" target="_blank" rel="noopener">https://pan.baidu.com/s/1eroz8KEHVVQyoKCgz_pYKg</a> </p><p>提取码：e072 </p></blockquote><p>请停止无效沟通（无效沟通正在毁掉你的人脉和生活！中国版的《超级聊天术》！46个最为有效的沟通技巧，100个最为常见的沟通场景，一学就会超级实用的沟通技巧！）.epub</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1u1SyeIRLVK0IN7C8097xRw" target="_blank" rel="noopener">https://pan.baidu.com/s/1u1SyeIRLVK0IN7C8097xRw</a> </p><p>提取码：j7xr</p></blockquote><p>赌运.epub</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1kFF01FSPRjFG8ox5qwksbg" target="_blank" rel="noopener">https://pan.baidu.com/s/1kFF01FSPRjFG8ox5qwksbg</a> </p><p>提取码：7mzf </p></blockquote><p>逃不开的经济周期2（理解金融动荡时期的真实情况）.epub</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1rZ6xqdAs0vw8eQHWEeevOg" target="_blank" rel="noopener">https://pan.baidu.com/s/1rZ6xqdAs0vw8eQHWEeevOg</a> </p><p>提取码：zk50</p></blockquote><p>金融原罪与金融文明.epub</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1lgmbqbb-DNK9RHBIZUAxoQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1lgmbqbb-DNK9RHBIZUAxoQ</a> </p><p>提取码：qxnc </p></blockquote><p>钱从哪里来</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1dVk0RdvVlgstClYlFcdRQw" target="_blank" rel="noopener">https://pan.baidu.com/s/1dVk0RdvVlgstClYlFcdRQw</a> </p><p>提取码：80em</p></blockquote><hr><p>1.早稻田10萬pdf壓縮版201705zip（1663.11G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1kHSjYWycsvvjSQAKBV0cjg" target="_blank" rel="noopener">https://pan.baidu.com/s/1kHSjYWycsvvjSQAKBV0cjg</a></p><p>提取码：qhkw</p></blockquote><p>2.東大10975_4Gzip[44]（167.65G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1VTqQRnp06NBVpTZrZORiGQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1VTqQRnp06NBVpTZrZORiGQ</a></p><p>提取码：yye0</p></blockquote><p>3.各类珍本古籍、史料纪传、军事兵法、古代兵书战策、地理堪舆方志、非常稀少不外传的珍本收藏书籍（70.21G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1Ht58WTd3_c1Md3WcidvPDA" target="_blank" rel="noopener">https://pan.baidu.com/s/1Ht58WTd3_c1Md3WcidvPDA</a></p><p>提取码：9yme</p></blockquote><p>4.宋会要辑稿 校点本全16册 SPAN&gt; 上海古籍出版2014（2.71G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1m88qIKqXccFLv8pOxLW6Mw" target="_blank" rel="noopener">https://pan.baidu.com/s/1m88qIKqXccFLv8pOxLW6Mw</a></p><p>提取码：mjki</p></blockquote><p>5.十三经注疏（艺文印书馆影印）（1.51G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1-66pNjdLpLR4NQOa5OkRKA" target="_blank" rel="noopener">https://pan.baidu.com/s/1-66pNjdLpLR4NQOa5OkRKA</a></p><p>提取码：5kp1</p></blockquote><p>6.十三经注疏.三百三十五卷（10.17G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1tBmiCgQXekrs3DVbbB96dw" target="_blank" rel="noopener">https://pan.baidu.com/s/1tBmiCgQXekrs3DVbbB96dw</a></p><p>提取码：w19t</p></blockquote><p>7.十三经注疏 繁体竖排（2.45G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/15VfSp9fOyUk7V1gGzsw6eQ" target="_blank" rel="noopener">https://pan.baidu.com/s/15VfSp9fOyUk7V1gGzsw6eQ</a></p><p>提取码：0kqu</p></blockquote><p>8.十三经注疏（188M）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1bGuA1EJ611s0OKjYe-yXEA" target="_blank" rel="noopener">https://pan.baidu.com/s/1bGuA1EJ611s0OKjYe-yXEA</a></p><p>提取码：74xe</p></blockquote><p>9.《清实录》全本</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/18RqV4a4Qz9nrKnwfHyoaxg提取码：ibcv" target="_blank" rel="noopener">https://pan.baidu.com/s/18RqV4a4Qz9nrKnwfHyoaxg提取码：ibcv</a></p></blockquote><p>10.通史类</p><blockquote><p>链接: <a href="https://pan.baidu.com/s/1ecTWh_q1szRu7lJme5Oo9g" target="_blank" rel="noopener">https://pan.baidu.com/s/1ecTWh_q1szRu7lJme5Oo9g</a></p><p>提取码: ng4x</p></blockquote><p>（二）系列丛书合集</p><p>1.经典珍藏合集系列（490.91G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1cKEfaoFPv2qP-BUeEN8tIQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1cKEfaoFPv2qP-BUeEN8tIQ</a></p><p>提取码：gwqy</p></blockquote><p>2.中华大典（9.02G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/12AsHuJZ6zW2joUJnF7lkdw" target="_blank" rel="noopener">https://pan.baidu.com/s/12AsHuJZ6zW2joUJnF7lkdw</a></p><p>提取码：hibi</p></blockquote><p>3.kindle伴侣电子书库，解压密码为sz520（30.61G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1eYsq4h_l-nJArHJiM_u-HA" target="_blank" rel="noopener">https://pan.baidu.com/s/1eYsq4h_l-nJArHJiM_u-HA</a></p><p>提取码：jpe8</p></blockquote><p>4.kindle人电子书合集,解压密码为sz520（81.52G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1K7sanuh9SLAzyF8KxZA-bw" target="_blank" rel="noopener">https://pan.baidu.com/s/1K7sanuh9SLAzyF8KxZA-bw</a></p><p>提取码：73lm</p></blockquote><p>5.Kindle书库48208册（8.48）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1RU3z3YHEhoI0v6FuE4d1fA" target="_blank" rel="noopener">https://pan.baidu.com/s/1RU3z3YHEhoI0v6FuE4d1fA</a></p><p>提取码：wlcf</p></blockquote><p>6.wode小书屋（125.11G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1B525W-jieQNv2nXcm6Sjgg" target="_blank" rel="noopener">https://pan.baidu.com/s/1B525W-jieQNv2nXcm6Sjgg</a></p><p>提取码：bcf8</p></blockquote><p>7.亚马逊Kindle商店12,000册原版英文书，解压密码为sz520（18.44G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1NAd_sckOhDGPgufxr3Qsig" target="_blank" rel="noopener">https://pan.baidu.com/s/1NAd_sckOhDGPgufxr3Qsig</a></p><p>提取码：sb0s</p></blockquote><p>8.kindle电子书资源14G</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1vAluJd-AW_4VBEMSgbhGhA" target="_blank" rel="noopener">https://pan.baidu.com/s/1vAluJd-AW_4VBEMSgbhGhA</a></p><p>提取码：vmnv</p></blockquote><p>9.商务印书馆日本丛书</p><blockquote><p><a href="https://pan.baidu.com/s/1bn8ifLl" target="_blank" rel="noopener">https://pan.baidu.com/s/1bn8ifLl</a></p></blockquote><p>10.世界历史</p><blockquote><p><a href="https://pan.baidu.com/s/1bpaS799#list/path=%2F" target="_blank" rel="noopener">https://pan.baidu.com/s/1bpaS799#list/path=%2F</a></p></blockquote><p>11.苏联丛书</p><blockquote><p>链接: <a href="https://pan.baidu.com/s/1xLMYdoON2cD7OeEZ3lETlg" target="_blank" rel="noopener">https://pan.baidu.com/s/1xLMYdoON2cD7OeEZ3lETlg</a> 提取码: uz4d</p></blockquote><p>12.世界历史文库</p><blockquote><p><a href="https://pan.baidu.com/s/1QS07G#list/path=%2F" target="_blank" rel="noopener">https://pan.baidu.com/s/1QS07G#list/path=%2F</a></p></blockquote><p>13.欧洲文学史</p><blockquote><p><a href="https://pan.baidu.com/s/1jG3PPPW#list/path=%2F" target="_blank" rel="noopener">https://pan.baidu.com/s/1jG3PPPW#list/path=%2F</a></p></blockquote><p>14.剑桥科学史丛书</p><blockquote><p><a href="https://pan.baidu.com/s/1dDxjlS1" target="_blank" rel="noopener">https://pan.baidu.com/s/1dDxjlS1</a></p></blockquote><p>15.俄国经略东方丛书</p><blockquote><p><a href="https://pan.baidu.com/s/1i5p2Dm9" target="_blank" rel="noopener">https://pan.baidu.com/s/1i5p2Dm9</a></p></blockquote><p>16.甲骨文丛书</p><blockquote><p><a href="https://pan.baidu.com/s/19O8ckrdiqwkrHrbozuexqg#list/path=%2F" target="_blank" rel="noopener">https://pan.baidu.com/s/19O8ckrdiqwkrHrbozuexqg#list/path=%2F</a></p></blockquote><p>17.外国文艺丛书</p><blockquote><p><a href="https://pan.baidu.com/s/1i3vfGjj#list/path=%2F" target="_blank" rel="noopener">https://pan.baidu.com/s/1i3vfGjj#list/path=%2F</a></p></blockquote><p>18.东亚历史</p><blockquote><p><a href="https://pan.baidu.com/s/1bpgYeKn#list/path=%2F&amp;parentPath=%2F" target="_blank" rel="noopener">https://pan.baidu.com/s/1bpgYeKn#list/path=%2F&amp;parentPath=%2F</a></p></blockquote><p>19.中国史 政治经济</p><blockquote><p><a href="https://pan.baidu.com/s/1jHDDDv4#list/path=%2F" target="_blank" rel="noopener">https://pan.baidu.com/s/1jHDDDv4#list/path=%2F</a></p></blockquote><p>20.中国史 民族边疆</p><blockquote><p><a href="https://pan.baidu.com/s/1o8lvzFO#list/path=%2F" target="_blank" rel="noopener">https://pan.baidu.com/s/1o8lvzFO#list/path=%2F</a></p></blockquote><p>21.中国史 思想文化</p><blockquote><p><a href="https://pan.baidu.com/s/1slfPFqd#list/path=%2F" target="_blank" rel="noopener">https://pan.baidu.com/s/1slfPFqd#list/path=%2F</a></p></blockquote><p>22.三联书店·文化生活译丛</p><blockquote><p><a href="https://pan.baidu.com/s/1mikpi1y#list/path=%2F" target="_blank" rel="noopener">https://pan.baidu.com/s/1mikpi1y#list/path=%2F</a></p></blockquote><p>23.东方历史学术文库系列，100本</p><blockquote><p>链接:<a href="https://pan.baidu.com/s/1PFluXcAwNqME_9SbphsDDA" target="_blank" rel="noopener">https://pan.baidu.com/s/1PFluXcAwNqME_9SbphsDDA</a> </p><p>提取码:p6gs</p></blockquote><p>24.申报影印本（160.03G）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1E_tw_pO_bQJAHbPke82ihg" target="_blank" rel="noopener">https://pan.baidu.com/s/1E_tw_pO_bQJAHbPke82ihg</a></p><p>提取码：a97b</p></blockquote><p>25.《阎锡山档案》</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1LsHAVyhoFY4rxhkUKfWuvA" target="_blank" rel="noopener">https://pan.baidu.com/s/1LsHAVyhoFY4rxhkUKfWuvA</a></p><p>提取码：hd53</p></blockquote><p>26.《新编剑桥中世纪史》（英文版）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/14bHThjINbrHF4jV-ZCaiCw" target="_blank" rel="noopener">https://pan.baidu.com/s/14bHThjINbrHF4jV-ZCaiCw</a></p><p>提取码：yunl</p></blockquote><p>27.《中国历史地图集》</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1UcZxfnDwcm4_NacNtjPAvA" target="_blank" rel="noopener">https://pan.baidu.com/s/1UcZxfnDwcm4_NacNtjPAvA</a></p><p>提取码：b460</p></blockquote><p>28.辛德勇著. 制造汉武帝 由汉武帝晚年政治形象的塑造看《资治通鉴》的历史构建[M]. 北京：生活·读书·新知三联书店, 2015.10</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/14wI3OVSOFLV6lGaQ7ShPNA" target="_blank" rel="noopener">https://pan.baidu.com/s/14wI3OVSOFLV6lGaQ7ShPNA</a></p><p>提取码：vedy</p></blockquote><p>29.哈佛中国史（套装全6册）（PDF+其他格式）</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1_-sK8g1l2uunJDTWXpMkkg" target="_blank" rel="noopener">https://pan.baidu.com/s/1_-sK8g1l2uunJDTWXpMkkg</a></p><p>提取码：5ss4</p></blockquote><p>30.何炳棣著. 读史阅世六十年. 桂林：广西师范大学出版社, 2009.03</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1jp5LAhHnUxpRuP1O79Fxsw" target="_blank" rel="noopener">https://pan.baidu.com/s/1jp5LAhHnUxpRuP1O79Fxsw</a></p><p>提取码：2czt</p></blockquote><p>31.瞿林东著. 唐代史学论稿 增订本. 北京：高等教育出版社, 2015.01</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1FeOXHJg7zi5WxogpdNoaZw" target="_blank" rel="noopener">https://pan.baidu.com/s/1FeOXHJg7zi5WxogpdNoaZw</a></p><p>提取码：azsn</p></blockquote><hr><p>新书学习：</p><p>★《钱从哪里来》</p><p>*作者：香帅</p><p>—（2019—2020年罗振宇“时间的朋友”跨年演讲重磅推荐，帮你找准自己的财富坐标。）</p><p>pdf，txt，epub，mobi 4格式链接：<a href="https://pan.baidu.com/s/1d8DfQLjWgTjl68GIC5oH8g" target="_blank" rel="noopener">https://pan.baidu.com/s/1d8DfQLjWgTjl68GIC5oH8g</a> </p><p>提取码：6vqs</p><p>★《深度说服：超级辩手的四堂思辨表达课》</p><p>*作者：梁秋阳</p><p>—（马东倾情推荐，黄执中、马薇薇作序，超级辩手的四堂思辨表达课）pdf，txt，epub，mobi 4格式链接：<a href="https://pan.baidu.com/s/15Cj0KjlKFc9rIsVE9nEqtA" target="_blank" rel="noopener">https://pan.baidu.com/s/15Cj0KjlKFc9rIsVE9nEqtA</a> </p><p>提取码：q4f9</p><p>★《破解生死大数据 : 一个医生和70亿人的健康真相》</p><p>*作者：杰瑞米·N.史密斯</p><p>—（《破解生死大数据》在讲述穆雷故事的同时，也普及了健康卫生史，特别是普及了全球疾病负担的知识，并对健康大数据、健康卫生投资和健康卫生政策都有很多的涉及。）</p><p>pdf，txt，epub，mobi 4格式链接：<a href="https://pan.baidu.com/s/1FtrIC7i8-IFEShxUso_sMQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1FtrIC7i8-IFEShxUso_sMQ</a> </p><p>提取码：saju </p><p>★《嘿！曼巴科比·布莱恩特传》</p><p>*作者：曹博</p><p>—（科比是NBA史上，纯技术最完整的球员之一；最勤奋的球员之一；最争强好胜的球员之一；最强的个人攻击手之一。是永远的篮球王者。过往的20年，是科比传奇的20年，本书用照片、用文字向科比致敬，向青春致敬。）</p><p>pdf，txt，epub，mobi 4格式链接：<a href="https://pan.baidu.com/s/1ZP_x0l6MWJjNjb6QFOHsTA" target="_blank" rel="noopener">https://pan.baidu.com/s/1ZP_x0l6MWJjNjb6QFOHsTA</a> </p><p>提取码：g5h1</p><p>新书学习：</p><p>★《认知：人行为背后的思维与智能》</p><p>*作者：赫伯特·西蒙</p><p>—（本书是著名心理学家和人工智能开创者赫伯特•西蒙关于人类认知的作品。本书介绍了人的认知结构，包括注意力、记忆等方面，然后分析了人们思维过程中问题解决的途径和策略。书中进一步分析了对于复杂问题，专家和普通人不同的心理表征，以及应该如何应对复杂问题。）</p><p>pdf，txt，epub，mobi 4格式链接：<a href="https://pan.baidu.com/s/1DGuXn31Md2VfDb91kpPFZA" target="_blank" rel="noopener">https://pan.baidu.com/s/1DGuXn31Md2VfDb91kpPFZA</a> </p><p>提取码：jkss</p><p>★《大局观：真实世界中的经济学思维》</p><p>*作者：何帆</p><p>—（这是一座经济学家搭建的思维训练营。）</p><p>pdf，txt，epub，mobi 4格式链接：<a href="https://pan.baidu.com/s/1GRk1KAPEZm45irlDpbXxeg" target="_blank" rel="noopener">https://pan.baidu.com/s/1GRk1KAPEZm45irlDpbXxeg</a> </p><p>提取码：b1g5</p><p>★《亲密陷阱：爱、欲望与平衡艺术》</p><p>*作者：[比利时]埃丝特·佩瑞尔</p><p>—（ 现代亲密关系领域教母、35年婚恋心理咨询师权威代表作，全球现象级婚恋畅销书，TED演讲点击量超2800万 ，30种语言出版，12年畅销不衰）</p><p>pdf，txt，epub，mobi 4格式链接：<a href="https://pan.baidu.com/s/187AaMSxCP6wHFdYXmLraxQ" target="_blank" rel="noopener">https://pan.baidu.com/s/187AaMSxCP6wHFdYXmLraxQ</a> </p><p>提取码：cxjo</p><p>★《去生活：松浦弥太郎的生活巧思》</p><p>*作者：【日】松浦弥太郎, 庄千里</p><p>—（继日本国民生活指南《100个基本》之后，影响数百万日本年轻人的生活美学大师松浦弥太郎又一生活哲学力作。）</p><p>pdf，txt，epub，mobi 4格式链接：<a href="https://pan.baidu.com/s/1u0L5ZuJynIAyGH85XFQKQw" target="_blank" rel="noopener">https://pan.baidu.com/s/1u0L5ZuJynIAyGH85XFQKQw</a> </p><p>提取码：04ay </p><p>樊登读书2020-01-25《中国文化的精神》链接：<a href="https://pan.baidu.com/s/1RisdAFc_LqXuKF9OX-iY-w" target="_blank" rel="noopener">https://pan.baidu.com/s/1RisdAFc_LqXuKF9OX-iY-w</a> </p><p>提取码：e0w9 </p><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>EBook</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电子书</tag>
      
      <tag>EBook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud Feign设计原理</title>
    <link href="/2019/12/24/Spring-Cloud-Feign%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/"/>
    <url>/2019/12/24/Spring-Cloud-Feign%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是Feign？"><a href="#什么是Feign？" class="headerlink" title="什么是Feign？"></a>什么是Feign？</h2><p>Feign 的英文表意为“假装，伪装，变形”， 是一个http请求调用的轻量级框架，可以以Java接口注解的方式调用Http请求，而不用像Java中通过封装HTTP请求报文的方式直接调用。Feign通过处理注解，将请求模板化，当实际调用的时候，传入参数，根据参数再应用到请求上，进而转化成真正的请求，这种请求相对而言比较直观。<br>Feign被广泛应用在Spring Cloud 的解决方案中，是学习基于Spring Cloud 微服务架构不可或缺的重要组件。<br>开源项目地址：<br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FOpenFeign%2Ffeign" target="_blank" rel="noopener">https://github.com/OpenFeign/feign</a></p><h2 id="Feign解决了什么问题？"><a href="#Feign解决了什么问题？" class="headerlink" title="Feign解决了什么问题？"></a>Feign解决了什么问题？</h2><p><strong>封装了Http调用流程，更适合面向接口化的变成习惯</strong><br>在服务调用的场景中，我们经常调用基于Http协议的服务，而我们经常使用到的框架可能有HttpURLConnection、Apache HttpComponnets、OkHttp3 、Netty等等，这些框架在基于自身的专注点提供了自身特性。而从角色划分上来看，他们的职能是一致的提供Http调用服务。具体流程如下：</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1ga7scfseulj30p10gdq3t.jpg" srcset="/img/loading.gif" alt="img"></p><h2 id="Feign是如何设计的？"><a href="#Feign是如何设计的？" class="headerlink" title="Feign是如何设计的？"></a>Feign是如何设计的？</h2><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1ga7sck4dinj30o70ufwgj.jpg" srcset="/img/loading.gif" alt="img"></p><h4 id="PHASE-1-基于面向接口的动态代理方式生成实现类"><a href="#PHASE-1-基于面向接口的动态代理方式生成实现类" class="headerlink" title="PHASE 1. 基于面向接口的动态代理方式生成实现类"></a>PHASE 1. 基于面向接口的动态代理方式生成实现类</h4><p>在使用feign 时，会定义对应的接口类，在接口类上使用Http相关的注解，标识HTTP请求参数信息,如下所示：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GitHub</span> </span>&#123;  <span class="hljs-meta">@RequestLine</span>(<span class="hljs-string">"GET /repos/&#123;owner&#125;/&#123;repo&#125;/contributors"</span>)  <span class="hljs-function">List&lt;Contributor&gt; <span class="hljs-title">contributors</span><span class="hljs-params">(@Param(<span class="hljs-string">"owner"</span>)</span> String owner, @<span class="hljs-title">Param</span><span class="hljs-params">(<span class="hljs-string">"repo"</span>)</span> String repo)</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Contributor</span> </span>&#123;  String login;  <span class="hljs-keyword">int</span> contributions;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String... args)</span> </span>&#123;    GitHub github = Feign.builder()                         .decoder(<span class="hljs-keyword">new</span> GsonDecoder())                         .target(GitHub.class, "https://api.github.com");      <span class="hljs-comment">// Fetch and print a list of the contributors to this library.</span>    List&lt;Contributor&gt; contributors = github.contributors(<span class="hljs-string">"OpenFeign"</span>, <span class="hljs-string">"feign"</span>);    <span class="hljs-keyword">for</span> (Contributor contributor : contributors) &#123;      System.out.println(contributor.login + <span class="hljs-string">" ("</span> + contributor.contributions + <span class="hljs-string">")"</span>);    &#125;  &#125;&#125;</code></pre><p>在Feign 底层，通过基于面向接口的动态代理方式生成实现类，将请求调用委托到动态代理实现类，基本原理如下所示：</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1ga7sct0h8dj30ln0a3aar.jpg" srcset="/img/loading.gif" alt="img"></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReflectiveFeign</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Feign</span></span>&#123; <span class="hljs-comment">///省略部分代码</span> <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">newInstance</span><span class="hljs-params">(Target&lt;T&gt; target)</span> </span>&#123;   <span class="hljs-comment">//根据接口类和Contract协议解析方式，解析接口类上的方法和注解，转换成内部的MethodHandler处理方式</span>   Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);   Map&lt;Method, MethodHandler&gt; methodToHandler = <span class="hljs-keyword">new</span> LinkedHashMap&lt;Method, MethodHandler&gt;();   List&lt;DefaultMethodHandler&gt; defaultMethodHandlers = <span class="hljs-keyword">new</span> LinkedList&lt;DefaultMethodHandler&gt;();   <span class="hljs-keyword">for</span> (Method method : target.type().getMethods()) &#123;     <span class="hljs-keyword">if</span> (method.getDeclaringClass() == Object<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;       <span class="hljs-keyword">continue</span>;     &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Util.isDefault(method)) &#123;       DefaultMethodHandler handler = <span class="hljs-keyword">new</span> DefaultMethodHandler(method);       defaultMethodHandlers.add(handler);       methodToHandler.put(method, handler);     &#125; <span class="hljs-keyword">else</span> &#123;       methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));     &#125;   &#125;   InvocationHandler handler = factory.create(target, methodToHandler);   <span class="hljs-comment">// 基于Proxy.newProxyInstance 为接口类创建动态实现，将所有的请求转换给InvocationHandler 处理。</span>   T proxy = (T) Proxy.newProxyInstance(target.type().getClassLoader(), <span class="hljs-keyword">new</span> Class&lt;?&gt;[]&#123;target.type()&#125;, handler);   <span class="hljs-keyword">for</span>(DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) &#123;     defaultMethodHandler.bindTo(proxy);   &#125;   <span class="hljs-keyword">return</span> proxy; &#125; <span class="hljs-comment">//省略部分代码</span></code></pre><h4 id="PHASE-2-根据Contract协议规则，解析接口类的注解信息，解析成内部表现："><a href="#PHASE-2-根据Contract协议规则，解析接口类的注解信息，解析成内部表现：" class="headerlink" title="PHASE 2. 根据Contract协议规则，解析接口类的注解信息，解析成内部表现："></a>PHASE 2. 根据Contract协议规则，解析接口类的注解信息，解析成内部表现：</h4><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1ga7sczwxdyj30pf0didgq.jpg" srcset="/img/loading.gif" alt="img"></p><p>Feign 定义了转换协议，定义如下：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Defines what annotations and values are valid on interfaces.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Contract</span> </span>&#123;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Called to parse the methods in the class that are linked to HTTP requests.</span><span class="hljs-comment">   * 传入接口定义，解析成相应的方法内部元数据表示</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> targetType &#123;<span class="hljs-doctag">@link</span> feign.Target#type() type&#125; of the Feign interface.</span><span class="hljs-comment">   */</span>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> break this and correct spelling at some point</span>  <span class="hljs-function">List&lt;MethodMetadata&gt; <span class="hljs-title">parseAndValidatateMetadata</span><span class="hljs-params">(Class&lt;?&gt; targetType)</span></span>;&#125;</code></pre><h5 id="默认Contract-实现"><a href="#默认Contract-实现" class="headerlink" title="默认Contract 实现"></a>默认Contract 实现</h5><p>Feign 默认有一套自己的协议规范，规定了一些注解，可以映射成对应的Http请求，如官方的一个例子：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GitHub</span> </span>&#123;    <span class="hljs-meta">@RequestLine</span>(<span class="hljs-string">"GET /repos/&#123;owner&#125;/&#123;repo&#125;/contributors"</span>)  <span class="hljs-function">List&lt;Contributor&gt; <span class="hljs-title">getContributors</span><span class="hljs-params">(@Param(<span class="hljs-string">"owner"</span>)</span> String owner, @<span class="hljs-title">Param</span><span class="hljs-params">(<span class="hljs-string">"repo"</span>)</span> String repository)</span>;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Contributor</span> </span>&#123;    String login;    <span class="hljs-keyword">int</span> contributions;  &#125;&#125;</code></pre><p>上述的例子中，尝试调用GitHub.getContributors(“foo”,”myrepo”)的的时候，会转换成如下的HTTP请求：</p><pre><code class="hljs http">GET /repos/foo/myrepo/contributorsHOST XXXX.XXX.XXX</code></pre><p>Feign 默认的协议规范</p><table><thead><tr><th>注解</th><th>接口Target</th><th>使用说明</th></tr></thead><tbody><tr><td><code>@RequestLine</code></td><td>方法上</td><td>定义HttpMethod 和 UriTemplate. UriTemplate 中使用<code>{}</code> 包裹的表达式，可以通过在方法参数上使用@Param 自动注入</td></tr><tr><td><code>@Param</code></td><td>方法参数</td><td>定义模板变量，模板变量的值可以使用名称的方式使用模板注入解析</td></tr><tr><td><code>@Headers</code></td><td>类上或者方法上</td><td>定义头部模板变量，使用@Param 注解提供参数值的注入。如果该注解添加在接口类上，则所有的请求都会携带对应的Header信息；如果在方法上，则只会添加到对应的方法请求上</td></tr><tr><td><code>@QueryMap</code></td><td>方法上</td><td>定义一个键值对或者 pojo，参数值将会被转换成URL上的 query 字符串上</td></tr><tr><td><code>@HeaderMap</code></td><td>方法上</td><td>定义一个HeaderMap, 与 UrlTemplate 和HeaderTemplate 类型，可以使用@Param 注解提供参数值</td></tr></tbody></table><p>具体FeignContract 是如何解析的，不在本文的介绍范围内，详情请参考代码：<br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FOpenFeign%2Ffeign%2Fblob%2Fmaster%2Fcore%2Fsrc%2Fmain%2Fjava%2Ffeign%2FContract.java" target="_blank" rel="noopener">https://github.com/OpenFeign/feign/blob/master/core/src/main/java/feign/Contract.java</a></p><h5 id="基于Spring-MVC的协议规范SpringMvcContract"><a href="#基于Spring-MVC的协议规范SpringMvcContract" class="headerlink" title="基于Spring MVC的协议规范SpringMvcContract:"></a>基于Spring MVC的协议规范SpringMvcContract:</h5><p>当前Spring Cloud 微服务解决方案中，为了降低学习成本，采用了Spring MVC的部分注解来完成 请求协议解析，也就是说 ，写客户端请求接口和像写服务端代码一样：客户端和服务端可以通过SDK的方式进行约定，客户端只需要引入服务端发布的SDK API，就可以使用面向接口的编码方式对接服务：</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1ga7sd3ug9pj30hv0bpmxp.jpg" srcset="/img/loading.gif" alt="img"></p><blockquote><p>我们团队内部就是按照这种思路，结合Spring Boot Starter 的特性，定义了服务端starter,<br>服务消费者在使用的时候，只需要引入Starter，就可以调用服务。这个比较适合平台无关性，接口抽象出来的好处就是可以根据服务调用实现方式自有切换：</p><ol><li>可以基于简单的Http服务调用；</li><li>可以基于Spring Cloud 微服务架构调用；</li><li>可以基于Dubbo SOA服务治理</li></ol><p>这种模式比较适合在SaSS混合软件服务的模式下自有切换，根据客户的硬件能力选择合适的方式部署，也可以基于自身的服务集群部署微服务</p></blockquote><p>至于Spring Cloud 是如何实现 协议解析的，可参考代码：<br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fspring-cloud%2Fspring-cloud-openfeign%2Fblob%2Fmaster%2Fspring-cloud-openfeign-core%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fcloud%2Fopenfeign%2Fsupport%2FSpringMvcContract.java" target="_blank" rel="noopener">https://github.com/spring-cloud/spring-cloud-openfeign/blob/master/spring-cloud-openfeign-core/src/main/java/org/springframework/cloud/openfeign/support/SpringMvcContract.java</a></p><p>当然，目前的Spring MVC的注解并不是可以完全使用的，有一些注解并不支持,如<code>@GetMapping</code>,<code>@PutMapping</code> 等，仅支持使用<code>@RequestMapping</code> 等，另外注解继承性方面也有些问题；具体限制细节，每个版本能会有些出入，可以参考上述的代码实现，比较简单。</p><blockquote><p>Spring Cloud 没有基于Spring MVC 全部注解来做Feign 客户端注解协议解析，个人认为这个是一个不小的坑。在刚入手Spring Cloud 的时候，就碰到这个问题。后来是深入代码才解决的…. 这个应该有人写了增强类来处理，暂且不表，先MARK一下，是一个开源代码练手的好机会。</p></blockquote><h5 id="PHASE-3-基于-RequestBean，动态生成Request"><a href="#PHASE-3-基于-RequestBean，动态生成Request" class="headerlink" title="PHASE 3. 基于 RequestBean，动态生成Request"></a>PHASE 3. 基于 RequestBean，动态生成Request</h5><p>根据传入的Bean对象和注解信息，从中提取出相应的值，来构造Http Request 对象：</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1ga7sd6wfyrj30r60bb0tf.jpg" srcset="/img/loading.gif" alt="img"></p><h5 id="PHASE-4-使用Encoder-将Bean转换成-Http报文正文（消息解析和转码逻辑）"><a href="#PHASE-4-使用Encoder-将Bean转换成-Http报文正文（消息解析和转码逻辑）" class="headerlink" title="PHASE 4. 使用Encoder 将Bean转换成 Http报文正文（消息解析和转码逻辑）"></a>PHASE 4. 使用Encoder 将Bean转换成 Http报文正文（消息解析和转码逻辑）</h5><p>Feign 最终会将请求转换成Http 消息发送出去，传入的请求对象最终会解析成消息体，如下所示：</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1ga7sd8dfm6j30jz0i574y.jpg" srcset="/img/loading.gif" alt="img"></p><p>在接口定义上Feign做的比较简单，抽象出了Encoder 和decoder 接口：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Encoder</span> </span>&#123;  <span class="hljs-comment">/** Type literal for &#123;<span class="hljs-doctag">@code</span> Map&lt;String, ?&gt;&#125;, indicating the object to encode is a form. */</span>  Type MAP_STRING_WILDCARD = Util.MAP_STRING_WILDCARD;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Converts objects to an appropriate representation in the template.</span><span class="hljs-comment">   *  将实体对象转换成Http请求的消息正文中</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> object   what to encode as the request body.</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> bodyType the type the object should be encoded as. &#123;<span class="hljs-doctag">@link</span> #MAP_STRING_WILDCARD&#125;</span><span class="hljs-comment">   *                 indicates form encoding.</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> template the request template to populate.</span><span class="hljs-comment">   * <span class="hljs-doctag">@throws</span> EncodeException when encoding failed due to a checked exception.</span><span class="hljs-comment">   */</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(Object object, Type bodyType, RequestTemplate template)</span> <span class="hljs-keyword">throws</span> EncodeException</span>;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Default implementation of &#123;<span class="hljs-doctag">@code</span> Encoder&#125;.</span><span class="hljs-comment">   */</span>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Default</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Encoder</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(Object object, Type bodyType, RequestTemplate template)</span> </span>&#123;      <span class="hljs-keyword">if</span> (bodyType == String<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;        template.body(object.toString());      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bodyType == <span class="hljs-keyword">byte</span>[]<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;        template.body((<span class="hljs-keyword">byte</span>[]) object, <span class="hljs-keyword">null</span>);      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (object != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> EncodeException(            format(<span class="hljs-string">"%s is not a type supported by this encoder."</span>, object.getClass()));      &#125;    &#125;  &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Decoder</span> </span>&#123;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Decodes an http response into an object corresponding to its &#123;<span class="hljs-doctag">@link</span></span><span class="hljs-comment">   * java.lang.reflect.Method#getGenericReturnType() generic return type&#125;. If you need to wrap</span><span class="hljs-comment">   * exceptions, please do so via &#123;<span class="hljs-doctag">@link</span> DecodeException&#125;.</span><span class="hljs-comment">   *  从Response 中提取Http消息正文，通过接口类声明的返回类型，消息自动装配</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> response the response to decode </span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> type     &#123;<span class="hljs-doctag">@link</span> java.lang.reflect.Method#getGenericReturnType() generic return type&#125; of</span><span class="hljs-comment">   *                 the method corresponding to this &#123;<span class="hljs-doctag">@code</span> response&#125;.</span><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> instance of &#123;<span class="hljs-doctag">@code</span> type&#125;</span><span class="hljs-comment">   * <span class="hljs-doctag">@throws</span> IOException     will be propagated safely to the caller.</span><span class="hljs-comment">   * <span class="hljs-doctag">@throws</span> DecodeException when decoding failed due to a checked exception besides IOException.</span><span class="hljs-comment">   * <span class="hljs-doctag">@throws</span> FeignException  when decoding succeeds, but conveys the operation failed.</span><span class="hljs-comment">   */</span>  <span class="hljs-function">Object <span class="hljs-title">decode</span><span class="hljs-params">(Response response, Type type)</span> <span class="hljs-keyword">throws</span> IOException, DecodeException, FeignException</span>;  <span class="hljs-comment">/** Default implementation of &#123;<span class="hljs-doctag">@code</span> Decoder&#125;. */</span>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Default</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StringDecoder</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">decode</span><span class="hljs-params">(Response response, Type type)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;      <span class="hljs-keyword">if</span> (response.status() == <span class="hljs-number">404</span>) <span class="hljs-keyword">return</span> Util.emptyValueOf(type);      <span class="hljs-keyword">if</span> (response.body() == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">byte</span>[]<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">equals</span>(<span class="hljs-title">type</span>)) </span>&#123;        <span class="hljs-keyword">return</span> Util.toByteArray(response.body().asInputStream());      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.decode(response, type);    &#125;  &#125;&#125;</code></pre><p>目前Feign 有以下实现：</p><table><thead><tr><th align="left">Encoder/ Decoder 实现</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">JacksonEncoder，JacksonDecoder</td><td align="left">基于 Jackson 格式的持久化转换协议</td></tr><tr><td align="left">GsonEncoder，GsonDecoder</td><td align="left">基于Google GSON 格式的持久化转换协议</td></tr><tr><td align="left">SaxEncoder，SaxDecoder</td><td align="left">基于XML 格式的Sax 库持久化转换协议</td></tr><tr><td align="left">JAXBEncoder，JAXBDecoder</td><td align="left">基于XML 格式的JAXB 库持久化转换协议</td></tr><tr><td align="left">ResponseEntityEncoder，ResponseEntityDecoder</td><td align="left">Spring MVC 基于 ResponseEntity&lt; T &gt; 返回格式的转换协议</td></tr><tr><td align="left">SpringEncoder，SpringDecoder</td><td align="left">基于Spring MVC HttpMessageConverters 一套机制实现的转换协议 ,应用于Spring Cloud 体系中</td></tr></tbody></table><h5 id="PHASE-5-拦截器负责对请求和返回进行装饰处理"><a href="#PHASE-5-拦截器负责对请求和返回进行装饰处理" class="headerlink" title="PHASE 5. 拦截器负责对请求和返回进行装饰处理"></a>PHASE 5. 拦截器负责对请求和返回进行装饰处理</h5><p>在请求转换的过程中，Feign 抽象出来了拦截器接口，用于用户自定义对请求的操作：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RequestInterceptor</span> </span>&#123;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 可以在构造RequestTemplate 请求时，增加或者修改Header, Method, Body 等信息</span><span class="hljs-comment">   * Called for every request. Add data using methods on the supplied &#123;<span class="hljs-doctag">@link</span> RequestTemplate&#125;.</span><span class="hljs-comment">   */</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(RequestTemplate template)</span></span>;&#125;</code></pre><p>比如，如果希望Http消息传递过程中被压缩，可以定义一个请求拦截器：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeignAcceptGzipEncodingInterceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseRequestInterceptor</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Creates new instance of &#123;<span class="hljs-doctag">@link</span> FeignAcceptGzipEncodingInterceptor&#125;.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> properties the encoding properties</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">FeignAcceptGzipEncodingInterceptor</span><span class="hljs-params">(FeignClientEncodingProperties properties)</span> </span>&#123;        <span class="hljs-keyword">super</span>(properties);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(RequestTemplate template)</span> </span>&#123;        <span class="hljs-comment">//  在Header 头部添加相应的数据信息</span>        addHeader(template, HttpEncoding.ACCEPT_ENCODING_HEADER, HttpEncoding.GZIP_ENCODING,                HttpEncoding.DEFLATE_ENCODING);    &#125;&#125;</code></pre><h5 id="PHASE-6-日志记录"><a href="#PHASE-6-日志记录" class="headerlink" title="PHASE 6. 日志记录"></a>PHASE 6. 日志记录</h5><p>在发送和接收请求的时候，Feign定义了统一的日志门面来输出日志信息 , 并且将日志的输出定义了四个等级：</p><table><thead><tr><th align="left">级别</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">NONE</td><td align="left">不做任何记录</td></tr><tr><td align="left">BASIC</td><td align="left">只记录输出Http 方法名称、请求URL、返回状态码和执行时间</td></tr><tr><td align="left">HEADERS</td><td align="left">记录输出Http 方法名称、请求URL、返回状态码和执行时间 和 Header 信息</td></tr><tr><td align="left">FULL</td><td align="left">记录Request 和Response的Header，Body和一些请求元数据</td></tr></tbody></table><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Logger</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">methodTag</span><span class="hljs-params">(String configKey)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StringBuilder().append(<span class="hljs-string">'['</span>).append(configKey.substring(<span class="hljs-number">0</span>, configKey.indexOf(<span class="hljs-string">'('</span>)))        .append(<span class="hljs-string">"] "</span>).toString();  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Override to log requests and responses using your own implementation. Messages will be http</span><span class="hljs-comment">   * request and response text.</span><span class="hljs-comment">   *</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> configKey value of &#123;<span class="hljs-doctag">@link</span> Feign#configKey(Class, java.lang.reflect.Method)&#125;</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> format    &#123;<span class="hljs-doctag">@link</span> java.util.Formatter format string&#125;</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> args      arguments applied to &#123;<span class="hljs-doctag">@code</span> format&#125;</span><span class="hljs-comment">   */</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(String configKey, String format, Object... args)</span></span>;  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logRequest</span><span class="hljs-params">(String configKey, Level logLevel, Request request)</span> </span>&#123;    log(configKey, <span class="hljs-string">"---&gt; %s %s HTTP/1.1"</span>, request.method(), request.url());    <span class="hljs-keyword">if</span> (logLevel.ordinal() &gt;= Level.HEADERS.ordinal()) &#123;      <span class="hljs-keyword">for</span> (String field : request.headers().keySet()) &#123;        <span class="hljs-keyword">for</span> (String value : valuesOrEmpty(request.headers(), field)) &#123;          log(configKey, <span class="hljs-string">"%s: %s"</span>, field, value);        &#125;      &#125;      <span class="hljs-keyword">int</span> bodyLength = <span class="hljs-number">0</span>;      <span class="hljs-keyword">if</span> (request.body() != <span class="hljs-keyword">null</span>) &#123;        bodyLength = request.body().length;        <span class="hljs-keyword">if</span> (logLevel.ordinal() &gt;= Level.FULL.ordinal()) &#123;          String              bodyText =              request.charset() != <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">new</span> String(request.body(), request.charset()) : <span class="hljs-keyword">null</span>;          log(configKey, <span class="hljs-string">""</span>); <span class="hljs-comment">// CRLF</span>          log(configKey, <span class="hljs-string">"%s"</span>, bodyText != <span class="hljs-keyword">null</span> ? bodyText : <span class="hljs-string">"Binary data"</span>);        &#125;      &#125;      log(configKey, <span class="hljs-string">"---&gt; END HTTP (%s-byte body)"</span>, bodyLength);    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logRetry</span><span class="hljs-params">(String configKey, Level logLevel)</span> </span>&#123;    log(configKey, <span class="hljs-string">"---&gt; RETRYING"</span>);  &#125;  <span class="hljs-function"><span class="hljs-keyword">protected</span> Response <span class="hljs-title">logAndRebufferResponse</span><span class="hljs-params">(String configKey, Level logLevel, Response response,</span></span><span class="hljs-function"><span class="hljs-params">                                            <span class="hljs-keyword">long</span> elapsedTime)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    String reason = response.reason() != <span class="hljs-keyword">null</span> &amp;&amp; logLevel.compareTo(Level.NONE) &gt; <span class="hljs-number">0</span> ?        <span class="hljs-string">" "</span> + response.reason() : <span class="hljs-string">""</span>;    <span class="hljs-keyword">int</span> status = response.status();    log(configKey, <span class="hljs-string">"&lt;--- HTTP/1.1 %s%s (%sms)"</span>, status, reason, elapsedTime);    <span class="hljs-keyword">if</span> (logLevel.ordinal() &gt;= Level.HEADERS.ordinal()) &#123;      <span class="hljs-keyword">for</span> (String field : response.headers().keySet()) &#123;        <span class="hljs-keyword">for</span> (String value : valuesOrEmpty(response.headers(), field)) &#123;          log(configKey, <span class="hljs-string">"%s: %s"</span>, field, value);        &#125;      &#125;      <span class="hljs-keyword">int</span> bodyLength = <span class="hljs-number">0</span>;      <span class="hljs-keyword">if</span> (response.body() != <span class="hljs-keyword">null</span> &amp;&amp; !(status == <span class="hljs-number">204</span> || status == <span class="hljs-number">205</span>)) &#123;        <span class="hljs-comment">// HTTP 204 No Content "...response MUST NOT include a message-body"</span>        <span class="hljs-comment">// HTTP 205 Reset Content "...response MUST NOT include an entity"</span>        <span class="hljs-keyword">if</span> (logLevel.ordinal() &gt;= Level.FULL.ordinal()) &#123;          log(configKey, <span class="hljs-string">""</span>); <span class="hljs-comment">// CRLF</span>        &#125;        <span class="hljs-keyword">byte</span>[] bodyData = Util.toByteArray(response.body().asInputStream());        bodyLength = bodyData.length;        <span class="hljs-keyword">if</span> (logLevel.ordinal() &gt;= Level.FULL.ordinal() &amp;&amp; bodyLength &gt; <span class="hljs-number">0</span>) &#123;          log(configKey, <span class="hljs-string">"%s"</span>, decodeOrDefault(bodyData, UTF_8, <span class="hljs-string">"Binary data"</span>));        &#125;        log(configKey, <span class="hljs-string">"&lt;--- END HTTP (%s-byte body)"</span>, bodyLength);        <span class="hljs-keyword">return</span> response.toBuilder().body(bodyData).build();      &#125; <span class="hljs-keyword">else</span> &#123;        log(configKey, <span class="hljs-string">"&lt;--- END HTTP (%s-byte body)"</span>, bodyLength);      &#125;    &#125;    <span class="hljs-keyword">return</span> response;  &#125;  <span class="hljs-function"><span class="hljs-keyword">protected</span> IOException <span class="hljs-title">logIOException</span><span class="hljs-params">(String configKey, Level logLevel, IOException ioe, <span class="hljs-keyword">long</span> elapsedTime)</span> </span>&#123;    log(configKey, <span class="hljs-string">"&lt;--- ERROR %s: %s (%sms)"</span>, ioe.getClass().getSimpleName(), ioe.getMessage(),        elapsedTime);    <span class="hljs-keyword">if</span> (logLevel.ordinal() &gt;= Level.FULL.ordinal()) &#123;      StringWriter sw = <span class="hljs-keyword">new</span> StringWriter();      ioe.printStackTrace(<span class="hljs-keyword">new</span> PrintWriter(sw));      log(configKey, sw.toString());      log(configKey, <span class="hljs-string">"&lt;--- END ERROR"</span>);    &#125;    <span class="hljs-keyword">return</span> ioe;  &#125;</code></pre><h5 id="PHASE-7-基于重试器发送HTTP请求"><a href="#PHASE-7-基于重试器发送HTTP请求" class="headerlink" title="PHASE 7 . 基于重试器发送HTTP请求"></a>PHASE 7 . 基于重试器发送HTTP请求</h5><p>Feign 内置了一个重试器，当HTTP请求出现IO异常时，Feign会有一个最大尝试次数发送请求，以下是Feign核心<br>代码逻辑：</p><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronousMethodHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodHandler</span> </span>&#123;  <span class="hljs-comment">// 省略部分代码</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object[] argv)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;   <span class="hljs-comment">//根据输入参数，构造Http 请求。</span>    RequestTemplate template = buildTemplateFromArgs.create(argv);    <span class="hljs-comment">// 克隆出一份重试器</span>    Retryer retryer = <span class="hljs-keyword">this</span>.retryer.clone();    <span class="hljs-comment">// 尝试最大次数，如果中间有结果，直接返回</span>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;      <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">return</span> executeAndDecode(template);      &#125; <span class="hljs-keyword">catch</span> (RetryableException e) &#123;        retryer.continueOrPropagate(e);        <span class="hljs-keyword">if</span> (logLevel != Logger.Level.NONE) &#123;          logger.logRetry(metadata.configKey(), logLevel);        &#125;        <span class="hljs-keyword">continue</span>;      &#125;    &#125;  &#125;</code></pre><p>重试器有如下几个控制参数：</p><table><thead><tr><th align="left">重试参数</th><th align="left">说明</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">period</td><td align="left">初始重试时间间隔，当请求失败后，重试器将会暂停 初始时间间隔(线程 sleep 的方式)后再开始，避免强刷请求，浪费性能</td><td align="left">100ms</td></tr><tr><td align="left">maxPeriod</td><td align="left">当请求连续失败时，重试的时间间隔将按照：<code>long interval = (long) (period * Math.pow(1.5, attempt - 1));</code> 计算，按照等比例方式延长，但是最大间隔时间为 maxPeriod, 设置此值能够避免 重试次数过多的情况下执行周期太长</td><td align="left">1000ms</td></tr><tr><td align="left">maxAttempts</td><td align="left">最大重试次数</td><td align="left">5</td></tr></tbody></table><p>具体的代码实现可参考：<br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FOpenFeign%2Ffeign%2Fblob%2Fmaster%2Fcore%2Fsrc%2Fmain%2Fjava%2Ffeign%2FRetryer.java" target="_blank" rel="noopener">https://github.com/OpenFeign/feign/blob/master/core/src/main/java/feign/Retryer.java</a></p><h5 id="PHASE-8-发送Http请求"><a href="#PHASE-8-发送Http请求" class="headerlink" title="PHASE 8. 发送Http请求"></a>PHASE 8. 发送Http请求</h5><p>Feign 真正发送HTTP请求是委托给 <code>feign.Client</code> 来做的：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Client</span> </span>&#123;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Executes a request against its &#123;<span class="hljs-doctag">@link</span> Request#url() url&#125; and returns a response.</span><span class="hljs-comment">   *  执行Http请求，并返回Response</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> request safe to replay.</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> options options to apply to this request.</span><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> connected response, &#123;<span class="hljs-doctag">@link</span> Response.Body&#125; is absent or unread.</span><span class="hljs-comment">   * <span class="hljs-doctag">@throws</span> IOException on a network error connecting to &#123;<span class="hljs-doctag">@link</span> Request#url()&#125;.</span><span class="hljs-comment">   */</span>  <span class="hljs-function">Response <span class="hljs-title">execute</span><span class="hljs-params">(Request request, Options options)</span> <span class="hljs-keyword">throws</span> IOException</span>;  &#125;</code></pre><p>Feign 默认底层通过JDK 的 <code>java.net.HttpURLConnection</code> 实现了<code>feign.Client</code>接口类,在每次发送请求的时候，都会创建新的HttpURLConnection 链接，这也就是为什么默认情况下Feign的性能很差的原因。可以通过拓展该接口，使用Apache HttpClient 或者OkHttp3等基于连接池的高性能Http客户端，我们项目内部使用的就是OkHttp3作为Http 客户端。</p><p>如下是Feign 的默认实现，供参考：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Default</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Client</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SSLSocketFactory sslContextFactory;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HostnameVerifier hostnameVerifier;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Null parameters imply platform defaults.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Default</span><span class="hljs-params">(SSLSocketFactory sslContextFactory, HostnameVerifier hostnameVerifier)</span> </span>&#123;      <span class="hljs-keyword">this</span>.sslContextFactory = sslContextFactory;      <span class="hljs-keyword">this</span>.hostnameVerifier = hostnameVerifier;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Response <span class="hljs-title">execute</span><span class="hljs-params">(Request request, Options options)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;      HttpURLConnection connection = convertAndSend(request, options);      <span class="hljs-keyword">return</span> convertResponse(connection).toBuilder().request(request).build();    &#125;    <span class="hljs-function">HttpURLConnection <span class="hljs-title">convertAndSend</span><span class="hljs-params">(Request request, Options options)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;      <span class="hljs-keyword">final</span> HttpURLConnection          connection =          (HttpURLConnection) <span class="hljs-keyword">new</span> URL(request.url()).openConnection();      <span class="hljs-keyword">if</span> (connection <span class="hljs-keyword">instanceof</span> HttpsURLConnection) &#123;        HttpsURLConnection sslCon = (HttpsURLConnection) connection;        <span class="hljs-keyword">if</span> (sslContextFactory != <span class="hljs-keyword">null</span>) &#123;          sslCon.setSSLSocketFactory(sslContextFactory);        &#125;        <span class="hljs-keyword">if</span> (hostnameVerifier != <span class="hljs-keyword">null</span>) &#123;          sslCon.setHostnameVerifier(hostnameVerifier);        &#125;      &#125;      connection.setConnectTimeout(options.connectTimeoutMillis());      connection.setReadTimeout(options.readTimeoutMillis());      connection.setAllowUserInteraction(<span class="hljs-keyword">false</span>);      connection.setInstanceFollowRedirects(<span class="hljs-keyword">true</span>);      connection.setRequestMethod(request.method());      Collection&lt;String&gt; contentEncodingValues = request.headers().get(CONTENT_ENCODING);      <span class="hljs-keyword">boolean</span>          gzipEncodedRequest =          contentEncodingValues != <span class="hljs-keyword">null</span> &amp;&amp; contentEncodingValues.contains(ENCODING_GZIP);      <span class="hljs-keyword">boolean</span>          deflateEncodedRequest =          contentEncodingValues != <span class="hljs-keyword">null</span> &amp;&amp; contentEncodingValues.contains(ENCODING_DEFLATE);      <span class="hljs-keyword">boolean</span> hasAcceptHeader = <span class="hljs-keyword">false</span>;      Integer contentLength = <span class="hljs-keyword">null</span>;      <span class="hljs-keyword">for</span> (String field : request.headers().keySet()) &#123;        <span class="hljs-keyword">if</span> (field.equalsIgnoreCase(<span class="hljs-string">"Accept"</span>)) &#123;          hasAcceptHeader = <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">for</span> (String value : request.headers().get(field)) &#123;          <span class="hljs-keyword">if</span> (field.equals(CONTENT_LENGTH)) &#123;            <span class="hljs-keyword">if</span> (!gzipEncodedRequest &amp;&amp; !deflateEncodedRequest) &#123;              contentLength = Integer.valueOf(value);              connection.addRequestProperty(field, value);            &#125;          &#125; <span class="hljs-keyword">else</span> &#123;            connection.addRequestProperty(field, value);          &#125;        &#125;      &#125;      <span class="hljs-comment">// Some servers choke on the default accept string.</span>      <span class="hljs-keyword">if</span> (!hasAcceptHeader) &#123;        connection.addRequestProperty(<span class="hljs-string">"Accept"</span>, <span class="hljs-string">"*/*"</span>);      &#125;      <span class="hljs-keyword">if</span> (request.body() != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">if</span> (contentLength != <span class="hljs-keyword">null</span>) &#123;          connection.setFixedLengthStreamingMode(contentLength);        &#125; <span class="hljs-keyword">else</span> &#123;          connection.setChunkedStreamingMode(<span class="hljs-number">8196</span>);        &#125;        connection.setDoOutput(<span class="hljs-keyword">true</span>);        OutputStream out = connection.getOutputStream();        <span class="hljs-keyword">if</span> (gzipEncodedRequest) &#123;          out = <span class="hljs-keyword">new</span> GZIPOutputStream(out);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (deflateEncodedRequest) &#123;          out = <span class="hljs-keyword">new</span> DeflaterOutputStream(out);        &#125;        <span class="hljs-keyword">try</span> &#123;          out.write(request.body());        &#125; <span class="hljs-keyword">finally</span> &#123;          <span class="hljs-keyword">try</span> &#123;            out.close();          &#125; <span class="hljs-keyword">catch</span> (IOException suppressed) &#123; <span class="hljs-comment">// NOPMD</span>          &#125;        &#125;      &#125;      <span class="hljs-keyword">return</span> connection;    &#125;    <span class="hljs-function">Response <span class="hljs-title">convertResponse</span><span class="hljs-params">(HttpURLConnection connection)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;      <span class="hljs-keyword">int</span> status = connection.getResponseCode();      String reason = connection.getResponseMessage();      <span class="hljs-keyword">if</span> (status &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(format(<span class="hljs-string">"Invalid status(%s) executing %s %s"</span>, status,            connection.getRequestMethod(), connection.getURL()));      &#125;      Map&lt;String, Collection&lt;String&gt;&gt; headers = <span class="hljs-keyword">new</span> LinkedHashMap&lt;String, Collection&lt;String&gt;&gt;();      <span class="hljs-keyword">for</span> (Map.Entry&lt;String, List&lt;String&gt;&gt; field : connection.getHeaderFields().entrySet()) &#123;        <span class="hljs-comment">// response message</span>        <span class="hljs-keyword">if</span> (field.getKey() != <span class="hljs-keyword">null</span>) &#123;          headers.put(field.getKey(), field.getValue());        &#125;      &#125;      Integer length = connection.getContentLength();      <span class="hljs-keyword">if</span> (length == -<span class="hljs-number">1</span>) &#123;        length = <span class="hljs-keyword">null</span>;      &#125;      InputStream stream;      <span class="hljs-keyword">if</span> (status &gt;= <span class="hljs-number">400</span>) &#123;        stream = connection.getErrorStream();      &#125; <span class="hljs-keyword">else</span> &#123;        stream = connection.getInputStream();      &#125;      <span class="hljs-keyword">return</span> Response.builder()              .status(status)              .reason(reason)              .headers(headers)              .body(stream, length)              .build();    &#125;  &#125;</code></pre><h2 id="Feign-的性能怎么样？"><a href="#Feign-的性能怎么样？" class="headerlink" title="Feign 的性能怎么样？"></a>Feign 的性能怎么样？</h2><p>Feign 整体框架非常小巧，在处理请求转换和消息解析的过程中，基本上没什么时间消耗。真正影响性能的，是处理Http请求的环节。<br>如上所述，由于默认情况下，Feign采用的是JDK的<code>HttpURLConnection</code>,所以整体性能并不高，刚开始接触Spring Cloud 的同学，如果没注意这些细节，可能会对Spring Cloud 有很大的偏见。<br>我们项目内部使用的是OkHttp3 作为连接客户端。</p><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>springCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springCloud</tag>
      
      <tag>Feign</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[fastjson]把对象转化成json避免</title>
    <link href="/2019/12/14/fastjson-%E6%8A%8A%E5%AF%B9%E8%B1%A1%E8%BD%AC%E5%8C%96%E6%88%90json%E9%81%BF%E5%85%8D/"/>
    <url>/2019/12/14/fastjson-%E6%8A%8A%E5%AF%B9%E8%B1%A1%E8%BD%AC%E5%8C%96%E6%88%90json%E9%81%BF%E5%85%8D/</url>
    
    <content type="html"><![CDATA[<p>DisableCircularReferenceDetect来禁止循环引用检测：</p><p>JSON.toJSONString(…, SerializerFeature.DisableCircularReferenceDetect)</p><p>当进行toJSONString的时候，默认如果重用对象的话，会使用引用的方式进行引用对象。</p><pre><code class="hljs json">"颜色": [        &#123;          <span class="hljs-attr">"$ref"</span>: <span class="hljs-string">"$.itemSkuList[0].itemSpecificationList[0]"</span>        &#125;,         &#123;          <span class="hljs-attr">"$ref"</span>: <span class="hljs-string">"$.itemSkuList[1].itemSpecificationList[0]"</span>        &#125;      ]</code></pre><h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>很多场景中，我们需要序列化的对象中存在循环引用，在许多的json库中，这会导致stackoverflow。在功能强大的fastjson中，你不需要担心这个问题。例如：</p><pre><code class="hljs java">A a = <span class="hljs-keyword">new</span> A();  B b = <span class="hljs-keyword">new</span> B(a);  a.setB(b);  String text = JSON.toJSONString(a); <span class="hljs-comment">//&#123;"b":&#123;"a":&#123;"$ref":".."&#125;&#125;&#125;  </span>A a1 = JSON.parseObject(text, A<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;  Assert.assertTrue(a1 == a1.getB().getA());</code></pre><p>引用是通过”$ref”来表示的</p><table><thead><tr><th align="left">引用</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>&quot;$ref&quot;:&quot;..&quot;</code></td><td align="left">上一级</td></tr><tr><td align="left"><code>&quot;$ref&quot;:&quot;@&quot;</code></td><td align="left">当前对象，也就是自引用</td></tr><tr><td align="left"><code>&quot;$ref&quot;:&quot;$&quot;</code></td><td align="left">根对象</td></tr><tr><td align="left"><code>&quot;$ref&quot;:&quot;$.children.0&quot;</code></td><td align="left">基于路径的引用，相当于 root.getChildren().get(0)</td></tr></tbody></table><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>fastjson</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[fastjson]SerializerFeature详解</title>
    <link href="/2019/12/14/fastjson-SerializerFeature%E8%AF%A6%E8%A7%A3/"/>
    <url>/2019/12/14/fastjson-SerializerFeature%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="SerializerFeature属性"><a href="#SerializerFeature属性" class="headerlink" title="SerializerFeature属性"></a>SerializerFeature属性</h1><table><thead><tr><th>名称</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>QuoteFieldNames</td><td>输出key时是否使用双引号,默认为true</td><td></td></tr><tr><td>UseSingleQuotes</td><td>使用单引号而不是双引号,默认为false</td><td></td></tr><tr><td>WriteMapNullValue</td><td>是否输出值为null的字段,默认为false</td><td></td></tr><tr><td>WriteEnumUsingToString</td><td>Enum输出name()或者original,默认为false</td><td></td></tr><tr><td>UseISO8601DateFormat</td><td>Date使用ISO8601格式输出，默认为false</td><td></td></tr><tr><td>WriteNullListAsEmpty</td><td>List字段如果为null,输出为[],而非null</td><td></td></tr><tr><td>WriteNullStringAsEmpty</td><td>字符类型字段如果为null,输出为”“,而非null</td><td></td></tr><tr><td>WriteNullNumberAsZero</td><td>数值字段如果为null,输出为0,而非null</td><td></td></tr><tr><td>WriteNullBooleanAsFalse</td><td>Boolean字段如果为null,输出为false,而非null</td><td></td></tr><tr><td>SkipTransientField</td><td>如果是true，类中的Get方法对应的Field是transient，序列化时将会被忽略。默认为true</td><td></td></tr><tr><td>SortField</td><td>按字段名称排序后输出。默认为false</td><td></td></tr><tr><td>WriteTabAsSpecial</td><td>把\t做转义输出，默认为false</td><td><code>不推荐</code></td></tr><tr><td>PrettyFormat</td><td>结果是否格式化,默认为false</td><td></td></tr><tr><td>WriteClassName</td><td>序列化时写入类型信息，默认为false。反序列化是需用到</td><td></td></tr><tr><td>DisableCircularReferenceDetect</td><td>消除对同一对象循环引用的问题，默认为false</td><td></td></tr><tr><td>WriteSlashAsSpecial</td><td>对斜杠’/’进行转义</td><td></td></tr><tr><td>BrowserCompatible</td><td>将中文都会序列化为\uXXXX格式，字节数会多一些，但是能兼容IE 6，默认为false</td><td></td></tr><tr><td>WriteDateUseDateFormat</td><td>全局修改日期格式,默认为false。JSON.DEFFAULT_DATE_FORMAT = “yyyy-MM-dd”;JSON.toJSONString(obj, SerializerFeature.WriteDateUseDateFormat);</td><td></td></tr><tr><td>DisableCheckSpecialChar</td><td>一个对象的字符串属性中如果有特殊字符如双引号，将会在转成json时带有反斜杠转移符。如果不需要转义，可以使用这个属性。默认为false</td><td></td></tr><tr><td>NotWriteRootClassName</td><td>含义</td><td></td></tr><tr><td>BeanToArray</td><td>将对象转为array输出</td><td></td></tr><tr><td>WriteNonStringKeyAsString</td><td>含义</td><td></td></tr><tr><td>NotWriteDefaultValue</td><td>含义</td><td></td></tr><tr><td>BrowserSecure</td><td>含义</td><td></td></tr><tr><td>IgnoreNonFieldGetter</td><td>含义</td><td></td></tr><tr><td>WriteEnumUsingName</td><td>含义</td><td>-</td></tr></tbody></table><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>User、Word来模拟各种数据类型。</li><li>SerializerFeatureTest：JSON部分示例的示例方法。</li></ul><h2 id="User类型：缺省get、set方法"><a href="#User类型：缺省get、set方法" class="headerlink" title="User类型：缺省get、set方法"></a>User类型：缺省get、set方法</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String add;    <span class="hljs-keyword">private</span> String old;&#125;</code></pre><h2 id="Word类型：缺省get、set方法"><a href="#Word类型：缺省get、set方法" class="headerlink" title="Word类型：缺省get、set方法"></a>Word类型：缺省get、set方法</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Word</span> </span>&#123;    <span class="hljs-keyword">private</span> String d;    <span class="hljs-keyword">private</span> String e;    <span class="hljs-keyword">private</span> String f;    <span class="hljs-keyword">private</span> String a;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> c;    <span class="hljs-keyword">private</span> Date date;    <span class="hljs-keyword">private</span> Map&lt;String , Object&gt; map;    <span class="hljs-keyword">private</span> List&lt;User&gt; list;&#125;</code></pre><h3 id="SerializerFeatureTest-测试类"><a href="#SerializerFeatureTest-测试类" class="headerlink" title="SerializerFeatureTest:测试类"></a>SerializerFeatureTest:测试类</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SerializerFeatureTest</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Word word;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;        word = <span class="hljs-keyword">new</span> Word();        word.setA(<span class="hljs-string">"a"</span>);        word.setB(<span class="hljs-number">2</span>);        word.setC(<span class="hljs-keyword">true</span>);        word.setD(<span class="hljs-string">"d"</span>);        word.setE(<span class="hljs-string">""</span>);        word.setF(<span class="hljs-keyword">null</span>);        word.setDate(<span class="hljs-keyword">new</span> Date());        List&lt;User&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;User&gt;();        User user1 = <span class="hljs-keyword">new</span> User();        user1.setId(<span class="hljs-number">1</span>);        user1.setOld(<span class="hljs-string">"11"</span>);        user1.setName(<span class="hljs-string">"用户1"</span>);        user1.setAdd(<span class="hljs-string">"北京"</span>);        User user2 = <span class="hljs-keyword">new</span> User();        user2.setId(<span class="hljs-number">2</span>);        user2.setOld(<span class="hljs-string">"22"</span>);        user2.setName(<span class="hljs-string">"用户2"</span>);        user2.setAdd(<span class="hljs-string">"上海"</span>);        User user3 = <span class="hljs-keyword">new</span> User();        user3.setId(<span class="hljs-number">3</span>);        user3.setOld(<span class="hljs-string">"33"</span>);        user3.setName(<span class="hljs-string">"用户3"</span>);        user3.setAdd(<span class="hljs-string">"广州"</span>);        list.add(user3);        list.add(user2);        list.add(<span class="hljs-keyword">null</span>);        list.add(user1);        word.setList(list);        Map&lt;String , Object&gt; map = <span class="hljs-keyword">new</span> HashedMap();        map.put(<span class="hljs-string">"mapa"</span>, <span class="hljs-string">"mapa"</span>);        map.put(<span class="hljs-string">"mapo"</span>, <span class="hljs-string">"mapo"</span>);        map.put(<span class="hljs-string">"mapz"</span>, <span class="hljs-string">"mapz"</span>);        map.put(<span class="hljs-string">"user1"</span>, user1);        map.put(<span class="hljs-string">"user3"</span>, user3);        map.put(<span class="hljs-string">"user4"</span>, <span class="hljs-keyword">null</span>);        map.put(<span class="hljs-string">"list"</span>, list);        word.setMap(map);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        init();<span class="hljs-comment">//        useSingleQuotes();</span><span class="hljs-comment">//        writeMapNullValue();</span><span class="hljs-comment">//        useISO8601DateFormat();</span><span class="hljs-comment">//        writeNullListAsEmpty();</span><span class="hljs-comment">//        writeNullStringAsEmpty();</span><span class="hljs-comment">//        sortField();</span><span class="hljs-comment">//        prettyFormat();</span><span class="hljs-comment">//        writeDateUseDateFormat();</span><span class="hljs-comment">//        beanToArray();</span>        showJsonBySelf();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 9:自定义</span><span class="hljs-comment">     * 格式化输出</span><span class="hljs-comment">     * 显示值为null的字段</span><span class="hljs-comment">     * 将为null的字段值显示为""</span><span class="hljs-comment">     * DisableCircularReferenceDetect:消除循环引用</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showJsonBySelf</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(JSON.toJSONString(word));        System.out.println(JSON.toJSONString(word, SerializerFeature.PrettyFormat,                SerializerFeature.WriteMapNullValue, SerializerFeature.WriteNullStringAsEmpty,                SerializerFeature.DisableCircularReferenceDetect,                SerializerFeature.WriteNullListAsEmpty));    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 8:</span><span class="hljs-comment">     * 将对象转为array输出</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beanToArray</span><span class="hljs-params">()</span> </span>&#123;        word.setMap(<span class="hljs-keyword">null</span>);        word.setList(<span class="hljs-keyword">null</span>);        System.out.println(JSON.toJSONString(word));        System.out.println(JSON.toJSONString(word, SerializerFeature.BeanToArray));    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 7:</span><span class="hljs-comment">     * WriteDateUseDateFormat:全局修改日期格式,默认为false。</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeDateUseDateFormat</span><span class="hljs-params">()</span> </span>&#123;        word.setMap(<span class="hljs-keyword">null</span>);        word.setList(<span class="hljs-keyword">null</span>);        System.out.println(JSON.toJSONString(word));        JSON.DEFFAULT_DATE_FORMAT = <span class="hljs-string">"yyyy-MM-dd"</span>;        System.out.println(JSON.toJSONString(word, SerializerFeature.WriteDateUseDateFormat));    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 6:</span><span class="hljs-comment">     * PrettyFormat</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prettyFormat</span><span class="hljs-params">()</span> </span>&#123;        word.setMap(<span class="hljs-keyword">null</span>);        word.setList(<span class="hljs-keyword">null</span>);        System.out.println(JSON.toJSONString(word));        System.out.println(JSON.toJSONString(word, SerializerFeature.PrettyFormat));    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * SortField:按字段名称排序后输出。默认为false</span><span class="hljs-comment">     * 这里使用的是fastjson：为了更好使用sort field martch优化算法提升parser的性能，fastjson序列化的时候，</span><span class="hljs-comment">     * 缺省把SerializerFeature.SortField特性打开了。</span><span class="hljs-comment">     * 反序列化的时候也缺省把SortFeidFastMatch的选项打开了。</span><span class="hljs-comment">     * 这样，如果你用fastjson序列化的文本，输出的结果是按照fieldName排序输出的，parser时也能利用这个顺序进行优化读取。</span><span class="hljs-comment">     * 这种情况下，parser能够获得非常好的性能。</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortField</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(JSON.toJSONString(word));        System.out.println(JSON.toJSONString(word, SerializerFeature.SortField));    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *  5:</span><span class="hljs-comment">     *  WriteNullStringAsEmpty:字符类型字段如果为null,输出为"",而非null</span><span class="hljs-comment">     *  需要配合WriteMapNullValue使用，现将null输出</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeNullStringAsEmpty</span><span class="hljs-params">()</span> </span>&#123;        word.setE(<span class="hljs-keyword">null</span>);        System.out.println(JSONObject.toJSONString(word));        System.out.println(<span class="hljs-string">"设置WriteMapNullValue后："</span>);        System.out.println(JSONObject.toJSONString(word, SerializerFeature.WriteMapNullValue));        System.out.println(<span class="hljs-string">"设置WriteMapNullValue、WriteNullStringAsEmpty后："</span>);        System.out.println(JSONObject.toJSONString(word, SerializerFeature.WriteMapNullValue, SerializerFeature.WriteNullStringAsEmpty));    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 4:</span><span class="hljs-comment">     * WriteNullListAsEmpty:List字段如果为null,输出为[],而非null</span><span class="hljs-comment">     * 需要配合WriteMapNullValue使用，现将null输出</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeNullListAsEmpty</span><span class="hljs-params">()</span> </span>&#123;        word.setList(<span class="hljs-keyword">null</span>);        System.out.println(JSONObject.toJSONString(word));        System.out.println(<span class="hljs-string">"设置WriteNullListAsEmpty后："</span>);        System.out.println(JSONObject.toJSONString(word, SerializerFeature.WriteMapNullValue, SerializerFeature.WriteNullListAsEmpty));    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 3:</span><span class="hljs-comment">     * UseISO8601DateFormat:Date使用ISO8601格式输出，默认为false</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useISO8601DateFormat</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(JSONObject.toJSONString(word));        System.out.println(<span class="hljs-string">"设置UseISO8601DateFormat后："</span>);        System.out.println(JSONObject.toJSONString(word, SerializerFeature.UseISO8601DateFormat));    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 2:</span><span class="hljs-comment">     * WriteMapNullValue:是否输出值为null的字段,默认为false</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeMapNullValue</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(JSONObject.toJSONString(word));        System.out.println(<span class="hljs-string">"设置WriteMapNullValue后："</span>);        System.out.println(JSONObject.toJSONString(word, SerializerFeature.WriteMapNullValue));    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 1:</span><span class="hljs-comment">     * UseSingleQuotes:使用单引号而不是双引号,默认为false</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useSingleQuotes</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(JSONObject.toJSONString(word));        System.out.println(<span class="hljs-string">"设置useSingleQuotes后："</span>);        System.out.println(JSONObject.toJSONString(word, SerializerFeature.UseSingleQuotes));    &#125;&#125;</code></pre><h2 id="对应输出结果如下："><a href="#对应输出结果如下：" class="headerlink" title="对应输出结果如下："></a>对应输出结果如下：</h2><p>1、useSingleQuotes：</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9yms5h9h1j30f003dwef.jpg" srcset="/img/loading.gif" alt="img"></p><p>2、writeMapNullValue：</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9yms6k0jhj30iu02rwee.jpg" srcset="/img/loading.gif" alt="img"></p><p>3、useISO8601DateFormat： </p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9yms7xdzkj30jn03oglo.jpg" srcset="/img/loading.gif" alt="img"></p><p>4、writeNullListAsEmpty：</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9yms8q45pj30lt048aa4.jpg" srcset="/img/loading.gif" alt="img"></p><p>5、writeNullStringAsEmpty： </p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9yms95rxsj30oj05sq37.jpg" srcset="/img/loading.gif" alt="img"></p><p>6、prettyFormat：</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9yms9ntfej30kk07ywej.jpg" srcset="/img/loading.gif" alt="img"></p><p>7、writeDateUseDateFormat： </p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymsbzofuj30jr040t8o.jpg" srcset="/img/loading.gif" alt="img"></p><p>8、beanToArray：</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymsd1sldj30ja037glk.jpg" srcset="/img/loading.gif" alt="img"></p><p>9、自定义组合：showJsonBySelf： </p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymse2vkzj30wl0csjs0.jpg" srcset="/img/loading.gif" alt="img"></p><p> 此时完整的输出如下：</p><pre><code class="hljs json">&#123;<span class="hljs-attr">"a"</span>:<span class="hljs-string">"a"</span>,<span class="hljs-attr">"b"</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">"c"</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">"d"</span>:<span class="hljs-string">"d"</span>,<span class="hljs-attr">"date"</span>:<span class="hljs-number">1473839656840</span>,<span class="hljs-attr">"e"</span>:<span class="hljs-string">""</span>,<span class="hljs-attr">"list"</span>:[&#123;<span class="hljs-attr">"add"</span>:<span class="hljs-string">"广州"</span>,<span class="hljs-attr">"id"</span>:<span class="hljs-number">3</span>,<span class="hljs-attr">"name"</span>:<span class="hljs-string">"用户3"</span>,<span class="hljs-attr">"old"</span>:<span class="hljs-string">"33"</span>&#125;,&#123;<span class="hljs-attr">"add"</span>:<span class="hljs-string">"上海"</span>,<span class="hljs-attr">"id"</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">"name"</span>:<span class="hljs-string">"用户2"</span>,<span class="hljs-attr">"old"</span>:<span class="hljs-string">"22"</span>&#125;,<span class="hljs-literal">null</span>,&#123;<span class="hljs-attr">"add"</span>:<span class="hljs-string">"北京"</span>,<span class="hljs-attr">"id"</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">"name"</span>:<span class="hljs-string">"用户1"</span>,<span class="hljs-attr">"old"</span>:<span class="hljs-string">"11"</span>&#125;],<span class="hljs-attr">"map"</span>:&#123;<span class="hljs-attr">"list"</span>:[&#123;<span class="hljs-attr">"$ref"</span>:<span class="hljs-string">"$.list[0]"</span>&#125;,&#123;<span class="hljs-attr">"$ref"</span>:<span class="hljs-string">"$.list[1]"</span>&#125;,<span class="hljs-literal">null</span>,&#123;<span class="hljs-attr">"$ref"</span>:<span class="hljs-string">"$.list[3]"</span>&#125;],<span class="hljs-attr">"user3"</span>:&#123;<span class="hljs-attr">"$ref"</span>:<span class="hljs-string">"$.list[0]"</span>&#125;,<span class="hljs-attr">"mapz"</span>:<span class="hljs-string">"mapz"</span>,<span class="hljs-attr">"mapo"</span>:<span class="hljs-string">"mapo"</span>,<span class="hljs-attr">"mapa"</span>:<span class="hljs-string">"mapa"</span>,<span class="hljs-attr">"user1"</span>:&#123;<span class="hljs-attr">"$ref"</span>:<span class="hljs-string">"$.list[3]"</span>&#125;&#125;&#125;&#123;    <span class="hljs-attr">"a"</span>:<span class="hljs-string">"a"</span>,    <span class="hljs-attr">"b"</span>:<span class="hljs-number">2</span>,    <span class="hljs-attr">"c"</span>:<span class="hljs-literal">true</span>,    <span class="hljs-attr">"d"</span>:<span class="hljs-string">"d"</span>,    <span class="hljs-attr">"date"</span>:<span class="hljs-number">1473839656840</span>,    <span class="hljs-attr">"e"</span>:<span class="hljs-string">""</span>,    <span class="hljs-attr">"f"</span>:<span class="hljs-string">""</span>,    <span class="hljs-attr">"list"</span>:[        &#123;            <span class="hljs-attr">"add"</span>:<span class="hljs-string">"广州"</span>,            <span class="hljs-attr">"id"</span>:<span class="hljs-number">3</span>,            <span class="hljs-attr">"name"</span>:<span class="hljs-string">"用户3"</span>,            <span class="hljs-attr">"old"</span>:<span class="hljs-string">"33"</span>        &#125;,        &#123;            <span class="hljs-attr">"add"</span>:<span class="hljs-string">"上海"</span>,            <span class="hljs-attr">"id"</span>:<span class="hljs-number">2</span>,            <span class="hljs-attr">"name"</span>:<span class="hljs-string">"用户2"</span>,            <span class="hljs-attr">"old"</span>:<span class="hljs-string">"22"</span>        &#125;,        <span class="hljs-literal">null</span>,        &#123;            <span class="hljs-attr">"add"</span>:<span class="hljs-string">"北京"</span>,            <span class="hljs-attr">"id"</span>:<span class="hljs-number">1</span>,            <span class="hljs-attr">"name"</span>:<span class="hljs-string">"用户1"</span>,            <span class="hljs-attr">"old"</span>:<span class="hljs-string">"11"</span>        &#125;    ],    <span class="hljs-attr">"map"</span>:&#123;        <span class="hljs-attr">"list"</span>:[            &#123;                <span class="hljs-attr">"add"</span>:<span class="hljs-string">"广州"</span>,                <span class="hljs-attr">"id"</span>:<span class="hljs-number">3</span>,                <span class="hljs-attr">"name"</span>:<span class="hljs-string">"用户3"</span>,                <span class="hljs-attr">"old"</span>:<span class="hljs-string">"33"</span>            &#125;,            &#123;                <span class="hljs-attr">"add"</span>:<span class="hljs-string">"上海"</span>,                <span class="hljs-attr">"id"</span>:<span class="hljs-number">2</span>,                <span class="hljs-attr">"name"</span>:<span class="hljs-string">"用户2"</span>,                <span class="hljs-attr">"old"</span>:<span class="hljs-string">"22"</span>            &#125;,            <span class="hljs-literal">null</span>,            &#123;                <span class="hljs-attr">"add"</span>:<span class="hljs-string">"北京"</span>,                <span class="hljs-attr">"id"</span>:<span class="hljs-number">1</span>,                <span class="hljs-attr">"name"</span>:<span class="hljs-string">"用户1"</span>,                <span class="hljs-attr">"old"</span>:<span class="hljs-string">"11"</span>            &#125;        ],        <span class="hljs-attr">"user4"</span>:<span class="hljs-literal">null</span>,        <span class="hljs-attr">"user3"</span>:&#123;            <span class="hljs-attr">"add"</span>:<span class="hljs-string">"广州"</span>,            <span class="hljs-attr">"id"</span>:<span class="hljs-number">3</span>,            <span class="hljs-attr">"name"</span>:<span class="hljs-string">"用户3"</span>,            <span class="hljs-attr">"old"</span>:<span class="hljs-string">"33"</span>        &#125;,        <span class="hljs-attr">"mapz"</span>:<span class="hljs-string">"mapz"</span>,        <span class="hljs-attr">"mapo"</span>:<span class="hljs-string">"mapo"</span>,        <span class="hljs-attr">"mapa"</span>:<span class="hljs-string">"mapa"</span>,        <span class="hljs-attr">"user1"</span>:&#123;            <span class="hljs-attr">"add"</span>:<span class="hljs-string">"北京"</span>,            <span class="hljs-attr">"id"</span>:<span class="hljs-number">1</span>,            <span class="hljs-attr">"name"</span>:<span class="hljs-string">"用户1"</span>,            <span class="hljs-attr">"old"</span>:<span class="hljs-string">"11"</span>        &#125;    &#125;&#125;</code></pre><p>注意：<br>- <a href="http://blog.csdn.net/u010246789/article/details/52538953" target="_blank" rel="noopener">fastjson把对象转化成json避免$ref</a></p><p>学习地址：<br>- <a href="http://blog.csdn.net/glarystar/article/details/6654494" target="_blank" rel="noopener">http://blog.csdn.net/glarystar/article/details/6654494</a><br>- <a href="http://blog.csdn.net/u013163567/article/details/50736096" target="_blank" rel="noopener">http://blog.csdn.net/u013163567/article/details/50736096</a></p><p>项目github地址：<br>- <a href="https://github.com/gubaijin/buildmavenweb" target="_blank" rel="noopener">https://github.com/gubaijin/buildmavenweb</a></p><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>fastjson</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>API 网关从入门到放弃</title>
    <link href="/2019/12/07/API-%E7%BD%91%E5%85%B3%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/"/>
    <url>/2019/12/07/API-%E7%BD%91%E5%85%B3%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/</url>
    
    <content type="html"><![CDATA[<blockquote><p>来源：<a href="http://www.jiangxinlingdu.com/thought/2019/09/12/gateway.html" target="_blank" rel="noopener">匠心零度</a><a href="http://www.jiangxinlingdu.com/thought/2019/09/12/gateway.html" target="_blank" rel="noopener">http://www.jiangxinlingdu.com/thought/2019/09/12/gateway.html</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>假设你正在开发一个电商网站，那么这里会涉及到很多后端的微服务，比如会员、商品、推荐服务等等。</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymmel0tcj30dg0dc0t7.jpg" srcset="/img/loading.gif" alt="img"></p><p>那么这里就会遇到一个问题，APP/Browser怎么去访问这些后端的服务? 如果业务比较简单的话，可以给每个业务都分配一个独立的域名(<a href="https://service.api.company.com)，但这种方式会有几个问题" target="_blank" rel="noopener">https://service.api.company.com)，但这种方式会有几个问题</a>:</p><ul><li>每个业务都会需要鉴权、限流、权限校验等逻辑，如果每个业务都各自为战，自己造轮子实现一遍，会很蛋疼，完全可以抽出来，放到一个统一的地方去做。</li><li>如果业务量比较简单的话，这种方式前期不会有什么问题，但随着业务越来越复杂，比如淘宝、亚马逊打开一个页面可能会涉及到数百个微服务协同工作，如果每一个微服务都分配一个域名的话，一方面客户端代码会很难维护，涉及到数百个域名，另一方面是连接数的瓶颈，想象一下你打开一个APP，通过抓包发现涉及到了数百个远程调用，这在移动端下会显得非常低效。</li><li>每上线一个新的服务，都需要运维参与，申请域名、配置Nginx等，当上线、下线服务器时，同样也需要运维参与，另外采用域名这种方式，对于环境的隔离也不太友好，调用者需要自己根据域名自己进行判断。</li><li>另外还有一个问题，后端每个微服务可能是由不同语言编写的、采用了不同的协议，比如HTTP、Dubbo、GRPC等，但是你不可能要求客户端去适配这么多种协议，这是一项非常有挑战的工作，项目会变的非常复杂且很难维护。</li><li>后期如果需要对微服务进行重构的话，也会变的非常麻烦，需要客户端配合你一起进行改造，比如商品服务，随着业务变的越来越复杂，后期需要进行拆分成多个微服务，这个时候对外提供的服务也需要拆分成多个，同时需要客户端配合你进行改造，非常蛋疼。</li></ul><h2 id="API-Gateway"><a href="#API-Gateway" class="headerlink" title="API Gateway"></a><strong>API Gateway</strong></h2><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymmfjn96j30dg0dcdgb.jpg" srcset="/img/loading.gif" alt=""></p><p>更好的方式是采用API网关，实现一个API网关接管所有的入口流量，类似Nginx的作用，将所有用户的请求转发给后端的服务器，但网关做的不仅仅只是简单的转发，也会针对流量做一些扩展，比如鉴权、限流、权限、熔断、协议转换、错误码统一、缓存、日志、监控、告警等，这样将通用的逻辑抽出来，由网关统一去做，业务方也能够更专注于业务逻辑，提升迭代的效率。</p><p>通过引入API网关，客户端只需要与API网关交互，而不用与各个业务方的接口分别通讯，但多引入一个组件就多引入了一个潜在的故障点，因此要实现一个高性能、稳定的网关，也会涉及到很多点。</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymmg0sxxj30sg0kpabh.jpg" srcset="/img/loading.gif" alt="img"></p><h2 id="API注册"><a href="#API注册" class="headerlink" title="API注册"></a><strong>API注册</strong></h2><p>业务方如何接入网关?一般来说有几种方式。</p><ul><li>第一种采用插件扫描业务方的API，比如Spring MVC的注解，并结合Swagger的注解，从而实现参数校验、文档&amp;&amp;SDK生成等功能，扫描完成之后，需要上报到网关的存储服务。</li><li>手动录入。比如接口的路径、请求参数、响应参数、调用方式等信息，但这种方式相对来说会麻烦一些，如果参数过多的话，前期录入会很费时费力。</li></ul><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymmguf7zj30u00fraal.jpg" srcset="/img/loading.gif" alt=""></p><ul><li>配置文件导入。比如通过Swagger\OpenAPI等，比如阿里云的网关:</li></ul><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymmhua4lj30u0064t93.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="协议转换"><a href="#协议转换" class="headerlink" title="协议转换"></a><strong>协议转换</strong></h2><p>内部的API可能是由很多种不同的协议实现的，比如HTTP、Dubbo、GRPC等，但对于用户来说其中很多都不是很友好，或者根本没法对外暴露，比如Dubbo服务，因此需要在网关层做一次协议转换，将用户的HTTP协议请求，在网关层转换成底层对应的协议，比如HTTP -&gt; Dubbo, 但这里需要注意很多问题，比如参数类型，如果类型搞错了，导致转换出问题，而日志又不够详细的话，问题会很难定位。</p><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a><strong>服务发现</strong></h2><p>网关作为流量的入口，负责请求的转发，但首先需要知道转发给谁，如何寻址，这里有几种方式:</p><ul><li>写死在代码/配置文件里，这种方式虽然比较挫，但也能使用，比如线上仍然使用的是物理机，IP变动不会很频繁，但扩缩容、包括应用上下线都会很麻烦，网关自身甚至需要实现一套健康监测机制。</li><li>域名。采用域名也是一种不错的方案，对于所有的语言都适用，但对于内部的服务，走域名会很低效，另外环境隔离也不太友好，比如预发、线上通常是同一个数据库，因此网关读取到的可能是同一个域名，这时候预发的网关调用的就是线上的服务。</li><li>注册中心。采用注册中心就不会有上述的这些问题，即使是在容器环境下，节点的IP变更比较频繁，但节点列表的实时维护会由注册中心搞定，对网关是透明的，另外应用的正常上下线、包括异常宕机等情况，也会由注册中心的健康检查机制检测到，并实时反馈给网关。并且采用注册中心性能也没有额外的性能损耗，采用域名的方式，额外需要走一次DNS解析、Nginx转发等，中间多了很多跳，性能会有很大的下降，但采用注册中心，网关是和业务方直接点对点的通讯，不会有额外的损耗。</li></ul><h2 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a><strong>服务调用</strong></h2><p>网关由于对接很多种不同的协议，因此可能需要实现很多种调用方式，比如HTTP、Dubbo等，基于性能原因，最好都采用异步的方式，而Http、Dubbo都是支持异步的，比如apache就提供了基于NIO实现的异步HTTP客户端。</p><p>因为网关会涉及到很多异步调用，比如拦截器、HTTP客户端、dubbo、redis等，因此需要考虑下异步调用的方式，如果基于回调或者future的话，代码嵌套会很深，可读性很差，可以参考zuul和spring cloud gateway的方案，基于响应式进行改造。</p><h2 id="优雅下线"><a href="#优雅下线" class="headerlink" title="优雅下线"></a><strong>优雅下线</strong></h2><p>优雅下线也是网关需要关注的一个问题，网关底层会涉及到很多种协议，比如HTTP、Dubbo，而HTTP又可以继续细分，比如域名、注册中心等，有些自身就支持优雅下线，比如Nginx自身是支持健康监测机制的，如果检测到某一个节点已经挂掉了，就会把这个节点摘掉，对于应用正常下线，需要结合发布系统，首先进行逻辑下线，然后对后续Nginx的健康监测请求直接返回失败(比如直接返回500),然后等待一段时间(根据Nginx配置决定)，然后再将应用实际下线掉。另外对于注册中心的其实也类似，一般注册中心是只支持手动下线的，可以在逻辑下线阶段调用注册中心的接口将节点下线掉，而有些不支持主动下线的，需要结合缓存的配置，让应用延迟下线。另外对于其他比如Dubbo等原理也是类似。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a><strong>性能</strong></h2><p>网关作为所有流量的入口，性能是重中之重，早期大部分网关都是基于同步阻塞模型构建的，比如Zuul 1.x。但这种同步的模型我们都知道，每个请求/连接都会占用一个线程，而线程在JVM中是一个很重的资源，比如Tomcat默认就是200个线程，如果网关隔离没有做好的话，当发生网络延迟、FullGC、第三方服务慢等情况造成上游服务延迟时，线程池很容易会被打满，造成新的请求被拒绝，但这个时候其实线程都阻塞在IO上，系统的资源被没有得到充分的利用。另外一点，容易受网络、磁盘IO等延迟影响。需要谨慎设置超时时间，如果设置不当，且服务隔离做的不是很完善的话，网关很容易被一个慢接口拖垮。</p><p>而异步化的方式则完全不同，通常情况下一个CPU核启动一个线程即可处理所有的请求、响应。一个请求的生命周期不再固定于一个线程，而是会分成不同的阶段交由不同的线程池处理，系统的资源能够得到更充分的利用。而且因为线程不再被某一个连接独占，一个连接所占用的系统资源也会低得多，只是一个文件描述符加上几个监听器等，而在阻塞模型中，每条连接都会独占一个线程，而线程是一个非常重的资源。对于上游服务的延迟情况，也能够得到很大的缓解，因为在阻塞模型中，慢请求会独占一个线程资源，而异步化之后，因为单条连接所占用的资源变的非常低，系统可以同时处理大量的请求。</p><p>如果是JVM平台，Zuul 2、Spring Cloud gateway等都是不错的异步网关选型，另外也可以基于Netty、Spring Boot2.x的webflux、vert.x或者servlet3.1的异步支持进行自研。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a><strong>缓存</strong></h2><p>对于一些幂等的get请求，可以在网关层面根据业务方指定的缓存头做一层缓存，存储到Redis等二级缓存中，这样一些重复的请求，可以在网关层直接处理，而不用打到业务线，降低业务方的压力，另外如果业务方节点挂掉，网关也能够返回自身的缓存。</p><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a><strong>限流</strong></h2><p>限流对于每个业务组件来说，可以说都是一个必须的组件，如果限流做不好的话，当请求量突增时，很容易导致业务方的服务挂掉，比如双11、双12等大促时，接口的请求量是平时的数倍，如果没有评估好容量，又没有做限流的话，很容易服务整个不可用，因此需要根据业务方接口的处理能力，做好限流策略，相信大家都见过淘宝、百度抢红包时的降级页面。</p><p>因此一定要在接入层做好限流策略，对于非核心接口可以直接将降级掉，保障核心服务的可用性，对于核心接口，需要根据压测时得到的接口容量，制定对应的限流策略。限流又分为几种:</p><ul><li>单机。单机性能比较高，不涉及远程调用，只是本地计数，对接口RT影响最小。但需要考虑下限流数的设置，比如是针对单台网关、还是整个网关集群，如果是整个集群的话，需要考虑到网关缩容、扩容时修改对应的限流数。</li><li>分布式。分布式的就需要一个存储节点维护当前接口的调用数，比如redis、sentinel等，这种方式由于涉及到远程调用，会有些性能损耗，另外也需要考虑到存储挂掉的问题，比如redis如果挂掉，网关需要考虑降级方案，是降级到本地限流，还是直接将限流功能本身降级掉。</li></ul><p>另外还有不同的策略:简单计数、令牌桶等，大部分场景下其实简单计数已经够用了，但如果需要支持突发流量等场景时，可以采用令牌桶等方案。还需要考虑根据什么限流，比如是IP、接口、用户维度、还是请求参数中的某些值，这里可以采用表达式，相对比较灵活。</p><h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a><strong>稳定性</strong></h2><p>稳定性是网关非常重要的一环，监控、告警需要做的很完善才可以，比如接口调用量、响应时间、异常、错误码、成功率等相关的监控告警，还有线程池相关的一些，比如活跃线程数、队列积压等，还有些系统层面的，比如CPU、内存、FullGC这些基本的。</p><p>网关是所有服务的入口，对于网关的稳定性的要求相对于其他服务会更高，最好能够一直稳定的运行，尽量少重启，但当新增功能、或者加日志排查问题时，不可避免的需要重新发布，因此可以参考zuul的方式，将所有的核心功能都基于不同的拦截器实现，拦截器的代码采用Groovy编写，存储到数据库中，支持动态加载、编译、运行，这样在出了问题的时候能够第一时间定位并解决，并且如果网关需要开发新功能，只需要增加新的拦截器，并动态添加到网关即可，不需要重新发布。</p><h2 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a><strong>熔断降级</strong></h2><p>熔断机制也是非常重要的一项。若某一个服务挂掉、接口响应严重超时等发生，则可能整个网关都被一个接口拖垮，因此需要增加熔断降级，当发生特定异常的时候，对接口降级由网关直接返回，可以基于Hystrix或者Resilience4j实现。</p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a><strong>日志</strong></h2><p>由于所有的请求都是由网关处理的，因此日志也需要相对比较完善，比如接口的耗时、请求方式、请求IP、请求参数、响应参数(注意脱敏)等，另外由于可能涉及到很多微服务，因此需要提供一个统一的traceId方便关联所有的日志，可以将这个traceId置于响应头中，方便排查问题。</p><h2 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a><strong>隔离</strong></h2><p>比如线程池、http连接池、redis等应用层面的隔离，另外也可以根据业务场景，将核心业务部署带单独的网关集群，与其他非核心业务隔离开。</p><h2 id="网关管控平台"><a href="#网关管控平台" class="headerlink" title="网关管控平台"></a><strong>网关管控平台</strong></h2><p>这块也是非常重要的一环，需要考虑好整个流程的用户体验，比如接入到网关的这个流程，能不能尽量简化、智能，比如如果是dubbo接口，我们可以通过到git仓库中获取源码、解析对应的类、方法，从而实现自动填充，尽量帮用户减少操作；另外接口一般是从测试-&gt;预发-&gt;线上，如果每次都要填写一遍表单会非常麻烦，我们能不能自动把这个事情做掉，另外如果网关部署到了多个可用区、甚至不同的国家，那这个时候，我们还需要接口数据同步功能，不然用户需要到每个后台都操作一遍，非常麻烦。</p><p>这块个人的建议是直接参考阿里云、aws等提供的网关服务即可，功能非常全面。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h2><p>其他还有些需要考虑到的点，比如接口mock，文档生成、sdk代码生成、错误码统一、服务治理相关的等，这里就不累述了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>目前的网关还是中心化的架构，所有的请求都需要走一次网关，因此当大促或者流量突增时，网关可能会成为性能的瓶颈，而且当网关接入的大量接口的时候，做好流量评估也不是一项容易的工作，每次大促前都需要跟业务方一起针对接口做压测，评估出大致的容量，并对网关进行扩容，而且网关是所有流量的入口，所有的请求都是由网关处理，要想准确的评估出容量很复杂。可以参考目前比较流行的ServiceMesh，采用去中心化的方案，将网关的逻辑下沉到sidecar中，sidecar和应用部署到同一个节点，并接管应用流入、流出的流量，这样大促时，只需要对相关的业务压测，并针对性扩容即可，另外升级也会更平滑，中心化的网关，即使灰度发布，但是理论上所有业务方的流量都会流入到新版本的网关，如果出了问题，会影响到所有的业务，但这种去中心化的方式，可以先针对非核心业务升级，观察一段时间没问题后，再全量推上线。另外ServiceMesh的方案，对于多语言支持也更友好。</p><p> 作者：aCoder2013<br> 链接：github.com/aCoder2013/blog/issues/35</p><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>gateway</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>压缩20M文件从30秒到1秒的优化过程</title>
    <link href="/2019/11/20/%E5%8E%8B%E7%BC%A920M%E6%96%87%E4%BB%B6%E4%BB%8E30%E7%A7%92%E5%88%B01%E7%A7%92%E7%9A%84%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B/"/>
    <url>/2019/11/20/%E5%8E%8B%E7%BC%A920M%E6%96%87%E4%BB%B6%E4%BB%8E30%E7%A7%92%E5%88%B01%E7%A7%92%E7%9A%84%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>文章来源公众号：<strong>IT牧场</strong></p></blockquote><p>有一个需求需要将前端传过来的10张照片，然后后端进行处理以后压缩成一个压缩包通过网络流传输出去。之前没有接触过用Java压缩文件的，所以就直接上网找了一个例子改了一下用了，改完以后也能使用，但是随着前端所传图片的大小越来越大的时候，耗费的时间也在急剧增加，最后测了一下压缩20M的文件竟然需要30秒的时间。压缩文件的代码如下。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">zipFileNoBuffer</span><span class="hljs-params">()</span> </span>&#123;    File zipFile = <span class="hljs-keyword">new</span> File(ZIP_FILE);    <span class="hljs-keyword">try</span> (ZipOutputStream zipOut = <span class="hljs-keyword">new</span> ZipOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(zipFile))) &#123;        <span class="hljs-comment">//开始时间</span>        <span class="hljs-keyword">long</span> beginTime = System.currentTimeMillis();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-keyword">try</span> (InputStream input = <span class="hljs-keyword">new</span> FileInputStream(JPG_FILE)) &#123;                zipOut.putNextEntry(<span class="hljs-keyword">new</span> ZipEntry(FILE_NAME + i));                <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;                <span class="hljs-keyword">while</span> ((temp = input.read()) != -<span class="hljs-number">1</span>) &#123;                    zipOut.write(temp);                &#125;            &#125;        &#125;        printInfo(beginTime);    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><p>这里找了一张2M大小的图片，并且循环十次进行测试。打印的结果如下，时间大概是30秒。</p><pre><code class="hljs css"><span class="hljs-selector-tag">fileSize</span><span class="hljs-selector-pseudo">:20M</span><span class="hljs-selector-tag">consum</span> <span class="hljs-selector-tag">time</span><span class="hljs-selector-pseudo">:29599</span></code></pre><h2 id="第一次优化过程-从30秒到2秒"><a href="#第一次优化过程-从30秒到2秒" class="headerlink" title="第一次优化过程-从30秒到2秒"></a>第一次优化过程-从30秒到2秒</h2><p>进行优化首先想到的是利用<strong>缓冲区</strong><code>BufferInputStream</code>。在<code>FileInputStream</code>中<code>read()</code>方法每次只读取一个字节。源码中也有说明。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Reads a byte of data from this input stream. This method blocks</span><span class="hljs-comment"> * if no input is yet available.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>     the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the</span><span class="hljs-comment"> *             file is reached.</span><span class="hljs-comment"> * <span class="hljs-doctag">@exception</span>  IOException  if an I/O error occurs.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;</code></pre><p>这是一个调用本地方法与原生操作系统进行交互，从磁盘中读取数据。每读取一个字节的数据就调用一次本地方法与操作系统交互，是非常耗时的。例如我们现在有30000个字节的数据，如果使用<code>FileInputStream</code>那么就需要调用30000次的本地方法来获取这些数据，而如果使用缓冲区的话（这里假设初始的缓冲区大小足够放下30000字节的数据）那么只需要调用一次就行。因为缓冲区在第一次调用<code>read()</code>方法的时候会直接从磁盘中将数据直接读取到内存中。随后再一个字节一个字节的慢慢返回。</p><blockquote><p><code>BufferedInputStream</code>内部封装了一个byte数组用于存放数据，默认大小是8192</p></blockquote><p>优化过后的代码如下</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">zipFileBuffer</span><span class="hljs-params">()</span> </span>&#123;    File zipFile = <span class="hljs-keyword">new</span> File(ZIP_FILE);    <span class="hljs-keyword">try</span> (ZipOutputStream zipOut = <span class="hljs-keyword">new</span> ZipOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(zipFile));            BufferedOutputStream bufferedOutputStream = <span class="hljs-keyword">new</span> BufferedOutputStream(zipOut)) &#123;        <span class="hljs-comment">//开始时间</span>        <span class="hljs-keyword">long</span> beginTime = System.currentTimeMillis();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-keyword">try</span> (BufferedInputStream bufferedInputStream = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(JPG_FILE))) &#123;                zipOut.putNextEntry(<span class="hljs-keyword">new</span> ZipEntry(FILE_NAME + i));                <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;                <span class="hljs-keyword">while</span> ((temp = bufferedInputStream.read()) != -<span class="hljs-number">1</span>) &#123;                    bufferedOutputStream.write(temp);                &#125;            &#125;        &#125;        printInfo(beginTime);    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><p>输出</p><pre><code class="hljs css"><span class="hljs-selector-tag">------Buffer</span><span class="hljs-selector-tag">fileSize</span><span class="hljs-selector-pseudo">:20M</span><span class="hljs-selector-tag">consum</span> <span class="hljs-selector-tag">time</span><span class="hljs-selector-pseudo">:1808</span></code></pre><p>可以看到相比较于第一次使用<code>FileInputStream</code>效率已经提升了许多了</p><h2 id="第二次优化过程-从2秒到1秒"><a href="#第二次优化过程-从2秒到1秒" class="headerlink" title="第二次优化过程-从2秒到1秒"></a>第二次优化过程-从2秒到1秒</h2><p>使用缓冲区<code>buffer</code>的话已经是满足了我的需求了，但是秉着学以致用的想法，就想着用NIO中知识进行优化一下。</p><h3 id="使用Channel"><a href="#使用Channel" class="headerlink" title="使用Channel"></a>使用Channel</h3><p>为什么要用<code>Channel</code>呢？因为在NIO中新出了<code>Channel</code>和<code>ByteBuffer</code>。正是因为它们的结构更加符合操作系统执行I/O的方式，所以其速度相比较于传统IO而言速度有了显著的提高。<code>Channel</code>就像一个包含着煤矿的矿藏，而<code>ByteBuffer</code>则是派送到矿藏的卡车。也就是说我们与数据的交互都是与<code>ByteBuffer</code>的交互。</p><p>在NIO中能够产生<code>FileChannel</code>的有三个类。分别是<code>FileInputStream</code>、<code>FileOutputStream</code>、以及既能读又能写的<code>RandomAccessFile</code>。</p><p>源码如下</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">zipFileChannel</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//开始时间</span>    <span class="hljs-keyword">long</span> beginTime = System.currentTimeMillis();    File zipFile = <span class="hljs-keyword">new</span> File(ZIP_FILE);    <span class="hljs-keyword">try</span> (ZipOutputStream zipOut = <span class="hljs-keyword">new</span> ZipOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(zipFile));            WritableByteChannel writableByteChannel = Channels.newChannel(zipOut)) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-keyword">try</span> (FileChannel fileChannel = <span class="hljs-keyword">new</span> FileInputStream(JPG_FILE).getChannel()) &#123;                zipOut.putNextEntry(<span class="hljs-keyword">new</span> ZipEntry(i + SUFFIX_FILE));                fileChannel.transferTo(<span class="hljs-number">0</span>, FILE_SIZE, writableByteChannel);            &#125;        &#125;        printInfo(beginTime);    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><p>我们可以看到这里并没有使用<code>ByteBuffer</code>进行数据传输，而是使用了<code>transferTo</code>的方法。这个方法是将两个通道进行直连。</p><pre><code class="hljs csharp">This method <span class="hljs-keyword">is</span> potentially much more efficient than a simple loop* that reads <span class="hljs-keyword">from</span> <span class="hljs-keyword">this</span> channel and writes to the target channel.  Many* operating systems can transfer bytes directly <span class="hljs-keyword">from</span> the filesystem cache* to the target channel without actually copying them.</code></pre><p>这是源码上的描述文字，大概意思就是使用<code>transferTo</code>的效率比循环一个<code>Channel</code>读取出来然后再循环写入另一个<code>Channel</code>好。操作系统能够直接传输字节从文件系统缓存到目标的<code>Channel</code>中，而不需要实际的<code>copy</code>阶段。</p><blockquote><p>copy阶段就是从内核空间转到用户空间的一个过程</p></blockquote><p>可以看到速度相比较使用缓冲区已经有了一些的提高。</p><pre><code class="hljs css"><span class="hljs-selector-tag">------Channel</span><span class="hljs-selector-tag">fileSize</span><span class="hljs-selector-pseudo">:20M</span><span class="hljs-selector-tag">consum</span> <span class="hljs-selector-tag">time</span><span class="hljs-selector-pseudo">:1416</span></code></pre><h4 id="内核空间和用户空间"><a href="#内核空间和用户空间" class="headerlink" title="内核空间和用户空间"></a>内核空间和用户空间</h4><p>那么为什么从内核空间转向用户空间这段过程会慢呢？首先我们需了解的是什么是内核空间和用户空间。在常用的操作系统中为了保护系统中的核心资源，于是将系统设计为四个区域，越往里权限越大，所以Ring0被称之为内核空间，用来访问一些关键性的资源。Ring3被称之为用户空间。</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/13146186-38f92e6466efaf60.jpg" srcset="/img/loading.gif" alt="img"></p><p>image</p><blockquote><p>用户态、内核态：线程处于内核空间称之为内核态，线程处于用户空间属于用户态</p></blockquote><p>那么我们如果此时应用程序（应用程序是都属于用户态的）需要访问核心资源怎么办呢？那就需要调用内核中所暴露出的接口用以调用，称之为<strong>系统调用</strong>。例如此时我们应用程序需要访问磁盘上的文件。此时应用程序就会调用系统调用的接口<code>open</code>方法，然后内核去访问磁盘中的文件，将文件内容返回给应用程序。大致的流程如下</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/13146186-53cc9499caddb485.jpg" srcset="/img/loading.gif" alt="img"></p><p>image</p><h4 id="直接缓冲区和非直接缓冲区"><a href="#直接缓冲区和非直接缓冲区" class="headerlink" title="直接缓冲区和非直接缓冲区"></a>直接缓冲区和非直接缓冲区</h4><p>既然我们要读取一个磁盘的文件，要废这么大的周折。有没有什么简单的方法能够使我们的应用直接操作磁盘文件，不需要内核进行中转呢？有，那就是建立直接缓冲区了。</p><ul><li><p>非直接缓冲区：非直接缓冲区就是我们上面所讲内核态作为中间人，每次都需要内核在中间作为中转。</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/13146186-6bbfb5446221cb2d.jpg" srcset="/img/loading.gif" alt="img"></p><p>image</p></li><li><p>直接缓冲区：直接缓冲区不需要内核空间作为中转copy数据，而是直接在物理内存申请一块空间，这块空间映射到内核地址空间和用户地址空间，应用程序与磁盘之间数据的存取通过这块直接申请的物理内存进行交互。</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/13146186-92211d2b9a85215e.jpg" srcset="/img/loading.gif" alt="img"></p><p>image</p></li></ul><p>既然直接缓冲区那么快，我们为什么不都用直接缓冲区呢？其实直接缓冲区有以下的缺点。直接缓冲区的缺点：</p><ol><li>不安全</li><li>消耗更多，因为它不是在JVM中直接开辟空间。这部分内存的回收只能依赖于垃圾回收机制，垃圾什么时候回收不受我们控制。</li><li>数据写入物理内存缓冲区中，程序就丧失了对这些数据的管理，即什么时候这些数据被最终写入从磁盘只能由操作系统来决定，应用程序无法再干涉。</li></ol><blockquote><p>综上所述，所以我们使用<code>transferTo</code>方法就是直接开辟了一段直接缓冲区。所以性能相比而言提高了许多</p></blockquote><h3 id="使用内存映射文件"><a href="#使用内存映射文件" class="headerlink" title="使用内存映射文件"></a>使用内存映射文件</h3><p>NIO中新出的另一个特性就是内存映射文件，内存映射文件为什么速度快呢？其实原因和上面所讲的一样，也是在内存中开辟了一段直接缓冲区。与数据直接作交互。源码如下</p><pre><code class="hljs java"><span class="hljs-comment">//Version 4 使用Map映射文件</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">zipFileMap</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//开始时间</span>    <span class="hljs-keyword">long</span> beginTime = System.currentTimeMillis();    File zipFile = <span class="hljs-keyword">new</span> File(ZIP_FILE);    <span class="hljs-keyword">try</span> (ZipOutputStream zipOut = <span class="hljs-keyword">new</span> ZipOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(zipFile));            WritableByteChannel writableByteChannel = Channels.newChannel(zipOut)) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            zipOut.putNextEntry(<span class="hljs-keyword">new</span> ZipEntry(i + SUFFIX_FILE));            <span class="hljs-comment">//内存中的映射文件</span>            MappedByteBuffer mappedByteBuffer = <span class="hljs-keyword">new</span> RandomAccessFile(JPG_FILE_PATH, <span class="hljs-string">"r"</span>).getChannel()                    .map(FileChannel.MapMode.READ_ONLY, <span class="hljs-number">0</span>, FILE_SIZE);            writableByteChannel.write(mappedByteBuffer);        &#125;        printInfo(beginTime);    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        e.printStackTrace();    &#125;&#125;</code></pre><p>打印如下</p><pre><code class="hljs css"><span class="hljs-selector-tag">---------Map</span><span class="hljs-selector-tag">fileSize</span><span class="hljs-selector-pseudo">:20M</span><span class="hljs-selector-tag">consum</span> <span class="hljs-selector-tag">time</span><span class="hljs-selector-pseudo">:1305</span></code></pre><p>可以看到速度和使用Channel的速度差不多的。</p><h3 id="使用Pipe"><a href="#使用Pipe" class="headerlink" title="使用Pipe"></a>使用Pipe</h3><p>Java NIO 管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。其中source通道用于读取数据，sink通道用于写入数据。可以看到源码中的介绍，大概意思就是写入线程会阻塞至有读线程从通道中读取数据。如果没有数据可读，读线程也会阻塞至写线程写入数据。直至通道关闭。</p><pre><code class="hljs ruby">Whether <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> a thread writing bytes to a pipe will block <span class="hljs-keyword">until</span> anotherthread reads those bytes</code></pre><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/13146186-3fbae68c65487c14.jpg" srcset="/img/loading.gif" alt="img"></p><p>image</p><p>我想要的效果是这样的。源码如下</p><pre><code class="hljs java"><span class="hljs-comment">//Version 5 使用Pip</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">zipFilePip</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">long</span> beginTime = System.currentTimeMillis();    <span class="hljs-keyword">try</span>(WritableByteChannel out = Channels.newChannel(<span class="hljs-keyword">new</span> FileOutputStream(ZIP_FILE))) &#123;        Pipe pipe = Pipe.open();        <span class="hljs-comment">//异步任务</span>        CompletableFuture.runAsync(()-&gt;runTask(pipe));        <span class="hljs-comment">//获取读通道</span>        ReadableByteChannel readableByteChannel = pipe.source();        ByteBuffer buffer = ByteBuffer.allocate(((<span class="hljs-keyword">int</span>) FILE_SIZE)*<span class="hljs-number">10</span>);        <span class="hljs-keyword">while</span> (readableByteChannel.read(buffer)&gt;= <span class="hljs-number">0</span>) &#123;            buffer.flip();            out.write(buffer);            buffer.clear();        &#125;    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;        e.printStackTrace();    &#125;    printInfo(beginTime);&#125;<span class="hljs-comment">//异步任务</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runTask</span><span class="hljs-params">(Pipe pipe)</span> </span>&#123;    <span class="hljs-keyword">try</span>(ZipOutputStream zos = <span class="hljs-keyword">new</span> ZipOutputStream(Channels.newOutputStream(pipe.sink()));            WritableByteChannel out = Channels.newChannel(zos)) &#123;        System.out.println(<span class="hljs-string">"Begin"</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            zos.putNextEntry(<span class="hljs-keyword">new</span> ZipEntry(i+SUFFIX_FILE));            FileChannel jpgChannel = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">new</span> File(JPG_FILE_PATH)).getChannel();            jpgChannel.transferTo(<span class="hljs-number">0</span>, FILE_SIZE, out);            jpgChannel.close();        &#125;    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;        e.printStackTrace();    &#125;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>生活处处都需要学习，有时候只是一个简单的优化，可以让你深入学习到各种不同的知识。所以在学习中要不求甚解，不仅要知道这个知识也要了解为什么要这么做。</li><li>知行合一：学习完一个知识要尽量应用一遍。这样才能记得牢靠。</li></ul><h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fmodouxiansheng%2FDoraemon" target="_blank" rel="noopener">源码地址</a></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.jianshu.com/p/f90866dcbffc" target="_blank" rel="noopener">https://www.jianshu.com/p/f90866dcbffc</a></li><li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fjuejin.im%2Fpost%2F5af942c6f265da0b7026050c" target="_blank" rel="noopener">https://juejin.im/post/5af942c6f265da0b7026050c</a></li><li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Ftime.geekbang.org%2Fcolumn%2Farticle%2F90109" target="_blank" rel="noopener">趣谈Linux操作系统</a></li><li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fmy.oschina.net%2FhappyBKs%2Fblog%2F1592329" target="_blank" rel="noopener">JAVA NIO 直接缓冲区和非直接缓冲区</a></li></ul><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee-20200407103256742.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重温乔布斯最经典演讲：求知若饥 虚心若愚</title>
    <link href="/2019/11/04/%E9%87%8D%E6%B8%A9%E4%B9%94%E5%B8%83%E6%96%AF%E6%9C%80%E7%BB%8F%E5%85%B8%E6%BC%94%E8%AE%B2%EF%BC%9A%E6%B1%82%E7%9F%A5%E8%8B%A5%E9%A5%A5-%E8%99%9A%E5%BF%83%E8%8B%A5%E6%84%9A/"/>
    <url>/2019/11/04/%E9%87%8D%E6%B8%A9%E4%B9%94%E5%B8%83%E6%96%AF%E6%9C%80%E7%BB%8F%E5%85%B8%E6%BC%94%E8%AE%B2%EF%BC%9A%E6%B1%82%E7%9F%A5%E8%8B%A5%E9%A5%A5-%E8%99%9A%E5%BF%83%E8%8B%A5%E6%84%9A/</url>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymmi8zu7j30ev0ghq33.jpg" srcset="/img/loading.gif" alt="Jobs"></p><p>　　Thank you. I am honored to be with you today at your commencement from one of the finest universities in the world. Truth be told, I never graduated from college. This is the closest I’ve ever gotten to a college graduation. Today I want to tell you three stories from my life. That’s it. No big deal. Just three stories.</p><p>　　很荣幸和大家一道参加这所世界上最好的一座大学的毕业典礼。我大学没毕业，说实话，这是我第一次离大学毕业典礼这么近。今天我想给大家讲三个我自己的故事，不讲别的，也不讲大道理，就讲三个故事。</p><p>　　The first story is about connecting the dots. I dropped out of Reed College after the first 6 months, but then stayed around as a drop-in for another 18 months or so before I really quit. So why did I drop out?</p><p>　　第一个故事讲的是点与点之间的关系。我在里德学院(Reed College)只读了六个月就退学了，此后便在学校里旁听，又过了大约一年半，我彻底离开。那么，我为什么退学呢?</p><p>　　It started before I was born. My biological mother was a young, unwed college graduate student, and she decided to put me up for adoption. She felt very strongly that I should be adopted by college graduates, so everything was all set for me to be adopted at birth by a lawyer and his wife. Except that when I popped out they decided at the last minute that they really wanted a girl. So my parents, who were on a waiting list, got a call in the middle of the night asking: “We have an unexpected baby boy; do you want him?” They said: “Of course.” My biological mother later found out that my mother had never graduated from college and that my father had never graduated from high school. She refused to sign the final adoption papers. She only relented a few months later when my parents promised that I would someday go to college.</p><p>　　这得从我出生前讲起。我的生母是一名年轻的未婚在校研究生，她决定将我送给别人收养。她非常希望收养我的是有大学学历的人，所以把一切都安排好了，我一出生就交给一对律师夫妇收养。没想到我落地的霎那间，那对夫妇却决定收养一名女孩。就这样，我的养父母─当时他们还在登记册上排队等着呢─半夜三更接到一个电话: “我们这儿有一个没人要的男婴，你们要么?”“当然要”他们回答。但是，我的生母后来发现我的养母不是大学毕业生，我的养父甚至连中学都没有毕业，所以她拒绝在最后的收养文件上签字。不过，没过几个月她就心软了，因为我的养父母许诺日后一定送我上大学。</p><p>　　And 17 years later I did go to college. But I naively chose a college that was almost as expensive as Stanford, and all of my working-class parents’ savings were being spent on my college tuition. After six months, I couldn’t see the value in it. I had no idea what I wanted to do with my life and no idea how college was going to help me figure it out. And here I was spending all of the money my parents had saved their entire life. So I decided to drop out and trust that it would all work out OK. It was pretty scary at the time, but looking back it was one of the best decisions I ever made. The minute I dropped out I could stop taking the required classes that didn’t interest me, and begin dropping in on the ones that looked interesting。It wasn’t all romantic. I didn’t have a dorm room, so I slept on the floor in friends’ rooms, I returned coke bottles for the 5? deposits to buy food with, and I would walk the 7 miles across town every Sunday night to get one good meal a week at the Hare Krishna temple. I loved it. And much of what I stumbled into by following my curiosity and intuition turned out to be priceless later on. Let me give you one example:</p><p>　　17 年后，我真的进了大学。当时我很天真，选了一所学费几乎和斯坦福大学一样昂贵的学校，当工人的养父母倾其所有的积蓄为我支付了大学学费。读了六个月后，我却看不出上学有什么意义。我既不知道自己这一生想干什么，也不知道大学是否能够帮我弄明白自己想干什么。这时，我就要花光父母一辈子节省下来的钱了。所以，我决定退学，并且坚信日后会证明我这样做是对的。当年做出这个决定时心里直打鼓，但现在回想起来，这还真是我有生以来做出的最好的决定之一。从退学那一刻起，我就可以不再选那些我毫无兴趣的必修课，开始旁听一些看上去有意思的课。那些日子一点儿都不浪漫。我没有宿舍，只能睡在朋友房间的地板上。我去退还可乐瓶，用那五分钱的押金来买吃的。每个星期天晚上我都要走七英里，到城那头的黑尔-科里施纳礼拜堂去，吃每周才能享用一次的美餐。我喜欢这样。我凭著好奇心和直觉所干的这些事情，有许多后来都证明是无价之宝。我给大家举个例子:</p><p>　　Reed College at that time offered perhaps the best calligraphy instruction in the country. Throughout the campus every poster, every label on every drawer, was beautifully hand calligraphed. Because I had dropped out and didn’t have to take the normal classes, I decided to take a calligraphy class to learn how to do this. I learned about serif and san serif typefaces, about varying the amount of space between different letter combinations, about what makes great typography great. It was beautiful, historical, artistically subtle in a way that science can’t capture, and I found it fascinating.</p><p>　　当时，里德学院的书法课大概是全国最好的。校园里所有的公告栏和每个抽屉标签上的字都写得非常漂亮。当时我已经退学，不用正常上课，所以我决定选一门书法课，学学怎么写好字。我学习写带短截线和不带短截线的印刷字体，根据不同字母组合调整其间距，以及怎样把版式调整得好上加好。这门课太棒了，既有历史价值，又有艺术造诣，这一点科学就做不到，而我觉得它妙不可言。</p><p>　　None of this had even a hope of any practical application in my life. But ten years later, when we were designing the first Macintosh computer, it all came back to me. And we designed it all into the Mac. It was the first computer with beautiful typography. If I had never dropped in on that single course in college, the Mac would have never had multiple typefaces or proportionally spaced fonts. And since Windows just copied the Mac, its likely that no personal computer would have them. If I had never dropped out, I would have never dropped in on this calligraphy class, and personal computers might not have the wonderful typography that they do. Of course it was impossible to connect the dots looking forward when I was in college. But it was very, very clear looking backwards ten years later.</p><p>　　当时我并不指望书法在以后的生活中能有什么实用价值。但是，十年之后，我们在设计第一台 Macintosh 计算机时，它一下子浮现在我眼前。于是，我们把这些东西全都设计进了计算机中。这是第一台有这么漂亮的文字版式的计算机。要不是我当初在大学里偶然选了这么一门课，Macintosh 计算机绝不会有那么多种印刷字体或间距安排合理的字号。要不是 Windows 照搬了 Macintosh，个人电脑可能不会有这些字体和字号。要不是退了学，我决不会碰巧选了这门书法课，个人电脑也可能不会有现在这些漂亮的版式了。当然，我在大学里不可能从这一点上看到它与将来的关系。十年之后再回头看，两者之间的关系就非常、非常清楚了。</p><p>　　Again, you can’t connect the dots looking forward; you can only connect them looking backwards. So you have to trust that the dots will somehow connect in your future. You have to trust in something — your gut, destiny, life, karma, whatever. This approach has never let me down, and it has made all the difference in my life.</p><p>　　你们同样不可能从现在这个点上看到将来;只有回头看时，才会发现它们之间的关系。所以，要相信这些点迟早会连接到一起。你们必须信赖某些东西─直觉、归宿、生命，还有业力，等等。这样做从来没有让我的希望落空过，而且还彻底改变了我的生活。</p><p>　　My second story is about love and loss. I was lucky — I found what I loved to do early in life. Woz and I started Apple in my parents garage when I was 20. We worked hard, and in 10 years Apple had grown from just the two of us in a garage into a $2 billion company with over 4000 employees. We had just released our finest creation — the Macintosh — a year earlier, and I had just turned 30. And then I got fired. How can you get fired from a company you started? Well, as Apple grew we hired someone who I thought was very talented to run the company with me, and for the first year or so things went well. But then our visions of the future began to diverge and eventually we had a falling out. When we did, our Board of Directors sided with him. So at 30 I was out. And very publicly out. What had been the focus of my entire adult life was gone, and it was devastating.</p><p>　　我的第二个故事是关于好恶与得失。幸运的是，我在很小的时候就发现自己喜欢做什么。我在 20 岁时和沃兹在我父母的车库里办起了苹果公司。我们干得很卖力，十年后，苹果公司就从车库里我们两个人发展成为一个拥有 20 亿元资产、4,000 名员工的大企业。那时，我们刚刚推出了我们最好的产品─ Macintosh 电脑─那是在第 9 年，我刚满 30 岁。可后来，我被解雇了。你怎么会被自己办的公司解雇呢?是这样，随著苹果公司越做越大，我们聘了一位我认为非常有才华的人与我一道管理公司。在开始的一年多里，一切都很顺利。可是，随后我俩对公司前景的看法开始出现分歧，最后我俩反目了。这时，董事会站在了他那一边，所以在 30 岁那年，我离开了公司，而且这件事闹得满城风雨。我成年后的整个生活重心都没有了，这使我心力交瘁。</p><p>　　I really didn’t know what to do for a few months. I felt that I had let the previous generation of entrepreneurs down - that I had dropped the baton as it was being passed to me. I met with David Packard and Bob Noyce and tried to apologize for screwing up so badly. I was a very public failure, and I even thought about running away from the valley. But something slowly began to dawn on me — I still loved what I did. The turn of events at Apple had not changed that one bit. I had been rejected, but I was still in love. And so I decided to start over.</p><p>　　一连几个月，我真的不知道应该怎么办。我感到自己给老一代的创业者丢了脸─因为我扔掉了交到自己手里的接力棒。我去见了戴维帕卡德和鲍勃.诺伊斯，想为把事情搞得这么糟糕说声道歉。这次失败弄得沸沸扬扬的，我甚至想过逃离硅谷。但是，渐渐地，我开始有了一个想法─我仍然热爱我过去做的一切。在苹果公司发生的这些风波丝毫没有改变这一点。我虽然被拒之门外，但我仍然深爱我的事业。于是，我决定从头开始。</p><p>　　I didn’t see it then, but it turned out that getting fired from Apple was the best thing that could have ever happened to me. The heaviness of being successful was replaced by the lightness of being a beginner again, less sure about everything. It freed me to enter one of the most creative periods of my life.</p><p>　　虽然当时我并没有意识到，但事实证明，被苹果公司炒鱿鱼是我一生中碰到的最好的事情。尽管前景未卜，但从头开始的轻松感取代了保持成功的沉重感。这使我进入了一生中最富有创造力的时期之一。</p><p>　　During the next five years, I started a company named NeXT, another company named Pixar, and fell in love with an amazing woman who would become my wife. Pixar went on to create the worlds first computer animated feature film, Toy Story, and is now the most successful animation studio in the world. In a remarkable turn of events, Apple bought NeXT, I retuned to Apple, and the technology we developed at NeXT is at the heart of Apple’s current renaissance. And Laurene and I have a wonderful family together.</p><p>　　在此后的五年里，我开了一家名叫 NeXT 的公司和一家叫皮克斯的公司，我还爱上一位了不起的女人，后来娶了她。皮克斯公司推出了世界上第一部用电脑制作的动画片《玩具总动员》(Toy Story)，它现在是全球最成功的动画制作室。世道轮回，苹果公司买下 NeXT 后，我又回到了苹果公司，我们在 NeXT 公司开发的技术成了苹果公司这次重新崛起的核心。我和劳伦娜(Laurene)也建立了美满的家庭。</p><p>　　I’m pretty sure none of this would have happened if I hadn’t been fired from Apple. It was awful tasting medicine, but I guess the patient needed it. Sometimes life hits you in the head with a brick. Don’t lose faith. I’m convinced that the only thing that kept me going was that I loved what I did. You’ve got to find what you love. And that is as true for your work as it is for your lovers. Your work is going to fill a large part of your life, and the only way to be truly satisfied is to do what you believe is great work. And the only way to do great work is to love what you do. If you haven’t found it yet, keep looking. Don’t settle. As with all matters of the heart, you’ll know when you find it. And, like any great relationship, it just gets better and better as the years roll on. So keep looking until you find it. Don’t settle.</p><p>　　我确信，如果不是被苹果公司解雇，这一切决不可能发生。这是一剂苦药，可我认为苦药利于病。有时生活会当头给你一棒，但不要灰心。我坚信让我一往无前的唯一力量就是我热爱我所做的一切。所以，一定得知道自己喜欢什么，选择爱人时如此，选择工作时同样如此。工作将是生活中的一大部分，让自己真正满意的唯一办法，是做自己认为是有意义的工作;做有意义的工作的唯一办法，是热爱自己的工作。你们如果还没有发现自己喜欢什么，那就不断地去寻找，不要急于做出决定。就像一切要凭着感觉去做的事情一样，一旦找到了自己喜欢的事，感觉就会告诉你。就像任何一种美妙的东西，历久弥新。所以说，要不断地寻找，直到找到自己喜欢的东西。不要半途而废。</p><p>　　My third story is about death. When I was 17, I read a quote that went something like: “If you live each day as if it was your last, someday you’ll most certainly be right.” It made an impression on me, and since then, for the past 33 years, I have looked in the mirror every morning and asked myself: “If today were the last day of my life, would I want to do what I am about to do today?” And whenever the answer has been “No” for too many days in a row, I know I need to change something.</p><p>　　我的第三个故事与死亡有关。17 岁那年，我读到过这样一段话，大意是:“如果把每一天都当作生命的最后一天，总有一天你会如愿以偿。”我记住了这句话，从那时起，33 年过去了，我每天早晨都对着镜子自问: “假如今天是生命的最后一天，我还会去做今天要做的事吗?”如果一连许多天我的回答都是“不”，我知道自己应该有所改变了。</p><p>　　Remembering that I’ll be dead soon is the most important tool I’ve ever encountered to help me make the big choices in life. Because almost everything — all external expectations, all pride, all fear of embarrassment or failure - these things just fall away in the face of death, leaving only what is truly important. Remembering that you are going to die is the best way I know to avoid the trap of thinking you have something to lose. You are already naked. There is no reason not to follow your heart.</p><p>　　让我能够做出人生重大抉择的最主要办法是，记住生命随时都有可能结束。因为几乎所有的东西─所有对自身之外的希求、所有的尊严、所有对困窘和失败的恐惧─在死亡来临时都将不复存在，只剩下真正重要的东西。记住自己随时都会死去，这是我所知道的防止患得患失的最好方法。你已经一无所有了，还有什么理由不跟着自己的感觉走呢。</p><p>　　About a year ago I was diagnosed with cancer. I had a scan at 7:30 in the morning, and it clearly showed a tumor on my pancreas. I didn’t even know what a pancreas was. The doctors told me this was almost certainly a type of cancer that is incurable, and that I should expect to live no longer than three to six months. My doctor advised me to go home and get my affairs in order, which is doctor’s code for prepare to die. It means to try to tell your kids everything you thought you’d have the next 10 years to tell them in just a few months. It means to make sure everything is buttoned up so that it will be as easy as possible for your family. It means to say your goodbyes. 　　</p><p>　　大约一年前，我被诊断患了癌症。那天早上七点半，我做了一次扫描检查，结果清楚地表明我的胰腺上长了一个瘤子，可那时我连胰腺是什么还不知道呢!医生告诉我说，几乎可以确诊这是一种无法治愈的恶性肿瘤，我最多还能活 3 到 6 个月。医生建议我回去把一切都安排好，其实这是在暗示“准备后事”。也就是说，把今后十年要跟孩子们说的事情在这几个月内嘱咐完;也就是说，把一切都安排妥当，尽可能不给家人留麻烦;也就是说，去跟大家诀别。</p><p>　　I lived with that diagnosis all day. Later that evening I had a biopsy, where they stuck an endoscope down my throat, through my stomach and into my intestines, put a needle into my pancreas and got a few cells from the tumor. I was sedated, but my wife, who was there, told me that when they viewed the cells under a microscope the doctors started crying because it turned out to be a very rare form of pancreatic cancer that is curable with surgery. I had the surgery and I’m fine now.</p><p>　　那一整天里，我的脑子一直没离开这个诊断。到了晚上，我做了一次组织切片检查，他们把一个内窥镜通过喉咙穿过我的胃进入肠子，用针头在胰腺的瘤子上取了一些细胞组织。当时我用了麻醉剂，陪在一旁的妻子后来告诉我，医生在显微镜里看了细胞之后叫了起来，原来这是一种少见的可以通过外科手术治愈的恶性肿瘤。我做了手术，现在好了。</p><p>　　This was the closest I’ve been to facing death, and I hope its the closest I get for a few more decades. Having lived through it, I can now say this to you with a bit more certainty than when death was a useful but purely intellectual concept:No one wants to die. Even people who want to go to heaven don’t want to die to get there. And yet death is the destination we all share. No one has ever escaped it. And that is as it should be, because Death is very likely the single best invention of Life. It is Life’s change agent. It clears out the old to make way for the new. Right now the new is you, but someday not too long from now, you will gradually become the old and be cleared away. Sorry to be so dramatic, but it is quite true.</p><p>　　这是我和死神离得最近的一次，我希望也是今后几十年里最近的一次。有了这次经历之后，现在我可以更加实在地和你们谈论死亡，而不是纯粹纸上谈兵，那就是: 谁都不愿意死。就是那些想进天堂的人也不愿意死后再进。然而，死亡是我们共同的归宿，没人能摆脱。我们注定会死，因为死亡很可能是生命最好的一项发明。它推进生命的变迁，旧的不去，新的不来。现在，你们就是新的，但在不久的将来，你们也会逐渐成为旧的，也会被淘汰。对不起，话说得太过分了，不过这是千真万确的。</p><p>　　Your time is limited, so don’t waste it living someone else’s life. Don’t be trapped by dogma — which is living with the results of other people’s thinking. Don’t let the noise of others’ opinions drown out your own inner voice. And most important, have the courage to follow your heart and intuition. They somehow already know what you truly want to become. Everything else is secondary.</p><p>　　你们的时间都有限，所以不要按照别人的意愿去活，这是浪费时间。不要囿于成见，那是在按照别人设想的结果而活。不要让别人观点的聒噪声淹没自己的心声。最主要的是，要有跟着自己感觉和直觉走的勇气。无论如何，感觉和直觉早就知道你到底想成为什么样的人，其他都是次要的。</p><p>　　When I was young, there was an amazing publication called The Whole Earth Catalog, which was one of the bibles of my generation. It was created by a fellow named Stewart Brand not far from here in Menlo Park, and he brought it to life with his poetic touch. This was in the late 1960’s, before personal computers and desktop publishing, so it was all made with typewriters, scissors, and polaroid cameras. It was sort of like Google in paperback form, 35 years before Google came along: it was idealistic, and overflowing with neat tools and great notions.</p><p>　　我年轻时有一本非常好的刊物，叫《全球概览》，这是我那代人的宝书之一，创办人名叫斯图尔特布兰德，就住在离这儿不远的门洛帕克市。他用诗一般的语言把刊物办得生动活泼。那是 20 世纪 60 年代末，还没有个人电脑和桌面印刷系统，全靠打字机、剪刀和宝丽莱照相机。它就像一种纸质的 Google，却比 Google 早问世了 35 年。这份刊物太完美了，查阅手段齐备、构思不凡。</p><p>　　Stewart and his team put out several issues of The Whole Earth Catalog, and then when it had run its course, they put out a final issue. It was the mid-1970s, and I was your age. On the back cover of their final issue was a photograph of an early morning country road, the kind you might find yourself hitchhiking on if you were so adventurous. Beneath it were the words: “Stay Hungry. Stay Foolish.” It was their farewell message as they signed off. Stay Hungry. Stay Foolish. And I have always wished that for myself.</p><p>　　斯图尔特和他的同事们出了好几期《全球概览》，到最后办不下去时，他们出了最后一期。那是 20 世纪 70 年代中期，我也就是你们现在的年纪。最后一期的封底上是一张清晨乡间小路的照片，就是那种爱冒险的人等在那儿搭便车的那种小路。照片下面写道: 好学若饥、谦卑若愚。那是他们停刊前的告别辞。求知若渴，大智若愚。这也是我一直想做到的。</p><p>　　And now, as you graduate to begin anew, I wish that for you. Stay Hungry. Stay Foolish.</p><p>　　眼下正值诸位大学毕业、开始新生活之际，我同样愿大家：好学若饥、谦卑若愚。</p><p>视频链接</p><p><a href="https://v.qq.com/x/page/k0550leuhtu.html?new=1" target="_blank" rel="noopener">https://v.qq.com/x/page/k0550leuhtu.html?new=1</a></p><hr><p><strong>乔布斯英文名句</strong></p><ol><li><p>“a leader and a follower innovation distinguishes between.”</p><p>“领袖和跟风者的区别就在于创新。”</p></li><li><p>“become a prominent pronoun, some people aren’t used to an environment quality.”<br>“成为卓越的代名词，很多人并不能适合需要杰出素质的环境。”</p></li><li><p>“the only way to accomplish something weiye is deeply love own enterprise. If you haven’t been able to find let oneself love career, continue to search, don’t give up. Follow your heart, someday you’ll find it.”</p><p>“成就一番伟业的唯一途径就是热爱自己的事业。如果你还没能找到让自己热爱的事业，继续寻找，不要放弃。跟随自己的心，总有一天你会找到的。”</p></li><li><p>“not everyone needs grew their own food, also not everyone needs doing their own wear clothes, we speak the language, use the others invention of mathematical invention others… we have been using someone else’s results. Use human existing Experience and knowledge to make inventions is a very great things. “</p><p>“并不是每个人都需要种植自己的粮食，也不是每个人都需要做自己穿的衣服，我们说着别人发明的语言，使用别人发明的数学…我们一直在使用别人的成果。使用人类的已有经验和知识来进行发明创造是一件很了不起的事情。”</p></li><li><p>“there’s a phrase in Buddhism, ‘beginner’s mind. have a beginner’s mind is a wonderful thing.”</p><p>“佛教中有一句话：初学者的心态；拥有初学者的心态是件了不起的事情。”</p></li><li><p>“we think watching TV, when people’s brains basic stop work on your computer when you want to turn your brain.”</p><p>“我们认为看电视的时候，人的大脑基本停止工作，打开电脑的时候，大脑才开始运转。”</p></li></ol><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    
    <tags>
      
      <tag>Jobs</tag>
      
      <tag>Steve Jobs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins构建工具集成</title>
    <link href="/2019/11/03/Jenkins%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E9%9B%86%E6%88%90/"/>
    <url>/2019/11/03/Jenkins%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E9%9B%86%E6%88%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p>来源公众号： DevOps持续集成</p></blockquote><h2 id="1-集成maven"><a href="#1-集成maven" class="headerlink" title="1. 集成maven"></a>1. 集成maven</h2><h3 id="1-1-先决条件"><a href="#1-1-先决条件" class="headerlink" title="1.1 先决条件"></a>1.1 先决条件</h3><ul><li>JDK：在maven3.3 以上的版本需要JDK版本1.7+。内存：没有最低限制。</li><li>磁盘：1G+可用磁盘空间。操作系统：没有限制。</li><li>下载maven <a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">Download</a></li></ul><h3 id="1-2-安装maven"><a href="#1-2-安装maven" class="headerlink" title="1.2 安装maven"></a>1.2 安装maven</h3><pre><code class="hljs bash">tar zxf apache-maven-3.6.0-bin.tar.gz -C /usr/<span class="hljs-built_in">local</span>/<span class="hljs-comment">#设置全局变量（/etc/profile）</span><span class="hljs-built_in">export</span> MAVEN_HOME=/usr/<span class="hljs-built_in">local</span>/apache-maven-3.6.0<span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$MAVEN_HOME</span>/bin<span class="hljs-built_in">source</span> /etc/profile</code></pre><h3 id="1-3-Jenkins配置maven"><a href="#1-3-Jenkins配置maven" class="headerlink" title="1.3 Jenkins配置maven"></a>1.3 Jenkins配置maven</h3><ul><li><p>系统设置-&gt;全局工具配置 <img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymn3b3fwj30o007xweq.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>编写Jenkinsfile</p>  <pre><code class="hljs bash">node &#123;    stage (<span class="hljs-string">"build"</span>)&#123;        mavenHome = tool <span class="hljs-string">'M3'</span>        sh <span class="hljs-string">"<span class="hljs-variable">$&#123;mavenHome&#125;</span>/bin/mvn -v"</span>    &#125;&#125;</code></pre></li></ul><ul><li>构建测试 <img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymn49lvrj30o00e4my9.jpg" srcset="/img/loading.gif" alt="">到此jenkins集成maven就完成了。</li></ul><h3 id="1-4-maven常用命令"><a href="#1-4-maven常用命令" class="headerlink" title="1.4 maven常用命令"></a>1.4 maven常用命令</h3><pre><code class="hljs bash">clean install -DskipTestsclean package</code></pre><h2 id="2-集成Ant"><a href="#2-集成Ant" class="headerlink" title="2. 集成Ant"></a>2. 集成Ant</h2><h3 id="2-1-先决条件"><a href="#2-1-先决条件" class="headerlink" title="2.1 先决条件"></a>2.1 先决条件</h3><ul><li>下载：<a href="https://ant.apache.org/bindownload.cgi" target="_blank" rel="noopener">Download</a><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymn4sopmj30kw0413z4.jpg" srcset="/img/loading.gif" alt=""></li></ul><h3 id="2-2-安装ant"><a href="#2-2-安装ant" class="headerlink" title="2.2 安装ant"></a>2.2 安装ant</h3><pre><code class="hljs bash">tar zxf apache-ant-1.10.5-bin.tar.gz -C /usr/<span class="hljs-built_in">local</span>/<span class="hljs-comment">#添加全局变量（/etc/profile）</span><span class="hljs-built_in">export</span> ANT_HOME=/usr/<span class="hljs-built_in">local</span>/apache-ant-1.10.5<span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$MAVEN_HOME</span>/bin:<span class="hljs-variable">$ANT_HOME</span>/bin<span class="hljs-built_in">source</span> /etc/profile</code></pre><ul><li>测试 <img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymn644tjj30mw020jrn.jpg" srcset="/img/loading.gif" alt=""></li></ul><h3 id="2-3-Jenkins配置ant"><a href="#2-3-Jenkins配置ant" class="headerlink" title="2.3 Jenkins配置ant"></a>2.3 Jenkins配置ant</h3><ul><li><p>系统设置-&gt;全局工具配置</p></li><li><p>编写Jenkinsfile</p>  <pre><code class="hljs bash">node &#123;    stage (<span class="hljs-string">"build"</span>)&#123;        antHome = tool <span class="hljs-string">'ANT'</span>        sh <span class="hljs-string">"<span class="hljs-variable">$&#123;antHome&#125;</span>/bin/ant -version"</span>    &#125;&#125;</code></pre></li></ul><ul><li><p>构建测试</p><p> <img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymn730xij30m807rq3e.jpg" srcset="/img/loading.gif" alt=""> 到此ant的集成就完成了</p></li></ul><h3 id="2-4-Ant常用命令"><a href="#2-4-Ant常用命令" class="headerlink" title="2.4 Ant常用命令"></a>2.4 Ant常用命令</h3><p><code>ant -buildfile -f build.xml</code></p><h2 id="3-集成Gradle"><a href="#3-集成Gradle" class="headerlink" title="3. 集成Gradle"></a>3. 集成Gradle</h2><h3 id="3-1-先决条件"><a href="#3-1-先决条件" class="headerlink" title="3.1 先决条件"></a>3.1 先决条件</h3><p> <img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9ymn7mrf3j30gd062wey.jpg" srcset="/img/loading.gif" alt=""></p><ul><li>下载:<a href="https://downloads.gradle.org/distributions/gradle-5.3-bin.zip" target="_blank" rel="noopener">Download</a></li></ul><h3 id="3-2-安装Gradle"><a href="#3-2-安装Gradle" class="headerlink" title="3.2 安装Gradle"></a>3.2 安装Gradle</h3><pre><code class="hljs bash">unzip gradle-5.3-bin.zip -d /usr/<span class="hljs-built_in">local</span>/<span class="hljs-comment">#添加全局变量（/etc/profile）</span><span class="hljs-built_in">export</span> GRADLE_HOME=/usr/<span class="hljs-built_in">local</span>/gradle-5.3<span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>: <span class="hljs-variable">$GRADLE_HOME</span>/bin<span class="hljs-built_in">source</span> /etc/profile</code></pre><h3 id="3-3-Jenkins配置gradle"><a href="#3-3-Jenkins配置gradle" class="headerlink" title="3.3 Jenkins配置gradle"></a>3.3 Jenkins配置gradle</h3><ul><li><p>系统设置-&gt;全局工具配置</p></li><li><p>编写Jenkinsfile</p>  <pre><code class="hljs bash">node &#123;    stage (<span class="hljs-string">"gradlebuild"</span>)&#123;        gradleHome = tool <span class="hljs-string">'GRADLE'</span>        sh <span class="hljs-string">"<span class="hljs-variable">$&#123;gradleHome&#125;</span>/bin/gradle -v"</span>    &#125;&#125;</code></pre></li></ul><ul><li>构建测试 <img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymn82gi8j30l20cu74x.jpg" srcset="/img/loading.gif" alt="">到此jenkins配置gradle完成</li></ul><h3 id="3-4-Gradle常用命令"><a href="#3-4-Gradle常用命令" class="headerlink" title="3.4 Gradle常用命令"></a>3.4 Gradle常用命令</h3><ul><li>./gradlew -v 版本号，首次运行，没有gradle的要下载的哦。</li><li>./gradlew clean 删除HelloWord/app目录下的build文件夹</li><li>./gradlew build 检查依赖并编译打包</li><li>./gradlew assembleDebug 编译并打Debug包</li><li>./gradlew assembleRelease 编译并打Release的包</li><li>./gradlew installRelease Release模式打包并安装</li><li>./gradlew uninstallRelease 卸载Release模式包</li></ul><h2 id="4-集成NPM"><a href="#4-集成NPM" class="headerlink" title="4.集成NPM"></a>4.集成NPM</h2><h3 id="4-1-先决条件"><a href="#4-1-先决条件" class="headerlink" title="4.1 先决条件"></a>4.1 先决条件</h3><ul><li>下载<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Download</a></li></ul><h3 id="4-2-安装Node"><a href="#4-2-安装Node" class="headerlink" title="4.2 安装Node"></a>4.2 安装Node</h3><pre><code class="hljs bash">tar xf node-v10.15.3-linux-x64.tar.xz -C /usr/<span class="hljs-built_in">local</span>/<span class="hljs-comment">#添加全局变量（/etc/profile）</span><span class="hljs-built_in">export</span> NODE_HOME=/usr/<span class="hljs-built_in">local</span>/node-v10.15.3-linux-x64<span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>: <span class="hljs-variable">$NODE_HOME</span>/bin<span class="hljs-built_in">source</span> /etc/profile</code></pre><ul><li>测试</li></ul><h3 id="4-3-Jenkins配置Npm"><a href="#4-3-Jenkins配置Npm" class="headerlink" title="4.3 Jenkins配置Npm"></a>4.3 Jenkins配置Npm</h3><ul><li><p>在Jenkins全局工具配置中并没有node，可以直接通过Jenkinsfile定义使用。</p></li><li><p>Jenkinsfile</p>  <pre><code class="hljs bash">node &#123;    stage (<span class="hljs-string">"npmbuild"</span>)&#123;        sh <span class="hljs-string">""</span><span class="hljs-string">"</span><span class="hljs-string">           export npmHome=/usr/local/node-v10.15.3-linux-x64</span><span class="hljs-string">           export PATH=\$PATH:\$npmHome/bin</span><span class="hljs-string">           npm -v</span><span class="hljs-string">           "</span><span class="hljs-string">""</span>    &#125;&#125;</code></pre></li></ul><ul><li>构建测试</li></ul><h3 id="4-4-Npm常用构建命令"><a href="#4-4-Npm常用构建命令" class="headerlink" title="4.4 Npm常用构建命令"></a>4.4 Npm常用构建命令</h3><p><code>npm install &amp;&amp; npm run build</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymn8kwtuj30o00ajwf3.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Jenkins</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins用户权限授权管理</title>
    <link href="/2019/11/03/Jenkins%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E6%8E%88%E6%9D%83%E7%AE%A1%E7%90%86/"/>
    <url>/2019/11/03/Jenkins%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E6%8E%88%E6%9D%83%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>来源公众号： DevOps持续集成</p></blockquote><p><em>1.创建role</em></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymm1tit7j30u00g53zf.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymm2z33hj30u00eiwfg.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymm3wg6xj30u00l3js1.jpg" srcset="/img/loading.gif" alt=""></p><p><em>2.授权插件API</em></p><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><pre><code class="hljs powershell">method:POSTurl: http://demo.com:<span class="hljs-number">8080</span>/securityRealm/createAccountByAdmin<span class="hljs-keyword">data</span>: &#123;<span class="hljs-string">"username"</span>: userName, <span class="hljs-string">"password1"</span>: <span class="hljs-string">'123456'</span>, <span class="hljs-string">"password2"</span>: <span class="hljs-string">'123456'</span>, <span class="hljs-string">"fullname"</span> : userName,<span class="hljs-string">"email"</span> : userName + <span class="hljs-string">'@jenkins.com'</span>&#125;</code></pre><h3 id="用户授权插件"><a href="#用户授权插件" class="headerlink" title="用户授权插件"></a>用户授权插件</h3><pre><code>method:POSTurl:http://demo.com:8080/role-strategy/strategy/assignRoleroletype: globalRoles projectRolesdata : {&apos;type&apos;: &apos;globalRoles&apos;,&apos;roleName&apos;: roleName,&apos;sid&apos;: userName}</code></pre><h2 id="脚本内容-Python"><a href="#脚本内容-Python" class="headerlink" title="脚本内容(Python)"></a>脚本内容(Python)</h2><pre><code class="hljs python"><span class="hljs-comment">#coding:utf8</span><span class="hljs-comment">#用户授权脚本</span><span class="hljs-keyword">import</span> requests<span class="hljs-keyword">import</span> sys<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">auth</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>        self.Jenkins = &#123;<span class="hljs-string">"url"</span>:<span class="hljs-string">"http://deme.com:8080/role-strategy/strategy/assignRole"</span>,                         <span class="hljs-string">"passwd"</span>:<span class="hljs-string">"xxxxxxxxxxxx"</span>&#125;    <span class="hljs-comment">#创建用户</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Create</span><span class="hljs-params">(self,userName)</span>:</span>        uurl=<span class="hljs-string">"http://demo.com:8080/securityRealm/createAccountByAdmin"</span>        refdata = &#123;<span class="hljs-string">"username"</span>: userName,                   <span class="hljs-string">"password1"</span>: <span class="hljs-string">'123456'</span>,                   <span class="hljs-string">"password2"</span>: <span class="hljs-string">'123456'</span>,                   <span class="hljs-string">"fullname"</span> : userName,                   <span class="hljs-string">"email"</span> : userName + <span class="hljs-string">'@jenkins.com'</span>&#125;        response = requests.post(uurl,data=refdata,auth=(<span class="hljs-string">'admin'</span>,self.Jenkins[<span class="hljs-string">"passwd"</span>]))        <span class="hljs-comment">#print(response.status_code,response.text)</span>    <span class="hljs-comment">#授权</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Grant</span><span class="hljs-params">(self,roleType,roleName,userName)</span>:</span>        self.Create(userName)        <span class="hljs-keyword">if</span> roleType == <span class="hljs-string">"global"</span> :            data = &#123;<span class="hljs-string">'type'</span>: <span class="hljs-string">'globalRoles'</span>,<span class="hljs-string">'roleName'</span>: roleName,<span class="hljs-string">'sid'</span>: userName&#125;        <span class="hljs-keyword">elif</span> roleType == <span class="hljs-string">"project"</span> :            data = &#123;<span class="hljs-string">'type'</span>: <span class="hljs-string">'projectRoles'</span>,<span class="hljs-string">'roleName'</span>: roleName,<span class="hljs-string">'sid'</span>: userName&#125;        response = requests.post(self.Jenkins[<span class="hljs-string">"url"</span>],                                data=data,                                auth=(<span class="hljs-string">'admin'</span>, self.Jenkins[<span class="hljs-string">"passwd"</span>]))        print(response.status_code,response.text)        <span class="hljs-keyword">return</span> int(response.status_code)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    <span class="hljs-keyword">if</span>  sys.argv[<span class="hljs-number">1</span>] == <span class="hljs-string">"help"</span>:        print(<span class="hljs-string">"1. 添加用户到users.txt中，每行一个."</span>)        print(<span class="hljs-string">"2. python role.py  global globalName"</span>)        print(<span class="hljs-string">"3. python role.py  project projectName"</span>)    <span class="hljs-keyword">else</span>:        server = auth()        roleType = sys.argv[<span class="hljs-number">1</span>]        roleName = sys.argv[<span class="hljs-number">2</span>]        <span class="hljs-comment">#get users</span>        f = open(<span class="hljs-string">"users.txt"</span>,<span class="hljs-string">"r"</span>)        users = f.readlines()        f.close()        <span class="hljs-comment">#do grant</span>        <span class="hljs-keyword">for</span> user <span class="hljs-keyword">in</span> users :            result = server.Grant(roleType,roleName,user)            <span class="hljs-keyword">if</span> result &lt;=<span class="hljs-number">400</span> :                print(<span class="hljs-string">"---&gt;&#123;0&#125;--&gt;&#123;1&#125;--&gt;&#123;2&#125; ---&gt;Success!"</span>.format(user,roleType,roleName))            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">"---&gt;&#123;0&#125;--&gt;&#123;1&#125;--&gt;&#123;2&#125; ---&gt;Error!"</span>.format(user,roleType,roleName))</code></pre><p>users.txt</p><pre><code class="hljs tex">zhangsanlisiwangwu</code></pre><p><em>最后：创建一个jenkins参数化job来管理用户的授权。</em></p><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Jenkins</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins项目、视图、插件管理</title>
    <link href="/2019/11/03/Jenkins%E9%A1%B9%E7%9B%AE%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <url>/2019/11/03/Jenkins%E9%A1%B9%E7%9B%AE%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>来源公众号： DevOps持续集成</p></blockquote><h2 id="1-项目管理"><a href="#1-项目管理" class="headerlink" title="1. 项目管理"></a>1. 项目管理</h2><h3 id="1-1-命名规范"><a href="#1-1-命名规范" class="headerlink" title="1.1 命名规范"></a>1.1 命名规范</h3><ul><li>业务名称-应用名称-应用类型_环境类型： cxy-wlck-ui_TEST, 只有命名规范才方便管理项目。</li></ul><h3 id="1-2-新建项目"><a href="#1-2-新建项目" class="headerlink" title="1.2 新建项目"></a>1.2 新建项目</h3><ul><li><p>管理页面</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymqjv0iuj30o00e6dh5.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>设置构建历史 <img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymqksrhqj30o009jjrs.jpg" srcset="/img/loading.gif" alt="管理页面"></p></li><li><p>选择参数化构建 <img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymqmnw1pj30o00dp0t9.jpg" srcset="/img/loading.gif" alt="管理页面"></p></li><li><p>设置构建触发器 <img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymqn45u6j30o009qt9c.jpg" srcset="/img/loading.gif" alt="管理页面"></p></li><li><p>设置Jenkinsfile <img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymqnuhrwj30o00dp0t1.jpg" srcset="/img/loading.gif" alt="管理页面"></p></li><li><p>构建项目 <img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymqp4ydkj30o007et96.jpg" srcset="/img/loading.gif" alt="管理页面"></p></li><li><p>查看构建日志<img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymqpyesbj30o00ajmxv.jpg" srcset="/img/loading.gif" alt="管理页面"></p></li><li><p>调试Pipeline <img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymqqfr9mj30o00c9gme.jpg" srcset="/img/loading.gif" alt="管理页面"></p></li></ul><h3 id="1-3-删除-禁用项目"><a href="#1-3-删除-禁用项目" class="headerlink" title="1.3 删除/禁用项目"></a>1.3 删除/禁用项目</h3><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymqsivgdj30o00d20tz.jpg" srcset="/img/loading.gif" alt="管理页面"></p><h3 id="1-4-项目分类"><a href="#1-4-项目分类" class="headerlink" title="1.4 项目分类"></a>1.4 项目分类</h3><ul><li>以业务简称为名，创建工程文件夹。将同一个业务的工程全部放到同一个文件夹中。</li><li><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymqun77cj30o00gdtab.jpg" srcset="/img/loading.gif" alt="管理页面"></li><li>移动项目 <img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymqvkxikj30o009bdgk.jpg" srcset="/img/loading.gif" alt="管理页面"></li><li><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymqzfoxwj30o006dt90.jpg" srcset="/img/loading.gif" alt="管理页面"></li><li>外部 <img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymr0tgr3j30o004kq2z.jpg" srcset="/img/loading.gif" alt="管理页面"></li><li>内部 <img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymr1s9rvj30o007edg5.jpg" srcset="/img/loading.gif" alt="管理页面"></li></ul><h2 id="2-视图管理"><a href="#2-视图管理" class="headerlink" title="2. 视图管理"></a>2. 视图管理</h2><ul><li>默认会创建一个all视图里面存放所有的项目。</li></ul><h3 id="2-1-创建视图"><a href="#2-1-创建视图" class="headerlink" title="2.1 创建视图"></a>2.1 创建视图</h3><ul><li>凭据-&gt; 系统-&gt; 全局凭据</li><li><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymr31lv4j30o007rgly.jpg" srcset="/img/loading.gif" alt="管理页面"></li><li><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymr51wdtj30o00870t1.jpg" srcset="/img/loading.gif" alt="管理页面"></li><li><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymr7pr3qj30o00ivdgq.jpg" srcset="/img/loading.gif" alt="管理页面"></li><li><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymra3m95j30o005wq34.jpg" srcset="/img/loading.gif" alt="管理页面"></li></ul><h3 id="2-2-删除视图"><a href="#2-2-删除视图" class="headerlink" title="2.2 删除视图"></a>2.2 删除视图</h3><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymrb1gsvj30o006h74o.jpg" srcset="/img/loading.gif" alt="管理页面"></p><h3 id="2-3-更新视图"><a href="#2-3-更新视图" class="headerlink" title="2.3 更新视图"></a>2.3 更新视图</h3><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymrc2gcjj30o006vmxl.jpg" srcset="/img/loading.gif" alt="管理页面"></p><h2 id="3-插件管理"><a href="#3-插件管理" class="headerlink" title="3. 插件管理"></a>3. 插件管理</h2><ul><li>系统设置-&gt;插件管理。<br><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymrcwyspj30o0078mxq.jpg" srcset="/img/loading.gif" alt="管理页面"></li></ul><h3 id="3-1-安装插件"><a href="#3-1-安装插件" class="headerlink" title="3.1 安装插件"></a>3.1 安装插件</h3><ul><li>勾选要安装的插件，选择安装后不重启。（有些插件需要安装后重启）</li></ul><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymrev3rtj30o00gjta9.jpg" srcset="/img/loading.gif" alt="管理页面"></p><ul><li>安装<br><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymrft7ohj30o009uq3j.jpg" srcset="/img/loading.gif" alt="管理页面"></li></ul><h3 id="3-2-卸载插件"><a href="#3-2-卸载插件" class="headerlink" title="3.2 卸载插件"></a>3.2 卸载插件</h3><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymrgni6pj30o004gt8v.jpg" srcset="/img/loading.gif" alt="管理页面"></p><h3 id="3-3-上传插件"><a href="#3-3-上传插件" class="headerlink" title="3.3 上传插件"></a>3.3 上传插件</h3><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymrhlcdbj30o006lglu.jpg" srcset="/img/loading.gif" alt="管理页面"></p><h3 id="3-4-切换插件更新站点"><a href="#3-4-切换插件更新站点" class="headerlink" title="3.4 切换插件更新站点"></a>3.4 切换插件更新站点</h3><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymrjody2j30o004i0ss.jpg" srcset="/img/loading.gif" alt="管理页面"></p><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Jenkins</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins用户、凭据、权限管理</title>
    <link href="/2019/11/03/Jenkins%E7%94%A8%E6%88%B7%E3%80%81%E5%87%AD%E6%8D%AE%E3%80%81%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <url>/2019/11/03/Jenkins%E7%94%A8%E6%88%B7%E3%80%81%E5%87%AD%E6%8D%AE%E3%80%81%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>来源公众号： DevOps持续集成</p></blockquote><h2 id="1-用户管理"><a href="#1-用户管理" class="headerlink" title="1. 用户管理"></a>1. 用户管理</h2><ul><li><p>配置用户接入入口: 系统管理-&gt;全局安全配置。</p></li><li><p>默认使用的是Jenkins数据库存储。</p></li><li><p>可以选择集成LDAP服务或者是GItlab服务（需要安装插件后才会有）。</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymt45ftfj30o00bk0t1.jpg" srcset="/img/loading.gif" alt=""></p></li></ul><h3 id="1-1-查看用户"><a href="#1-1-查看用户" class="headerlink" title="1.1 查看用户"></a>1.1 查看用户</h3><ul><li>以使用Jenkins专有数据库为例，用户管理入口: 系统管理-&gt; 管理用户</li></ul><h3 id="1-2-创建用户"><a href="#1-2-创建用户" class="headerlink" title="1.2 创建用户"></a>1.2 创建用户</h3><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymt56ehoj30o00ahwes.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="1-3-删除用户"><a href="#1-3-删除用户" class="headerlink" title="1.3 删除用户"></a>1.3 删除用户</h3><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymt62pwkj30o007zdg0.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="1-4-更新用户"><a href="#1-4-更新用户" class="headerlink" title="1.4 更新用户"></a>1.4 更新用户</h3><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9ymt6wyxuj30o00hpq3n.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="2-凭据管理"><a href="#2-凭据管理" class="headerlink" title="2. 凭据管理"></a>2. 凭据管理</h2><ul><li>凭据可以用来存储需要密文保护的数据库密码、Gitlab密码信息。</li><li>凭据类型： <img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymt7ev35j30o004sgls.jpg" srcset="/img/loading.gif" alt=""></li></ul><h3 id="2-1-查看凭据"><a href="#2-1-查看凭据" class="headerlink" title="2.1 查看凭据"></a>2.1 查看凭据</h3><ul><li>凭据-&gt; 系统-&gt; 全局凭据</li><li></li></ul><h3 id="2-2-新建凭据"><a href="#2-2-新建凭据" class="headerlink" title="2.2 新建凭据"></a>2.2 新建凭据</h3><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymt8dvbzj30o0099glw.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="2-3-删除凭据"><a href="#2-3-删除凭据" class="headerlink" title="2.3 删除凭据"></a>2.3 删除凭据</h3><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymt9cza4j30o008m3yy.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="2-4-更新凭据"><a href="#2-4-更新凭据" class="headerlink" title="2.4 更新凭据"></a>2.4 更新凭据</h3><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymtamrgfj30o007p3yt.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="2-5-移动凭据"><a href="#2-5-移动凭据" class="headerlink" title="2.5 移动凭据"></a>2.5 移动凭据</h3><ul><li>凭据支持多个域，支持将凭据移动到其他域中。 <img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymtb3wc5j30o00660sz.jpg" srcset="/img/loading.gif" alt=""></li></ul><h2 id="3-权限管理"><a href="#3-权限管理" class="headerlink" title="3. 权限管理"></a>3. 权限管理</h2><ul><li>权限默认使用 Role-Based Strategy,其他方式如图所示。 <img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymtbmfpvj30gd07pdfz.jpg" srcset="/img/loading.gif" alt=""></li></ul><h3 id="3-1-管理权限"><a href="#3-1-管理权限" class="headerlink" title="3.1 管理权限"></a>3.1 管理权限</h3><ul><li><p>系统设置-&gt;Manage and Assign Roles-&gt;Manage Roles</p></li><li><p>Global roles：添加用户和用户组，分配某个用户属于哪个用户组。</p></li><li><p>Project roles：添加某个工程或某一组工程的用户或用户组</p></li><li><p>Slave roles：添加某个节点或某一组节点的用户或用户组</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymtc6lpmj30o007ggly.jpg" srcset="/img/loading.gif" alt=""></p></li></ul><h3 id="3-2-全局权限"><a href="#3-2-全局权限" class="headerlink" title="3.2 全局权限"></a>3.2 全局权限</h3><p>凭据参数、字符参数、密码参数、布尔值参数、文件参数、文本参数、运行时参数、选项参数 <img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymtdyrwuj30o008m0tb.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="3-3-项目权限"><a href="#3-3-项目权限" class="headerlink" title="3.3 项目权限"></a>3.3 项目权限</h3><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymteu2phj30o007iq3g.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="3-4-权限授权"><a href="#3-4-权限授权" class="headerlink" title="3.4 权限授权"></a>3.4 权限授权</h3><ul><li>系统设置-&gt;Manage and Assign Roles-&gt;Assign Roles <img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymtfeal9j30o00g1t99.jpg" srcset="/img/loading.gif" alt=""></li></ul><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Jenkins</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins安装</title>
    <link href="/2019/11/03/Jenkins%E5%AE%89%E8%A3%85/"/>
    <url>/2019/11/03/Jenkins%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<blockquote><p>来源公众号： DevOps持续集成</p></blockquote><h2 id="1-先决条件"><a href="#1-先决条件" class="headerlink" title="1. 先决条件"></a>1. 先决条件</h2><h3 id="1-1-软件要求"><a href="#1-1-软件要求" class="headerlink" title="1.1 软件要求"></a>1.1 软件要求</h3><p>Java8 无论是Java运行时环境（JRE）还是Java开发工具包（JDK）都可以。安装JDK：yum -y install java</p><h3 id="1-2-硬件要求"><a href="#1-2-硬件要求" class="headerlink" title="1.2 硬件要求"></a>1.2 硬件要求</h3><ul><li><p>最低配置：256MB可用内存，1GB可用磁盘空间（Docker推荐10GB）。</p></li><li><p>小团队配置：1GB+可用内存， 50GB+可用磁盘空间。</p></li><li><p>注意：如果将Jenkins以docker方式运行的话，这些都不是必须的。</p></li></ul><h2 id="2-安装部署"><a href="#2-安装部署" class="headerlink" title="2. 安装部署"></a>2. 安装部署</h2><h3 id="2-1-基于WAR包部署"><a href="#2-1-基于WAR包部署" class="headerlink" title="2.1 基于WAR包部署"></a>2.1 基于WAR包部署</h3><p>Jenkins的web应用程序archive（war）包是可以在任何支持Java的操作系统上运行。Jenkins最新 war包</p><ul><li>将下载的war包放到jenkins的目录中（可以自定义)。</li><li>运行命令 java -jar jenkins.war启动。</li><li>此时可以看到Jenkins的启动日志，查看是否有异常。</li><li>通过浏览器访问<a href="http://localhost:8080。">http://localhost:8080。</a></li></ul><p>注意：可以通过 –httpPort方式指定端口， java -jar jenkins.war -httpPort=9090。</p><h3 id="2-2-基于MAC系统部署"><a href="#2-2-基于MAC系统部署" class="headerlink" title="2.2 基于MAC系统部署"></a>2.2 基于MAC系统部署</h3><ul><li>下载软件包手动安装</li><li>brew install jenkins #安装jenkins最新版本</li><li>brew install jenkins-lts #安装jenkinsLTS版本</li></ul><h3 id="2-3-基于Windows系统安装"><a href="#2-3-基于Windows系统安装" class="headerlink" title="2.3 基于Windows系统安装"></a>2.3 基于Windows系统安装</h3><ul><li>下载软件包通过向导安装即可。</li></ul><h3 id="2-4-基于Linux系统部署（推荐）"><a href="#2-4-基于Linux系统部署（推荐）" class="headerlink" title="2.4 基于Linux系统部署（推荐）"></a>2.4 基于Linux系统部署（推荐）</h3><ul><li>下载软件包</li><li>rpm –ivh jenkins-2.150.3-1.1.noarch.rpm #安装</li><li>service jenkins start #启动服务</li><li>chkconfig jenkins on #开机自启</li></ul><h2 id="3-安装后配置"><a href="#3-安装后配置" class="headerlink" title="3. 安装后配置"></a>3. 安装后配置</h2><h3 id="3-1-解锁Jenkins"><a href="#3-1-解锁Jenkins" class="headerlink" title="3.1 解锁Jenkins"></a>3.1 解锁Jenkins</h3><ul><li>当您第一次访问Jenkins的时候，系统会要求您使用自动生成的密码对其进行解锁。</li><li>解锁秘钥可以通过$JENKINS_HOME/secrets/initialAdminPassword文件获取。还可以通过在启动日志中获取。 <img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymrvk8puj30o00gh74w.jpg" srcset="/img/loading.gif" alt=""></li></ul><h3 id="3-2-自定义Jenkins插件"><a href="#3-2-自定义Jenkins插件" class="headerlink" title="3.2 自定义Jenkins插件"></a>3.2 自定义Jenkins插件</h3><ul><li>解锁Jenkins之后再自定义Jenkins页面，您可以安装任何数量的插件作为初始化的一部分。</li><li>分别是安装建议的插件和选择要安装的插件（如果不确定要安装那些的时候可以选择此选项，灵活的自定义安装）。</li><li>插件安装多了也没关系，可以后面再jenkins插件管理页面删除哦。 <img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymrwm0zhj30o00bvt9e.jpg" srcset="/img/loading.gif" alt=""></li></ul><h3 id="3-3-创建用户"><a href="#3-3-创建用户" class="headerlink" title="3.3 创建用户"></a>3.3 创建用户</h3><ul><li>在这里创建一个管理员账号，到此jenkins的初始化配置已完成。 <img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymrz0si1j30o0097q34.jpg" srcset="/img/loading.gif" alt=""></li></ul><h3 id="3-4-配置更新站点"><a href="#3-4-配置更新站点" class="headerlink" title="3.4 配置更新站点"></a>3.4 配置更新站点</h3><ul><li>由于使用官方的站点速度相对很慢，这里采用清华大学的jenkins更新站点。</li><li>站点地址: <a href="https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json![](https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymrzyjnaj30o0057aal.jpg)" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json![](https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymrzyjnaj30o0057aal.jpg)</a></li></ul><h3 id="3-5-安装slave节点"><a href="#3-5-安装slave节点" class="headerlink" title="3.5 安装slave节点"></a>3.5 安装slave节点</h3><ul><li><p>系统管理-&gt;节点管理</p><p> <img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9yms0taq3j30o00a43z1.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>创建完成后会出现slave节点启动的命令，下载agent.jar，然后启动服务。 <img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9yms1twppj30o007egly.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>启动命令</p><p>  wget <a href="http://192.168.0.41/jnlpJars/agent.jar" target="_blank" rel="noopener">http://192.168.0.41/jnlpJars/agent.jar</a><br>  java -jar agent.jar -jnlpUrl <a href="http://192.168.0.41/computer/test1/slave-agent.jnlp" target="_blank" rel="noopener">http://192.168.0.41/computer/test1/slave-agent.jnlp</a> -secret 807b0135fb5b071d99930166ac4fc5dd0cf355e670a66da73120dfa2e8cebc5f -workDir “/var/lib/jenkins”</p></li><li><p>启动成功 <img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9yms2ncctj30o00cfq3m.jpg" srcset="/img/loading.gif" alt=""></p></li></ul><h3 id="3-6-Jenkins配置文件"><a href="#3-6-Jenkins配置文件" class="headerlink" title="3.6 Jenkins配置文件"></a>3.6 Jenkins配置文件</h3><ul><li>以rpm方式部署的配置文件在/etc/sysconfig/jenkins，可以定义Jenkins启动参数和端口。 <img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9yms4ki1hj30o00a4my6.jpg" srcset="/img/loading.gif" alt=""></li></ul><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Jenkins</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jenkins简介</title>
    <link href="/2019/11/03/Jenkins%E7%AE%80%E4%BB%8B/"/>
    <url>/2019/11/03/Jenkins%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>来源公众号： DevOps持续集成</p></blockquote><h2 id="1-认识Jenkins"><a href="#1-认识Jenkins" class="headerlink" title="1. 认识Jenkins"></a>1. 认识Jenkins</h2><h3 id="1-1-Jenkins是什么？"><a href="#1-1-Jenkins是什么？" class="headerlink" title="1.1 Jenkins是什么？"></a>1.1 Jenkins是什么？</h3><p>Jenkins官网 Jenkins前身是Hudson，使用java语言开发的自动化发布工具。在中大型金融等企业中普遍使用Jenkins来作为项目发布工具。Jenkins官方提供的插件使Jenkins更为强大。</p><h3 id="1-2-Jenkins特点"><a href="#1-2-Jenkins特点" class="headerlink" title="1.2 Jenkins特点"></a>1.2 Jenkins特点</h3><ul><li>开源免费</li><li>多平台支持（windows/linux/macos）</li><li>主从分布式架构</li><li>提供web可视化配置管理页面</li><li>安装配置简单</li><li>插件资源丰富</li></ul><h3 id="1-3-Jenkins发展"><a href="#1-3-Jenkins发展" class="headerlink" title="1.3 Jenkins发展"></a>1.3 Jenkins发展</h3><p>Jenkins的前身是Hudson，采用JAVA编写的持续集成开源工具。Hudson由Sun公司在2004年启动，第一个版本于2005年在java.net发布。2007年开始Hudson逐渐取代CruiseControl和其他的开源构建工具的江湖地位。在2008年的JavaOne大会上在开发者解决方案中获得杜克选择大奖（Duke’s Choice Award）。</p><p>在2010年11月期间，因为Oracle对Sun的收购带来了Hudson的所有权问题。主要的项目贡献者和Oracle之间，尽管达成了很多协议，但有个关键问题就是商标名称“Hudson”。甲骨文在2010年12月声明拥有该名称并申请商标的权利。因此，2011年1月11日，有人要求投票将项目名称从“Hudson”改为“Jenkins”。2011年1月29日，该建议得到社区投票的批准，创建了Jenkins项目。</p><p>2011年2月1日，甲骨文表示，他们打算继续开发Hudson，并认为Jenkins只是一个分支，而不是重命名。因此，Jenkins和Hudson继续作为两个独立的项目，每个都认为对方是自己的分支。到2013年12月，GitHub上的Jenkins拥有567个项目成员和约1,100个公共仓库，与此相对的Hudson有32个项目成员和17个公共仓库。到现在两者的差异更多，应该说Jenkins已经全面超越了Hudson。此外，大家可能是出于讨厌Oracle的情绪，作为Java开发者天然地应该支持和使用Jenkins。</p><h2 id="2-Jenkins-WebUI"><a href="#2-Jenkins-WebUI" class="headerlink" title="2. Jenkins WebUI"></a>2. Jenkins WebUI</h2><h3 id="2-1-管理页面"><a href="#2-1-管理页面" class="headerlink" title="2.1 管理页面"></a>2.1 管理页面</h3><p>系统管理页面包含系统管理、全局安全管理、全局工具配置、节点管理、授权管理、插件管理、系统备份管理、日志监控管理<img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymm9o0udj30o00c7aaz.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="2-2-项目管理页面"><a href="#2-2-项目管理页面" class="headerlink" title="2.2 项目管理页面"></a>2.2 项目管理页面</h3><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymma9vazj30o00cdmy0.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="2-3-构建输出页面"><a href="#2-3-构建输出页面" class="headerlink" title="2.3 构建输出页面"></a>2.3 构建输出页面</h3><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymmbcwzkj30o00cb3z8.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="3-Jenkins构建"><a href="#3-Jenkins构建" class="headerlink" title="3. Jenkins构建"></a>3. Jenkins构建</h2><h3 id="3-1-Jenkins项目类型"><a href="#3-1-Jenkins项目类型" class="headerlink" title="3.1 Jenkins项目类型"></a>3.1 Jenkins项目类型</h3><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymmc9js3j30o00fowfr.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="3-2-Jenkins参数类型"><a href="#3-2-Jenkins参数类型" class="headerlink" title="3.2 Jenkins参数类型"></a>3.2 Jenkins参数类型</h3><p>凭据参数、字符参数、密码参数、布尔值参数、文件参数、文本参数、运行时参数、选项参数 <img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymmd3gdoj30o00hjq3s.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="3-3-Jenkins触发器"><a href="#3-3-Jenkins触发器" class="headerlink" title="3.3 Jenkins触发器"></a>3.3 Jenkins触发器</h3><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymmdplflj30o008oq35.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Jenkins</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>几个Git仓库开源软件的比较</title>
    <link href="/2019/11/01/%E5%87%A0%E4%B8%AAGit%E4%BB%93%E5%BA%93%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <url>/2019/11/01/%E5%87%A0%E4%B8%AAGit%E4%BB%93%E5%BA%93%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<h1 id="几个Git仓库开源软件的比较"><a href="#几个Git仓库开源软件的比较" class="headerlink" title="几个Git仓库开源软件的比较"></a>几个Git仓库开源软件的比较</h1><table><thead><tr><th align="center">特性</th><th align="center">gitlab</th><th align="center">gitblit</th><th align="center">gitbucket</th><th align="center">gogs</th><th align="center">gitolite</th></tr></thead><tbody><tr><td align="center">公开库</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">私有库</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">在线编辑</td><td align="center">√</td><td align="center">×</td><td align="center">√</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center">wiki</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">issue</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">fork</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">pull request</td><td align="center">√</td><td align="center">×</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">支持ssh</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="center">√</td><td align="center">？</td></tr><tr><td align="center">邮件通知</td><td align="center">√</td><td align="center">？</td><td align="center">√</td><td align="center">√</td><td align="center">？</td></tr><tr><td align="center">项目统计</td><td align="center">√</td><td align="center">×</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">组织管理</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">中文支持</td><td align="center">×</td><td align="center">√</td><td align="center">×</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">权限控制</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">插件机制</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">系统资源要求</td><td align="center">高</td><td align="center">高</td><td align="center">高</td><td align="center">很低</td><td align="center">低</td></tr><tr><td align="center">方便安装</td><td align="center">巨大不方便</td><td align="center">单文件部署</td><td align="center">单文件部署</td><td align="center">单文件部署</td><td align="center">未知</td></tr><tr><td align="center">开发语言</td><td align="center">ruby</td><td align="center">java</td><td align="center">scala</td><td align="center">go</td><td align="center">perl</td></tr><tr><td align="center">项目历史（年）</td><td align="center">?</td><td align="center">5</td><td align="center">3</td><td align="center">2</td><td align="center"></td></tr><tr><td align="center">开发者数量</td><td align="center">?</td><td align="center">97</td><td align="center">80</td><td align="center">196</td><td align="center"></td></tr></tbody></table><p>通过这个表格得出如下的结论：</p><ul><li>如果你希望开展git仓库托管服务并且信任gitlab的实力，可以采用gitlab，不过中文化的工作量不小。</li><li>如果仅仅是小型团队的内部git仓库管理，gogs足够了。尽管缺少细致的权限控制，但是极低的资源占用，丰富的功能还是很吸引人的。而且，gogs的开发似乎很活跃，贡献人数也比较多。BTW，gogs项目是中国人创建的。</li><li>如果必须采用java部署，gitblit目前是不错的选择，但是gitblit缺少了pull request这个重量级的协作工具是一大遗憾。</li></ul><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee-20200407103030299.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Git</tag>
      
      <tag>Vcs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python爬取某音乐网站里面的某板块</title>
    <link href="/2019/10/22/Python%E7%88%AC%E5%8F%96%E6%9F%90%E9%9F%B3%E4%B9%90%E7%BD%91%E7%AB%99%E9%87%8C%E9%9D%A2%E7%9A%84%E6%9F%90%E6%9D%BF%E5%9D%97/"/>
    <url>/2019/10/22/Python%E7%88%AC%E5%8F%96%E6%9F%90%E9%9F%B3%E4%B9%90%E7%BD%91%E7%AB%99%E9%87%8C%E9%9D%A2%E7%9A%84%E6%9F%90%E6%9D%BF%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymp6b9hxj311s0ogwjk.jpg" srcset="/img/loading.gif" alt="img"></p><blockquote><p>Python爬取某音乐网站里面的某板块。</p><p>本代码只作用学习交流使用</p></blockquote><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><span class="hljs-comment"># @FileName: qq_music.py</span><span class="hljs-keyword">import</span> json<span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> re<span class="hljs-keyword">import</span> requests<span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<span class="hljs-keyword">from</span> selenium.webdriver.chrome.options <span class="hljs-keyword">import</span> Options<span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> WebDriverWait<span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QqMusic</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-comment"># 设置 chrome 无界面化模式</span>        self.chrome_options = Options()        self.chrome_options.add_argument(<span class="hljs-string">'--headless'</span>)        self.chrome_options.add_argument(<span class="hljs-string">'--disable-gpu'</span>)        chrome_driver = <span class="hljs-string">"/usr/local/bin/chromedriver"</span>  <span class="hljs-comment"># 指定位置</span>        self.header = &#123;            <span class="hljs-string">"accept"</span>: <span class="hljs-string">"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3"</span>,            <span class="hljs-string">"accept-language"</span>: <span class="hljs-string">"zh-CN,zh;q=0.9"</span>,            <span class="hljs-string">"referer"</span>: <span class="hljs-string">"https://y.qq.com/n/yqq/toplist/26.html"</span>,            <span class="hljs-string">"upgrade-insecure-requests"</span>: <span class="hljs-string">"1"</span>,            <span class="hljs-string">"user-agent"</span>: <span class="hljs-string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36"</span>        &#125;        self.driver = webdriver.Chrome(chrome_driver, options=self.chrome_options)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">loading_music</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        等到列表里面的歌曲 加载完成后在处理</span><span class="hljs-string"></span><span class="hljs-string">        # 等待元素出现在DOM</span><span class="hljs-string">        WebDriverWait(self._driver).until(EC.presence_of_element_located((By.ID, value)))</span><span class="hljs-string"></span><span class="hljs-string">        # 等待元素显示在页面</span><span class="hljs-string">        WebDriverWait(self._driver,10).until(EC.visibility_of_element_located((By.NAME, value)))</span><span class="hljs-string"></span><span class="hljs-string">        # 等待元素从页面消失</span><span class="hljs-string">        WebDriverWait(self._driver, 10, 0.2).until_not(EC.visibility_of_element_located((By.CLASS_NAME, value))))</span><span class="hljs-string"></span><span class="hljs-string">        # 等待页面的title显示</span><span class="hljs-string">        WebDriverWait(self._driver, 5,0.2).until(EC.title_contains(title))</span><span class="hljs-string"></span><span class="hljs-string">        一次查找多个元素 (这些方法会返回一个list列表):</span><span class="hljs-string">        find_elements_by_name</span><span class="hljs-string">        find_elements_by_xpath</span><span class="hljs-string">        find_elements_by_link_text</span><span class="hljs-string">        find_elements_by_partial_link_text</span><span class="hljs-string">        find_elements_by_tag_name</span><span class="hljs-string">        find_elements_by_class_name</span><span class="hljs-string">        find_elements_by_css_selector</span><span class="hljs-string">        :return:</span><span class="hljs-string">        """</span>        self.driver.get(<span class="hljs-string">"https://y.qq.com/n/yqq/toplist/26.html"</span>)        print(self.driver.title)        WebDriverWait(self.driver, <span class="hljs-number">10</span>).until(            EC.presence_of_all_elements_located((By.CLASS_NAME, <span class="hljs-string">"songlist__songname_txt"</span>)))        lists = self.driver.find_elements_by_class_name(<span class="hljs-string">"songlist__songname_txt"</span>)        pattern = re.compile(<span class="hljs-string">r"https://y.qq.com/n/yqq/song/(\S+).html"</span>)  <span class="hljs-comment"># 取出每首歌的具体链接</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(lists)):            li = lists.__getitem__(i)            a = li.find_element_by_class_name(<span class="hljs-string">"js_song"</span>)            href = a.get_attribute(<span class="hljs-string">"href"</span>)            music_name = a.get_attribute(<span class="hljs-string">"title"</span>)            m = pattern.match(href)            <span class="hljs-keyword">yield</span> m.group(<span class="hljs-number">1</span>), music_name    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cut_download_url</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        筛选和查找下载的url</span><span class="hljs-string">        :return:</span><span class="hljs-string">        """</span>        <span class="hljs-keyword">for</span> music_url, music_name <span class="hljs-keyword">in</span> self.loading_music():            data = json.dumps(&#123;<span class="hljs-string">"req"</span>: &#123;<span class="hljs-string">"module"</span>: <span class="hljs-string">"CDN.SrfCdnDispatchServer"</span>, <span class="hljs-string">"method"</span>: <span class="hljs-string">"GetCdnDispatch"</span>,                                       <span class="hljs-string">"param"</span>: &#123;<span class="hljs-string">"guid"</span>: <span class="hljs-string">"3802082216"</span>, <span class="hljs-string">"calltype"</span>: <span class="hljs-number">0</span>, <span class="hljs-string">"userip"</span>: <span class="hljs-string">""</span>&#125;                                       &#125;,                               <span class="hljs-string">"req_0"</span>: &#123;                                   <span class="hljs-string">"module"</span>: <span class="hljs-string">"vkey.GetVkeyServer"</span>, <span class="hljs-string">"method"</span>: <span class="hljs-string">"CgiGetVkey"</span>,                                   <span class="hljs-string">"param"</span>: &#123;                                       <span class="hljs-string">"guid"</span>: <span class="hljs-string">"3802082216"</span>, <span class="hljs-string">"songmid"</span>: [<span class="hljs-string">f'<span class="hljs-subst">&#123;music_url&#125;</span>'</span>],                                       <span class="hljs-string">"songtype"</span>: [<span class="hljs-number">0</span>], <span class="hljs-string">"uin"</span>: <span class="hljs-string">"0"</span>, <span class="hljs-string">"loginflag"</span>: <span class="hljs-number">1</span>, <span class="hljs-string">"platform"</span>: <span class="hljs-string">"20"</span>                                   &#125;                               &#125;, <span class="hljs-string">"comm"</span>: &#123;<span class="hljs-string">"uin"</span>: <span class="hljs-number">0</span>, <span class="hljs-string">"format"</span>: <span class="hljs-string">"json"</span>, <span class="hljs-string">"ct"</span>: <span class="hljs-number">24</span>, <span class="hljs-string">"cv"</span>: <span class="hljs-number">0</span>&#125;&#125;)            url = <span class="hljs-string">"https://u.y.qq.com/cgi-bin/musicu.fcg?callback=getplaysongvkey3131073469569151&amp;"</span> \                  <span class="hljs-string">"g_tk=5381&amp;jsonpCallback=getplaysongvkey3131073469569151&amp;loginUin=0&amp;hostUin=0&amp;"</span> \                  <span class="hljs-string">f"format=jsonp&amp;inCharset=utf8&amp;outCharset=utf-8¬ice=0&amp;platform=yqq&amp;needNewCode=0&amp;data=<span class="hljs-subst">&#123;data&#125;</span>"</span>            response = requests.get(url=<span class="hljs-string">f"<span class="hljs-subst">&#123;url&#125;</span>"</span>,                                    headers=self.header)            html = response.text            <span class="hljs-comment"># music_json = json.loads(re.findall(r'^\w+\((.*)\)$',html)[0])</span>            music_json = html.split(<span class="hljs-string">"("</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">")"</span>)[<span class="hljs-number">0</span>]            music_json = json.loads(music_json)            req = music_json[<span class="hljs-string">'req'</span>][<span class="hljs-string">'data'</span>]            sip = req[<span class="hljs-string">"sip"</span>][<span class="hljs-number">-1</span>]            purl = music_json[<span class="hljs-string">'req_0'</span>][<span class="hljs-string">'data'</span>][<span class="hljs-string">'midurlinfo'</span>][<span class="hljs-number">0</span>][<span class="hljs-string">'purl'</span>]            url = <span class="hljs-string">f"<span class="hljs-subst">&#123;sip&#125;</span><span class="hljs-subst">&#123;purl&#125;</span>"</span>            <span class="hljs-keyword">yield</span> url, music_name    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">downloading</span><span class="hljs-params">(self, url, music_name)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        开始下载</span><span class="hljs-string">        :param url:</span><span class="hljs-string">        :param music_name:</span><span class="hljs-string">        :return:</span><span class="hljs-string">        """</span>        res = requests.get(<span class="hljs-string">f"<span class="hljs-subst">&#123;url&#125;</span>"</span>)        chunk_size = <span class="hljs-number">1024</span>        <span class="hljs-comment"># content_size = int(res.headers['content-length'])</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(<span class="hljs-string">"qq_music"</span>):            os.mkdir(<span class="hljs-string">"qq_music"</span>)        <span class="hljs-keyword">with</span> open(<span class="hljs-string">f"qq_music/<span class="hljs-subst">&#123;music_name&#125;</span>.m4a"</span>, <span class="hljs-string">'wb'</span>) <span class="hljs-keyword">as</span> f:            <span class="hljs-comment"># pbar = tqdm(total=int(content_size/1024))</span>            <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> res.iter_content(chunk_size=chunk_size):                f.write(data)                <span class="hljs-comment"># pbar.update()</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span>        downloads = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> self.cut_download_url()]        pbar = tqdm(total=len(downloads))        <span class="hljs-keyword">for</span> num, (url, music_name) <span class="hljs-keyword">in</span> enumerate(downloads):            self.downloading(url, music_name)            pbar.update()QqMusic().run()</code></pre><p>运行</p><pre><code class="hljs bash">python3 qq_music.py</code></pre><p>结果：</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymp77qqcj325e02oaaw.jpg" srcset="/img/loading.gif" alt="image-20191022190329400"></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymp92c3jj31ei0jqq7q.jpg" srcset="/img/loading.gif" alt="image-20191022190449649"></p><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>公共DNS性能大比拼</title>
    <link href="/2019/10/21/%E5%85%AC%E5%85%B1DNS%E6%80%A7%E8%83%BD%E5%A4%A7%E6%AF%94%E6%8B%BC/"/>
    <url>/2019/10/21/%E5%85%AC%E5%85%B1DNS%E6%80%A7%E8%83%BD%E5%A4%A7%E6%AF%94%E6%8B%BC/</url>
    
    <content type="html"><![CDATA[<p>​    今天中午，访问Gitee突然访问不进去，然后收到红薯通知：阿里云停止了 Gitee.com 的域名解析。</p><p>​    <img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymniewo5j30k8065mxv.jpg" srcset="/img/loading.gif" alt="msg"></p><p>​    码云官方也随后给出解决办法</p><blockquote><p>没有任何提示，没有任何提前通知，阿里云停止了 Gitee.com 的域名解析！！！</p><p>我们正在跟阿里云联系了解具体情况！</p><p>如果你访问不了请暂时在 hosts 里映射 gitee.com 域名到 IP地址 212.64.62.174</p><p>对此造成你的不便，我们深表歉意。</p></blockquote><p>​    那么先解释一下什么是DNS，百度百科说：域名系统（Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。通俗一点来说就是：我们不可能记住那么多的IP地址，但是我们可以记住域名啊，比如baidu.com，我们在地址栏输入baidu.com之后，会经过一个域名解析服务器把我们输入的域名转换为Ip。所以DNS最通俗来说就是一个域名解析服务器。</p><p>​    那么为什么阿里云hold处理之后很多用户受影响，而一少部分用户没有受影响呢？或者说为什么修改本地Hosts就可以继续正常访问呢？</p><p>​    其实所有的域名解析，会先经过一次本地HOSTS文件检索，如果本地有对应配置解析，会先走自己本地所配置的解析，如果本地没有配置，那么会继续往上解析，由于国内网络运营商为了大家网络响应速度（减少域名解析时间）并且现在绝大多数的站点都托管在阿里云云服务上，所以绝大多数运营商都会把自己的DNS服务器定向到阿里云的DNS解析器。所以只要我们避开阿里云DNS解析基本就解决了这个问题。至于其它是什么原因我们不做太多的探讨。</p><p>​    以下对DNS解析器进行一些性能上的分析。</p><p><strong>DNS解析器性能大比拼：CloudFlare vs 谷歌vs Quad9 vs OpenDNS</strong></p><p>​    几个月前，我对市面上几款顶级的免费DNS解析器的性能作了一番比较。当时恰好在Quad9发布之后，我试图搞清楚使用哪一个DNS解析器比较好，以便推荐给亲朋好友。面前有谷歌、OpenDNS和Quad9等好多选择，不过我喜欢选择。</p><p>情况在完全变得好转。CloudFlare是最了解互联网性能的公司之一，它最近推出了自己的免费DNS解析器。它在默认情况下支持基于TLS的DNS和基于HTTPS的DNS，这使得它更引人关注。</p><p>现在我们有了更有意思的比较对象：谷歌的8.8.8.8、Quad9的9.9.9.9和CloudFlare的1.1.1.1，此外还有OpenDNS的208.67.222.222和另外几家小众提供商作为可供我们使用的选择。</p><p><strong>测试的几家提供商</strong></p><p>​    不妨比较一下几家提供商，看看它们在世界各地的网速有多快。这些是我们选择评估的8家顶级的免费DNS提供商：</p><ul><li>谷歌 8.8.8.8：私密的、未经过滤的。这是最受欢迎的选择。</li><li>CloudFlare 1.1.1.1：私密的、未经过滤的。它是新玩家。</li><li>Quad 9 9.9.9.9：私密的、关注安全的。它是阻止访问恶意网站的新玩家。</li><li>OpenDNS 208.67.222.222：阻止恶意域名，并提供阻止成人内容这个选项的旧玩家。</li><li>诺顿DNS 199.85.126.20：阻止恶意域名，并与其防病毒软件集成起来的旧玩家。</li><li>CleanBrowsing 185.228.168.168：私密的、关注安全的。阻止访问成人内容的新玩家。</li><li>Yandex DNS 77.88.8.7：阻止恶意域名的旧玩家。它在俄罗斯非常受欢迎。</li><li>Comodo DNS 8.26.56.26：阻止恶意域名的旧玩家。</li></ul><p>下面这张图列出了它们在隐私选项方面的功能特性：</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymnjxnv3j30m805swew.jpg" srcset="/img/loading.gif" alt=""></p><p><strong>隐私选项比较</strong></p><p>​    上面的隐私选项基于提供商的承诺：不记录日志或不共享你的DNS请求。</p><p><strong>地点</strong></p><p>​    我们从全球的18个地点进行了测试。我们主要使用VPS提供商+一些宽带位置，尝试从尽可能多的地方查询它们的DNS。它会告诉我们它们的连接有多可靠、数据中心的位置以及该地区某个用户的体验有多完善。选择的地点如下：</p><ul><li>北美：圣迭戈、洛杉矶、纽约、多伦多、蒙特利尔、亚特兰大、达拉斯、弗里蒙特和旧金山</li><li>欧洲：伦敦、巴黎、阿姆斯特丹和法兰克福</li><li>亚洲：东京、新加坡、班加罗尔（印度）、悉尼和布里斯班（澳大利亚）</li><li>南美洲：圣保罗</li></ul><p><strong>测试结果摘要</strong></p><p>​    我们的测试非常简单，我们针对不同的流行域名（谷歌、facebook、twitter和Gmail等）在一个小时内执行了70次DNS查询。我们对每个位置的所有请求求平均值，以获得每个DNS解析器的整体性能指标。</p><p><strong>长话短说/摘要</strong></p><ul><li>所有提供商（Yandex除外）在北美和欧洲都表现非常好。它们在美国、加拿大和欧洲的响应时间均小于15毫秒，这令人惊讶。实际上，你选项其中任何一家，都不会注意到几毫秒的延迟差异。然而，亚洲和南美洲在总体平均值上有所不同，因为一些提供商在那里的连接不是很好。</li><li>就所有地点中的72%而言，CloudFlare是速度最快的DNS。它在全球的平均值很低，仅为4.98毫秒，令人刮目相看。</li><li>谷歌和Quad9分别名列第二和第三。Quad9在北美和欧洲的速度比谷歌快，但在亚洲/南美洲表现欠佳。</li><li>CloudFlare在每个地方都表现不俗。谷歌和Quad9在某些地方的响应时间很长，相比之下CloudFlare在各个地方都表现出色。</li><li>Yandex仅面向俄罗斯。它不像其他提供商那样利用任播（Anycast），在每个地方都非常缓慢。</li><li>CleanBrowsing是提供成人（色情）内容过滤机制的速度最快的提供商。</li><li>我们知道自己无法一对一地比较这些提供商，因为它们都拥有可能增加一些延迟的特殊功能（比如Quad9和Comodo阻止访问恶意域名）。具体结果如下。</li></ul><p><strong>全球平均值</strong></p><p>#1 CloudFlare：4.98ms</p><p>#2 谷歌: 16.44 ms</p><p>#3 Quad9: 18.25 ms</p><p>#4 CleanBrowsing: 19.14 ms</p><p>#5 诺顿: 34.75 ms</p><p>#6 OpenDNS: 46.51 ms</p><p>#7 Comodo: 71.90</p><p>#8 Yandex: 169.91</p><p><strong>北美平均值</strong></p><p>#1 CloudFlare: 3.93 ms</p><p>#2 Quad9: 7.21 ms</p><p>#3 诺顿: 8.32 ms</p><p>#4 谷歌: 8.53 ms</p><p>#5 CleanBrowsing: 11.83 ms</p><p>#6 OpenDNS: 14.66 ms</p><p>#7 Comodo: 25.91 ms</p><p>#8 Yandex: 119.09 ms</p><p><strong>欧洲平均值</strong></p><p>#1 CloudFlare: 2.96</p><p>#2 Quad9: 4.35</p><p>#3 CleanBrowsing: 5.74</p><p>#4 谷歌: 7.17</p><p>#5 OpenDNS: 8.99</p><p>#6 诺顿: 10.35</p><p>#7 Comodo: 13.06</p><p>#8 Yandex: 35.74</p><p><strong>测试数据</strong></p><p>美国纽约</p><p>#1Quad9 1.50 ms</p><p>#2CloudFlare 1.57 ms</p><p>#4Norton_DNS 7.28 ms</p><p>#5Google_DNS 7.71 ms</p><p>#6OpenDNS 9.71 ms</p><p>#6CleanBrowsing 10.85 ms</p><p>#7Comodo_DNS 12.00 ms</p><p>#8Yandex_DNS 108.14 ms</p><p>美国圣迭戈</p><p>#1 CloudFlare 8.57 ms</p><p>#2Norton_DNS 9.00 ms</p><p>#3Google_DNS 14.28 ms</p><p>#4CleanBrowsing 19.28 ms</p><p>#5OpenDNS 19.42 ms</p><p>#6Quad9 19.42 ms</p><p>#7Comodo_DNS 40.00 ms</p><p>#8Yandex_DNS 193.57 ms</p><p>加拿大多伦多</p><p>#1 CloudFlare 3.42 ms</p><p>#2Google_DNS 9.42 ms</p><p>#3Norton_DNS 13.00 ms</p><p>#4CleanBrowsing 13.71 ms</p><p>#5Quad9 15.28 ms</p><p>#6OpenDNS 17.85 ms</p><p>#7Comodo_DNS 21.71 ms</p><p>#8Yandex_DNS 124.14 ms</p><p>加拿大蒙特利尔</p><p>#1 CleanBrowsing 15.28 ms</p><p>#2Google_DNS 16.71 ms</p><p>#3CloudFlare 17.00 ms</p><p>#4Quad9 17.71 ms</p><p>#5OpenDNS 23.42 ms</p><p>#6Norton_DNS 25.71 ms</p><p>#7Comodo_DNS 84.28 ms</p><p>#8Yandex_DNS 118.85 ms</p><p>美国亚特兰大</p><p>#1 Quad9 1.71 ms</p><p>#2CloudFlare 1.85 ms</p><p>#3Google_DNS 4.14 ms</p><p>#4CleanBrowsing 15.42 ms</p><p>#5Norton_DNS 17.00 ms</p><p>#6OpenDNS 17.14 ms</p><p>#7Comodo_DNS 18.57 ms</p><p>#8Yandex_DNS 127.57 ms</p><p>美国达拉斯</p><p>#1CloudFlare 2.10 ms</p><p>#2Norton_DNS 3.14 ms</p><p>#3Quad9 3.42 ms</p><p>#4OpenDNS 6.71 ms</p><p>#5Google_DNS 7.14 ms</p><p>#6CleanBrowsing 10.85 ms</p><p>#7Comodo_DNS 38.42 ms</p><p>#8Yandex_DNS 153.28 ms</p><p>美国弗里蒙特</p><p>#1 CloudFlare 2.00 ms</p><p>#2Norton_DNS 6.14 ms</p><p>#3Quad9 11.00 ms</p><p>#4CleanBrowsing 11.85 ms</p><p>#5Google_DNS 13.71 ms</p><p>#6Comodo_DNS 22.00 ms</p><p>#7OpenDNS 24.42 ms</p><p>#8Yandex_DNS 185.00 ms</p><p>美国旧金山</p><p>#1 Norton_DNS 2.00 ms</p><p>#2Quad9 2.14 ms</p><p>#3CloudFlare 2.85 ms</p><p>#4Google_DNS 12.28 ms</p><p>#5CleanBrowsing 21.14 ms</p><p>#6Comodo_DNS 22.14 ms</p><p>#7OpenDNS 28.00 ms</p><p>#8Yandex_DNS 180.42 ms</p><p>英国伦敦</p><p>#1 CloudFlare 1.14 ms</p><p>#2Quad9 1.85 ms</p><p>#3CleanBrowsing 2.00 ms</p><p>#4Norton_DNS 6.57 ms</p><p>#5Google_DNS 7.71 ms</p><p>#6Comodo_DNS 9.85 ms</p><p>#7OpenDNS 9.85 ms</p><p>#8Yandex_DNS 35.57 ms</p><p>法国巴黎</p><p>#1CloudFlare 5.14 ms</p><p>#2Comodo_DNS 10.00 ms</p><p>#3Google_DNS 10.14 ms</p><p>#4Quad9 12.71 ms</p><p>#5OpenDNS 13.57 ms</p><p>#7CleanBrowsing 14.85 ms</p><p>#6Norton_DNS 23.85 ms</p><p>#8Yandex_DNS 38.14 ms</p><p>荷兰阿姆斯特丹</p><p>#1CloudFlare 1.14 ms</p><p>#2CleanBrowsing 1.14 ms</p><p>#3Quad9 1.71 ms</p><p>#4Google_DNS 2.71 ms</p><p>#5OpenDNS 4.42 ms</p><p>#6Norton_DNS 9.85 ms</p><p>#7Comodo_DNS 12.85 ms</p><p>#8Yandex_DNS 40.42 ms</p><p>德国法兰克福</p><p>#1 Norton_DNS 1.14 ms</p><p>#2Quad9 1.14 ms</p><p>#3CloudFlare 4.42 ms</p><p>#4CleanBrowsing 5.00 ms</p><p>#5Google_DNS 8.14 ms</p><p>#6OpenDNS 8.14 ms</p><p>#7Comodo_DNS 19.57 ms</p><p>#8Yandex_DNS 28.85 ms</p><p>日本东京</p><p>#1CloudFlare 2.00 ms</p><p>#2CleanBrowsing 2.14 ms</p><p>#3Norton_DNS 6.14 ms</p><p>#4Google_DNS 17.28 ms</p><p>#5Quad9 40.57 ms</p><p>#6Comodo_DNS 124.14 ms</p><p>#7OpenDNS 125.71 ms</p><p>#8Yandex_DNS 283.00 ms</p><p>新加坡</p><p>#1CloudFlare 1.14 ms</p><p>#2Google_DNS 2.00 ms</p><p>#3Quad9 2.14 ms</p><p>#4CleanBrowsing 2.28 ms</p><p>#5OpenDNS 28.14 ms</p><p>#6Norton_DNS 34.14 ms</p><p>#7Comodo_DNS 203.71 ms</p><p>#8Yandex_DNS 343.00 ms</p><p>印度班加罗尔</p><p>#1CloudFlare 7.42 ms</p><p>#2Norton_DNS 21.28 ms</p><p>#3Quad9 38.85 ms</p><p>#4Google_DNS 40.71 ms</p><p>#5OpenDNS 59.42 ms</p><p>#6CleanBrowsing 138.71 ms</p><p>#7Comodo_DNS 150.57 ms</p><p>#8Yandex_DNS 171.57 ms</p><p>澳大利亚悉尼</p><p>#1CloudFlare 22.28 ms</p><p>#2Quad9 25.00 ms</p><p>#3Google_DNS 26.14 ms</p><p>#4CleanBrowsing 34.57 ms</p><p>#5OpenDNS 37.85 ms</p><p>#6Norton_DNS 164.57 ms</p><p>#7Comodo_DNS 186.28 ms</p><p>#8Yandex_DNS 352.14 ms</p><p>澳大利亚布里斯班</p><p>#1CloudFlare 3.00 ms</p><p>#2CleanBrowsing 13.57 ms</p><p>#3Quad9 17.71 ms</p><p>#4Google_DNS 66.14 ms</p><p>#5Norton_DNS 160.14 ms</p><p>#6Comodo_DNS 188.28 ms</p><p>#7OpenDNS 190.28 ms</p><p>#8Yandex_DNS 336.71 ms</p><p>巴西圣保罗</p><p>#1CloudFlare 2.71 ms</p><p>#2CleanBrowsing 12.00 ms</p><p>#3Google_DNS 29.71 ms</p><p>#4Norton_DNS 114.71 ms</p><p>#5Quad9 114.71 ms</p><p>#6Comodo_DNS 129.85 ms</p><p>#7OpenDNS 213.14 ms</p><p>#8Yandex_DNS 238.14 ms</p><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee-20200407103021459.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>DNS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DNS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python自动更换壁纸爬虫与tkinter结合</title>
    <link href="/2019/10/14/Python%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%8D%A2%E5%A3%81%E7%BA%B8%E7%88%AC%E8%99%AB%E4%B8%8Etkinter%E7%BB%93%E5%90%88/"/>
    <url>/2019/10/14/Python%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%8D%A2%E5%A3%81%E7%BA%B8%E7%88%AC%E8%99%AB%E4%B8%8Etkinter%E7%BB%93%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p>直接上代码</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> ctypes<span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> requests<span class="hljs-keyword">import</span> os<span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span> Tk, Label, Button,Entry,StringVar,messagebox<span class="hljs-comment"># '放到AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup下把本文件后缀设为pyw 就会开机自启'</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bz</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>        self.curent_url = <span class="hljs-string">'https://tenapi.cn/img/acg.php'</span>        self.root = Tk()        self.root.attributes(<span class="hljs-string">"-alpha"</span>, <span class="hljs-number">0.8</span>)        self.root.title(<span class="hljs-string">'壁纸切---by Alterem'</span>)        self.root.geometry(<span class="hljs-string">'218x55+1300+20'</span>)        self.b1 = Button(self.root, text=<span class="hljs-string">' 换一类 '</span>, command=self.change_type, fg=<span class="hljs-string">'#00f235'</span>,width=<span class="hljs-number">8</span>).place(x=<span class="hljs-number">0</span>, y=<span class="hljs-number">0</span>)        self.b2 = Button(self.root, text=<span class="hljs-string">'下一张&gt;&gt;  频率(分)'</span>, command=self.change_next, fg=<span class="hljs-string">'blue'</span>,width=<span class="hljs-number">22</span>).place(x=<span class="hljs-number">63</span>, y=<span class="hljs-number">0</span>)        self.b3 = Button(self.root, text=<span class="hljs-string">'停止切换'</span>, command=self.stop, fg=<span class="hljs-string">'red'</span>, width=<span class="hljs-number">8</span>).place(x=<span class="hljs-number">0</span>, y=<span class="hljs-number">30</span>)        self.label = Label(self.root, text=<span class="hljs-string">'二次元'</span>,fg=<span class="hljs-string">'#9e3dff'</span>)        self.label.place(x=<span class="hljs-number">85</span>, y=<span class="hljs-number">30</span>)        e = StringVar()        self.input=Entry(self.root,textvariable=e,fg=<span class="hljs-string">'#ffaf0a'</span>)        e.set(<span class="hljs-number">0.1</span>)       <span class="hljs-comment">#默认0.1分钟   6s</span>        self.input.place(x=<span class="hljs-number">153</span>, y=<span class="hljs-number">30</span>)        self.url_list = &#123;<span class="hljs-number">1</span>: [<span class="hljs-string">'影视'</span>, <span class="hljs-string">'http://pic.tsmp4.net/api/yingshi/img.php'</span>],                         <span class="hljs-number">2</span>: [<span class="hljs-string">'随机'</span>, <span class="hljs-string">'http://lorempixel.com/1920/1080/'</span>],                         <span class="hljs-number">3</span>: [<span class="hljs-string">'女神'</span>, <span class="hljs-string">'http://pic.tsmp4.net/api/nvsheng/img.php'</span>],                         <span class="hljs-number">4</span>: [<span class="hljs-string">'风景'</span>, <span class="hljs-string">'http://pic.tsmp4.net/api/fengjing/img.php'</span>],                         <span class="hljs-number">5</span>: [<span class="hljs-string">'二次元'</span>, <span class="hljs-string">'https://tenapi.cn/img/acg.php'</span>]&#125;        self.path = <span class="hljs-string">'D:\壁纸'</span>        self.filepath = self.path + <span class="hljs-string">'/img.jpg'</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(self.path):            os.makedirs(self.path)        self.flag = <span class="hljs-literal">True</span>        self.start = <span class="hljs-number">1</span>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stop</span><span class="hljs-params">(self)</span>:</span>        self.flag = <span class="hljs-literal">False</span>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">change_type</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">if</span> self.start &gt; <span class="hljs-number">5</span>:            self.start = <span class="hljs-number">1</span>        list = self.url_list.get(self.start)        curent_type = list[<span class="hljs-number">0</span>]        self.curent_url = list[<span class="hljs-number">1</span>]        self.label[<span class="hljs-string">'text'</span>] = curent_type        self.start += <span class="hljs-number">1</span>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">change_next</span><span class="hljs-params">(self)</span>:</span>        data = requests.get(url=self.curent_url).content        <span class="hljs-keyword">with</span> open(self.filepath, <span class="hljs-string">'wb'</span>) <span class="hljs-keyword">as</span> f:            f.write(data)        self.config()     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_img</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">try</span>:            self.num = eval(self.input.get()) * <span class="hljs-number">60</span>  <span class="hljs-comment">#捕获结束界面后的异常</span>        <span class="hljs-keyword">except</span> Exception:            <span class="hljs-keyword">pass</span>        <span class="hljs-keyword">try</span>:            data = requests.get(url=self.curent_url).content            <span class="hljs-keyword">with</span> open(self.filepath, <span class="hljs-string">'wb'</span>) <span class="hljs-keyword">as</span> f:                f.write(data)            time.sleep(self.num)       <span class="hljs-comment"># 睡眠单位秒</span>            self.config()        <span class="hljs-keyword">except</span> Exception:            <span class="hljs-keyword">pass</span>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">config</span><span class="hljs-params">(self)</span>:</span>        ctypes.windll.user32.SystemParametersInfoW(<span class="hljs-number">20</span>, <span class="hljs-number">0</span>, self.filepath, <span class="hljs-number">0</span>)  <span class="hljs-comment"># 设置桌面壁纸.</span>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">img</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">while</span> self.flag:            self.get_img()     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span>        t1 = Thread(target=self.img)        <span class="hljs-comment"># t1.setDaemon(True)           #设置守护线程 ---&gt;是否完全关闭</span>        t1.start()        self.root.mainloop()        <span class="hljs-keyword">if</span> self.flag:            root = Tk()            root.withdraw()            messagebox.showinfo(<span class="hljs-string">"by Alterem"</span>, <span class="hljs-string">"只关闭了界面! 图片还在切换! 请进入任务管理器结束进程"</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    b = Bz()    b.run()</code></pre><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Tkinter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL的5种时间类型的比较</title>
    <link href="/2019/10/13/MySQL%E7%9A%845%E7%A7%8D%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <url>/2019/10/13/MySQL%E7%9A%845%E7%A7%8D%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th>日期时间类型</th><th>占用空间</th><th>日期格式</th><th>最小值</th><th>最大值</th><th>零值表示</th></tr></thead><tbody><tr><td>DATETIME</td><td>8 bytes</td><td>YYYY-MM-DD HH:MM:SS</td><td>1000-01-01 00:00:00</td><td>9999-12-31 23:59:59</td><td>0000-00-00 00:00:00</td></tr><tr><td>TIMESTAMP</td><td>4 bytes</td><td>YYYY-MM-DD HH:MM:SS</td><td>19700101080001</td><td>2038 年的某个时刻</td><td>00000000000000</td></tr><tr><td>DATE</td><td>4 bytes</td><td>YYYY-MM-DD</td><td>1000-01-01</td><td>9999-12-31</td><td>0000-00-00</td></tr><tr><td>TIME</td><td>3 bytes</td><td>HH:MM:SS</td><td>-838:59:59</td><td>838:59:59</td><td>00:00:00</td></tr><tr><td>YEAR</td><td>1 bytes</td><td>YYYY</td><td>1901</td><td>2155</td><td>0000</td></tr></tbody></table><p><strong>DATETIME</strong></p><pre><code>DATETIME 用于表示 年月日 时分秒，是 DATE 和 TIME 的组合，并且记录的年份（见上表）比较长久。如果实际应用中有这样的需求，就可以使用 DATETIME 类型。</code></pre><p>1、DATETIME列可以设置为多个，默认可为null，可以手动设置其值。  </p><p>2、DATETIME列不可设定默认值。 </p><p>3、DATETIME列可以变相的设定默认值，比如通过触发器、或者在插入数据时候，将DATETIME字段值设置为now()，这样可以做到了，尤其是后者，在程序开发中常常用到。</p><p> <strong>TIMESTAMP</strong></p><ul><li><p>TIMESTAMP 用于表示 年月日 时分秒，但是记录的年份（见上表）比较短暂，TIMESTAMP列必须有默认值，默认值可以为“0000-00-00 00:00:00”，但不能为null。</p></li><li><p>TIMESTAMP 和时区相关，更能反映当前时间。当插入日期时，会先转换为本地时区后再存放；当查询日期时，会将日期转换为本地时区后再显示。所以不同时区的人看到的同一时间是  不一样的。</p></li><li><p>表中的第一个 TIMESTAMP 列自动设置为系统时间（CURRENT_TIMESTAMP）。当插入或更新一行，但没有明确给 TIMESTAMP 列赋值，也会自动设置为当前系统时间。如果表中有第二个 TIMESTAMP 列，则默认值设置为0000-00-00 00:00:00。</p></li><li><p>TIMESTAMP 的属性受 Mysql 版本和服务器 SQLMode 的影响较大。</p><p>   如果记录的日期需要让不同时区的人使用，最好使用 TIMESTAMP。</p></li></ul><p>注：一般建表时候，创建时间用datetime，更新时间用timestamp。</p><p> <strong>DATE</strong></p><pre><code>DATE 用于表示 年月日，如果实际应用值需要保存 年月日 就可以使用 DATE。</code></pre><p> <strong>TIME</strong></p><pre><code>TIME 用于表示 时分秒，如果实际应用值需要保存 时分秒 就可以使用 TIME。</code></pre><p> <strong>YEAR</strong></p><pre><code>YEAR 用于表示 年份，YEAR 有 2 位（最好使用4位）和 4 位格式的年。 默认是4位。如果实际应用只保存年份，那么用 1 bytes 保存 YEAR 类型完全可以。不但能够节约存储空间，还能提高表的操作效率。</code></pre><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySql在CentOS上执行自动备份</title>
    <link href="/2019/10/13/MySQL%E5%9C%A8CentOS%E4%B8%8A%E6%89%A7%E8%A1%8C%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD/"/>
    <url>/2019/10/13/MySQL%E5%9C%A8CentOS%E4%B8%8A%E6%89%A7%E8%A1%8C%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD/</url>
    
    <content type="html"><![CDATA[<p>​    开发中我们常常有使用Svn或者Git来管理我们的代码或者是项目相关的文件，然而他们都有一个共同点就是：<strong>版本控制</strong></p><p>​    很多人会问为什么要使用Svn或者是Git，那么我会问：我相信你写的代码很好，但是有一天你修改了很多很多的Bug，但是突然想到以前的代码中有一个比较重要的算法你不小心覆盖掉了，这时候你应该怎么办？</p><p>​    或许你会告诉我你可以在修改这些代码之前备份一次当前修改的文件，或者是当前项目。</p><p>​    但是时间久了你的机器上会有多少备份文件呢？</p><p>​    如果有一天你的同事需要回滚到之前的代码看一下那时候Bug的原因，你会从你的机器上找到指定时间的文件发给他嘛？</p><p>​    当然不是，我们有Svn或者是Git之后我们可以方便的看到文件之前的版本，还可以方便的对比。那么现在清楚了版本控制的重要性了。</p><p>​    同样数据库也是这样，我们的系统99%都离不开数据库，因为我们总要把数据存储起来。</p><p>​    那如果我们数据库被误删、被黑客入侵、被恶意修改怎么办？</p><p>​    那么我们可以试着让我们的服务器自动来帮我们备份数据库的数据到指定位置，万一有一天我们的数据库不小心手抖了，我们还可以用备份下来的数据库脚本直接恢复。</p><p>​    上脚本：</p><pre><code class="hljs bash"><span class="hljs-comment"># db username</span>db_user=<span class="hljs-string">"test"</span>  <span class="hljs-comment"># db password</span>db_passwd=<span class="hljs-string">"test"</span><span class="hljs-comment"># db host</span>db_host=<span class="hljs-string">"121.201.5.216"</span><span class="hljs-comment"># backup db name</span>db_name=<span class="hljs-string">"Alterem"</span>  <span class="hljs-comment"># the directory for story your backup file.  </span>backup_dir=<span class="hljs-string">"backup"</span>  <span class="hljs-built_in">cd</span> <span class="hljs-comment"># date format for backup file (dd-mm-yyyy)  </span>time=<span class="hljs-string">"<span class="hljs-variable">$(date +"%Y-%m-%d-%H-%M-%S")</span>"</span>  <span class="hljs-comment"># mysql, mysqldump and some other bin's path  </span>MYSQL=<span class="hljs-string">"/usr/local/mysql/bin/mysql"</span>  MYSQLDUMP=<span class="hljs-string">"/usr/local/mysql/bin/mysqldump"</span>  GZIP=<span class="hljs-string">"/bin/gzip"</span>    <span class="hljs-variable">$MYSQLDUMP</span> -u <span class="hljs-variable">$db_user</span> -h <span class="hljs-variable">$db_host</span> -p<span class="hljs-variable">$db_passwd</span> <span class="hljs-variable">$db_name</span> | <span class="hljs-variable">$GZIP</span> -9 &gt; <span class="hljs-string">"/data/backup/<span class="hljs-variable">$backup_dir</span>/<span class="hljs-variable">$db_name</span>"</span>_<span class="hljs-string">"<span class="hljs-variable">$time</span>.gz"</span></code></pre><h3 id="创建定时器"><a href="#创建定时器" class="headerlink" title="创建定时器"></a>创建定时器</h3><pre><code class="hljs bash">crontab -e</code></pre><p>添加定时器</p><pre><code class="hljs bash"><span class="hljs-comment"># 每天凌晨 1 点 30 分 进行数据备份</span>30  1  *  *  * /root/mysql-backup.sh</code></pre><p>重启定时器</p><pre><code class="hljs bash">/etc/rc.d/init.d/crond restart</code></pre><h3 id="cron解析"><a href="#cron解析" class="headerlink" title="cron解析"></a>cron解析</h3><pre><code class="hljs bash"><span class="hljs-comment"># For details see man 4 crontabs</span><span class="hljs-comment"># Example of job definition:</span><span class="hljs-comment"># .---------------- minute (0 - 59)</span><span class="hljs-comment"># |  .------------- hour (0 - 23)</span><span class="hljs-comment"># |  |  .---------- day of month (1 - 31)</span><span class="hljs-comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span><span class="hljs-comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span><span class="hljs-comment"># |  |  |  |  |</span><span class="hljs-comment"># *  *  *  *  * user-name command to be executed</span></code></pre><p><a href="http://cron.qqe2.com/" target="_blank" rel="noopener">在线Cron表达式生成器</a>：<a href="http://cron.qqe2.com/" target="_blank" rel="noopener">http://cron.qqe2.com/</a></p><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python拆分excel</title>
    <link href="/2019/10/11/python%E6%8B%86%E5%88%86excel/"/>
    <url>/2019/10/11/python%E6%8B%86%E5%88%86excel/</url>
    
    <content type="html"><![CDATA[<p>根据某一列，拆分成几个不同的EXCEL文件<br>操作方法：将EXCEL文件拖至EXE文件上，根据提示操作。</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymnkx1s0g311j0jj18k.gif" srcset="/img/loading.gif" alt="img"></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> openpyxl<span class="hljs-keyword">from</span> openpyxl.utils <span class="hljs-keyword">import</span> get_column_letter<span class="hljs-keyword">import</span> xlrd<span class="hljs-keyword">import</span> sys, os, collections<span class="hljs-keyword">from</span> pprint <span class="hljs-keyword">import</span> pprint<span class="hljs-keyword">from</span> copy <span class="hljs-keyword">import</span> copy  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">splitExcel</span><span class="hljs-params">(object)</span>:</span>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, sourceFile, titleLine=None, splitColumn=None)</span>:</span>        self.sourceFile = sourceFile        self.sourceWorkbook = openpyxl.load_workbook(sourceFile)        self.targetWorkbook = openpyxl.Workbook()        self.targetWorkbook.remove(self.targetWorkbook.active)         <span class="hljs-comment"># 源工作表（object对象）</span>        self.sourceWorksheet = <span class="hljs-literal">None</span>        <span class="hljs-comment"># 最大行数</span>        self.sourceWorkbookMaxRow = <span class="hljs-literal">None</span>        <span class="hljs-comment"># 最大列数</span>        self.sourceWorkbookMaxColumn = <span class="hljs-literal">None</span>        <span class="hljs-comment"># 源工作表索引号</span>        self.sourceWorksheetIndex = <span class="hljs-literal">None</span>        <span class="hljs-comment"># 标题所在行号，用户输入时索引从1开始，内部处理时请留意索引数</span>        <span class="hljs-comment"># if titleLine == None:</span>        <span class="hljs-comment">#     titleLine = int(input('请输入标题所在行[2]: ').strip())</span>        self.titleLine = titleLine        <span class="hljs-comment"># 根据哪个列进行拆分，用户输入时索引从1开始，内部处理时请留意索引数</span>        self.splitColumn = splitColumn        <span class="hljs-comment"># 源工作薄当前行号</span>        self.sbCurrectLine = <span class="hljs-literal">None</span>        <span class="hljs-comment"># 目标工作薄各表当前数据行号</span>        self.tbCurrectLines = &#123;&#125;        <span class="hljs-comment"># 表头文字</span>        self.header = []        <span class="hljs-comment"># 各表数据</span>        self.data = collections.OrderedDict()        <span class="hljs-comment"># 保存列宽</span>        self.columnsWidth = collections.OrderedDict()        <span class="hljs-comment"># 格式</span>        self.formats = &#123;&#125;     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">readData</span><span class="hljs-params">(self)</span>:</span>        wb = xlrd.open_workbook(self.sourceFile)        ws = wb.sheet_by_index(self.sourceWorksheetIndex)        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(ws.nrows):            <span class="hljs-keyword">if</span> x &lt; self.titleLine:                <span class="hljs-comment"># 表头</span>                self.header.append(ws.row_values(x))            <span class="hljs-keyword">else</span>:                v = ws.cell(x, self.splitColumn - <span class="hljs-number">1</span>).value                sheetName = self.clearSheetName(v)                <span class="hljs-comment"># 将表名加入data字典</span>                <span class="hljs-keyword">if</span> sheetName <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.data.keys():                    self.data[sheetName] = []                <span class="hljs-comment"># 添加数据</span>                self.data[sheetName].append(ws.row_values(x))     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">selectSplitSheet</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">if</span> len(self.sourceWorkbook.sheetnames) == <span class="hljs-number">1</span>:            self.sourceWorksheet = self.sourceWorkbook.active            self.sourceWorksheetIndex = <span class="hljs-number">0</span>        <span class="hljs-keyword">else</span>:            _n_ = <span class="hljs-number">0</span>            print(<span class="hljs-string">'在工作薄中找到以下工作表：'</span>)            <span class="hljs-keyword">for</span> SheetName <span class="hljs-keyword">in</span> self.sourceWorkbook.sheetnames:                print(_n_, SheetName)                _n_ += <span class="hljs-number">1</span>             n = <span class="hljs-number">0</span>            _input = input(<span class="hljs-string">'请输入要拆分表的序号[0]: '</span>).strip()            <span class="hljs-keyword">if</span> _input != <span class="hljs-string">''</span>:                n = int(_input)            self.sourceWorksheet = self.sourceWorkbook.worksheets[n]            self.sourceWorksheetIndex = n     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">selectSplitColumn</span><span class="hljs-params">(self)</span>:</span>        wb = xlrd.open_workbook(self.sourceFile)        ws = wb.sheet_by_index(self.sourceWorksheetIndex)         <span class="hljs-comment"># 保存一下最大行数、列数，以供其它（属性）地方使用</span>        self.sourceWorkbookMaxRow = ws.nrows        self.sourceWorkbookMaxColumn = ws.ncols         print(<span class="hljs-string">'\n在工作表的标题行（第 %s 行）找到以下列: '</span> % self.titleLine)         <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, ws.ncols + <span class="hljs-number">1</span>):            print(y, ws.cell(self.titleLine - <span class="hljs-number">1</span>, y - <span class="hljs-number">1</span>).value)         columnNum = input(<span class="hljs-string">'请输入拆分列号[2]: '</span>).strip()        <span class="hljs-keyword">if</span> columnNum == <span class="hljs-string">''</span>:            columnNum = <span class="hljs-number">2</span>        <span class="hljs-keyword">else</span>:            columnNum = int(columnNum)        self.splitColumn = columnNum     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">readCellsStyle</span><span class="hljs-params">(self)</span>:</span>        ws = self.sourceWorksheet        maxColumn = self.sourceWorkbookMaxColumn        styles = [[<span class="hljs-literal">None</span>] * (maxColumn + <span class="hljs-number">11</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(self.titleLine + <span class="hljs-number">11</span>)]        fonts = [[<span class="hljs-literal">None</span>] * (maxColumn + <span class="hljs-number">11</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(self.titleLine + <span class="hljs-number">11</span>)]        borders = [[<span class="hljs-literal">None</span>] * (maxColumn + <span class="hljs-number">11</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(self.titleLine + <span class="hljs-number">11</span>)]        fills = [[<span class="hljs-literal">None</span>] * (maxColumn + <span class="hljs-number">11</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(self.titleLine + <span class="hljs-number">11</span>)]        alignments = [[<span class="hljs-literal">None</span>] * (maxColumn + <span class="hljs-number">11</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(self.titleLine + <span class="hljs-number">11</span>)]        number_formats = [[<span class="hljs-literal">None</span>] * (maxColumn + <span class="hljs-number">11</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(self.titleLine + <span class="hljs-number">11</span>)]        protections = [[<span class="hljs-literal">None</span>] * (maxColumn + <span class="hljs-number">11</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(self.titleLine + <span class="hljs-number">11</span>)]        heights = [<span class="hljs-literal">None</span>] * (self.titleLine + <span class="hljs-number">11</span>)        widths = [<span class="hljs-literal">None</span>] * (maxColumn + <span class="hljs-number">11</span>)        <span class="hljs-comment"># isDates = [None] * (maxColumn + 11)</span>         <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, self.titleLine + <span class="hljs-number">2</span>):            heights[x] = ws.row_dimensions[x].height            <span class="hljs-comment"># print(x,'height',heights[x])</span>            <span class="hljs-comment"># for y in range(1, ws.max_column + 1):</span>            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, maxColumn + <span class="hljs-number">1</span>):                styles[x][y] = copy(ws.cell(x, y).style.replace(<span class="hljs-string">'常规'</span>, <span class="hljs-string">'Normal'</span>))                fonts[x][y] = copy(ws.cell(x, y).font)                borders[x][y] = copy(ws.cell(x, y).border)                fills[x][y] = copy(ws.cell(x, y).fill)                alignments[x][y] = copy(ws.cell(x, y).alignment)                number_formats[x][y] = copy(ws.cell(x, y).number_format)                protections[x][y] = copy(ws.cell(x, y).protection)                <span class="hljs-keyword">if</span> y <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> widths:                    widths[y] = ws.column_dimensions[get_column_letter(y)].width                <span class="hljs-comment"># print(y, get_column_letter(y), ws.column_dimensions[get_column_letter(y)].width)</span>                <span class="hljs-comment"># if y not in isDates:</span>                <span class="hljs-comment">#     isDates[y] = ws.cell(x, y).is_date</span>         self.formats[<span class="hljs-string">'heights'</span>] = heights        self.formats[<span class="hljs-string">'styles'</span>] = styles        self.formats[<span class="hljs-string">'fonts'</span>] = fonts        self.formats[<span class="hljs-string">'borders'</span>] = borders        self.formats[<span class="hljs-string">'fills'</span>] = fills        self.formats[<span class="hljs-string">'alignments'</span>] = alignments        self.formats[<span class="hljs-string">'number_formats'</span>] = number_formats        self.formats[<span class="hljs-string">'protections'</span>] = protections        self.formats[<span class="hljs-string">'widths'</span>] = widths        <span class="hljs-comment"># self.formats['isDates'] = isDates</span>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">writeFormatToNewWorkbook</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">for</span> sheetName <span class="hljs-keyword">in</span> self.data.keys():            ws = self.targetWorkbook[sheetName]            <span class="hljs-comment"># for x in range(1,self.titleLine+2):</span>            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, ws.max_row + <span class="hljs-number">1</span>):                <span class="hljs-comment"># 表头</span>                <span class="hljs-keyword">if</span> x &lt;= self.titleLine:                    xx = x                    <span class="hljs-comment"># ws.row_dimensions[x].height = self.formats['heights'][x]</span>                <span class="hljs-keyword">else</span>:                    <span class="hljs-comment"># 表数据</span>                    xx = self.titleLine + <span class="hljs-number">1</span>                height = self.formats[<span class="hljs-string">'heights'</span>][xx]                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> height == <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> height &gt; <span class="hljs-number">0</span>:                    ws.row_dimensions[x].height = self.formats[<span class="hljs-string">'heights'</span>][xx]                 <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, ws.max_column + <span class="hljs-number">1</span>):                    <span class="hljs-comment"># 表头</span>                    <span class="hljs-keyword">if</span> x &lt;= self.titleLine:                        <span class="hljs-comment"># 路过空白单元格</span>                        <span class="hljs-comment"># if ws.cell(x, y).value == '':</span>                        <span class="hljs-comment">#     continue</span>                        width = self.formats[<span class="hljs-string">'widths'</span>][y]                        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> width == <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> width &gt; <span class="hljs-number">0</span>:                            ws.column_dimensions[get_column_letter(y)].width = self.formats[<span class="hljs-string">'widths'</span>][y]                        xx = x                    <span class="hljs-keyword">else</span>:                        <span class="hljs-comment"># 表数据</span>                        xx = self.titleLine + <span class="hljs-number">1</span>                    ws.cell(x, y).style = self.formats[<span class="hljs-string">'styles'</span>][xx][y]                    ws.cell(x, y).font = self.formats[<span class="hljs-string">'fonts'</span>][xx][y]                    ws.cell(x, y).border = self.formats[<span class="hljs-string">'borders'</span>][xx][y]                    ws.cell(x, y).fill = self.formats[<span class="hljs-string">'fills'</span>][xx][y]                    ws.cell(x, y).alignment = self.formats[<span class="hljs-string">'alignments'</span>][xx][y]                    ws.cell(x, y).number_format = self.formats[<span class="hljs-string">'number_formats'</span>][xx][y]                    ws.cell(x, y).protection = self.formats[<span class="hljs-string">'protections'</span>][xx][y]                     <span class="hljs-comment"># if x&gt;self.titleLine and self.formats['isDates'][y]:</span>                    <span class="hljs-comment">#     ws.cell(x, y).number_format = 'yyyy/mm/dd'</span>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">writeDataToNewWorkbook</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">for</span> sheetName <span class="hljs-keyword">in</span> self.data.keys():            ws = self.targetWorkbook.create_sheet(sheetName)            <span class="hljs-comment"># 写入头文字</span>            x = <span class="hljs-number">0</span>  <span class="hljs-comment"># 行号</span>            <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> self.header:                x += <span class="hljs-number">1</span>                y = <span class="hljs-number">0</span>  <span class="hljs-comment"># 列号</span>                <span class="hljs-keyword">for</span> cellValue <span class="hljs-keyword">in</span> row:                    y += <span class="hljs-number">1</span>                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> cellValue == <span class="hljs-string">''</span>:                        ws.cell(x, y).value = cellValue            <span class="hljs-comment"># 写入数据</span>            <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> self.data[sheetName]:                ws.append(row)     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clearSheetName</span><span class="hljs-params">(self, name, replaceAs=<span class="hljs-string">'-'</span>)</span>:</span>        invalidChars = <span class="hljs-string">r':\/?*[]：'</span>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> invalidChars:            name = name.replace(c, replaceAs).strip()        <span class="hljs-keyword">return</span> name     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">selectTitleLine</span><span class="hljs-params">(self)</span>:</span>        wb = xlrd.open_workbook(self.sourceFile)        ws = wb.sheet_by_index(self.sourceWorksheetIndex)         <span class="hljs-comment"># 保存一下最大行数、列数，以供其它（属性）地方使用</span>        self.sourceWorkbookMaxRow = ws.nrows        self.sourceWorkbookMaxColumn = ws.ncols         print(<span class="hljs-string">'打印所拆分工作表前10行，前5列数据：'</span>)        maxY = ws.ncols        <span class="hljs-keyword">if</span> ws.ncols &gt; <span class="hljs-number">5</span>:            maxY = <span class="hljs-number">5</span>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):            tempList = []            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> range(maxY):                tempList.append(ws.cell(x, y).value)            print(<span class="hljs-string">'第%s行：'</span> % (x + <span class="hljs-number">1</span>), tempList)         titleLine = <span class="hljs-number">2</span>        n = input(<span class="hljs-string">'\n请输入标题行所在行号[2]：'</span>).strip()        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> n == <span class="hljs-string">''</span>:            titleLine = int(n)         self.titleLine = titleLine     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make</span><span class="hljs-params">(self)</span>:</span>        self.selectSplitSheet()        self.selectTitleLine()        self.selectSplitColumn()         print(<span class="hljs-string">'开始读取数据...'</span>)        self.readData()        print(<span class="hljs-string">'开始读取格式...'</span>)        self.readCellsStyle()        print(<span class="hljs-string">'开始写入数据至分表...'</span>)        self.writeDataToNewWorkbook()        print(<span class="hljs-string">'开始写入格式至分表...'</span>)        self.writeFormatToNewWorkbook()     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save</span><span class="hljs-params">(self, filename=None)</span>:</span>        <span class="hljs-keyword">if</span> filename == <span class="hljs-literal">None</span>:            splitPath = os.path.split(self.sourceFile)            filename = splitPath[<span class="hljs-number">0</span>] + <span class="hljs-string">'/拆分_'</span> + splitPath[<span class="hljs-number">1</span>]        self.targetWorkbook.save(filename)        self.sourceWorkbook.close()        self.targetWorkbook.close()        <span class="hljs-keyword">return</span> filename  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">saveWorksheetToWorkbook</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, excelFile)</span>:</span>        self.excelFile = excelFile     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">saveTo</span><span class="hljs-params">(self, savePath=None, addNumToFilename=True)</span>:</span>        <span class="hljs-keyword">if</span> savePath == <span class="hljs-literal">None</span>:            splitPath = os.path.splitext(self.excelFile)            savePath = splitPath[<span class="hljs-number">0</span>]            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(savePath):                os.makedirs(savePath, exist_ok=<span class="hljs-literal">True</span>)         wb = openpyxl.load_workbook(self.excelFile)        sheetNames = wb.sheetnames        wb.close()         <span class="hljs-comment">#</span>        <span class="hljs-comment"># _input=input('正在保存各表至独立工作薄，文件名前是否加序号？[Y] Y/N：').strip().lower()</span>        <span class="hljs-comment"># if _input=='n':</span>        <span class="hljs-comment">#     addNumToFilename=False</span>         n=<span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> sheetName <span class="hljs-keyword">in</span> sheetNames:            n+=<span class="hljs-number">1</span>            print(<span class="hljs-string">'保存'</span>, n, sheetName)            wb = openpyxl.load_workbook(self.excelFile)            <span class="hljs-keyword">for</span> ws <span class="hljs-keyword">in</span> wb.worksheets:                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> sheetName == ws.title:                    wb.remove(ws)             xh=<span class="hljs-string">''</span>            <span class="hljs-keyword">if</span> addNumToFilename:                xh=str(n)            filename=<span class="hljs-string">'%s/%s%s.xlsx'</span> % (savePath, xh,sheetName)            wb.save(filename)            wb.close()         <span class="hljs-keyword">return</span> savePath  <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    file = <span class="hljs-string">r'C:\Users\Alterem\Desktop\汇总.xlsx'</span>    file = sys.argv[<span class="hljs-number">1</span>]    se = splitExcel(file)    <span class="hljs-comment"># file = r'C:\Users\Alterem\Desktop\2019年积分排名－2019-07-09.xlsx'</span>    <span class="hljs-comment"># se = splitExcel(file, 1, 3)</span>    se.make()    f = se.save()    print(<span class="hljs-string">'拆分汇总文件：'</span>, f)     <span class="hljs-comment"># f=r'C:\Users\Alterem\Desktop\汇总.拆分.xlsx'</span>    saveTo = saveWorksheetToWorkbook(f)    p = saveTo.saveTo()    print(<span class="hljs-string">'拆分表保存文件夹：'</span>, p)     input(<span class="hljs-string">'\n完成，按回车键退出。'</span>)</code></pre><p>欢迎提出问题</p><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>excel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lombok介绍、使用方法和总结</title>
    <link href="/2019/09/30/Lombok%E4%BB%8B%E7%BB%8D%E3%80%81%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E6%80%BB%E7%BB%93/"/>
    <url>/2019/09/30/Lombok%E4%BB%8B%E7%BB%8D%E3%80%81%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p>文章来源公众号：猿人谷</p></blockquote><h1 id="1-Lombok背景介绍"><a href="#1-Lombok背景介绍" class="headerlink" title="1 Lombok背景介绍"></a>1 Lombok背景介绍</h1><p>官方介绍如下：</p><pre><code class="hljs tex">Project Lombok makes java a spicier language by adding 'handlers' that know how to build and compile simple, boilerplate-free, not-quite-java code.</code></pre><p>大致意思是Lombok通过增加一些“处理程序”，可以让java变得简洁、快速。</p><h1 id="2-Lombok使用方法"><a href="#2-Lombok使用方法" class="headerlink" title="2 Lombok使用方法"></a>2 Lombok使用方法</h1><p>Lombok能以简单的注解形式来简化java代码，提高开发人员的开发效率。例如开发中经常需要写的javabean，都需要花时间去添加相应的getter/setter，也许还要去写构造器、equals等方法，而且需要维护，当属性多时会出现大量的getter/setter方法，这些显得很冗长也没有太多技术含量，一旦修改属性，就容易出现忘记修改对应方法的失误。</p><p>Lombok能通过注解的方式，在编译时自动为属性生成构造器、getter/setter、equals、hashcode、toString方法。出现的神奇就是在源码中没有getter和setter方法，但是在编译生成的字节码文件中有getter和setter方法。这样就省去了手动重建这些代码的麻烦，使代码看起来更简洁些。</p><p>Lombok的使用跟引用jar包一样，可以在官网（<a href="https://projectlombok.org/download）下载jar包，也可以使用maven添加依赖：" target="_blank" rel="noopener">https://projectlombok.org/download）下载jar包，也可以使用maven添加依赖：</a></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.16.20<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>接下来我们来分析Lombok中注解的具体用法。</p><h2 id="2-1-Data"><a href="#2-1-Data" class="headerlink" title="2.1 @Data"></a>2.1 @Data</h2><p>@Data注解在类上，会为类的所有属性自动生成setter/getter、equals、canEqual、hashCode、toString方法，如为final属性，则不会为该属性生成setter方法。</p><p>官方实例如下：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.AccessLevel;<span class="hljs-keyword">import</span> lombok.Setter;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> lombok.ToString;<span class="hljs-meta">@Data</span> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataExample</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;  <span class="hljs-meta">@Setter</span>(AccessLevel.PACKAGE) <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> score;  <span class="hljs-keyword">private</span> String[] tags;    <span class="hljs-meta">@ToString</span>(includeFieldNames=<span class="hljs-keyword">true</span>)  <span class="hljs-meta">@Data</span>(staticConstructor=<span class="hljs-string">"of"</span>)  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Exercise</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> T value;  &#125;&#125;</code></pre><p>如不使用Lombok，则实现如下：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataExample</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> score;  <span class="hljs-keyword">private</span> String[] tags;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DataExample</span><span class="hljs-params">(String name)</span> </span>&#123;    <span class="hljs-keyword">this</span>.name = name;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;  &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;    <span class="hljs-keyword">this</span>.age = age;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setScore</span><span class="hljs-params">(<span class="hljs-keyword">double</span> score)</span> </span>&#123;    <span class="hljs-keyword">this</span>.score = score;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getScore</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.score;  &#125;    <span class="hljs-keyword">public</span> String[] getTags() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.tags;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTags</span><span class="hljs-params">(String[] tags)</span> </span>&#123;    <span class="hljs-keyword">this</span>.tags = tags;  &#125;    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"DataExample("</span> + <span class="hljs-keyword">this</span>.getName() + <span class="hljs-string">", "</span> + <span class="hljs-keyword">this</span>.getAge() + <span class="hljs-string">", "</span> + <span class="hljs-keyword">this</span>.getScore() + <span class="hljs-string">", "</span> + Arrays.deepToString(<span class="hljs-keyword">this</span>.getTags()) + <span class="hljs-string">")"</span>;  &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canEqual</span><span class="hljs-params">(Object other)</span> </span>&#123;    <span class="hljs-keyword">return</span> other <span class="hljs-keyword">instanceof</span> DataExample;  &#125;    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">this</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> DataExample)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    DataExample other = (DataExample) o;    <span class="hljs-keyword">if</span> (!other.canEqual((Object)<span class="hljs-keyword">this</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.getName() == <span class="hljs-keyword">null</span> ? other.getName() != <span class="hljs-keyword">null</span> : !<span class="hljs-keyword">this</span>.getName().equals(other.getName())) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.getAge() != other.getAge()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">if</span> (Double.compare(<span class="hljs-keyword">this</span>.getScore(), other.getScore()) != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">if</span> (!Arrays.deepEquals(<span class="hljs-keyword">this</span>.getTags(), other.getTags())) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  &#125;    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PRIME = <span class="hljs-number">59</span>;    <span class="hljs-keyword">int</span> result = <span class="hljs-number">1</span>;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> temp1 = Double.doubleToLongBits(<span class="hljs-keyword">this</span>.getScore());    result = (result*PRIME) + (<span class="hljs-keyword">this</span>.getName() == <span class="hljs-keyword">null</span> ? <span class="hljs-number">43</span> : <span class="hljs-keyword">this</span>.getName().hashCode());    result = (result*PRIME) + <span class="hljs-keyword">this</span>.getAge();    result = (result*PRIME) + (<span class="hljs-keyword">int</span>)(temp1 ^ (temp1 &gt;&gt;&gt; <span class="hljs-number">32</span>));    result = (result*PRIME) + Arrays.deepHashCode(<span class="hljs-keyword">this</span>.getTags());    <span class="hljs-keyword">return</span> result;  &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Exercise</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> T value;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Exercise</span><span class="hljs-params">(String name, T value)</span> </span>&#123;      <span class="hljs-keyword">this</span>.name = name;      <span class="hljs-keyword">this</span>.value = value;    &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Exercise&lt;T&gt; <span class="hljs-title">of</span><span class="hljs-params">(String name, T value)</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Exercise&lt;T&gt;(name, value);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.value;    &#125;        <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">"Exercise(name="</span> + <span class="hljs-keyword">this</span>.getName() + <span class="hljs-string">", value="</span> + <span class="hljs-keyword">this</span>.getValue() + <span class="hljs-string">")"</span>;    &#125;        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canEqual</span><span class="hljs-params">(Object other)</span> </span>&#123;      <span class="hljs-keyword">return</span> other <span class="hljs-keyword">instanceof</span> Exercise;    &#125;        <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;      <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">this</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;      <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> Exercise)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;      Exercise&lt;?&gt; other = (Exercise&lt;?&gt;) o;      <span class="hljs-keyword">if</span> (!other.canEqual((Object)<span class="hljs-keyword">this</span>)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.getName() == <span class="hljs-keyword">null</span> ? other.getValue() != <span class="hljs-keyword">null</span> : !<span class="hljs-keyword">this</span>.getName().equals(other.getName())) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.getValue() == <span class="hljs-keyword">null</span> ? other.getValue() != <span class="hljs-keyword">null</span> : !<span class="hljs-keyword">this</span>.getValue().equals(other.getValue())) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;        <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PRIME = <span class="hljs-number">59</span>;      <span class="hljs-keyword">int</span> result = <span class="hljs-number">1</span>;      result = (result*PRIME) + (<span class="hljs-keyword">this</span>.getName() == <span class="hljs-keyword">null</span> ? <span class="hljs-number">43</span> : <span class="hljs-keyword">this</span>.getName().hashCode());      result = (result*PRIME) + (<span class="hljs-keyword">this</span>.getValue() == <span class="hljs-keyword">null</span> ? <span class="hljs-number">43</span> : <span class="hljs-keyword">this</span>.getValue().hashCode());      <span class="hljs-keyword">return</span> result;    &#125;  &#125;&#125;</code></pre><h2 id="2-2-Getter-Setter"><a href="#2-2-Getter-Setter" class="headerlink" title="2.2 @Getter/@Setter"></a>2.2 @Getter/@Setter</h2><p>如果觉得@Data太过残暴（因为@Data集合了@ToString、@EqualsAndHashCode、@Getter/@Setter、@RequiredArgsConstructor的所有特性）不够精细，可以使用@Getter/@Setter注解，此注解在属性上，可以为相应的属性自动生成Getter/Setter方法，示例如下：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.AccessLevel;<span class="hljs-keyword">import</span> lombok.Getter;<span class="hljs-keyword">import</span> lombok.Setter;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetterSetterExample</span> </span>&#123;  <span class="hljs-meta">@Getter</span> <span class="hljs-meta">@Setter</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age = <span class="hljs-number">10</span>;    <span class="hljs-meta">@Setter</span>(AccessLevel.PROTECTED) <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">"%s (age: %d)"</span>, name, age);  &#125;&#125;</code></pre><p>如果不使用Lombok：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetterSetterExample</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age = <span class="hljs-number">10</span>;  <span class="hljs-keyword">private</span> String name;    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">"%s (age: %d)"</span>, name, age);  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> age;  &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;    <span class="hljs-keyword">this</span>.age = age;  &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;    <span class="hljs-keyword">this</span>.name = name;  &#125;&#125;</code></pre><h2 id="2-3-NonNull"><a href="#2-3-NonNull" class="headerlink" title="2.3 @NonNull"></a>2.3 @NonNull</h2><p>该注解用在属性或构造器上，Lombok会生成一个非空的声明，可用于校验参数，能帮助避免空指针。</p><p>示例如下：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.NonNull;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonNullExample</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Something</span> </span>&#123;  <span class="hljs-keyword">private</span> String name;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NonNullExample</span><span class="hljs-params">(@NonNull Person person)</span> </span>&#123;    <span class="hljs-keyword">super</span>(<span class="hljs-string">"Hello"</span>);    <span class="hljs-keyword">this</span>.name = person.getName();  &#125;&#125;</code></pre><p>不使用Lombok：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.NonNull;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonNullExample</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Something</span> </span>&#123;  <span class="hljs-keyword">private</span> String name;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NonNullExample</span><span class="hljs-params">(@NonNull Person person)</span> </span>&#123;    <span class="hljs-keyword">super</span>(<span class="hljs-string">"Hello"</span>);    <span class="hljs-keyword">if</span> (person == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"person"</span>);    &#125;    <span class="hljs-keyword">this</span>.name = person.getName();  &#125;&#125;</code></pre><h2 id="2-4-Cleanup"><a href="#2-4-Cleanup" class="headerlink" title="2.4 @Cleanup"></a>2.4 @Cleanup</h2><p>该注解能帮助我们自动调用close()方法，很大的简化了代码。</p><p>示例如下：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.Cleanup;<span class="hljs-keyword">import</span> java.io.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CleanupExample</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-meta">@Cleanup</span> InputStream in = <span class="hljs-keyword">new</span> FileInputStream(args[<span class="hljs-number">0</span>]);    <span class="hljs-meta">@Cleanup</span> OutputStream out = <span class="hljs-keyword">new</span> FileOutputStream(args[<span class="hljs-number">1</span>]);    <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10000</span>];    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;      <span class="hljs-keyword">int</span> r = in.read(b);      <span class="hljs-keyword">if</span> (r == -<span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;      out.write(b, <span class="hljs-number">0</span>, r);    &#125;  &#125;&#125;</code></pre><p>如不使用Lombok，则需如下：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CleanupExample</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    InputStream in = <span class="hljs-keyword">new</span> FileInputStream(args[<span class="hljs-number">0</span>]);    <span class="hljs-keyword">try</span> &#123;      OutputStream out = <span class="hljs-keyword">new</span> FileOutputStream(args[<span class="hljs-number">1</span>]);      <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10000</span>];        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;          <span class="hljs-keyword">int</span> r = in.read(b);          <span class="hljs-keyword">if</span> (r == -<span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;          out.write(b, <span class="hljs-number">0</span>, r);        &#125;      &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (out != <span class="hljs-keyword">null</span>) &#123;          out.close();        &#125;      &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;      <span class="hljs-keyword">if</span> (in != <span class="hljs-keyword">null</span>) &#123;        in.close();      &#125;    &#125;  &#125;&#125;</code></pre><h2 id="2-5-EqualsAndHashCode"><a href="#2-5-EqualsAndHashCode" class="headerlink" title="2.5 @EqualsAndHashCode"></a>2.5 @EqualsAndHashCode</h2><p>默认情况下，会使用所有非静态（non-static）和非瞬态（non-transient）属性来生成equals和hasCode，也能通过exclude注解来排除一些属性。</p><p>示例如下：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.EqualsAndHashCode;<span class="hljs-meta">@EqualsAndHashCode</span>(exclude=&#123;<span class="hljs-string">"id"</span>, <span class="hljs-string">"shape"</span>&#125;)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EqualsAndHashCodeExample</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> transientVar = <span class="hljs-number">10</span>;  <span class="hljs-keyword">private</span> String name;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> score;  <span class="hljs-keyword">private</span> Shape shape = <span class="hljs-keyword">new</span> Square(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);  <span class="hljs-keyword">private</span> String[] tags;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;  &#125;    <span class="hljs-meta">@EqualsAndHashCode</span>(callSuper=<span class="hljs-keyword">true</span>)  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> width, height;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Square</span><span class="hljs-params">(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span> </span>&#123;      <span class="hljs-keyword">this</span>.width = width;      <span class="hljs-keyword">this</span>.height = height;    &#125;  &#125;&#125;</code></pre><h2 id="2-6-ToString"><a href="#2-6-ToString" class="headerlink" title="2.6 @ToString"></a>2.6 @ToString</h2><p>类使用@ToString注解，Lombok会生成一个toString()方法，默认情况下，会输出类名、所有属性（会按照属性定义顺序），用逗号来分割。</p><p>通过将<code>includeFieldNames</code>参数设为true，就能明确的输出toString()属性。这一点是不是有点绕口，通过代码来看会更清晰些。</p><p>使用Lombok的示例：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.ToString;<span class="hljs-meta">@ToString</span>(exclude=<span class="hljs-string">"id"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ToStringExample</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STATIC_VAR = <span class="hljs-number">10</span>;  <span class="hljs-keyword">private</span> String name;  <span class="hljs-keyword">private</span> Shape shape = <span class="hljs-keyword">new</span> Square(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);  <span class="hljs-keyword">private</span> String[] tags;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getName();  &#125;    <span class="hljs-meta">@ToString</span>(callSuper=<span class="hljs-keyword">true</span>, includeFieldNames=<span class="hljs-keyword">true</span>)  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> width, height;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Square</span><span class="hljs-params">(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span> </span>&#123;      <span class="hljs-keyword">this</span>.width = width;      <span class="hljs-keyword">this</span>.height = height;    &#125;  &#125;&#125;</code></pre><p>不使用Lombok的示例如下：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ToStringExample</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STATIC_VAR = <span class="hljs-number">10</span>;  <span class="hljs-keyword">private</span> String name;  <span class="hljs-keyword">private</span> Shape shape = <span class="hljs-keyword">new</span> Square(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);  <span class="hljs-keyword">private</span> String[] tags;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getName();  &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> width, height;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Square</span><span class="hljs-params">(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span> </span>&#123;      <span class="hljs-keyword">this</span>.width = width;      <span class="hljs-keyword">this</span>.height = height;    &#125;        <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">"Square(super="</span> + <span class="hljs-keyword">super</span>.toString() + <span class="hljs-string">", width="</span> + <span class="hljs-keyword">this</span>.width + <span class="hljs-string">", height="</span> + <span class="hljs-keyword">this</span>.height + <span class="hljs-string">")"</span>;    &#125;  &#125;    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"ToStringExample("</span> + <span class="hljs-keyword">this</span>.getName() + <span class="hljs-string">", "</span> + <span class="hljs-keyword">this</span>.shape + <span class="hljs-string">", "</span> + Arrays.deepToString(<span class="hljs-keyword">this</span>.tags) + <span class="hljs-string">")"</span>;  &#125;&#125;</code></pre><h2 id="2-7-NoArgsConstructor-RequiredArgsConstructor-and-AllArgsConstructor"><a href="#2-7-NoArgsConstructor-RequiredArgsConstructor-and-AllArgsConstructor" class="headerlink" title="2.7 @NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor"></a>2.7 @NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor</h2><p>无参构造器、部分参数构造器、全参构造器。Lombok没法实现多种参数构造器的重载。</p><p>Lombok示例代码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.AccessLevel;<span class="hljs-keyword">import</span> lombok.RequiredArgsConstructor;<span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<span class="hljs-keyword">import</span> lombok.NonNull;<span class="hljs-meta">@RequiredArgsConstructor</span>(staticName = <span class="hljs-string">"of"</span>)<span class="hljs-meta">@AllArgsConstructor</span>(access = AccessLevel.PROTECTED)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConstructorExample</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> x, y;  <span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">private</span> T description;    <span class="hljs-meta">@NoArgsConstructor</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoArgsExample</span> </span>&#123;    <span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">private</span> String field;  &#125;&#125;</code></pre><p>不使用Lombok的示例如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConstructorExample</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> x, y;  <span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">private</span> T description;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ConstructorExample</span><span class="hljs-params">(T description)</span> </span>&#123;    <span class="hljs-keyword">if</span> (description == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"description"</span>);    <span class="hljs-keyword">this</span>.description = description;  &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">ConstructorExample&lt;T&gt; <span class="hljs-title">of</span><span class="hljs-params">(T description)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConstructorExample&lt;T&gt;(description);  &#125;    <span class="hljs-meta">@java</span>.beans.ConstructorProperties(&#123;<span class="hljs-string">"x"</span>, <span class="hljs-string">"y"</span>, <span class="hljs-string">"description"</span>&#125;)  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">ConstructorExample</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, T description)</span> </span>&#123;    <span class="hljs-keyword">if</span> (description == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"description"</span>);    <span class="hljs-keyword">this</span>.x = x;    <span class="hljs-keyword">this</span>.y = y;    <span class="hljs-keyword">this</span>.description = description;  &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoArgsExample</span> </span>&#123;    <span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">private</span> String field;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NoArgsExample</span><span class="hljs-params">()</span> </span>&#123;    &#125;  &#125;&#125;</code></pre><h1 id="3-Lombok工作原理分析"><a href="#3-Lombok工作原理分析" class="headerlink" title="3 Lombok工作原理分析"></a>3 Lombok工作原理分析</h1><p>会发现在Lombok使用的过程中，只需要添加相应的注解，无需再为此写任何代码。自动生成的代码到底是如何产生的呢？</p><p>核心之处就是对于注解的解析上。JDK5引入了注解的同时，也提供了两种解析方式。</p><ul><li>运行时解析</li></ul><p>运行时能够解析的注解，必须将@Retention设置为RUNTIME，这样就可以通过反射拿到该注解。java.lang,reflect反射包中提供了一个接口AnnotatedElement，该接口定义了获取注解信息的几个方法，Class、Constructor、Field、Method、Package等都实现了该接口，对反射熟悉的朋友应该都会很熟悉这种解析方式。</p><ul><li>编译时解析</li></ul><p>编译时解析有两种机制，分别简单描述下：</p><p>1）Annotation Processing Tool</p><p>apt自JDK5产生，JDK7已标记为过期，不推荐使用，JDK8中已彻底删除，自JDK6开始，可以使用Pluggable Annotation Processing API来替换它，apt被替换主要有2点原因：</p><ul><li>api都在com.sun.mirror非标准包下</li><li>没有集成到javac中，需要额外运行</li></ul><p>2）Pluggable Annotation Processing API</p><p><a href="https://jcp.org/en/jsr/detail?id=269" target="_blank" rel="noopener">JSR 269</a>自JDK6加入，作为apt的替代方案，它解决了apt的两个问题，javac在执行的时候会调用实现了该API的程序，这样我们就可以对编译器做一些增强，这时javac执行的过程如下：</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymsf9xjbj30go0230sq.jpg" srcset="/img/loading.gif" alt="123"></p><p>Lombok本质上就是一个实现了“<a href="https://www.jcp.org/en/jsr/detail?id=269" target="_blank" rel="noopener">JSR 269 API</a>”的程序。在使用javac的过程中，它产生作用的具体流程如下：</p><ol><li>javac对源代码进行分析，生成了一棵抽象语法树（AST）</li><li>运行过程中调用实现了“JSR 269 API”的Lombok程序</li><li>此时Lombok就对第一步骤得到的AST进行处理，找到@Data注解所在类对应的语法树（AST），然后修改该语法树（AST），增加getter和setter方法定义的相应树节点</li><li>javac使用修改后的抽象语法树（AST）生成字节码文件，即给class增加新的节点（代码块）</li></ol><p>拜读了Lombok源码，对应注解的实现都在HandleXXX中，比如@Getter注解的实现时HandleGetter.handle()。还有一些其它类库使用这种方式实现，比如<a href="https://github.com/google/auto" target="_blank" rel="noopener">Google Auto</a>、<a href="http://square.github.io/dagger/" target="_blank" rel="noopener">Dagger</a>等等。</p><h1 id="4-Lombok的优缺点"><a href="#4-Lombok的优缺点" class="headerlink" title="4. Lombok的优缺点"></a>4. Lombok的优缺点</h1><p>优点：</p><ol><li>能通过注解的形式自动生成构造器、getter/setter、equals、hashcode、toString等方法，提高了一定的开发效率</li><li>让代码变得简洁，不用过多的去关注相应的方法</li><li>属性做修改时，也简化了维护为这些属性所生成的getter/setter方法等</li></ol><p>缺点：</p><ol><li>不支持多种参数构造器的重载</li><li>虽然省去了手动创建getter/setter方法的麻烦，但大大降低了源代码的可读性和完整性，降低了阅读源代码的舒适度</li></ol><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>Lombok虽然有很多优点，但Lombok更类似于一种IDE插件，项目也需要依赖相应的jar包。Lombok依赖jar包是因为编译时要用它的注解，为什么说它又类似插件？因为在使用时，eclipse或IntelliJ IDEA都需要安装相应的插件，在编译器编译时通过操作AST（抽象语法树）改变字节码生成，变向的就是说它在改变java语法。它不像spring的依赖注入或者mybatis的ORM一样是运行时的特性，而是编译时的特性。这里我个人最感觉不爽的地方就是对插件的依赖！因为Lombok只是省去了一些人工生成代码的麻烦，但IDE都有快捷键来协助生成getter/setter等方法，也非常方便。</p><p>知乎上有位大神发表过对Lombok的一些看法：</p><pre><code class="hljs tex">这是一种低级趣味的插件，不建议使用。JAVA发展到今天，各种插件层出不穷，如何甄别各种插件的优劣？能从架构上优化你的设计的，能提高应用程序性能的 ，实现高度封装可扩展的...， 像lombok这种，像这种插件，已经不仅仅是插件了，改变了你如何编写源码，事实上，少去了代码你写上去又如何？ 如果JAVA家族到处充斥这样的东西，那只不过是一坨披着金属颜色的屎，迟早会被其它的语言取代。</code></pre><p>虽然话糙但理确实不糙，试想一个项目有非常多类似Lombok这样的插件，个人觉得真的会极大的降低阅读源代码的舒适度。</p><p>虽然非常不建议在属性的getter/setter写一些业务代码，但在多年项目的实战中，有时通过给getter/setter加一点点业务代码，能极大的简化某些业务场景的代码。所谓取舍，也许就是这时的舍弃一定的规范，取得极大的方便。</p><p>我现在非常坚信一条理念，任何编程语言或插件，都仅仅只是工具而已，即使工具再强大也在于用的人，就如同小米加步枪照样能赢飞机大炮的道理一样。结合具体业务场景和项目实际情况，无需一味追求高大上的技术，适合的才是王道。</p><p>Lombok有它的得天独厚的优点，也有它避之不及的缺点，熟知其优缺点，在实战中灵活运用才是王道。</p><p>参考：</p><p><a href="https://projectlombok.org/features/" target="_blank" rel="noopener">https://projectlombok.org/features/</a></p><p><a href="https://github.com/rzwitserloot/lombok?spm=a2c4e.11153940.blogcont59972.5.2aeb6d32hayLHv" target="_blank" rel="noopener">https://github.com/rzwitserloot/lombok?spm=a2c4e.11153940.blogcont59972.5.2aeb6d32hayLHv</a></p><p><a href="https://www.zhihu.com/question/42348457" target="_blank" rel="noopener">https://www.zhihu.com/question/42348457</a></p><p><a href="https://blog.csdn.net/ghsau/article/details/52334762" target="_blank" rel="noopener">https://blog.csdn.net/ghsau/article/details/52334762</a></p><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高可用的一些思考和理解</title>
    <link href="/2019/09/29/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E5%92%8C%E7%90%86%E8%A7%A3/"/>
    <url>/2019/09/29/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E5%92%8C%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文来源公众号：匠心零度</p></blockquote><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymp28hfsj30hs0c3752.jpg" srcset="/img/loading.gif" alt="img"></p><p>在目前的互联网大时代，在高并发等冲击下，还必须保证<strong>服务高可用</strong>，如果服务不高可用那么意味着：</p><ul><li>系统不是7*24小时提供服务，那么用户体验就特别差了，可能用户下次不用了，留不住用户。</li><li>当系统不可用的时候，对公司的形象是有所影响的，BAT类似这种技术都是象征的。</li><li>最重要的一点，当系统不可用的时候，直接损失就是金钱！！！基本都是秒算损失的，依稀记得<strong>2015年5月28日携程网瘫痪事件</strong>，按照携程一季度财报公布的数据，携程宕机的损失为平均每小时106.48万美元。</li></ul><p>高可用是非常复杂的，自己水平有限，并不能涵盖那么多，只能说是自己对高可用的一些思考和理解。</p><h2 id="那么怎么使系统高可用呢？"><a href="#那么怎么使系统高可用呢？" class="headerlink" title="那么怎么使系统高可用呢？"></a>那么怎么使系统高可用呢？</h2><blockquote><p>我们不能让服务器不挂，让服务不挂，那么怎么样让这种必败的局面不会有问题呢，就是可以挂，服务可以坏，那么怎么让系统还可以提供服务呢？</p></blockquote><p>首先如果机器有很多，服务有很多，就算坏了一部分也没有问题啊，必败的局面得到的解决。下面进行一步一步剖析，如果机器里面存储了特定值，那么就不能扩展，必须是用挂的那台机器，那么这个是不行的，机器问题好解决，相同的配置替代是容易的，那么应用服务也是类似，应用服务可以不存储状态有关的值在任何机器而自己内部不会有存储一些特定的特征数据，如果有就没办法很容易的扩展，只有当每个主件都是一样的时候，无任何差异，我们才好替换，容易扩展，那么这个就叫着<strong>服务的无状态化。</strong></p><blockquote><p>假如目前服务已经是无状态化了，那么如何让系统动态的感知到服务挂了呢？不然请求还是回去到挂的那台机器，怎么转移到新的机器呢？那么可能就需要<strong>服务发现与注册了。</strong></p><p>如果达到了上面的情况，应对一般的情况基本已经够了，但是互联网是复杂的，刚刚说的机器坏，服务坏了的问题，那么如果网络出现短暂不通因为怎么办呢？</p></blockquote><p>所以服务之间应该有<strong>心跳的检测，</strong>来定期看看是否可通（机器坏了，服务挂了，网络不通了）反正就是不可达了。这种情况通过服务注册与发现即可解决，但是有时候网络是闪断下那么在那种特定的情况呢？比如刚刚a服务已经把请求发送给了b服务，b服务已经接收到请求了，那么这个时候忽然网络断了，但是b服务进行把逻辑处理做完成了，但是a服务反应的就是没有响应，前台超时了，那么再一次触发下，那么如果b服务把之前的逻辑再做一遍是否存在问题呢？ 比如支付，已经付款200元，难道再付款200元吗？这里需要提到一个<strong>幂等性</strong>的设计概念，什么是幂等呢，就是多次执行结果都一样，如果有幂等性设计那么就不怕这种情况了，在没有得到反馈情况<strong>重试</strong>即可，也不会出现问题。</p><blockquote><p>达到上面说的这些就是应对机器坏了，服务挂了，网络不通或者闪断等情况已经基本没有什么大问题了，那么目前互联网都是高并发，那么在高并发的情况，如何来提高系统的能力的？</p></blockquote><p>就和搬东西一样，一个人慢，可以多来点人一起帮东西，由于上面的架构是可以添加机器，服务的，那么很容易想到的就是多来点机器和服务。那么这样一定比机器少要快的，比如有5台机器，那么很多请求过来了，用什么策略让他们分摊到不同的机器呢？通过设备，通过一些软件层面，但是其中一定有服务发现注册，不然没办法动态知道节点变化，还有就是对一些信息的控制，黑白名单，访问频率等。<strong>很多时候，加机器可能看起来比较low，但是有时候的确比较有效，但是也不能一味的加机器，有些情况加机器是解决不了的了。</strong></p><p>机器多了的确快了，如果在服务里面有一个阻塞方法，那么就算服务在多也没用，所以必须注意关于<strong>服务超时的问题，</strong>由于服务是幂等的，就算再次执行也没有任何关系，有了超时就不会卡很久影响到后面的服务了（下游服务宕机了，线程死锁了，下游服务忙等等）。</p><p>关于同步，异步的一些设计模式，在有些必须顺序执行的业务场景就必须要使用同步了，在非必须的这种场景那么用异步一定比同步处理的并发量要大（由于中间件经历很多步骤，所以从单个请求的总时间来看并不一定有同步的快，但是从一个宏观的角度来看提高并发的请求会大很多了）。简单聊聊异步，在一个服务内部，异步那么就需要提到多线程了，多线程很多有点提高cpu利用率，提高系统性能，但是实现成本要高很多了，那么不同服务直接的如何异步呢，消息中间件了，（消息中间件很难，第一要保证<strong>真异步，</strong>第二需要保证<strong>不重不漏</strong>，就这2点真的很难，特别是在大数据情况下），特别是网络I/O需要重点考虑异步模型，不过Netty封装的挺好了。</p><blockquote><p>由于每个机器，或者服务都是有上限的，如果量一下泄洪式的过来并且不是他的能力可以处理的，那么该如果解决呢？</p></blockquote><p>该问题在生活中到处可见，刚刚好国庆回家、出去玩，随处可见该事项体现，比如过安检的时候，有一个保安专门拿一个牌看人差不多了，让后面的人等，等处理的查不多了，在让后面的人进行，之后类似在等。，但是如果有级别高的，或者车快发车了，一般让他们先过，在软件架构里面应该叫<strong>限流、服务降级，</strong>一般有两种控制策略（1，拒绝部分请求，2，关闭部分服务）可能之前的时候都提到了关闭部分服务，不过现在不推荐了（<strong>毕竟也是公司技术实力的体现</strong>），目前重点说的是关于拒绝部分请求，关于这块的控制在那里添加？就是那块需要控制，应该每层都需要加下该控制。</p><p>依稀记得行业里面有句话，<strong>高并发、高可用三大法宝：限流、降级、缓存</strong>，关于缓存，大家应该接触的最多，互联网业务特点就是读多写少，那么就非常适合使用缓存了。</p><blockquote><p>由于所以请求在一个服务，扩展还是不好扩展，而且统一服务里面有些调用特别多，有些调用就比较少，因为继续划分，继续拆，这样还是可以再次提高并发。</p></blockquote><p><strong>微服务了，</strong>微服务概念很多，首先提到的就是搞垂直拆分，很容易理解，之后垂直业务可能也很多，还需要继续水平拆分，（这里一切的拆分依据都是根据自己公司的业务，理解越深才的越好）。</p><p>通过上面的这些，服务可以挂，机器可以坏，网络不通或者闪断的问题都解决了，并且可以提高并发，尽最大努力来让服务高可用。<strong>那么由于这么做带来了很多问题，</strong>所以需要把这些修改带来的问题解决：</p><ul><li>以前在一个服务里面，对于事务的控制很容易，那么微服务之后，事务的控制就显的特别重要了，很多时候我们不能强一致性，但是我们可以做到<strong>最终一致性</strong>就是可以的。</li><li>调用链监控也就显得特别重要了，一起的还有预警也特别重要了。</li><li>分布式日志也显得特别重要了。</li><li>高级的jstack、Btrace在真实环境就是特别重要的。</li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><blockquote><p>本人水平有限，难免会有一些理解偏差的地方，如果发现，欢迎各位积极指出，感谢！！！</p></blockquote><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee-20200407102957991.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>高可用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Python】哄女朋友的那些奇技淫巧</title>
    <link href="/2019/09/27/%E3%80%90Python%E3%80%91%E5%93%84%E5%A5%B3%E6%9C%8B%E5%8F%8B%E7%9A%84%E9%82%A3%E4%BA%9B%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    <url>/2019/09/27/%E3%80%90Python%E3%80%91%E5%93%84%E5%A5%B3%E6%9C%8B%E5%8F%8B%E7%9A%84%E9%82%A3%E4%BA%9B%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文来源公众号： <strong>Python乱炖</strong></p><img src="https://mp.weixin.qq.com/mp/qrcode?scene=10000004&size=102&__biz=MzU1NDcwNTE2OA==&mid=2247486190&idx=1&sn=a1707f91b23d437f758131818d73dda4&send_time=" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" /></blockquote><h3 id="Python里面的奇技淫巧"><a href="#Python里面的奇技淫巧" class="headerlink" title="Python里面的奇技淫巧"></a>Python里面的奇技淫巧</h3><blockquote><p><strong>声明</strong></p><p><strong>“以下所有模块均可</strong></p><p><strong>使用pip直接安装”</strong></p></blockquote><p><strong>说python是</strong></p><p><strong>所有编程语言里面</strong></p><p><strong>最奇葩的语言</strong></p><p><strong>这肯定是没错了</strong></p><p><strong>它可以做</strong></p><p><strong>自动化，爬虫，数据，AI，机器学习</strong></p><p><strong>这些我们暂且不说</strong></p><p><strong>可是它竟然还可以</strong></p><p><strong>撩妹</strong></p><p><strong>撩到妹</strong></p><p><strong>定位女朋友</strong></p><p><strong>和女朋友聊天</strong></p><p><strong>天天和女朋友早晚安</strong></p><p><strong>给女朋友打电话</strong></p><p><strong>讨女朋友开心</strong></p><p><strong>让女朋友崇拜你</strong></p><p><strong>………</strong></p><p><strong>怎么样？</strong></p><p><strong>够厉害吧</strong></p><p><strong>赶紧跟着狗哥</strong></p><p><strong>来看看python里面的奇技淫巧吧！</strong></p><h3 id="pinyin"><a href="#pinyin" class="headerlink" title="pinyin"></a>pinyin</h3><p><strong>第一个就是我们的pinyin模块了，这个模块骚就骚在可以直接把中文汉字转化成中文的汉语拼音，甚至连第几声发音都可以给你搞出来，具体使用很简单，导入后直接使用get方法即可：</strong></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> pinyintransf = pinyin.get(<span class="hljs-string">"狗哥"</span>)trans2 = pinyin.get(<span class="hljs-string">"狗哥"</span>, format=<span class="hljs-string">"strip"</span>)</code></pre><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymoss66zj30q70g7q3p.jpg" srcset="/img/loading.gif" alt="img"></p><h3 id="qrcode"><a href="#qrcode" class="headerlink" title="qrcode"></a>qrcode</h3><p><strong>下面这个是我们的二维码生成器，可以将文字，号码，网址存放在二维码中，只需要只用make方法去生成二维码，如何使用save方法保存二维码图片即可。很简单的两部搞定！下面我们来看一个栗子：</strong></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> qrcodewords=<span class="hljs-string">'https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzU1NDcwNTE2OA==&amp;scene=126#wechat_redirect'</span>img = qrcode.make(words)img.save(<span class="hljs-string">'test.png'</span>)img.show()</code></pre><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymou71fqj30u00g70ts.jpg" srcset="/img/loading.gif" alt="img"></p><h3 id="myqr"><a href="#myqr" class="headerlink" title="myqr"></a>myqr</h3><p><strong>如果说刚刚的qrcode已经足够神奇了的话，那这个将会更加神奇，因为它可以以图片为背景来生成二维码，背景图片可以是动态gif也可以是静态jpg，png，整个生成二维码的步骤也要比上面简单许多，你甚至都不需要敲代码就可以享受到动态二维码的美好，可以直接在终端（cmd）敲一句口令即可生成二维码！（需要安装好myqr）</strong></p><pre><code class="hljs bash">myqr <span class="hljs-string">"https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzU1NDcwNTE2OA==&amp;scene=126#wechat_redirect"</span> -v 1 -l Q -n <span class="hljs-string">"s_qr.gif"</span> -p s.gif -con 1.2 -bri 1.2 -c</code></pre><p><strong>整个口令你需要修改的就是：</strong></p><p><strong>url网址修改成你需要的</strong></p><p><strong>s.gif修改成你自己图片的地址</strong></p><p><strong>其他的参数你不知道什么意思均可以不动</strong></p><p><strong>如果想了解具体参数是什么意思，可参考狗哥公众号内python生成二维码那片文章。</strong></p><p><strong>效果如下：</strong></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymow2exxg30e90e9qk3.gif" srcset="/img/loading.gif" alt="img"></p><h3 id="jieba"><a href="#jieba" class="headerlink" title="jieba"></a>jieba</h3><p><strong>jieba，真的就是结巴的意思，主要是用来进行分词的。</strong></p><p><strong>jieba 可以**</strong>把一句话拆分成多个词。**</p><p><strong>从一句话（一段话）中提取最重要的几个关键词。</strong></p><p><strong>最常用的功能应该就是这些吧，分词之后结合 TF-IDF，就可以做搜索工具和相关推荐了。</strong></p><p><strong>狗哥推荐：结合本次推荐的这些模块，使用结巴工具来和女朋友聊天，是个不错的主意！</strong></p><p>下面看看切割示范：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> jiebastring = <span class="hljs-string">"大家都说狗哥好，狗哥帅气人又好"</span>sl = jieba.cut(string, cut_all=<span class="hljs-literal">True</span>)print(<span class="hljs-string">'全的模式:'</span>, list(sl))sl = jieba.cut(string, cut_all=<span class="hljs-literal">False</span>)print(<span class="hljs-string">"精确模式:"</span>, list(sl))sl = jieba.cut(string)print(<span class="hljs-string">'搜索模式:'</span>, list(sl))</code></pre><p><strong>结巴还有很多高级的方法，希望大家多多发掘，如果实在懒，在狗哥的公众号里面搜一下也就找到了。</strong></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymowyfkmj30u0042dgw.jpg" srcset="/img/loading.gif" alt="img"></p><p><strong>itchat/wxpy</strong></p><p><strong>itchat和wxpy这两个模块功能都差不多，都是用于微信聊天的，可以用来获取朋友圈好友的数据，也可以用来和好友聊天自动回复等等。（接上图灵机器人也是无敌了）</strong></p><p><strong>使用itchat很简单，导入模块后调用login方法便可以直接扫码登陆了：</strong></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> itchatitchat.login()</code></pre><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymoxyhxhj30u00h0ac1.jpg" srcset="/img/loading.gif" alt="img"></p><p><strong>登陆了之后可以通过get_friends方法获取到所有的微信好友</strong></p><pre><code class="hljs python">friends = itchat.get_friends(update=<span class="hljs-literal">True</span>)[<span class="hljs-number">0</span>:]</code></pre><p><strong>至于获取微信好友要干啥，那就随你了，狗哥直接教你发送消息吧，直接使用send方法指明发送对象即可：</strong></p><pre><code class="hljs python">users = itchat.search_friends(<span class="hljs-string">"亲爱的"</span>)userName = users[<span class="hljs-number">0</span>][<span class="hljs-string">'UserName'</span>]print(userName)itchat.send(<span class="hljs-string">'亲爱的，送你一个杨树林要不要？'</span>, toUserName=userName)</code></pre><p><strong>这边狗哥直接选择了一个用户直接发送消息</strong></p><p><strong>当然，我们除了发送消息，还可以设置自动回复：</strong></p><p><strong>定义几个方法，调用itchat自带的装饰器即可：</strong></p><pre><code class="hljs python"><span class="hljs-keyword">from</span> itchat.content <span class="hljs-keyword">import</span> *<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reply</span><span class="hljs-params">(msg)</span>:</span>   itchat.send((<span class="hljs-string">'23333'</span>), msg[<span class="hljs-string">'FromUserName'</span>])<span class="hljs-meta">@itchat.msg_register([PICTURE])</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pic_replay</span><span class="hljs-params">(msg)</span>:</span>   itchat.send((<span class="hljs-string">'最近又漂亮了'</span>),           msg[<span class="hljs-string">'FromUserName'</span>])<span class="hljs-meta">@itchat.msg_register([RECORDING])</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rec_replay</span><span class="hljs-params">(msg)</span>:</span>   itchat.send((<span class="hljs-string">'连声音都是这么迷人'</span>),           msg[<span class="hljs-string">'FromUserName'</span>])<span class="hljs-meta">@itchat.msg_register([VIDEO,])</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">video_replay</span><span class="hljs-params">(msg)</span>:</span>   itchat.send((<span class="hljs-string">'我没流量了，视频打不开啊'</span>),           msg[<span class="hljs-string">'FromUserName'</span>])<span class="hljs-meta">@itchat.msg_register([SHARING])</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">share_replay</span><span class="hljs-params">(msg)</span>:</span>   itchat.send((<span class="hljs-string">'这链接我这么怎么点不进去啊'</span>),           msg[<span class="hljs-string">'FromUserName'</span>])</code></pre><p><strong>没错定义好回复的对象，只要登陆上了，这些回复就会生效了！</strong></p><p><strong>狗哥测试的一个例子：</strong></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymozpmrzj30a20ftdg9.jpg" srcset="/img/loading.gif" alt="img"></p><h3 id="wordcloud"><a href="#wordcloud" class="headerlink" title="wordcloud"></a>wordcloud</h3><p><strong>下面这个看起来比较鬼畜，但是其实在数据可视化里面它的用处还是比较强大的。</strong></p><p><strong>词云这个东西一般与numpy，matplotlib，jieba，pillow连用，用起来也是挺麻烦的</strong></p><p><strong>狗哥这里整理了一个简单的版本供大家参考：</strong></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<span class="hljs-keyword">import</span> re<span class="hljs-keyword">import</span> jieba<span class="hljs-keyword">from</span> wordcloud <span class="hljs-keyword">import</span> WordCloud,\   ImageColorGenerator,\   STOPWORDS<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">with</span> open(<span class="hljs-string">'content.txt'</span>, <span class="hljs-string">'r'</span>, encoding=<span class="hljs-string">'utf-8'</span>) <span class="hljs-keyword">as</span> f:   word = (f.read())   f.close()<span class="hljs-comment"># 图片模板和字体</span>image = np.array(Image.open(<span class="hljs-string">'ditu.jpg'</span>))font = <span class="hljs-string">r'C:\\Windows\\fonts\\msyh.ttf'</span><span class="hljs-comment"># 去掉英文，保留中文</span>resultword = re.sub(<span class="hljs-string">"[A-Za-z0-9\[\`\~\!\@\#\$\^\&amp;\*\(\)\=\|\&#123;\&#125;"</span>                   <span class="hljs-string">"\'\:\;\'\,\[\]\.\&lt;\&gt;\/\?\~\。\@\#\\\&amp;\*\%]"</span>,                   <span class="hljs-string">""</span>, word)wordlist_after_jieba = jieba.cut(resultword)wl_space_split = <span class="hljs-string">" "</span>.join(wordlist_after_jieba)<span class="hljs-comment"># 设置停用词</span>sw = set(STOPWORDS)<span class="hljs-comment"># 关键一步</span>my_wordcloud = WordCloud(scale=<span class="hljs-number">4</span>,                        font_path=font,                        mask=image,                        stopwords=sw,                        background_color=<span class="hljs-string">'white'</span>,                        max_words=<span class="hljs-number">100</span>,                        max_font_size=<span class="hljs-number">60</span>,                        random_state=<span class="hljs-number">20</span>).\   generate(wl_space_split)<span class="hljs-comment"># 显示生成的词云</span>plt.imshow(my_wordcloud)plt.axis(<span class="hljs-string">"off"</span>)plt.show()<span class="hljs-comment"># 保存生成的图片</span>my_wordcloud.to_file(<span class="hljs-string">'result.jpg'</span>)</code></pre><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymp0rpdnj30oo0e1n02.jpg" srcset="/img/loading.gif" alt="img"></p><p>欢迎关注微信公众号​：</p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SonarQube的使用-在idea&amp;eclipse中安装与使用sonarlint</title>
    <link href="/2019/09/26/SonarQube%E7%9A%84%E4%BD%BF%E7%94%A8-%E5%9C%A8idea&amp;eclipse%E4%B8%AD%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8sonarlint/"/>
    <url>/2019/09/26/SonarQube%E7%9A%84%E4%BD%BF%E7%94%A8-%E5%9C%A8idea&amp;eclipse%E4%B8%AD%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8sonarlint/</url>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h3><p>​        代码质量管理的开源平台，用于管理源代码的质量 通过插件形式，可以支持包括java,C#,C/C++,PL/SQL,Cobol,JavaScrip,Groovy等等二十几种编程语言的代码质量管理与检测。集成了CheckStyle，PMD，Findbugs等工具校验规则，具有重复代码发现，代码测试覆盖率，代码注释率，及所有的检测率变化追踪的功能特性。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h3><p>​        SonarQube:开源的代码质量管控平台，我们使用的<a href="http://localhost:9000即为SonarQube。">http://localhost:9000即为SonarQube。</a></p><p>​        SonarLint:一个扩展插件，可以安装在idea与eclipse等开发工具中</p><h3 id="Eclipse中的使用"><a href="#Eclipse中的使用" class="headerlink" title="Eclipse中的使用"></a><strong>Eclipse中的使用</strong></h3><h4 id="1、-安装"><a href="#1、-安装" class="headerlink" title="1、  安装"></a>1、  安装</h4><p>​            help -&gt; eclipse marketplace…，搜索sonarlint, Install。</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ympesx0zj30u00xmtba.jpg" srcset="/img/loading.gif" alt="eclipse marketplace"></p><h4 id="2、-使用"><a href="#2、-使用" class="headerlink" title="2、  使用"></a>2、  使用</h4><p>打开java文件，soanrlint会自动进行检测，对于不规范或有问题的代码会在下方划蓝色波浪线，如图：</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ympglu0dj30vs0c2ab1.jpg" srcset="/img/loading.gif" alt="soanrlint"></p><p>鼠标放在蓝色部分会有弹框显示错误信息或建议修改信息</p><p>点击“open description of rule”可以查看具体的错误描述，错误示例及修改示例。</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymphmzexj322s0okgqj.jpg" srcset="/img/loading.gif" alt="info"></p><p>在项目或单个java文件上右键 -&gt; sonarlint -&gt; Analyze 进行手动操作分析。这样SonarLint Report面板中查看所有的异常信息</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ympkahq6j323a0om42c.jpg" srcset="/img/loading.gif" alt="error"></p><h4 id="3、Server"><a href="#3、Server" class="headerlink" title="3、Server"></a>3、Server</h4><p>连接SonarQube的主要目的是同步分析规则、质量规则与自定义设置。操作如下：</p><p>从Window -&gt; show view 中找到SonarLint Bindings打开；</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ympltet3j30gw0n0gn5.jpg" srcset="/img/loading.gif" alt="open"></p><p>在该面板空白处 右键创建 server连接，选择SonarQube</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ympmmr9zj30zy0n0jss.jpg" srcset="/img/loading.gif" alt="new"></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ympnoy67j30zy0n03zm.jpg" srcset="/img/loading.gif" alt="url"></p><p>url为：<a href="http://localhost:9000" target="_blank" rel="noopener">http://localhost:9000</a></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymppxsmgj30zy0n0js9.jpg" srcset="/img/loading.gif" alt="utoken"></p><p>使用UserName+Password或者token登陆</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ympraf22j30zy0n0myf.jpg" srcset="/img/loading.gif" alt="token"></p><p>没有token可以点击右侧按钮创建，或者寻找管理员创建</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ympt5lc9j30zy0n0q44.jpg" srcset="/img/loading.gif" alt="locahost"></p><p>配置名称</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ympu9mwcj30zy0n0dgx.jpg" srcset="/img/loading.gif" alt="finish"></p><p>完成服务配置</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ympv4ohxj30t60n0mxw.jpg" srcset="/img/loading.gif" alt="bind"></p><p>绑定工程，点击add</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ympwi0fcj30l80ksjsq.jpg" srcset="/img/loading.gif" alt="add"></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ympxit8fj30t60n0q3t.jpg" srcset="/img/loading.gif" alt="next"></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ympyhmppj31qm0sawhz.jpg" srcset="/img/loading.gif" alt="setting"></p><p>输入sonarQube中创建的工程的名称</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ympzptzaj30t60n0gmu.jpg" srcset="/img/loading.gif" alt="f"></p><p>完成</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymq1afbhj323k0oaq5r.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="4、-结果同步SonarQube显示"><a href="#4、-结果同步SonarQube显示" class="headerlink" title="4、 结果同步SonarQube显示"></a>4、 结果同步SonarQube显示</h4><p>在maven的settings.xml中配置如下：</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymq283h7j31ey0gan0q.jpg" srcset="/img/loading.gif" alt="setting"></p><p>配置完成后，使用soanr:sonar命令运行项目，此部分要求JDK为1.8。<code>clean install sonar:sonar</code></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymq40r24j326c0raqb5.jpg" srcset="/img/loading.gif" alt="package"></p><p>可以打开<a href="http://localhost:9000/dashboard?id=com.xxx查看对应的错误信息，也可以在SonarQube点击Issues进行查看" target="_blank" rel="noopener">http://localhost:9000/dashboard?id=com.xxx查看对应的错误信息，也可以在SonarQube点击Issues进行查看</a></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymq5616rj31jw0b20vw.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymq7qiowj315y0u0jtb.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="IDEA中使用"><a href="#IDEA中使用" class="headerlink" title="IDEA中使用"></a><strong>IDEA中使用</strong></h3><h4 id="1、-安装-1"><a href="#1、-安装-1" class="headerlink" title="1、  安装"></a>1、  安装</h4><p>​            File -&gt; settings -&gt; plugins 搜索sonarLint，Install。</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymq84v9pj31cg07074z.jpg" srcset="/img/loading.gif" alt="install"></p><h4 id="2、-使用-1"><a href="#2、-使用-1" class="headerlink" title="2、 使用"></a>2、 使用</h4><p>在左下角点击隐藏面板，可以看到sonarLint，打开</p><p>打开java文件，soanrlint会自动进行检测，对于不规范或有问题的代码会添加暗金色的背景色，鼠标放上去会有如图提示：</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymqa33uhj315o0u0n20.jpg" srcset="/img/loading.gif" alt="error"></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymqb0kjsj32hc0u0jy5.jpg" srcset="/img/loading.gif" alt="error"></p><p>也可以通过点击上图的绿色倒三角手动执行分析。</p><h4 id="3、-Server"><a href="#3、-Server" class="headerlink" title="3、 Server"></a>3、 Server</h4><p>连接SonarQube的主要目的是同步分析规则、质量规则与自定义设置。操作如下：</p><p>从File -&gt; settings -&gt; OtherSettings中找到“SonarLint General Settings”打开；</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymqcut2ej31nq0q4mzv.jpg" srcset="/img/loading.gif" alt=""></p><p>点击加号，输入一个name，如localhost;选择SonarQube，Url为<a href="http://localhost9000；" target="_blank" rel="noopener">http://localhost9000；</a></p><p>选择Login/Password或者token，输入账号与密码或者token；</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymqea12tj31nq0q4q51.jpg" srcset="/img/loading.gif" alt=""></p><p>finish</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymqf8fetj31nq0q475u.jpg" srcset="/img/loading.gif" alt="finish"></p><p>勾选“Enable binding to remote SonarQube Server”,选择添加的server,搜索到你需要绑定的项目，然后选择确认。</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymqg4txyj313s0u0dhl.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="4、结果同步SonarQube显示"><a href="#4、结果同步SonarQube显示" class="headerlink" title="4、结果同步SonarQube显示"></a>4、结果同步SonarQube显示</h4><p>同Eclipse部分，此部分要求JDK为1.8。</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymqh83gmj31330u0gnp.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymqhzedij31330u0gnp.jpg" srcset="/img/loading.gif" alt="png"></p><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>SonarQube</category>
      
      <category>SonarLint</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SonarQube</tag>
      
      <tag>SonarLint</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[SonarQube的使用] SonarQube安装</title>
    <link href="/2019/09/26/SonarQube%E7%9A%84%E4%BD%BF%E7%94%A8-SonarQube%E5%AE%89%E8%A3%85/"/>
    <url>/2019/09/26/SonarQube%E7%9A%84%E4%BD%BF%E7%94%A8-SonarQube%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="工欲善其事必先利其器"><a href="#工欲善其事必先利其器" class="headerlink" title="工欲善其事必先利其器"></a>工欲善其事必先利其器</h2><h3 id="一-SonarQube代码质量检查工具简介"><a href="#一-SonarQube代码质量检查工具简介" class="headerlink" title="一 . SonarQube代码质量检查工具简介"></a>一 . SonarQube代码质量检查工具简介</h3><blockquote><p>Sonar (SonarQube)是一个开源平台，用于管理源代码的质量</p><p>Sonar 不只是一个质量数据报告工具，更是代码质量管理平台</p></blockquote><p>支持Java, C#, C/C++, PL/SQL, Cobol, JavaScrip, Groovy 等等二十几种编程语言的代码质量管理与检测。</p><p>Sonar可以从以下七个维度检测代码质量，而作为开发人员至少需要处理前5种代码质量问题。</p><ol><li><p>不遵循代码标准</p></li><li><p>sonar可以通过PMD,CheckStyle,Findbugs等等代码规则检测工具规范代码编写。</p></li><li><p>潜在的缺陷</p><p>sonar可以通过PMD,CheckStyle,Findbugs等等代码规则检测工具检 测出潜在的缺陷。</p></li><li><p>糟糕的复杂度分布</p><p>文件、类、方法等，如果复杂度过高将难以改变，这会使得开发人员 难以理解它们, 且如果没有自动化的单元测试，对于程</p><p>序中的任何组件的改变都将可能导致需要全面的回归测试。</p></li><li><p>重复</p><p>显然程序中包含大量复制粘贴的代码是质量低下的，sonar可以展示 源码中重复严重的地方。</p></li><li><p>注释不足或者过多</p><p>没有注释将使代码可读性变差，特别是当不可避免地出现人员变动 时，程序的可读性将大幅下降 而过多的注释又会使得开发人员将精力过多地花费在阅读注释上，亦违背初衷。</p></li><li><p>缺乏单元测试</p><p>sonar可以很方便地统计并展示单元测试覆盖率。</p></li><li><p>糟糕的设计</p><p>通过sonar可以找出循环，展示包与包、类与类之间的相互依赖关系，可以检测自定义的架构规则 通过sonar可以管理第三方</p><p>的jar包，可以利用LCOM4检测单个任务规则的应用情况， 检测藕合。</p></li></ol><h4 id="为什么要选择sonarQube"><a href="#为什么要选择sonarQube" class="headerlink" title="为什么要选择sonarQube?"></a>为什么要选择sonarQube?</h4><p>个人使用之后认为 : sonarQube的优势如下(相比于阿里编码规约这种市面上常见类似软件):</p><ol><li><p>更加优秀的图形化界面</p><p>基本上通过界面就可以对自己项目的代码状况一目了然</p></li><li><p>可以查询出其它软件难以定位到的问题</p><p>比如 : </p><p>可能导致空指针异常的问题 (对象在进行使用前没有加空的判断)</p><p>可能导致内存泄漏的问题, 在try catch 块里面,直接使用e.printStackTrace()将堆栈信息打印到内存的</p><p>可能导致的漏洞 : 成员变量使用public定义的</p><p>还有诸如 : 流等未关闭或者是非正常关闭都能够检测出来!</p><p>功能非常强大!!</p></li></ol><h3 id="二-安装："><a href="#二-安装：" class="headerlink" title="二. 安装："></a>二. 安装：</h3><h4 id="2-1-安装SonarQube-web-server"><a href="#2-1-安装SonarQube-web-server" class="headerlink" title="2.1 安装SonarQube web server"></a>2.1 安装SonarQube web server</h4><ol><li><p>首先确保安装了jdk1.8 +</p></li><li><p>到此链接 <a href="https://www.sonarqube.org/downloads/" target="_blank" rel="noopener">https://www.sonarqube.org/downloads/</a> </p><p>下载sonalqube(下载社区版,是开源的),</p></li></ol><p>我下载的是sonarqube-7.2.1，因为最新版<strong>7.9.1</strong>需要<strong>jdk11</strong>支持</p><p>并解压,解压完之后的目录如下 :</p><p>  <img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymoi44lcj31eo0omagi.jpg" srcset="/img/loading.gif" alt=""></p><ol start="3"><li><p>到解压目录的bin\macosx-universal-64(对应系统)目录下:</p><p>linux、Mac <code>sh sonar.sh start</code>启动</p><p>windows 双击<code>StartSonar.bat</code> 启动</p></li><li><p>到浏览器界面,输入 : <a href="http://localhost:9000" target="_blank" rel="noopener">http://localhost:9000</a> </p><p>如果能访问表明安装成功</p></li></ol><h4 id="2-2-安装数据库"><a href="#2-2-安装数据库" class="headerlink" title="2.2 安装数据库"></a>2.2 安装数据库</h4><ol><li><p>版本要求:</p><p>在conf目录下的sonar.properties文件下:</p><p>有这样一行配置 : </p><pre><code class="hljs properties"><span class="hljs-comment">#----- MySQL &gt;=5.6 &amp;&amp; &lt; 8.0</span></code></pre></li><li><p>为sonarqube 创建一个数据库</p><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> sonar;<span class="hljs-comment">-- 创建数据库</span></code></pre></li><li><p>创建sonarqube用户并进行授权</p><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">'username'</span>@<span class="hljs-string">'host'</span> <span class="hljs-keyword">IDENTIFIED</span> <span class="hljs-keyword">BY</span> <span class="hljs-string">'password'</span>; <span class="hljs-comment">-- 创建用户并设置密码</span><span class="hljs-comment">-- username 为创建的用户名</span><span class="hljs-comment">-- host 为对应的主机地址,本地就是localhost</span><span class="hljs-comment">-- password 为设置的密码</span><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">ON</span> *.* <span class="hljs-keyword">TO</span> <span class="hljs-string">'username'</span>@<span class="hljs-string">'localhost'</span>;<span class="hljs-comment">-- 对用户进行授权操作</span></code></pre></li><li><p>修改SonarQube配置文件,添加Mysql相关配置</p><pre><code class="hljs properties"><span class="hljs-meta">sonar.jdbc.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance&amp;useSSL=false</span><span class="hljs-comment"># 刚刚创建的sonarQube用户</span><span class="hljs-meta">sonar.jdbc.username</span>=<span class="hljs-string">sonar</span><span class="hljs-comment"># 创建用户对应的密码</span><span class="hljs-meta">sonar.jdbc.password</span>=<span class="hljs-string">sonar</span><span class="hljs-comment"># 设置编码格式为UTF-8</span><span class="hljs-meta">sonar.sorceEncoding</span>=<span class="hljs-string">UTF-8</span><span class="hljs-comment"># sonar登陆用户名</span><span class="hljs-meta">sonar.login</span>=<span class="hljs-string">admin</span><span class="hljs-comment"># sonar登陆密码</span><span class="hljs-meta">sonar.password</span>=<span class="hljs-string">admin</span></code></pre></li></ol><h4 id="2-3-重新启动服务端"><a href="#2-3-重新启动服务端" class="headerlink" title="2.3 重新启动服务端"></a>2.3 重新启动服务端</h4><ol><li><p>退出 SonarQube 服务端</p><p>在之前弹出的cmd窗口执行ctrl + c,</p><p>弹出来的提示选择Y,退出SonarQube服务</p></li><li><p>双击StartSonar.bat文件, 重新启动SonarQube</p><p>这次因为要进行数据库的初始化操作,所以需要的时间可能稍微久一点</p></li><li><p>启动成功后,浏览器输入 : <a href="http://localhost:9000" target="_blank" rel="noopener">http://localhost:9000</a> 进入界面</p></li><li><p>登录 </p><p>点击界面右上角的登录按钮, 进行登录 :</p><p>初始的账户名 : admin</p><p>初始的密码  :  admin</p><p>附 : 一些关键配置的修改,如 主机地址,context,端口号等:</p><p>通常情况下使用默认的配置即可!</p><p>文件 /conf/sonar.properties</p><pre><code class="hljs properties"><span class="hljs-comment">#sonar.web.host=0.0.0.0 </span><span class="hljs-comment">#sonar.web.context=</span><span class="hljs-comment">#sonar.web.port=9000</span></code></pre></li></ol><h3 id="三-使用"><a href="#三-使用" class="headerlink" title="三. 使用"></a>三. 使用</h3><h4 id="3-1-安装必要的插件-汉化包举例"><a href="#3-1-安装必要的插件-汉化包举例" class="headerlink" title="3.1. 安装必要的插件 (汉化包举例)"></a>3.1. 安装必要的插件 (汉化包举例)</h4><p>点击 导航栏的 Administration, 选择Marketplace</p><p>搜索 Chinese pack, 点击install进行安装</p><p>安装成功后, 重启 SonarQube !</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymoldzq6j31jr0u0wk8.jpg" srcset="/img/loading.gif" alt="pack"></p><h4 id="3-2-开始分析项目代码源代码"><a href="#3-2-开始分析项目代码源代码" class="headerlink" title="3.2. 开始分析项目代码源代码"></a>3.2. 开始分析项目代码源代码</h4><p>使用maven的方式进行分析</p><h5 id="3-2-1-编辑maven-的settings-xml文件"><a href="#3-2-1-编辑maven-的settings-xml文件" class="headerlink" title="3.2.1 编辑maven 的settings.xml文件"></a>3.2.1 编辑maven 的settings.xml文件</h5><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pluginGroups</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pluginGroup</span>&gt;</span>org.sonarsource.scanner.maven<span class="hljs-tag">&lt;/<span class="hljs-name">pluginGroup</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pluginGroups</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>sonar<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">sonar.host.url</span>&gt;</span>http://loaclhost:9000<span class="hljs-tag">&lt;/<span class="hljs-name">sonar.host.url</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span></code></pre><p>其中sonar.host.url 值就是 上文启动的sonar 服务器地址。</p><h5 id="3-2-2-对maven项目进行分析"><a href="#3-2-2-对maven项目进行分析" class="headerlink" title="3.2.2 对maven项目进行分析"></a>3.2.2 对maven项目进行分析</h5><p>到项目所在的文件路径下: </p><p>使用命令提示符或者是power shell执行 如下命令: </p><pre><code class="hljs shell">mvn org.sonarsource.scanner.maven:sonar-maven-plugin:3.6.0.1398:sonar</code></pre><p>出现: BUILD SUCCESS 标识之后</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymomt8guj32dq0sutlb.jpg" srcset="/img/loading.gif" alt="BUILD SUCCESS"></p><p>刷新界面查看 :</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymopjdz6j31bv0u0n3x.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymoqvxqaj31bv0u0n3x.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="3-3-配置分析参数"><a href="#3-3-配置分析参数" class="headerlink" title="3.3 配置分析参数"></a>3.3 配置分析参数</h4><p>强制参数：    </p><ol><li>Server<br>sonar.host.url        <a href="http://localhost:9000" target="_blank" rel="noopener">http://localhost:9000</a></li><li>Project Configuration<br>sonar.projectKey              Maven   <groupId>:<artifactId><br>sonar.sources                  Maven 默认的源码路径</li></ol><p>可以配置的参数：</p><ol><li>Project identity<br>sonar.projectName        项目名称<br>sonar.projectversion     项目版本</li><li>Authentication<br>sonar.login                  分析该项目的用户名称<br>sonar.password                分析该项目的用户密码</li></ol><h4 id="3-4-程序员用户使用说明"><a href="#3-4-程序员用户使用说明" class="headerlink" title="3.4. 程序员用户使用说明"></a>3.4. 程序员用户使用说明</h4><p>SonarQube Web管理者通过配置和设置以下参数值对项目源代码进行：</p><p>复杂度、覆盖率、文档、重复、问题、可维护性、可靠性、安全性、大小等约束和规范。</p><p>sonar中的质量阈管理以下内容。</p><pre><code class="hljs scheme">复杂度复杂度复杂度/类复杂度/文件复杂度/方法覆盖率分支覆盖集成测试的新分支覆盖新代码的分支覆盖率覆盖率新集成测试覆盖新覆盖率集成测试分支覆盖集成测试覆盖集成测试覆盖行集成测试未覆盖分支集成测试未覆盖行代码覆盖率集成测试的新行覆盖新代码覆盖率代码行集成测试的新行覆盖覆盖的新代码总体分支覆盖率总体新分支覆盖率总体覆盖率总体新覆盖率总体代码覆盖率总体新代码覆盖率总体覆盖的新行数总体未覆盖分支总体未覆盖的新分支总体未覆盖代码总体未覆盖新行数单元测试忽略数未覆盖分支集成测试未覆盖的新分支未覆盖新分支未覆盖的代码集成测试未覆盖的行未覆盖的新代码单元测试持续时间单元测试错误数单元测试失败数单元测试成功 (%)单元测试数文档注释行注释 (%)公共API公共注释的API (%)公共未注释的API重复重复块重复文件重复行重复行(%)问题阻断违规确认问题严重违规误判问题提示违规违规主要违规次要违规新阻断违规新严重违规新提示违规新违规新主要违规新次要违规开启问题重开问题不修复的问题可维护性新代码的技术债务坏味道达到可维护性A级所需的工作新增坏味道技术债务技术债务比率新代码技术债务比率ManagementBurned budgetBusiness valueTeam size可靠性Bugs新增Bugs可靠性修复工作新代码的可靠性修复工作安全性新增漏洞安全修复工作新代码的安全修复工作漏洞大小类目录文件方法生成的行数生成的代码行数行数代码行数项目语句</code></pre><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Sonar</category>
      
      <category>SonarQube</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Sonar</tag>
      
      <tag>SonarQube</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>教程|教你如何给你的头像添加一个好看的国旗</title>
    <link href="/2019/09/24/%E6%95%99%E7%A8%8B-%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E7%BB%99%E4%BD%A0%E7%9A%84%E5%A4%B4%E5%83%8F%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9C%8B%E7%9A%84%E5%9B%BD%E6%97%97/"/>
    <url>/2019/09/24/%E6%95%99%E7%A8%8B-%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E7%BB%99%E4%BD%A0%E7%9A%84%E5%A4%B4%E5%83%8F%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9C%8B%E7%9A%84%E5%9B%BD%E6%97%97/</url>
    
    <content type="html"><![CDATA[<p>今天朋友圈又火了，听说原因是 <strong>@腾讯官网</strong> 就能得到一顶绿色的帽子，啊呸，是一个好看的国庆节头像，可是听说没一会就502了，那么我们自己动手实现一个吧</p><p>由于代码比较简单就不一一介绍了。</p><a id="more"></a><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> cvs = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"cvs"</span>);<span class="hljs-keyword">var</span> ctx = cvs.getContext(<span class="hljs-string">"2d"</span>);<span class="hljs-keyword">var</span> exportImage = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"export"</span>);<span class="hljs-keyword">var</span> img = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"img"</span>);<span class="hljs-keyword">var</span> hat = <span class="hljs-string">"hat6"</span>;<span class="hljs-keyword">var</span> canvasFabric;<span class="hljs-keyword">var</span> hatInstance;<span class="hljs-keyword">var</span> screenWidth = <span class="hljs-built_in">window</span>.screen.width &lt; <span class="hljs-number">500</span> ? <span class="hljs-built_in">window</span>.screen.width : <span class="hljs-number">300</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">viewer</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">var</span> file = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"upload"</span>).files[<span class="hljs-number">0</span>];<span class="hljs-built_in">console</span>.log(file);<span class="hljs-keyword">var</span> reader = <span class="hljs-keyword">new</span> FileReader;<span class="hljs-keyword">if</span> (file) &#123;reader.readAsDataURL(file);reader.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;img.src = reader.result;img.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;img2Cvs(img)&#125;&#125;&#125; <span class="hljs-keyword">else</span> &#123;img.src = <span class="hljs-string">""</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">img2Cvs</span>(<span class="hljs-params">img</span>) </span>&#123;cvs.width = img.width;cvs.height = img.height;cvs.style.display = <span class="hljs-string">"block"</span>;canvasFabric = <span class="hljs-keyword">new</span> fabric.Canvas(<span class="hljs-string">"cvs"</span>, &#123;width: screenWidth,height: screenWidth,backgroundImage: <span class="hljs-keyword">new</span> fabric.Image(img, &#123;scaleX: screenWidth / img.width,scaleY: screenWidth / img.height&#125;)&#125;);changeHat();<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"uploadContainer"</span>).style.display = <span class="hljs-string">"none"</span>;<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"uploadText"</span>).style.display = <span class="hljs-string">"none"</span>;<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"upload"</span>).style.display = <span class="hljs-string">"none"</span>;<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"change"</span>).style.display = <span class="hljs-string">"block"</span>;<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"exportBtn"</span>).style.display = <span class="hljs-string">"block"</span>;<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"tip"</span>).style.opacity = <span class="hljs-number">1</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeHat</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">document</span>.getElementById(hat).style.display = <span class="hljs-string">"none"</span>;<span class="hljs-keyword">var</span> hats = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">"hide"</span>);hat = <span class="hljs-string">"hat"</span> + (+hat.replace(<span class="hljs-string">"hat"</span>, <span class="hljs-string">""</span>) + <span class="hljs-number">1</span>) % hats.length;<span class="hljs-keyword">var</span> hatImage = <span class="hljs-built_in">document</span>.getElementById(hat);hatImage.style.display = <span class="hljs-string">"block"</span>;<span class="hljs-keyword">if</span> (hatInstance) &#123;canvasFabric.remove(hatInstance)&#125;hatInstance = <span class="hljs-keyword">new</span> fabric.Image(hatImage, &#123;top: <span class="hljs-number">40</span>,left: screenWidth / <span class="hljs-number">3</span>,scaleX: <span class="hljs-number">100</span> / hatImage.width,scaleY: <span class="hljs-number">100</span> / hatImage.height,cornerColor: <span class="hljs-string">"#0b3a42"</span>,cornerStrokeColor: <span class="hljs-string">"#fff"</span>,cornerStyle: <span class="hljs-string">"circle"</span>,transparentCorners: <span class="hljs-literal">false</span>,rotatingPointOffset: <span class="hljs-number">30</span>&#125;);hatInstance.setControlVisible(<span class="hljs-string">"bl"</span>, <span class="hljs-literal">false</span>);hatInstance.setControlVisible(<span class="hljs-string">"tr"</span>, <span class="hljs-literal">false</span>);hatInstance.setControlVisible(<span class="hljs-string">"tl"</span>, <span class="hljs-literal">false</span>);hatInstance.setControlVisible(<span class="hljs-string">"mr"</span>, <span class="hljs-literal">false</span>);hatInstance.setControlVisible(<span class="hljs-string">"mt"</span>, <span class="hljs-literal">false</span>);canvasFabric.add(hatInstance)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exportFunc</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">"canvas-container"</span>)[<span class="hljs-number">0</span>].style.display = <span class="hljs-string">"none"</span>;<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"exportBtn"</span>).style.display = <span class="hljs-string">"none"</span>;<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"tip"</span>).innerHTML = <span class="hljs-string">"长按图片保存或分享"</span>;<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"change"</span>).style.display = <span class="hljs-string">"none"</span>;cvs.style.display = <span class="hljs-string">"none"</span>;exportImage.style.display = <span class="hljs-string">"block"</span>;exportImage.src = canvasFabric.toDataURL(&#123;width: screenWidth,height: screenWidth&#125;)&#125;</code></pre><p>最后效果</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymmwsocwj31tg0roq69.jpg" srcset="/img/loading.gif" alt="image-20190924171759373"></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymmxqcayj30t80lgjte.jpg" srcset="/img/loading.gif" alt="image-20190924171817825"></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymmzogrjj315m0kejur.jpg" srcset="/img/loading.gif" alt="image-20190924171842699">拖动图片可见已经拼合成一张完整图片了</p><p>右键查看源代码</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymn2ezqkj31jm0c0784.jpg" srcset="/img/loading.gif" alt="image-20190924171947774"></p><p>源码地址：<a href="https://gitee.com/alterem/avatar.git" target="_blank" rel="noopener">https://gitee.com/alterem/avatar.git</a></p><p>演示地址：<a href="http://alterem.gitee.io/avatar/" target="_blank" rel="noopener">http://alterem.gitee.io/avatar/</a></p>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在SpringMVC项目中使用HIkariCP</title>
    <link href="/2019/06/24/%E5%9C%A8SpringMVC%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8HIkariCP/"/>
    <url>/2019/06/24/%E5%9C%A8SpringMVC%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8HIkariCP/</url>
    
    <content type="html"><![CDATA[<h4 id="什么是HIkariCP"><a href="#什么是HIkariCP" class="headerlink" title="什么是HIkariCP"></a>什么是HIkariCP</h4><blockquote><p><a href="https://www.jianshu.com/p/15b846107a7c" target="_blank" rel="noopener">https://www.jianshu.com/p/15b846107a7c</a></p></blockquote><h4 id="使用HikariCP数据源"><a href="#使用HikariCP数据源" class="headerlink" title="使用HikariCP数据源"></a>使用HikariCP数据源</h4><h5 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h5><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.zaxxer<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>HikariCP<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><a id="more"></a><h5 id="Spring-mvc-xml"><a href="#Spring-mvc-xml" class="headerlink" title="Spring-mvc.xml"></a>Spring-mvc.xml</h5><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.zaxxer.hikari.HikariDataSource"</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">"shutdown"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driverClassName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.driver&#125;"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"jdbcUrl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.url&#125;"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.username&#125;"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;jdbc.password&#125;"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"connectionTestQuery"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"SELECT 1"</span> /&gt;</span><span class="hljs-comment">&lt;!-- 生效超时 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"validationTimeout"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"3000"</span> /&gt;</span>        <span class="hljs-comment">&lt;!-- 连接只读数据库时配置为true， 保证安全 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"readOnly"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"false"</span> /&gt;</span>        <span class="hljs-comment">&lt;!-- 等待连接池分配连接的最大时长（毫秒），超过这个时长还没可用的连接则发生SQLException， 缺省:30秒 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"connectionTimeout"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"60000"</span> /&gt;</span>        <span class="hljs-comment">&lt;!-- 一个连接idle状态的最大时长（毫秒），超时则被释放（retired），缺省:10分钟 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"idleTimeout"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"60000"</span> /&gt;</span>        <span class="hljs-comment">&lt;!-- 一个连接的生命时长（毫秒），超时而且没被使用则被释放（retired），缺省:30分钟，建议设置比数据库超时时长少30秒，参考MySQL</span><span class="hljs-comment">            wait_timeout参数（show variables like '%timeout%';） --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"maxLifetime"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"60000"</span> /&gt;</span>        <span class="hljs-comment">&lt;!-- 连接池中允许的最大连接数。缺省值：10；推荐的公式：((core_count * 2) + effective_spindle_count) --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"maximumPoolSize"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"10"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><h4 id="启动成功日志"><a href="#启动成功日志" class="headerlink" title="启动成功日志"></a>启动成功日志</h4><pre><code class="hljs bash">17:36:50.838 [main] WARN  com.zaxxer.hikari.HikariConfig - HikariPool-1 - idleTimeout has been <span class="hljs-built_in">set</span> but has no effect because the pool is operating as a fixed size pool.17:36:50.838 [main] DEBUG com.zaxxer.hikari.HikariConfig - HikariPool-1 - configuration:17:36:50.841 [main] DEBUG com.zaxxer.hikari.HikariConfig - allowPoolSuspension.............false17:36:50.841 [main] DEBUG com.zaxxer.hikari.HikariConfig - autoCommit......................true17:36:50.841 [main] DEBUG com.zaxxer.hikari.HikariConfig - catalog.........................none17:36:50.841 [main] DEBUG com.zaxxer.hikari.HikariConfig - connectionInitSql...............none17:36:50.841 [main] DEBUG com.zaxxer.hikari.HikariConfig - connectionTestQuery.............<span class="hljs-string">"SELECT 1"</span>17:36:50.841 [main] DEBUG com.zaxxer.hikari.HikariConfig - connectionTimeout...............6000017:36:50.841 [main] DEBUG com.zaxxer.hikari.HikariConfig - dataSource......................none17:36:50.841 [main] DEBUG com.zaxxer.hikari.HikariConfig - dataSourceClassName.............none17:36:50.841 [main] DEBUG com.zaxxer.hikari.HikariConfig - dataSourceJNDI..................none17:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - dataSourceProperties............&#123;password=&lt;masked&gt;&#125;17:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - driverClassName.................<span class="hljs-string">"com.mysql.jdbc.Driver"</span>17:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - healthCheckProperties...........&#123;&#125;17:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - healthCheckRegistry.............none17:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - idleTimeout.....................6000017:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - initializationFailTimeout.......117:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - isolateInternalQueries..........false17:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - jdbcUrl.........................jdbc:mysql://ykx.uerp.net:3306/ykx?useUnicode=<span class="hljs-literal">true</span>&amp;characterEncoding=utf817:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - leakDetectionThreshold..........017:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - maxLifetime.....................6000017:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - maximumPoolSize.................1017:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - metricRegistry..................none17:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - metricsTrackerFactory...........none17:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - minimumIdle.....................1017:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - password........................&lt;masked&gt;17:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - poolName........................<span class="hljs-string">"HikariPool-1"</span>17:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - readOnly........................false17:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - registerMbeans..................false17:36:50.844 [main] DEBUG com.zaxxer.hikari.HikariConfig - scheduledExecutor...............none17:36:50.844 [main] DEBUG com.zaxxer.hikari.HikariConfig - schema..........................none17:36:50.844 [main] DEBUG com.zaxxer.hikari.HikariConfig - threadFactory...................internal17:36:50.844 [main] DEBUG com.zaxxer.hikari.HikariConfig - transactionIsolation............default17:36:50.844 [main] DEBUG com.zaxxer.hikari.HikariConfig - username........................<span class="hljs-string">"ykx"</span>17:36:50.844 [main] DEBUG com.zaxxer.hikari.HikariConfig - validationTimeout...............300017:36:50.844 [main] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Starting...17:36:51.257 [main] DEBUG com.zaxxer.hikari.pool.HikariPool - HikariPool-1 - Added connection com.mysql.jdbc.JDBC4Connection@1d77a31d17:36:51.260 [main] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Start completed.</code></pre>]]></content>
    
    
    <categories>
      
      <category>HIkariCP</category>
      
      <category>dataSource</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HIkariCP</tag>
      
      <tag>dataSource</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis在Spring环境下的事务管理</title>
    <link href="/2019/06/13/MyBatis%E5%9C%A8Spring%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    <url>/2019/06/13/MyBatis%E5%9C%A8Spring%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>MyBatis的设计思想很简单，可以看做是对JDBC的一次封装，并提供强大的动态SQL映射功能。但是由于它本身也有一些缓存、事务管理等功能，所以实际使用中还是会碰到一些问题——另外，最近接触了JFinal，其思想和Hibernate类似，但要更简洁，和MyBatis的设计思想不同，但有一点相同：都是想通过简洁的设计最大限度地简化开发和提升性能——说到性能，前段时间碰到两个问题： </p><ol><li>在一个上层方法（DAO方法的上层）内删除一条记录，然后再插入一条相同<strong>主键</strong>的记录时，会报主键冲突的错误。     </li><li>某些项目中的DAO方法平均执行时间会是其他一些项目中的 <strong>2倍</strong> 。     </li></ol><p>第一个问题是偶尔会出现，在实验环境无论如何也重现不了，经过分析MyBatis的逻辑，估计是两个DAO分别拿到了两个不同的Connection，第二个语句比第一个更早的被提交，导致了主键冲突，有待进一步的分析和验证。对于第二个问题，本文将尝试通过分析源代码和实验找到它的root cause，主要涉及到以下内容： </p><ol><li><p>问题描述与分析     </p></li><li><p>MyBatis在Spring环境下的载入过程     </p></li><li><p>MyBatis在Spring环境下事务的管理     </p></li><li><p>实验验证     </p></li></ol><a id="more"></a><h3 id="项目环境"><a href="#项目环境" class="headerlink" title="项目环境"></a>项目环境</h3><p>整个系统是微服务架构，这里讨论的「项目」是指一个单独的服务。单个项目的框架基本是Spring+MyBatis，具体版本如下： </p><pre><code class="hljs java">Spring <span class="hljs-number">3.2</span><span class="hljs-number">.9</span>/<span class="hljs-number">4.3</span><span class="hljs-number">.5</span> + Mybatis <span class="hljs-number">3.2</span><span class="hljs-number">.6</span> + mybatis-spring <span class="hljs-number">1.2</span><span class="hljs-number">.2</span> + mysql connector <span class="hljs-number">5.1</span><span class="hljs-number">.20</span> + commons-dbcp <span class="hljs-number">1.4</span></code></pre><p>与MyBatis和事务相关的配置如下： </p><pre><code class="hljs java"><span class="hljs-comment">//代码1</span>&lt;!-- bean#1--&gt; &lt;bean id=<span class="hljs-string">"dataSource"</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"org.apache.commons.dbcp.BasicDataSource"</span>        destroy-method=<span class="hljs-string">"close"</span>&gt;        &lt;!-- 一些数据库信息配置--&gt;        &lt;!-- 一些DBCP连接池配置 --&gt;         <span class="hljs-comment">//在这里设置是否自动提交</span>        &lt;property name=<span class="hljs-string">"defaultAutoCommit"</span> value=<span class="hljs-string">"$&#123;dbcp.defaultAutoCommit&#125;"</span> /&gt;  &lt;/bean&gt;&lt;!-- bean#2--&gt;  &lt;bean id=<span class="hljs-string">"sqlSessionFactory"</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;        &lt;property name=<span class="hljs-string">"dataSource"</span> ref=<span class="hljs-string">"dataSource"</span> /&gt;        &lt;property name=<span class="hljs-string">"mapperLocations"</span> value=<span class="hljs-string">"classpath*:path/to/mapper/**/*.xml"</span> /&gt;  &lt;/bean&gt;&lt;!-- bean#3 --&gt;  &lt;bean id=<span class="hljs-string">"transactionManager"</span>        <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;        &lt;property name=<span class="hljs-string">"dataSource"</span> ref=<span class="hljs-string">"dataSource"</span> /&gt;  &lt;/bean&gt;&lt;!-- bean#4--&gt;  &lt;bean <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;        &lt;property name=<span class="hljs-string">"basePackage"</span> value=<span class="hljs-string">".path.to.mapper"</span> /&gt;        &lt;property name=<span class="hljs-string">"sqlSessionFactoryBeanName"</span> value=<span class="hljs-string">"sqlSessionFactory"</span>/&gt;  &lt;/bean&gt; &lt;!-- bean5 --&gt;  &lt;tx:annotation-driven transaction-manager=<span class="hljs-string">"transactionManager"</span> /&gt;</code></pre><h3 id="问题描述与分析"><a href="#问题描述与分析" class="headerlink" title="问题描述与分析"></a>问题描述与分析</h3><p>一倍的时间差挺严重的，平均到每次调用，正常的大约在6到10几     <code>ms</code>，慢的要近20     <code>ms</code>，由于调用次数很多，导致整体性能会有很大的差别。经过仔细比对这几个项目，发现DAO执行慢的项目的数据源配置（bean#1）中<code>defaultAutoCommit</code>的配置都是<code>false</code>。而且将此配置改为 <code>true</code>之后就恢复了正常。 </p><p>由此推断是在MyBatis在执行「非自动提交」语句时，进行等待，或者多提交了一次，导致实际调用数据库API次数增多。但是这个推断也有个问题，由于整个项目是在Spring环境中运行的，而且也开启了Spring的事务管理，所以还是需要详细的看一下MyBatis到底是如何装配DAO方法与管理事务的，才能彻底解开谜团。 </p><h3 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h3><p>首先写一个Service，其中调用了同一个mapper类的两个方法分别2次，<code>insertModelList()</code>会在数据库中插入两条记录，<code>delModels()</code>方法会删除这两条记录，代码如下： </p><pre><code class="hljs java"><span class="hljs-comment">//代码2</span><span class="hljs-comment">//@Transactional</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testIS</span><span class="hljs-params">()</span></span>&#123;    List&lt;Model&gt; models= <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-comment">//省略一些数据工作。。。</span>    modelMapper.insertModelList(<span class="hljs-number">50001l</span>, models);    modelMapper.delModels(<span class="hljs-number">50001</span>);    <span class="hljs-keyword">if</span> (CollectionUtils.isNotEmpty(models))        modelMapper.insertModelList(<span class="hljs-number">50001</span>, models);    modelMapper.delModels(<span class="hljs-number">50001</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testOther</span><span class="hljs-params">()</span></span>&#123;    System.out.println(<span class="hljs-string">"加载类："</span>);    System.out.println(modelMapper.getClass().getClassLoader());    modelMapper.delModels(<span class="hljs-number">50001</span>);&#125;</code></pre><p>实际项目中使用cat来进行执行时间的统计，这里也仿照cat，使用一个单独的AOP类实现时间的计算： </p><pre><code class="hljs java"><span class="hljs-comment">//代码3</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DaoTimeAdvice</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> time = <span class="hljs-number">0</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> num = <span class="hljs-number">0</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">calcTime</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;    <span class="hljs-keyword">long</span> then = System.nanoTime();    Object object = joinPoint.proceed();    <span class="hljs-keyword">long</span> now = System.nanoTime();    setTime(getTime() + (now-then));    setNum(getNum() + <span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> object;  &#125;  <span class="hljs-comment">//省略getter &amp; setter。。。</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printInfo</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">"总共次数："</span> + num);    System.out.println(<span class="hljs-string">"总共时间："</span> + time);    System.out.println(<span class="hljs-string">"平均时间："</span> + time / num);  &#125;&#125;</code></pre><p>测试代码： </p><pre><code class="hljs java"><span class="hljs-comment">//代码4</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;    System.out.println(<span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"[yyyy-MM-dd HH:mm:ss]"</span>).format(<span class="hljs-keyword">new</span> Date())            + <span class="hljs-string">" 开始测试!"</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; TEST_NUM; i++) &#123;        ItemStrategyServiceTest ist = (ItemStrategyServiceTest) context.getBean(<span class="hljs-string">"isTS"</span>);        ist.testIS();        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">1000</span> == <span class="hljs-number">0</span>) &#123;            System.out.println(<span class="hljs-string">"1000次"</span>);        &#125;    &#125;    DaoTimeAdvice ad = (DaoTimeAdvice) context.getBean(<span class="hljs-string">"daoTimeAdvice"</span>);    ad.printInfo();    ItemStrategyServiceTest ist = (ItemStrategyServiceTest) context.getBean(<span class="hljs-string">"isTS"</span>);    ist.testOther();    System.exit(<span class="hljs-number">1</span>);&#125;</code></pre><p>测试结果： </p><table><thead><tr><th><code>defaultAutoCommit</code></th><th>循环次数</th><th>共消耗时间(ns)</th><th>平均时间(ns)</th></tr></thead><tbody><tr><td>true</td><td>40000</td><td>17831088316</td><td>445777</td></tr><tr><td>true</td><td>40000</td><td>17881589992</td><td>447039</td></tr><tr><td>false</td><td>40000</td><td>27280458229</td><td>682011</td></tr><tr><td>false</td><td>40000</td><td>27237413893</td><td>680935</td></tr></tbody></table><p>defaultAutoCommit为<code>false</code>时的执行时间是<code>true</code>的近1.5倍，并没有重现2倍的时间消耗，估计是在cat统计或者其他AOP方法的执行时还有其他消耗，从而扩大了<code>false</code>和<code>true</code>之间的区别。 </p><h3 id="MyBatis在Spring环境下的载入过程"><a href="#MyBatis在Spring环境下的载入过程" class="headerlink" title="MyBatis在Spring环境下的载入过程"></a>MyBatis在Spring环境下的载入过程</h3><p>按照第一节中的配置文件，整个MyBatis中DAO的bean的装配应该是这样的： </p><ol><li><p>先使用BasicDataSource装配一个数据源的bean（bean#1），名字叫做<code>dataSource</code>。         </p><p>这个bean很简单，就是实例化并注册到Spring的上下文中。         </p></li><li><p>使用<code>dataSource</code>来创建<code>sqlSessionFactory</code>（bean#2)，这个bean创建时会扫描MyBatis的语句映射文件并解析。         </p><p>在MyBatis中，真正的数据库读写操作是通过SqlSession的实例来实现的，而SqlSession要通过SQLSessionFactory来管理。这里的 <code>org.mybatis.spring.SqlSessionFactoryBean</code>实现了FactoryBean类（这个类比较特殊，与主题无关，这里不再赘述），Spring会从这个bean中会获取真正的SQLSessionFactory的实例，源代码中显示，实际返回的对象是DefaultSqlSessionFactory的实例。         </p></li><li><p>使用<code>sqlSessionFactory</code>这个工厂类来创建mapper扫描器（bean#4），并创建含有DAO方法的实例。         </p><p>为了让上层方法可以通过普通的方法调用来使用DAO方法，需要往Spring上下文里注册相应的bean，而在MyBatis的普通使用场景中是没有mapper的实现类的（具体的SQL语句映射通过注解或者XML文件来实现），只有接口，在MyBatis中这些接口是通过动态代理实现的。这里使用的类是 <code>org.mybatis.spring.mapper.MapperScannerConfigurer</code>，它实现了<code>org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor</code>接口，所以会在Spring中「所有的bean定义全部注册完成，但还没有实例化」之前，调用方法向Spring上下文注册mapper实现类（动态代理的对象）。具体代码如下：         </p><pre><code class="hljs java"> <span class="hljs-comment">//代码5</span> <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> </span>&#123;   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.processPropertyPlaceHolders) &#123;     processPropertyPlaceHolders();   &#125;   ClassPathMapperScanner scanner = <span class="hljs-keyword">new</span> ClassPathMapperScanner(registry);   <span class="hljs-comment">//设置一些属性</span>   scanner.scan(StringUtils.tokenizeToStringArray(<span class="hljs-keyword">this</span>.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS)); &#125; <span class="hljs-comment">/**</span><span class="hljs-comment">* Perform a scan within the specified base packages.</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> basePackages the packages to check for annotated classes</span><span class="hljs-comment">* <span class="hljs-doctag">@return</span> number of beans registered</span><span class="hljs-comment">*/</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">scan</span><span class="hljs-params">(String... basePackages)</span> </span>&#123;   <span class="hljs-keyword">int</span> beanCountAtScanStart = <span class="hljs-keyword">this</span>.registry.getBeanDefinitionCount();   doScan(basePackages);   <span class="hljs-comment">// Register annotation config processors, if necessary.</span>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.includeAnnotationConfig) &#123;     AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="hljs-keyword">this</span>.registry);   &#125;   <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.registry.getBeanDefinitionCount() - beanCountAtScanStart); &#125;</code></pre><p>在源代码里可以看到，真正的mapper实现类是<code>org.mybatis.spring.mapper.MapperFactoryBean&lt;Object&gt;</code>，具体的逻辑在方法<code>org.mybatis.spring.mapper.ClassPathMapperScanner.processBeanDefinitions(Set&lt;BeanDefinitionHolder&gt;)</code>里。最后，每一个方法的执行，最终落入了             <code>org.mybatis.spring.SqlSessionTemplate</code>的某个方法中，并被如下这个拦截器拦截：         </p><pre><code class="hljs java"><span class="hljs-comment">//代码6</span>  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Proxy needed to route MyBatis method calls to the proper SqlSession got</span><span class="hljs-comment">   * from Spring's Transaction Manager</span><span class="hljs-comment">   * It also unwraps exceptions thrown by &#123;<span class="hljs-doctag">@code</span> Method#invoke(Object, Object...)&#125; to</span><span class="hljs-comment">   * pass a &#123;<span class="hljs-doctag">@code</span> PersistenceException&#125; to the &#123;<span class="hljs-doctag">@code</span> PersistenceExceptionTranslator&#125;.</span><span class="hljs-comment">   */</span><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlSessionInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;  SqlSession sqlSession = getSqlSession(      SqlSessionTemplate.<span class="hljs-keyword">this</span>.sqlSessionFactory,      SqlSessionTemplate.<span class="hljs-keyword">this</span>.executorType,      SqlSessionTemplate.<span class="hljs-keyword">this</span>.exceptionTranslator);  <span class="hljs-keyword">try</span> &#123;    Object result = method.invoke(sqlSession, args);    <span class="hljs-keyword">if</span> (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.<span class="hljs-keyword">this</span>.sqlSessionFactory)) &#123;      <span class="hljs-comment">// force commit even on non-dirty sessions because some databases require</span>      <span class="hljs-comment">// a commit/rollback before calling close()</span>      sqlSession.commit(<span class="hljs-keyword">true</span>);    &#125;    <span class="hljs-keyword">return</span> result;  &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;    <span class="hljs-comment">//省略一些错误处理</span>    <span class="hljs-keyword">throw</span> unwrapped;  &#125; <span class="hljs-keyword">finally</span> &#123;    <span class="hljs-keyword">if</span> (sqlSession != <span class="hljs-keyword">null</span>) &#123;      closeSqlSession(sqlSession, SqlSessionTemplate.<span class="hljs-keyword">this</span>.sqlSessionFactory);    &#125;  &#125;&#125;&#125;</code></pre></li><li><p>MyBatis在Spring环境下事务的管理         </p><p>从源代码中知道真正的SqlSessionFactory使用的是<code>org.apache.ibatis.session.defaults.DefaultSqlSessionFactory</code>的实例，同时，事务管理使用     <code>org.mybatis.spring.transaction.SpringManagedTransactionFactory</code>。但是在代码1的配置中，还添加了Spring事务管理的配置，就是在某个Service方法（或某个其他可被扫描到的方法）上加上<code>@Transactional</code>注解，那么Spring的事务管理会自动创建事务，那么它和MyBatis的事务之间是怎么协作的呢？         </p><p>可以看到在代码6中的方法<code>isSqlSessionTransactional()</code>，它会返回上层代码中是否有Spring的事务，如果有，将不会执行下边的<code>commit()</code>。在我的项目中的实际情况是没有Spring事务，所以肯定是走到了下面的<code>commit()</code>，这个方法最终落到了<code>SpringManagedTransactionFactory</code>中的<code>commit()</code>，看代码：         </p><pre><code class="hljs java"><span class="hljs-comment">//代码7</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">openConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;  <span class="hljs-keyword">this</span>.connection = DataSourceUtils.getConnection(<span class="hljs-keyword">this</span>.dataSource);  <span class="hljs-keyword">this</span>.autoCommit = <span class="hljs-keyword">this</span>.connection.getAutoCommit();  <span class="hljs-keyword">this</span>.isConnectionTransactional = DataSourceUtils.isConnectionTransactional(<span class="hljs-keyword">this</span>.connection, <span class="hljs-keyword">this</span>.dataSource);   &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commit</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.connection != <span class="hljs-keyword">null</span> &amp;&amp; !<span class="hljs-keyword">this</span>.isConnectionTransactional &amp;&amp; !<span class="hljs-keyword">this</span>.autoCommit) &#123;    <span class="hljs-keyword">if</span> (LOGGER.isDebugEnabled()) &#123;      LOGGER.debug(<span class="hljs-string">"Committing JDBC Connection ["</span> + <span class="hljs-keyword">this</span>.connection + <span class="hljs-string">"]"</span>);    &#125;    <span class="hljs-keyword">this</span>.connection.commit();  &#125;&#125;</code></pre><p>可以看到，此处是否要执行<code>commit()</code>操作是由3个变量决定的，如果DataSource的 <code>autoCommit</code>是 <code>false</code>，则其结果一定为 <code>true</code>，控制台也会看到一行日志：<code>Committing JDBC Connection [xxxxxx]</code>，刚好与项目中遇到的情况相同。这个提交动作是需要和数据库交互的，比较耗时。         </p></li></ol><h3 id="实验验证"><a href="#实验验证" class="headerlink" title="实验验证"></a>实验验证</h3><p>由上一节分析得出，造成DAO方法执行时间变长的原因是会多执行一次提交，那么如果上层方法被Spring事务管理器托管（或者数据源的     <code>defaultAutoCommit</code>为     <code>true</code>，这个条件已经在刚开始的问题重现被验证），则不会执行MyBatis的提交动作，DAO方法应该相应的执行时间会变短。于是将Service方法加上     <code>@transactional</code>注解，分别测试     <code>true</code>和     <code>false</code>的情况。结果： </p><table><thead><tr><th align="left">defaultCommit</th><th align="left">循环次数</th><th align="left">共消耗时间</th><th align="left">平均时间</th></tr></thead><tbody><tr><td align="left">true</td><td align="left">40000</td><td align="left">7017113852</td><td align="left">175427</td></tr><tr><td align="left">false</td><td align="left">40000</td><td align="left">7283591630</td><td align="left">182089</td></tr></tbody></table><p>可以看到执行的时间已经基本接近，由此基本可以确定是这个原因造成的。这里仍然有几个疑点，尤其是问题重现时没有出现2倍的时间消耗，如果你有别的想法，也欢迎提出来讨论。 </p><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>MyBatis</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MyBatis</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CAS4.0分布式部署以及使用Redis缓存共享ticket</title>
    <link href="/2019/06/12/CAS4-0%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8Redis%E7%BC%93%E5%AD%98%E5%85%B1%E4%BA%ABticket/"/>
    <url>/2019/06/12/CAS4-0%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8Redis%E7%BC%93%E5%AD%98%E5%85%B1%E4%BA%ABticket/</url>
    
    <content type="html"><![CDATA[<p>CAS4.0分布式部署以及使用Redis缓存共享ticket </p><p>当业务不断拓展，系统用户在不断增加时，我们的平台统一登录认证服务无法承受当前压力。此时，我们需要分布式部署我们的统一登录认证服务。 </p><p>CAS的分布式部署，除了注意session共享，通过nginx或者apache反向代理外，还需要注意票据ticket的存储共享。 在ticketRegistry.xml文件中，配置ticket相关的信息。</p><a id="more"></a><p>主要配置：1.注册ticket存储，2.定时清除过期ticket。 </p><p>由于我们使用的Redis缓存Key设置了过期时间，因此可以注释掉清除过期ticket的定时器及相关类。</p><p>编写新的ticket存储类需要继承类AbstractDistributedTicketRegistry。代码如下： </p><pre><code class="hljs java"><span class="hljs-keyword">package</span> cas.ticket;    <span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;  <span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;  <span class="hljs-keyword">import</span> java.io.ObjectInputStream;  <span class="hljs-keyword">import</span> java.io.ObjectOutputStream;  <span class="hljs-keyword">import</span> java.util.Collection;    <span class="hljs-keyword">import</span> org.jasig.cas.ticket.Ticket;  <span class="hljs-keyword">import</span> org.jasig.cas.ticket.TicketGrantingTicket;  <span class="hljs-keyword">import</span> org.jasig.cas.ticket.registry.AbstractDistributedTicketRegistry;    <span class="hljs-keyword">import</span> cn.net.xinyi.util.SysPropertiesUtil;  <span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;  <span class="hljs-keyword">import</span> redis.clients.jedis.JedisPool;  <span class="hljs-keyword">import</span> redis.clients.jedis.JedisPoolConfig;    <span class="hljs-comment">/** </span><span class="hljs-comment"> * 使用Redis存储Ticket </span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> XIVA </span><span class="hljs-comment"> */</span>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisTicketRegistry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractDistributedTicketRegistry</span>  </span><span class="hljs-class"></span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> redisDatabaseNum;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String hosts;            <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> port;            <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> connTimeout;            <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String redisPassword;        <span class="hljs-comment">/** </span><span class="hljs-comment">     * ST最大空闲时间 </span><span class="hljs-comment">     */</span>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> st_time;        <span class="hljs-comment">/** </span><span class="hljs-comment">     * TGT最大空闲时间 </span><span class="hljs-comment">     */</span>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> tgt_time;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisPool cachePool;        <span class="hljs-keyword">static</span>      &#123;          redisDatabaseNum = SysPropertiesUtil.getPropertyInt(<span class="hljs-string">"redis_database_num"</span>);            hosts = SysPropertiesUtil.getProperty(<span class="hljs-string">"redis_hosts"</span>);                    port = SysPropertiesUtil.getPropertyInt(<span class="hljs-string">"redis_port"</span>);            connTimeout = SysPropertiesUtil.getPropertyInt(<span class="hljs-string">"redis_conn_timeout"</span>);                    redisPassword = SysPropertiesUtil.getProperty(<span class="hljs-string">"redis_password"</span>);            st_time = SysPropertiesUtil.getPropertyInt(<span class="hljs-string">"st_time"</span>);            tgt_time = SysPropertiesUtil.getPropertyInt(<span class="hljs-string">"tgt_time"</span>);            cachePool = <span class="hljs-keyword">new</span> JedisPool(<span class="hljs-keyword">new</span> JedisPoolConfig(), hosts, port, connTimeout, redisPassword);      &#125;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addTicket</span><span class="hljs-params">(Ticket ticket)</span>  </span><span class="hljs-function">    </span>&#123;          Jedis jedis = cachePool.getResource();            jedis.select(redisDatabaseNum);            <span class="hljs-keyword">int</span> seconds = <span class="hljs-number">0</span>;            String key = ticket.getId();            <span class="hljs-keyword">if</span> (ticket <span class="hljs-keyword">instanceof</span> TicketGrantingTicket)          &#123;              seconds = tgt_time / <span class="hljs-number">1000</span>;          &#125;          <span class="hljs-keyword">else</span>          &#123;              seconds = st_time / <span class="hljs-number">1000</span>;          &#125;            ByteArrayOutputStream bos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();          ObjectOutputStream oos = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">try</span>          &#123;                oos = <span class="hljs-keyword">new</span> ObjectOutputStream(bos);                oos.writeObject(ticket);            &#125;          <span class="hljs-keyword">catch</span> (Exception e)          &#123;              logger.error(<span class="hljs-string">"adding ticket to redis error."</span>);          &#125;          <span class="hljs-keyword">finally</span>          &#123;              <span class="hljs-keyword">try</span>              &#123;                  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != oos)                      oos.close();                &#125;              <span class="hljs-keyword">catch</span> (Exception e)              &#123;                  logger.error(<span class="hljs-string">"oos closing error when adding ticket to redis."</span>);              &#125;          &#125;            jedis.set(key.getBytes(), bos.toByteArray());          jedis.expire(key.getBytes(), seconds);          jedis.close();        &#125;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">deleteTicket</span><span class="hljs-params">(String ticketId)</span>  </span><span class="hljs-function">    </span>&#123;          <span class="hljs-keyword">if</span> (ticketId == <span class="hljs-keyword">null</span>)          &#123;              <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;          &#125;            Jedis jedis = cachePool.getResource();          jedis.select(redisDatabaseNum);                    jedis.del(ticketId.getBytes());          jedis.close();          <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;      &#125;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> Ticket <span class="hljs-title">getTicket</span><span class="hljs-params">(String ticketId)</span>  </span><span class="hljs-function">    </span>&#123;          <span class="hljs-keyword">return</span> getProxiedTicketInstance(getRawTicket(ticketId));      &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> Ticket <span class="hljs-title">getRawTicket</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String ticketId)</span>  </span><span class="hljs-function">    </span>&#123;          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == ticketId)          &#123;              <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;          &#125;            Jedis jedis = cachePool.getResource();          jedis.select(redisDatabaseNum);          Ticket ticket = <span class="hljs-keyword">null</span>;          <span class="hljs-keyword">byte</span>[] bytes = jedis.get(ticketId.getBytes());          <span class="hljs-keyword">if</span> (bytes == <span class="hljs-keyword">null</span> || bytes.length &lt; <span class="hljs-number">1</span>)          &#123;              <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;          &#125;          ByteArrayInputStream bais = <span class="hljs-keyword">new</span> ByteArrayInputStream(bytes);          ObjectInputStream ois = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">try</span>          &#123;              ois = <span class="hljs-keyword">new</span> ObjectInputStream(bais);              ticket = (Ticket) ois.readObject();          &#125;          <span class="hljs-keyword">catch</span> (Exception e)          &#123;              e.printStackTrace();              logger.error(<span class="hljs-string">"getting ticket to redis error."</span>);          &#125;          <span class="hljs-keyword">finally</span>          &#123;              <span class="hljs-keyword">try</span>              &#123;                  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != ois)                  &#123;                      ois.close();                  &#125;              &#125;              <span class="hljs-keyword">catch</span> (Exception e)              &#123;                  e.printStackTrace();                  logger.error(<span class="hljs-string">"ois closing error when getting ticket to redis."</span>);              &#125;          &#125;            jedis.close();          <span class="hljs-keyword">return</span> ticket;      &#125;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;Ticket&gt; <span class="hljs-title">getTickets</span><span class="hljs-params">()</span>  </span><span class="hljs-function">    </span>&#123;          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">"GetTickets not supported."</span>);        &#125;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">needsCallback</span><span class="hljs-params">()</span>  </span><span class="hljs-function">    </span>&#123;          <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;      &#125;        <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateTicket</span><span class="hljs-params">(Ticket ticket)</span>  </span><span class="hljs-function">    </span>&#123;          <span class="hljs-keyword">this</span>.addTicket(ticket);        &#125;    &#125;</code></pre><p>变更后的ticketRegistry.xml代码如下：</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  <span class="hljs-comment">&lt;!--  </span><span class="hljs-comment">  </span><span class="hljs-comment">    Licensed to Jasig under one or more contributor license  </span><span class="hljs-comment">    agreements. See the NOTICE file distributed with this work  </span><span class="hljs-comment">    for additional information regarding copyright ownership.  </span><span class="hljs-comment">    Jasig licenses this file to you under the Apache License,  </span><span class="hljs-comment">    Version 2.0 (the "License"); you may not use this file  </span><span class="hljs-comment">    except in compliance with the License.  You may obtain a  </span><span class="hljs-comment">    copy of the License at the following location:  </span><span class="hljs-comment">  </span><span class="hljs-comment">      http://www.apache.org/licenses/LICENSE-2.0  </span><span class="hljs-comment">  </span><span class="hljs-comment">    Unless required by applicable law or agreed to in writing,  </span><span class="hljs-comment">    software distributed under the License is distributed on an  </span><span class="hljs-comment">    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  </span><span class="hljs-comment">    KIND, either express or implied.  See the License for the  </span><span class="hljs-comment">    specific language governing permissions and limitations  </span><span class="hljs-comment">    under the License.  </span><span class="hljs-comment">  </span><span class="hljs-comment">--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span>  </span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span>  </span><span class="hljs-tag">       <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">"http://www.springframework.org/schema/p"</span>  </span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>          Configuration for the default TicketRegistry which stores the tickets in-memory and cleans them out as specified intervals.      <span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>             <span class="hljs-comment">&lt;!-- Ticket Registry   </span><span class="hljs-comment">  &lt;bean id="ticketRegistry" class="org.jasig.cas.ticket.registry.DefaultTicketRegistry" /&gt;  </span><span class="hljs-comment">  --&gt;</span>        <span class="hljs-comment">&lt;!-- ticket store on redis db  --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"ticketRegistry"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"cas.ticket.RedisTicketRegistry"</span> /&gt;</span>          <span class="hljs-comment">&lt;!--Quartz --&gt;</span>      <span class="hljs-comment">&lt;!-- TICKET REGISTRY CLEANER   </span><span class="hljs-comment">    &lt;bean id="ticketRegistryCleaner" class="org.jasig.cas.ticket.registry.support.DefaultTicketRegistryCleaner"  </span><span class="hljs-comment">        p:ticketRegistry-ref="ticketRegistry"  </span><span class="hljs-comment">        p:logoutManager-ref="logoutManager" /&gt;  </span><span class="hljs-comment">      </span><span class="hljs-comment">    &lt;bean id="jobDetailTicketRegistryCleaner" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"  </span><span class="hljs-comment">        p:targetObject-ref="ticketRegistryCleaner"  </span><span class="hljs-comment">        p:targetMethod="clean" /&gt;  </span><span class="hljs-comment">      </span><span class="hljs-comment">    &lt;bean id="triggerJobDetailTicketRegistryCleaner" class="org.springframework.scheduling.quartz.SimpleTriggerBean"  </span><span class="hljs-comment">        p:jobDetail-ref="jobDetailTicketRegistryCleaner"  </span><span class="hljs-comment">        p:startDelay="20000"  </span><span class="hljs-comment">        p:repeatInterval="5000000" /&gt; --&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Cas</category>
      
      <category>Redis</category>
      
      <category>Ticket</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cas</tag>
      
      <tag>Redis</tag>
      
      <tag>Ticket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring极速集成注解Redis实践</title>
    <link href="/2019/06/12/Spring%E6%9E%81%E9%80%9F%E9%9B%86%E6%88%90%E6%B3%A8%E8%A7%A3Redis%E5%AE%9E%E8%B7%B5/"/>
    <url>/2019/06/12/Spring%E6%9E%81%E9%80%9F%E9%9B%86%E6%88%90%E6%B3%A8%E8%A7%A3Redis%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<p>Redis 做为基于内存的 Key-Value 数据库，用来做缓存服务器性价比相当高。 </p><p>官方推出的面向 Java 的 Client Jedis，提供了很多接口和方法，可以让 Java 操作使用 Redis。 </p><p>Spring 团队对 Jedis 进行了封装，独立为 spring-data-redis 项目，配合 spring 特性并集成 Jedis 的一些命令和方法。 </p><p>本文重点描述集成过程，能让你迅速的通过 spring-data-redis 将 redis 集成到 spring 项目中,毕竟大家都忙的。 </p><a id="more"></a><h3 id="1-添加项目依赖"><a href="#1-添加项目依赖" class="headerlink" title="1. 添加项目依赖"></a>1. 添加项目依赖</h3><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--redis 缓存--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.data<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="2-添加-spring-redis-context-配置"><a href="#2-添加-spring-redis-context-配置" class="headerlink" title="2. 添加 spring-redis-context 配置"></a>2. 添加 spring-redis-context 配置</h3><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span></span><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span><span class="hljs-tag"><span class="hljs-string">                        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</span></span><span class="hljs-tag"><span class="hljs-string">                        http://www.springframework.org/schema/context</span></span><span class="hljs-tag"><span class="hljs-string">                        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>redis 相关类 Spring 托管<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>    <span class="hljs-comment">&lt;!--载入 redis 配置文件--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:redis.properties"</span> <span class="hljs-attr">ignore-unresolvable</span>=<span class="hljs-string">"true"</span>/&gt;</span>    <span class="hljs-comment">&lt;!-- 配置 JedisPoolConfig 实例 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"poolConfig"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"redis.clients.jedis.JedisPoolConfig"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"maxIdle"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.maxIdle&#125;"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"maxTotal"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.maxActive&#125;"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"maxWaitMillis"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.maxWait&#125;"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"testOnBorrow"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.testOnBorrow&#125;"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 配置JedisConnectionFactory --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"jedisConnectionFactory"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.data.redis.connection.jedis.JedisConnectionFactory"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hostName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.host&#125;"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"port"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.port&#125;"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.pass&#125;"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"database"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.dbIndex&#125;"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"poolConfig"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"poolConfig"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 配置RedisTemplate --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"redisTemplate"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.data.redis.core.RedisTemplate"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"connectionFactory"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"jedisConnectionFactory"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 配置RedisCacheManager --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"redisCacheManager"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.data.redis.cache.RedisCacheManager"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"redisOperations"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"redisTemplate"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"defaultExpiration"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;redis.expiration&#125;"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 配置RedisCacheConfig --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"redisCacheConfig"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.rambo.sdh.common.util.RedisCacheConfig"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"jedisConnectionFactory"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"redisTemplate"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"redisCacheManager"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre><p>JedisConnectionFactory 为 Jedis 连接工厂，配置由单独抽象的 JedisPoolConfig 提供。 </p><p>如果你熟悉 Spring 的 JdbcTemplate 对象的话，这里大概能猜出来 RedisTemplate 的作用，RedisTemplate 对 RedisConnection 进行了封装。 </p><p>提供连接管理，序列化等功能，它对 Redis 的交互进行了更高层次的抽象，极大的方便和简化了 Redis 的操作。 </p><p>RedisCacheManager 做为 redis 统一的调度和管理者，有兴趣可以反编译源码看看。 </p><p>继承自 org.springframework.cache.transaction.AbstractTransactionSupportingCacheManager 并实现 org.springframework.cache.CacheManager。 </p><h3 id="3-添加-redis-properties"><a href="#3-添加-redis-properties" class="headerlink" title="3. 添加 redis.properties"></a>3. 添加 redis.properties</h3><pre><code class="hljs properties"><span class="hljs-comment">#============================#</span><span class="hljs-comment">#==== Redis settings ====#</span><span class="hljs-comment">#============================#</span><span class="hljs-comment">#redis 服务器 IP</span><span class="hljs-meta">redis.host</span>=<span class="hljs-string">127.0.0.1</span><span class="hljs-comment">#redis 服务器端口</span><span class="hljs-meta">redis.port</span>=<span class="hljs-string">6379</span><span class="hljs-comment">#redis 密码</span><span class="hljs-meta">redis.pass</span>=<span class="hljs-string">redis#2017</span><span class="hljs-comment">#redis 支持16个数据库（相当于不同用户）可以使不同的应用程序数据彼此分开同时又存储在相同的实例上</span><span class="hljs-meta">redis.dbIndex</span>=<span class="hljs-string">0</span><span class="hljs-comment">#redis 缓存数据过期时间单位秒</span><span class="hljs-meta">redis.expiration</span>=<span class="hljs-string">3000</span><span class="hljs-comment">#控制一个 pool 最多有多少个状态为 idle 的jedis实例</span><span class="hljs-meta">redis.maxIdle</span>=<span class="hljs-string">300</span><span class="hljs-comment">#控制一个 pool 可分配多少个jedis实例</span><span class="hljs-meta">redis.maxActive</span>=<span class="hljs-string">600</span><span class="hljs-comment">#当borrow一个jedis实例时，最大的等待时间，如果超过等待时间，则直接抛出JedisConnectionException；</span><span class="hljs-meta">redis.maxWait</span>=<span class="hljs-string">1000</span><span class="hljs-comment">#在borrow一个jedis实例时，是否提前进行alidate操作；如果为true，则得到的jedis实例均是可用的；</span><span class="hljs-meta">redis.testOnBorrow</span>=<span class="hljs-string">true</span></code></pre><p>当然配置文件你也可以硬编码到程序中，只是在参数发生改变的时候比较痛苦一点而已。 </p><p>其中大部分配置项都是围绕着 jedisPool ，如果你对数据库连接池比较熟，你会发现它俩的配置项有点相似。 </p><p>当系统 redis 遇到问题出现故障时，理解这里的选项是个不错的选择。 </p><p>更多配置项详解: </p><blockquote><p><a href="https://link.zhihu.com/?target=http%3A//www.2cto.com/database/201311/254449.html">http://www.2cto.com/database/201311/254449.html</a> </p></blockquote><h3 id="4-编写自定义-redis-配置类"><a href="#4-编写自定义-redis-配置类" class="headerlink" title="4. 编写自定义 redis 配置类"></a>4. 编写自定义 redis 配置类</h3><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableCaching</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisCacheConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CachingConfigurerSupport</span> </span>&#123;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Logger log = LoggerFactory.getLogger(RedisCacheConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> JedisConnectionFactory mJedisConnectionFactory;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> RedisTemplate&lt;String, String&gt; mRedisTemplate;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> RedisCacheManager mRedisCacheManager;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RedisCacheConfig</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RedisCacheConfig</span><span class="hljs-params">(JedisConnectionFactory mJedisConnectionFactory, RedisTemplate&lt;String, String&gt; mRedisTemplate, RedisCacheManager mRedisCacheManager)</span> </span>&#123;        <span class="hljs-keyword">super</span>();        <span class="hljs-keyword">this</span>.mJedisConnectionFactory = mJedisConnectionFactory;        <span class="hljs-keyword">this</span>.mRedisTemplate = mRedisTemplate;        <span class="hljs-keyword">this</span>.mRedisCacheManager = mRedisCacheManager;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> JedisConnectionFactory <span class="hljs-title">redisConnectionFactory</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> mJedisConnectionFactory;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String, String&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory cf)</span> </span>&#123;        <span class="hljs-keyword">return</span> mRedisTemplate;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> CacheManager <span class="hljs-title">cacheManager</span><span class="hljs-params">(RedisTemplate&lt;?, ?&gt; redisTemplate)</span> </span>&#123;        <span class="hljs-keyword">return</span> mRedisCacheManager;    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> KeyGenerator <span class="hljs-title">keyGenerator</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> KeyGenerator() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">generate</span><span class="hljs-params">(Object o, Method method, Object... objects)</span> </span>&#123;                StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();                sb.append(o.getClass().getName());                sb.append(method.getName());                <span class="hljs-keyword">for</span> (Object obj : objects) &#123;                    sb.append(obj.toString());                &#125;                <span class="hljs-keyword">return</span> sb.toString();            &#125;        &#125;;    &#125;&#125;</code></pre><p>该配置类继承自 org.springframework.cache.annotation.CachingConfigurerSupport 并实现 org.springframework.cache.annotation.CachingConfigurer 的方法。 </p><p>通俗一点，该类告诉 spring 当前使用的缓存服务为 redis 并自定义了缓存 key 生成的规则。 </p><h3 id="5-在你喜欢的地方进行注解缓存"><a href="#5-在你喜欢的地方进行注解缓存" class="headerlink" title="5. 在你喜欢的地方进行注解缓存"></a>5. 在你喜欢的地方进行注解缓存</h3><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ympcrzd7j30k00bvwfe.jpg" srcset="/img/loading.gif" alt="img"></p><p>spring缓存一般使用在服务层，在你想缓存的方法上面添加相应的注解即可，下面三个缓存的注解你得掌握。 </p><ul><li>@Cacheable spring 会在其被调用后将返回值缓存起来，以保证下次利用同样的参数来执行该方法时可以直接从缓存中获取结果，而不需要再次执行该方法。     </li><li>@CachePut 标注的方法在执行前不会去检查缓存中是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入指定的缓存中。     </li><li>@CacheEvict 用来标注在需要清除缓存元素的方法或类上的。     </li></ul><p>当然这些注解里面还有很多其他的属性配置，配合 spring-el 表达式能做的事情还有很多，大概只有你想不到，没有做不到。 </p><p>在业务规则比较复杂的情况下，缓存 key 的设计相当重要，设计出色可以使你的应用飞起来。 </p><p>整个集成工作就结束了，是不是很简单，上述算是 redis 的冰山一角，还有很多像 redis 路由/分布式/集群….，有机会实践慢慢体会。 </p><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运算符优先级</title>
    <link href="/2019/06/12/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <url>/2019/06/12/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<p>Java 运算符优先级</p><table><thead><tr><th align="left">运算符</th><th align="left">优先级</th></tr></thead><tbody><tr><td align="left">postfix</td><td align="left"><em>expr</em>++ <em>expr</em>–</td></tr><tr><td align="left">unary</td><td align="left">++<em>expr</em> –<em>expr</em> +<em>expr</em> -<em>expr</em> ~ !</td></tr><tr><td align="left">multiplicative</td><td align="left">* / %</td></tr><tr><td align="left">additive</td><td align="left">+ -</td></tr><tr><td align="left">shift</td><td align="left">&lt;&lt; &gt;&gt; &gt;&gt;&gt;</td></tr><tr><td align="left">relational</td><td align="left">&lt; &gt; &lt;= &gt;= instanceof</td></tr><tr><td align="left">equality</td><td align="left">== !=</td></tr><tr><td align="left">bitwise AND</td><td align="left">&amp;</td></tr><tr><td align="left">bitwise exclusive OR</td><td align="left">^</td></tr><tr><td align="left">bitwise inclusive OR</td><td align="left">&#124;</td></tr><tr><td align="left">logical AND</td><td align="left">&amp;&amp;</td></tr><tr><td align="left">logical OR</td><td align="left">&#124;&#124;</td></tr><tr><td align="left">ternary</td><td align="left">? :</td></tr><tr><td align="left">assignment</td><td align="left">= += -= *= /= %= &amp;= ^=</td></tr></tbody></table><p>C++运算符优先级</p><table><thead><tr><th align="left">Precedence</th><th align="left">Operator</th><th align="left">Description</th><th align="left">Associativity</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">::</td><td align="left">Scope resolution</td><td align="left">Left-to-right</td></tr><tr><td align="left">2</td><td align="left">++    –</td><td align="left">Suffix/postfix increment and decrement</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">()</td><td align="left">Function call</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">[]</td><td align="left">Array subscripting</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">.</td><td align="left">Element selection by reference</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">−&gt;</td><td align="left">Element selection through pointer</td><td align="left"></td></tr><tr><td align="left">3</td><td align="left">++    –</td><td align="left">Prefix increment and decrement</td><td align="left">Right-to-left</td></tr><tr><td align="left"></td><td align="left">+    −</td><td align="left">Unary plus and minus</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">!    ~</td><td align="left">Logical NOT and bitwise NOT</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">(<em>type</em>)</td><td align="left">Type cast</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">*</td><td align="left">Indirection (dereference)</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">&amp;</td><td align="left">Address-of</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">sizeof</td><td align="left">Size-of</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">new,  new[]</td><td align="left">Dynamic memory allocation</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">delete,  delete[]</td><td align="left">Dynamic memory deallocation</td><td align="left"></td></tr><tr><td align="left">4</td><td align="left">.*    -&gt;*</td><td align="left">Pointer to member</td><td align="left">Left-to-right</td></tr><tr><td align="left">5</td><td align="left">*    /    %</td><td align="left">Multiplication, division, and remainder</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left">+    −</td><td align="left">Addition and subtraction</td><td align="left"></td></tr><tr><td align="left">7</td><td align="left">&lt;&lt;    &gt;&gt;</td><td align="left">Bitwise left shift and right shift</td><td align="left"></td></tr><tr><td align="left">8</td><td align="left">&lt;    &lt;=</td><td align="left">For relational operators &lt; and ≤ respectively</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">&gt;    &gt;=</td><td align="left">For relational operators &gt; and ≥ respectively</td><td align="left"></td></tr><tr><td align="left">9</td><td align="left">==    !=</td><td align="left">For relational = and ≠ respectively</td><td align="left"></td></tr><tr><td align="left">10</td><td align="left">&amp;</td><td align="left">Bitwise AND</td><td align="left"></td></tr><tr><td align="left">11</td><td align="left">^</td><td align="left">Bitwise XOR (exclusive or)</td><td align="left"></td></tr><tr><td align="left">12</td><td align="left">&#124;</td><td align="left">Bitwise OR (inclusive or)</td><td align="left"></td></tr><tr><td align="left">13</td><td align="left">&amp;&amp;</td><td align="left">Logical AND</td><td align="left"></td></tr><tr><td align="left">14</td><td align="left">&#124;&#124;</td><td align="left">Logical OR</td><td align="left"></td></tr><tr><td align="left">15</td><td align="left">?:</td><td align="left">Ternary conditional</td><td align="left">Right-to-Left</td></tr><tr><td align="left">16</td><td align="left">=</td><td align="left">Direct assignment (provided by default for C++ classes)</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">+=    −=</td><td align="left">Assignment by sum and difference</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">*=    /=    %=</td><td align="left">Assignment by product, quotient, and remainder</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">&lt;&lt;=    &gt;&gt;=</td><td align="left">Assignment by bitwise left shift and right shift</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">&amp;=    ^=    &#124;=</td><td align="left">Assignment by bitwise AND, XOR, and OR</td><td align="left"></td></tr><tr><td align="left">17</td><td align="left">throw</td><td align="left">Throw operator (for exceptions)</td><td align="left"></td></tr><tr><td align="left">18</td><td align="left">,</td><td align="left">Comma</td><td align="left">Left-to-right</td></tr></tbody></table><p>C语言运算符优先级</p><table><thead><tr><th align="left">Precedence</th><th align="left">Operator</th><th align="left">Description</th><th align="left">Associativity</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">++  –</td><td align="left">Suffix/postfix increment and decrement</td><td align="left">Left-to-right</td></tr><tr><td align="left"></td><td align="left">()</td><td align="left">Function call</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">[]</td><td align="left">Array subscripting</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">.</td><td align="left">Structure and union member access</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">−&gt;</td><td align="left">Structure and union member access through pointer</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">(<em>type</em>){<em>list</em>}</td><td align="left">Compound literal(C99)</td><td align="left"></td></tr><tr><td align="left">2</td><td align="left">++  –</td><td align="left">Prefix increment and decrement</td><td align="left">Right-to-left</td></tr><tr><td align="left"></td><td align="left">+  −</td><td align="left">Unary plus and minus</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">!  ~</td><td align="left">Logical NOT and bitwise NOT</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">(<em>type</em>)</td><td align="left">Type cast</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">*</td><td align="left">Indirection (dereference)</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">&amp;</td><td align="left">Address-of</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">sizeof</td><td align="left">Size-of</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">_Alignof</td><td align="left">Alignment requirement(C11)</td><td align="left"></td></tr><tr><td align="left">3</td><td align="left">*  /  %</td><td align="left">Multiplication, division, and remainder</td><td align="left">Left-to-right</td></tr><tr><td align="left">4</td><td align="left">+  −</td><td align="left">Addition and subtraction</td><td align="left"></td></tr><tr><td align="left">5</td><td align="left">&lt;&lt;  &gt;&gt;</td><td align="left">Bitwise left shift and right shift</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left">&lt;  &lt;=</td><td align="left">For relational operators &lt; and ≤ respectively</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">&gt;  &gt;=</td><td align="left">For relational operators &gt; and ≥ respectively</td><td align="left"></td></tr><tr><td align="left">7</td><td align="left">==  !=</td><td align="left">For relational = and ≠ respectively</td><td align="left"></td></tr><tr><td align="left">8</td><td align="left">&amp;</td><td align="left">Bitwise AND</td><td align="left"></td></tr><tr><td align="left">9</td><td align="left">^</td><td align="left">Bitwise XOR (exclusive or)</td><td align="left"></td></tr><tr><td align="left">10</td><td align="left">&#124;</td><td align="left">Bitwise OR (inclusive or)</td><td align="left"></td></tr><tr><td align="left">11</td><td align="left">&amp;&amp;</td><td align="left">Logical AND</td><td align="left"></td></tr><tr><td align="left">12</td><td align="left">&#124;&#124;</td><td align="left">Logical OR</td><td align="left"></td></tr><tr><td align="left">13</td><td align="left">?:</td><td align="left">Ternary conditional</td><td align="left">Right-to-Left</td></tr><tr><td align="left">14</td><td align="left">=</td><td align="left">Simple assignment</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">+=  −=</td><td align="left">Assignment by sum and difference</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">*=  /=  %=</td><td align="left">Assignment by product, quotient, and remainder</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">&lt;&lt;=  &gt;&gt;=</td><td align="left">Assignment by bitwise left shift and right shift</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">&amp;=  ^=</td><td align="left">=</td><td align="left">Assignment by bitwise AND, XOR, and OR</td></tr><tr><td align="left">15</td><td align="left">,</td><td align="left">Comma</td><td align="left">Left-to-right</td></tr></tbody></table><p>PHP运算符优先级</p><table><thead><tr><th align="left">结合方向</th><th align="left">运算符</th><th align="left">附加信息</th></tr></thead><tbody><tr><td align="left">非结合</td><td align="left">clone new</td><td align="left">clone 和 new</td></tr><tr><td align="left">左</td><td align="left">[</td><td align="left">array()</td></tr><tr><td align="left">非结合</td><td align="left">++ –</td><td align="left">递增／递减运算符</td></tr><tr><td align="left">非结合</td><td align="left">~ - (int) (float) (string) (array) (object) (bool) @</td><td align="left">类型</td></tr><tr><td align="left">非结合</td><td align="left">instanceof</td><td align="left">类型</td></tr><tr><td align="left">右结合</td><td align="left">!</td><td align="left">逻辑操作符</td></tr><tr><td align="left">左</td><td align="left">* / %</td><td align="left">算术运算符</td></tr><tr><td align="left">左</td><td align="left">+ - .</td><td align="left">算术运算符 和 字符串运算符</td></tr><tr><td align="left">左</td><td align="left">&lt;&lt; &gt;&gt;</td><td align="left">位运算符</td></tr><tr><td align="left">非结合</td><td align="left">&lt; &lt;= &gt; &gt;= &lt;&gt;</td><td align="left">比较运算符</td></tr><tr><td align="left">非结合</td><td align="left">== != === !==</td><td align="left">比较运算符</td></tr><tr><td align="left">左</td><td align="left">&amp;</td><td align="left">位运算符 和 引用</td></tr><tr><td align="left">左</td><td align="left">^</td><td align="left">位运算符</td></tr><tr><td align="left">左</td><td align="left">&#124;</td><td align="left">位运算符</td></tr><tr><td align="left">左</td><td align="left">&amp;&amp;</td><td align="left">逻辑运算符</td></tr><tr><td align="left">左</td><td align="left">&#124;&#124;</td><td align="left">逻辑运算符</td></tr><tr><td align="left">左</td><td align="left">? :</td><td align="left">三元运算符</td></tr><tr><td align="left">右</td><td align="left">= += -= *= /= .= %= &amp;= &#124;= ^= &lt;&lt;= &gt;&gt;=</td><td align="left">赋值运算符</td></tr><tr><td align="left">左</td><td align="left">and</td><td align="left">逻辑运算符</td></tr><tr><td align="left">左</td><td align="left">xor</td><td align="left">逻辑运算符</td></tr><tr><td align="left">左</td><td align="left">or</td><td align="left">逻辑运算符</td></tr><tr><td align="left">左</td><td align="left">,</td><td align="left">多处用到</td></tr></tbody></table><p>Python 运算符优先级<br>| 运算符               | 描述             | 序号 |<br>| :——————- | :————— | —- |<br>| lambda               | Lambda表达式     | 1    |<br>| or                   | 布尔“或”         | 2    |<br>| and                  | 布尔“与”         | 3    |<br>| not x                | 布尔“非”         | 4    |<br>| in，not in           | 成员测试         | 5    |<br>| is，is not           | 同一性测试       | 6    |<br>| &lt;，&lt;=，&gt;，&gt;=，!=，== | 比较             | 7    |<br>| &#124;               | 按位或           | 8    |<br>| ^                    | 按位异或         | 9    |<br>| &amp;                    | 按位与           | 10   |<br>| &lt;&lt;，&gt;&gt;               | 移位             | 11   |<br>| +，-                 | 加法与减法       | 12   |<br>| <em>，/，%              | 乘法、除法与取余 | 13   |<br>| +x，-x               | 正负号           | 14   |<br>| ~x                   | 按位翻转         | 15   |<br>| *</em>                   | 指数             | 16   |<br>| x.attribute          | 属性参考         | 17   |<br>| x[index]             | 下标             | 18   |<br>| x[index:index]       | 寻址段           | 19   |<br>| f(arguments…)      | 函数调用         | 20   |<br>| (experession,…)    | 绑定或元组显示   | 21   |<br>| [expression,…]     | 列表显示         | 22   |<br>| {key:datum,…}      | 字典显示         | 23   |<br>| ‘expression,…’     | 字符串转换       | 24   |</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EurekaClient注册到EurekaServer的秘密</title>
    <link href="/2019/06/12/EurekaClient%E6%B3%A8%E5%86%8C%E5%88%B0EurekaServer%E7%9A%84%E7%A7%98%E5%AF%86/"/>
    <url>/2019/06/12/EurekaClient%E6%B3%A8%E5%86%8C%E5%88%B0EurekaServer%E7%9A%84%E7%A7%98%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们知道Eureka分为两部分，Eureka Server和Eureka Client。Eureka Server充当注册中心的角色，Eureka Client相对于Eureka Server来说是客户端，需要将自身信息注册到注册中心。本文主要介绍的就是在Eureka Client注册到Eureka Server时     <code>RetryableClientQuarantineRefreshPercentage</code>参数的使用技巧。 </p><a id="more"></a><h2 id="Eureka-Client注册过程分析"><a href="#Eureka-Client注册过程分析" class="headerlink" title="Eureka Client注册过程分析"></a>Eureka Client注册过程分析</h2><p>Eureka Client注册到Eureka Server时，首先遇到第一个问题就是Eureka Client端要知道Server的地址，这个参数对应的是     <code>eureka.client.service-url.defaultZone</code>举个例子，在Eureka Client的properties文件中配置如下： </p><pre><code class="hljs properties"><span class="hljs-meta">eureka.client.service-url.defaultZone</span>=<span class="hljs-string"></span><span class="hljs-attr">http</span>:<span class="hljs-string">//localhost:8761/eureka,http://localhost:8762/eureka,http://localhost:8763/eureka,http://localhost:8764/eureka</span></code></pre><p>如上图所示，Eureka Client配置对应的Eureka Server地址分别是8761、8762、8763、8764。这里存在两个问题： </p><ul><li>Eureka Client会将自身信息分别注册到这四个地址吗？     </li><li>Eureka Clinent注册机制是怎样的？     </li></ul><p>源码面前一目了然，带着这两个问题我们通过源码来解答这两个问题。Eureka Client在启动的时候注册源码如下：<br><code>RetryableEurekaHttpClient</code>中的<code>execut</code>方法 </p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-keyword">protected</span> &lt;R&gt; <span class="hljs-function">EurekaHttpResponse&lt;R&gt; <span class="hljs-title">execute</span><span class="hljs-params">(RequestExecutor&lt;R&gt; requestExecutor)</span> </span>&#123;    List&lt;EurekaEndpoint&gt; candidateHosts = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">int</span> endpointIdx = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> retry = <span class="hljs-number">0</span>; retry &lt; numberOfRetries; retry++) &#123;        EurekaHttpClient currentHttpClient = delegate.get();        EurekaEndpoint currentEndpoint = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span> (currentHttpClient == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (candidateHosts == <span class="hljs-keyword">null</span>) &#123;                candidateHosts = getHostCandidates();                <span class="hljs-keyword">if</span> (candidateHosts.isEmpty()) &#123;                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TransportException(<span class="hljs-string">"There is no known eureka server; cluster server list is empty"</span>);                &#125;            &#125;            <span class="hljs-keyword">if</span> (endpointIdx &gt;= candidateHosts.size()) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TransportException(<span class="hljs-string">"Cannot execute request on any known server"</span>);            &#125;            currentEndpoint = candidateHosts.get(endpointIdx++);            currentHttpClient = clientFactory.newClient(currentEndpoint);        &#125;        <span class="hljs-keyword">try</span> &#123;            EurekaHttpResponse&lt;R&gt; response = requestExecutor.execute(currentHttpClient);            <span class="hljs-keyword">if</span> (serverStatusEvaluator.accept(response.getStatusCode(), requestExecutor.getRequestType())) &#123;                delegate.set(currentHttpClient);                <span class="hljs-keyword">if</span> (retry &gt; <span class="hljs-number">0</span>) &#123;                    logger.info(<span class="hljs-string">"Request execution succeeded on retry #&#123;&#125;"</span>, retry);                &#125;                <span class="hljs-keyword">return</span> response;            &#125;            logger.warn(<span class="hljs-string">"Request execution failure with status code &#123;&#125;; retrying on another server if available"</span>, response.getStatusCode());        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            logger.warn(<span class="hljs-string">"Request execution failed with message: &#123;&#125;"</span>, e.getMessage());  <span class="hljs-comment">// just log message as the underlying client should log the stacktrace</span>        &#125;        <span class="hljs-comment">// Connection error or 5xx from the server that must be retried on another server</span>        delegate.compareAndSet(currentHttpClient, <span class="hljs-keyword">null</span>);        <span class="hljs-keyword">if</span> (currentEndpoint != <span class="hljs-keyword">null</span>) &#123;            quarantineSet.add(currentEndpoint);        &#125;    &#125;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TransportException(<span class="hljs-string">"Retry limit reached; giving up on completing the request"</span>);&#125;</code></pre><p>按照我的理解，代码精简后内容如下： </p><pre><code class="hljs java"><span class="hljs-keyword">int</span> endpointIdx = <span class="hljs-number">0</span>;<span class="hljs-comment">//用来保存所有Eureka Server信息(8761、8762、8763、8764)</span>List&lt;EurekaEndpoint&gt; candidateHosts = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//numberOfRetries的值代码写死默认为3次</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> retry = <span class="hljs-number">0</span>; retry &lt; numberOfRetries; retry++) &#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> *首次进入循环时，获取全量的Eureka Server信息(8761、8762、8763、8764)</span><span class="hljs-comment"> */</span><span class="hljs-keyword">if</span> (candidateHosts == <span class="hljs-keyword">null</span>) &#123;        candidateHosts = getHostCandidates();    &#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> *通过endpointIdx自增，依次获取Eureka Server信息，然后发送</span><span class="hljs-comment"> *注册的Post请求.</span><span class="hljs-comment"> */</span>    currentEndpoint = candidateHosts.get(endpointIdx++);    currentHttpClient = clientFactory.newClient(currentEndpoint);    <span class="hljs-keyword">try</span> &#123;       <span class="hljs-comment">/**</span><span class="hljs-comment"> *发送注册的Post请求动作，注意如果成功，则跳出循环，如果失败则</span><span class="hljs-comment"> *根据endpointIdx依次获取下一个Eureka Server.</span><span class="hljs-comment"> */</span>        response = requestExecutor.execute(currentHttpClient);        <span class="hljs-keyword">return</span> respones;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        <span class="hljs-comment">//向注册中心(Eureka Server)发起注册的post出现异常时，打印日志...</span>    &#125;    <span class="hljs-comment">//如果此次注册动作失败，将当前的信息保存到quarantineSet中(一个Set集合)</span>    <span class="hljs-keyword">if</span> (currentEndpoint != <span class="hljs-keyword">null</span>) &#123;        quarantineSet.add(currentEndpoint);    &#125;&#125;<span class="hljs-comment">//如果都失败,则以异常形式抛出...</span><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TransportException(<span class="hljs-string">"Retry limit reached; giving up on completing the request"</span>);</code></pre><p>上面代码中还有一个方法很重要就是     <code>List&lt;EurekaEndpoint&gt; candidateHosts = getHostCandidates();</code>接下来看下     <code>getHostCandidates()</code>方法源码 </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;EurekaEndpoint&gt; <span class="hljs-title">getHostCandidates</span><span class="hljs-params">()</span> </span>&#123;    List&lt;EurekaEndpoint&gt; candidateHosts = clusterResolver.getClusterEndpoints();    quarantineSet.retainAll(candidateHosts);    <span class="hljs-comment">// If enough hosts are bad, we have no choice but start over again</span>    <span class="hljs-keyword">int</span> threshold = (<span class="hljs-keyword">int</span>) (candidateHosts.size() * transportConfig.getRetryableClientQuarantineRefreshPercentage());    <span class="hljs-keyword">if</span> (quarantineSet.isEmpty()) &#123;        <span class="hljs-comment">// no-op</span>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (quarantineSet.size() &gt;= threshold) &#123;        logger.debug(<span class="hljs-string">"Clearing quarantined list of size &#123;&#125;"</span>, quarantineSet.size());        quarantineSet.clear();    &#125; <span class="hljs-keyword">else</span> &#123;        List&lt;EurekaEndpoint&gt; remainingHosts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(candidateHosts.size());        <span class="hljs-keyword">for</span> (EurekaEndpoint endpoint : candidateHosts) &#123;            <span class="hljs-keyword">if</span> (!quarantineSet.contains(endpoint)) &#123;                remainingHosts.add(endpoint);            &#125;        &#125;        candidateHosts = remainingHosts;    &#125;    <span class="hljs-keyword">return</span> candidateHosts;&#125;</code></pre><p>按照我的理解，将代码精简下，只包括关键逻辑，内容如下： </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;EurekaEndpoint&gt; <span class="hljs-title">getHostCandidates</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取所有defaultZone配置的注册中心信息(Eureka Server)，</span><span class="hljs-comment">     * 在本文例子中代表4个(8761、8762、8763、8764)Eureka Server</span><span class="hljs-comment">     */</span>    List candidateHosts = clusterResolver.getClusterEndpoints();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * quarantineSet这个Set集合中保存的是不可用的Eureka Server</span><span class="hljs-comment">     * 此处是拿不可用的Eureka Server与全量的Eureka Server取交集</span><span class="hljs-comment">     */</span>    quarantineSet.retainAll(candidateHosts);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据RetryableClientQuarantineRefreshPercentage参数计算阈值</span><span class="hljs-comment">     * 该阈值后续会和quarantineSet中保存的不可用的Eureka Server个数</span><span class="hljs-comment">     * 作比较，从而判断是否返回全量的Eureka Server还是过滤掉不可用的</span><span class="hljs-comment">     * Eureka Server。</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">int</span> threshold =        (<span class="hljs-keyword">int</span>) (        candidateHosts.size()              *        transportConfig.getRetryableClientQuarantineRefreshPercentage()        );    <span class="hljs-keyword">if</span> (quarantineSet.isEmpty()) &#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 首次进入的时候，此时quarantineSet为空，直接返回全量的</span><span class="hljs-comment">         * Eureka Server列表</span><span class="hljs-comment">         */</span>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (quarantineSet.size() &gt;= threshold) &#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 将不可用的Eureka Server与threshold值相比较，如果不可</span><span class="hljs-comment">         * 用的Eureka Server个数大于阈值，则将之间保存的Eureka</span><span class="hljs-comment">         * Server内容直接清空，并返回全量的Eureka Server列表。</span><span class="hljs-comment">         */</span>        quarantineSet.clear();    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 通过quarantineSet集合保存不可用的Eureka Server来过滤</span><span class="hljs-comment">         * 全量的EurekaServer，从而获取此次Eureka Client要注册要</span><span class="hljs-comment">         * 注册的Eureka Server实例地址。</span><span class="hljs-comment">         */</span>        List&lt;EurekaEndpoint&gt; remainingHosts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(candidateHosts.size());        <span class="hljs-keyword">for</span> (EurekaEndpoint endpoint : candidateHosts) &#123;            <span class="hljs-keyword">if</span> (!quarantineSet.contains(endpoint)) &#123;                remainingHosts.add(endpoint);            &#125;        &#125;        candidateHosts = remainingHosts;    &#125;    <span class="hljs-keyword">return</span> candidateHosts;&#125;</code></pre><p>通过源码分析，我们现在初步知道，当Eureka Client向Eureka Server发起注册请求的时候(根据defaultZone寻找Eureka Server列表)，如果有一次请求注册成功，那么后续就不会在向其他Eureka Server发起注册请求。以本文为例，注册中心有四个(8761、8762、8763、8764)。如果8761对应的Eureka Server服务的状态是UP，那么Eureka Client向该注册中心注册成功后，不会再向(8762、8763、8764)对应的Eureka Server发起注册请求(对应程序是在for循环中直接return respones)。 </p><p>说到这里又引出来另外一个问题，如果8761这个Eureka Server是down掉的呢？ </p><p>根据源码我们可知Eureka Client首次会向8761这个Server发起注册请求，如果该Server的状态是down，那么它会将该Server保存到quarantineSet这个Set集合中，然后再次访问8762这个Eureka Server，如果8762这个Server的状态依旧是down，它也会把这个Server保存到quarantineSet这个Set集合中，然后继续访问8763这个Server，如果8763这个Server的状态依旧是down，此时除了会将其保存到quarantineSet这个Set集合中之外，还会跳出本次循环。从而结束此次注册过程。 </p><p>说道这里有人要问接下来会不会向8764这个Server发起注册，答案是否定的，因为循环的次数默认是3次。所以即使8764这个Server的状态是UP，它也不会接收到来自Eureka Client发起的注册信息。 </p><p>Eureka Client向Eureka Server发起注册信息的过程除了在Eureka Client启动的时候触发，还有另外一种方式，就是后台定时任务。<br>假设我们上面描述的场景是在Eureka Client启动的时候，因为在启动的时候注册这个过程全部失败了，当后台定时任务执行时，还会进入该注册流程。注意此时quarantineSet的值为3(8761、8762、8763之前注册失败的Eureka Server)。<br>所以当程序再次进入     <code>getHostCandidates()</code>方法时，     <code>if (quarantineSet.isEmpty())</code>这个方法是不满足的，接下来会走     <code>else if (quarantineSet.size() &gt;= threshold)</code>这个判断，如果这个判断成立，那么会将quarantineSet集合清空，同时返回全量的Eureka Server列表，如果这个判断不成立，会拿quarantineSet集合中保存的内容去过滤Eureka Server的全量列表。以本文为例： </p><ul><li><code>quarantineSet</code>中保存的是(8761、8762、8763)三个Eureka Server     </li><li>Eureka Server全量列表的内容是(8761、8762、8763、8764)四个Eureka Server，过滤后返回的结果为8764这个Eureka Server。     </li></ul><p>在本文的例子中8761、8762、8763这三个Eureka Server的状态是down而8764这个Eureka Server的状态是UP，我们其实是想走到最后的else分支，从而完成过滤操作，并最终得到8764这个Server，遗憾的是它并不会走到这个分支，而是被上面的     <code>else if (quarantineSet.size() &gt;= threshold)</code>这个分支所拦截，返回的依旧是全量的Eureka Server列表。这样造成的后果就是Eureka Client依旧会依次向(8761、8762、8763)这三个down的Eureka Server发起注册请求。<br>那么问题的关键在哪里呢？问题的关键就是threshold这个值的由来，因为此时quarantineSet.size()的值为3，而3这个值大于threshold，从而导致，会将quarantineSet集合清空，返回全量的Server列表。<br>我们知道threshold这个值是根据全量的Eureka Server列表乘以一个可配置的参数计算出来的，在本文的例子当中，我的properties文件中除了defaultZone之外并没有配置这个参数，那么也就是说这个参数是有默认值的，通过源码我们了解到，这个默认值是0.66。具体源码如下： </p><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PropertyBasedTransportConfigConstants</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> *省略部分源码</span><span class="hljs-comment"> */</span>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Values</span> </span>&#123;        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SESSION_RECONNECT_INTERVAL = <span class="hljs-number">20</span>*<span class="hljs-number">60</span>;        <span class="hljs-comment">//默认值为0.66</span>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> QUARANTINE_REFRESH_PERCENTAGE = <span class="hljs-number">0.66</span>;        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DATA_STALENESS_TRHESHOLD = <span class="hljs-number">5</span>*<span class="hljs-number">60</span>;        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ASYNC_RESOLVER_REFRESH_INTERVAL = <span class="hljs-number">5</span>*<span class="hljs-number">60</span>*<span class="hljs-number">1000</span>;        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ASYNC_RESOLVER_WARMUP_TIMEOUT = <span class="hljs-number">5000</span>;        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ASYNC_EXECUTOR_THREADPOOL_SIZE = <span class="hljs-number">5</span>;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> *<span class="hljs-doctag">@return</span> the percentage of the full endpoints set above which the   </span><span class="hljs-comment"> *quarantine set is cleared in the range [0, 1.0]</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getRetryableClientQuarantineRefreshPercentage</span><span class="hljs-params">()</span></span>;</code></pre><p>看到这里就不难理解了，因为这个值是0.66而此时全量的Eureka Server值为4。计算之后的值为2，而由于注册的for循环为3次，所以当第二次发起注册流程的时候quarantineSet的值始终大于threshold。这样就会导致一个问题，就是如果8761、8762、8763一直是down即使8764一直是好的，那么Eureka Client也不会注册成功。而且这个参数值的区间为0到1. </p><p>既然通过源码分析我们找到了问题根源，其实对应的我们也找到了解决这个问题的办法，就是对应把这个参数值调大些。<br>这个值在properties中对应的写法如下： </p><pre><code class="hljs java">eureka.client.transport.retryableClientQuarantineRefreshPercentage = xxx</code></pre><p>接下来我们修改下properties文件，修改后的内容如下： </p><pre><code class="hljs java">eureka.client.service-url.defaultZone=http:<span class="hljs-comment">//localhost:8761/eureka,http://localhost:8762/eureka,http://localhost:8763/eureka,http://localhost:8764/eureka</span>eureka.client.transport.retryableClientQuarantineRefreshPercentage=<span class="hljs-number">1</span></code></pre><p>接下来按照这个配置再次回顾下上面的流程： </p><ul><li>Eureka Client启动时进行注册(8761、8762、8763的状态是down)，所以此时quarantineSet的值为3.     </li><li>接下来在定时任务中又触发注册事件，此时因为参数的值从0.66调整为1。所以计算出的threshold的值为4。而此时quarantineSet的值为3。所以不会进入到         <code>else if (quarantineSet.size() &gt;= threshold)</code>分支，而是会进入最后的esle分支。     </li><li>在else分支中会完成过滤功能，最终返回的list中的结果只有一个就是8764这个Eureka Server。     </li><li>Eureka Client向8764这个Eureka Server发起注册请求，得到成功相应，并返回。     </li></ul><h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>说道这里我们感觉好像是解决了这个问题，那么问一个问题，这个参数值可以设置的无限大吗？ </p><p>比如我将这个参数值设置为10，虽然javaDoc中说明这个参数值的范围在0-1之间，但是并没有说明如果将这个参数调整大于1会出现什么情况。接下来按照上面的流程我们分析下：<br>之前我们分析的流程中的前提是8761、8762、8763这三台Server的状态是down而8764这个server的状态是up，现在我们修改下这个前提。<br>假设一开始8761、8762、8763、8764这四台Eureka Server的状态都是down。 </p><ul><li>Eureka Client启动时进行注册(8761、8762、8763的状态是down)，所以此时quarantineSet的值为3.     </li><li>接下来在定时任务中又触发注册事件，此时因为参数的值从0.66调整为10。所以计算出的threshold的值为40。而此时quarantineSet的值为3。所以不会进入到         <code>else if (quarantineSet.size() &gt;= threshold)</code>分支，而是会进入最后的esle分支。     </li><li>在else分支中会完成过滤功能，最终返回的list中的结果只有一个就是8764这个Eureka Server。     </li><li>Eureka Client向8764这个Eureka Server发起注册请求，因为此时8764的状态也是down导致注册失败，此时quarantineSet中的内容是(8761、8762、8763、8764)     </li><li>当定时任务再次触发时         <code>if (quarantineSet.isEmpty())</code>这个分支不会进入，因为此时quarantineSet的值为4     </li><li><code>else if (quarantineSet.size() &gt;= threshold)</code>这分支也不会进入因为threshold的值为40     </li><li>最终会进入else分支，这个分支原本的含义是想通过quarantineSet来充当过滤器，从全量的Eureka Server中过滤掉之前状态为down的Eureka Server，但是由于quarantineSet的值现在已经是全量，导致过滤后的结果返回的是一个空的list。即使此时Eureka Server列表(8761、8762、8763、8764)任何一个Server的状态变为UP，该Eureka Client也不可能完成注册事件。     </li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>上面出现的那个问题，根本原因个人认为是由于     <code>eureka.client.transport.retryableClientQuarantineRefreshPercentage</code>参数过大而源码中没有校验，从而导致没有进入     <code>else if (quarantineSet.size() &gt;= threshold)</code>的逻辑分支，因为此时如果quarantineSet中的值已经达到了所有Eureka Server列表，那么此时我们希望的是将这个Set集合清空，从而再次返回全量的Eureka Server列表，也就是说再重新来一次注册流程。<br>所以基于上面的分析，个人认为在源码的     <code>getHostCandidates</code>增加下校验，具体代码如下： </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;EurekaEndpoint&gt; <span class="hljs-title">getHostCandidates</span><span class="hljs-params">()</span> </span>&#123;    List&lt;EurekaEndpoint&gt; candidateHosts = clusterResolver.getClusterEndpoints();    quarantineSet.retainAll(candidateHosts);    <span class="hljs-comment">// If enough hosts are bad, we have no choice but start over again</span>    <span class="hljs-keyword">int</span> threshold = (<span class="hljs-keyword">int</span>) (candidateHosts.size() * transportConfig.getRetryableClientQuarantineRefreshPercentage());        <span class="hljs-comment">/**</span><span class="hljs-comment">     * 增加判断如果threshold的值过大，即超过Eureka Server</span><span class="hljs-comment">     * 列表的数量，那么将其再次赋值，赋值的内容为Eureka Server</span><span class="hljs-comment">     * 列表的数量。</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">if</span> (threshold &gt; candidateHosts.size()) &#123;      threshold = candidateHosts.size();    &#125;    <span class="hljs-keyword">if</span> (quarantineSet.isEmpty()) &#123;        <span class="hljs-comment">// no-op</span>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (quarantineSet.size() &gt;= threshold) &#123;        logger.debug(<span class="hljs-string">"Clearing quarantined list of size &#123;&#125;"</span>, quarantineSet.size());        quarantineSet.clear();    &#125; <span class="hljs-keyword">else</span> &#123;        List&lt;EurekaEndpoint&gt; remainingHosts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(candidateHosts.size());        <span class="hljs-keyword">for</span> (EurekaEndpoint endpoint : candidateHosts) &#123;            <span class="hljs-keyword">if</span> (!quarantineSet.contains(endpoint)) &#123;                remainingHosts.add(endpoint);            &#125;        &#125;        candidateHosts = remainingHosts;    &#125;    <span class="hljs-keyword">return</span> candidateHosts;&#125;</code></pre><p>以上内容就是个人对     <code>eureka.client.transport.retryableClientQuarantineRefreshPercentage</code>的理解，由于本人知识水平有限，对此问题也可能理解不正确，还请大家多多留言讨论。</p><p>最后感谢<a href="http://spring4all.com/" target="_blank" rel="noopener">spring4all社区</a>提供这个平台，能让大家交流学习Spring相关知识。 </p>]]></content>
    
    
    <categories>
      
      <category>Eureka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Eureka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用hexo搭建个人博客</title>
    <link href="/2019/06/12/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2019/06/12/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>最近开始研究blog，找到了很多开源的系统，java、asp、nodejs、php，下面介绍一种基于nodejs的开源blog，网上有很多关于hexo的文档但是个人感觉还是欠缺不能一次达到目的，因为本人现在手上只有<strong>mint发行版的linux，所以直接用mint直接搭建</strong>，因为hexo是基于nodejs的应用，所以要先安装nodejs </p><hr><h4 id="1-Nodejs安装"><a href="#1-Nodejs安装" class="headerlink" title="1.Nodejs安装"></a>1.Nodejs安装</h4><p>使用apt-get 安装的nodejs版本过老，会导致安装hexo的时候出问题。<br>官方推荐的安装方法： </p><pre><code class="hljs bash">curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -sudo apt-get install -y nodejs</code></pre><p>centos 上： </p><pre><code class="hljs bash">wget https://nodejs.org/dist/v7.7.4/node-v7.7.4-linux-x64.tar.gztar zxvf node-v7.7.4-linux-x64.tar.gz</code></pre><a id="more"></a><p>sudo vi /etc/profile </p><pre><code class="hljs properties"><span class="hljs-comment"># node （注释作用）</span><span class="hljs-attr">export</span> <span class="hljs-string">NODE_HOME=/home/user/software/node-v7.7.4-linux-x64</span><span class="hljs-attr">export</span> <span class="hljs-string">PATH=$PATH:$NODE_HOME/bin  </span><span class="hljs-attr">export</span> <span class="hljs-string">NODE_PATH=$NODE_HOME/lib/node_modules</span></code></pre><p>:wq （保存并退出）<br>source /etc/profile （使配置文件生效） </p><h4 id="2-Hexo安装"><a href="#2-Hexo安装" class="headerlink" title="2.Hexo安装"></a>2.Hexo安装</h4><p><a href="https://github.com/hexojs/hexo/" target="_blank" rel="noopener">Hexo</a> 是一个功能强大的静态网站生成系统，快速、简洁、高效。Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。可以一键部署到github，还有丰富的插件和主题,还支持热部署哦。执行如下命令进行安装 </p><pre><code class="hljs bash">sudo npm install hexo-cli -g</code></pre><p>安装Hexo安成后，使用如下命令快速新建一个博客系统，然后运行它： </p><ol><li><code>hexo init blog</code>     </li><li><code>cd blog</code>     </li><li><code>npm install</code>     </li><li><code>hexo server</code>     </li></ol><p>如果npm安装失败，请使用sudo安装。运行成功后，访问 <a href="http://0.0.0.0:4000/" target="_blank" rel="noopener">http://127.0.0.1:4000/</a><a href="http://127.0.0.1:4000/" target="_blank" rel="noopener"> </a> </p><p>Hexo 生成博客的目录结构： </p><pre><code class="hljs bash">.├── _config.yml├── db.json├── node_modules├── package.json├── public├── scaffolds├── <span class="hljs-built_in">source</span>└── themes</code></pre><p>其中_config.yml是配置站点的文件，public是hexo生成的静态站点文件夹，scaffolds是模板文件夹，source是存在用户资源的文件夹，themes是主题文件夹。</p><h4 id="3-站点配置"><a href="#3-站点配置" class="headerlink" title="3.站点配置"></a>3.站点配置</h4><p>找到title，subtitle，author参数配置，分别配置站点的标题、副标题和作者 </p><pre><code class="hljs yaml"><span class="hljs-attr">title:</span> <span class="hljs-string">Alter的博客</span><span class="hljs-attr">subtitle:</span> <span class="hljs-string">专注于Java</span><span class="hljs-attr">description:</span> <span class="hljs-string">我就是我不一样的水果</span><span class="hljs-attr">author:</span> <span class="hljs-string">Alter</span><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span></code></pre><p>然后配置站点的url和permalink，这两个分别是你的站点的url host地址以及文章的永久连接 </p><pre><code class="hljs yaml"><span class="hljs-attr">url:</span> <span class="hljs-string">http://www.alterempty.cn</span><span class="hljs-string">root:/</span><span class="hljs-string">permalink::year/:month/:day/:title.html</span><span class="hljs-attr">permalink_defaults:</span></code></pre><p>permalink 我配置的是年月日以及title，后缀是html，便于搜索收录。permalink详情参见： <a href="http://hexo.io/zh-cn/docs/permalinks.html" target="_blank" rel="noopener">http://hexo.io/zh-cn/docs/permalinks.html</a> </p><h4 id="4-新增一篇文章"><a href="#4-新增一篇文章" class="headerlink" title="4.新增一篇文章"></a>4.新增一篇文章</h4><p>使用如下命令即可新增一篇md格式的文章： </p><pre><code class="hljs shell">hexo new'github-page-with-hexo'</code></pre><p>然后就会在sources/_posts生成一篇文件名为github-page-with-hexo.md的markdown文件。编辑该文件就可以写博客了 </p><p>Front-matter 是文件最上方以 —- 分隔的区域，用于指定个别文件的变量，举例来说： </p><pre><code class="hljs markdown">title:"使用Hexo在Github上搭建自己的博客"date:2017-03-22 00:00:04tags:-Hexo-Githubcategories:-Hexo---</code></pre><p>目前的categories只能有一个一级分类，如果填写多个，第二个会被解析为二级分类，以及类推。tags可以允许有多个。更多关于Front-matter请参考 <a href="http://hexo.io/zh-cn/docs/front-matter.html" target="_blank" rel="noopener">http://hexo.io/zh-cn/docs/front-matter.html</a> 。 </p><h4 id="5-安装git"><a href="#5-安装git" class="headerlink" title="5.安装git"></a>5.安装git</h4><pre><code class="hljs shell">sudo apt install git</code></pre><p>通过 git –version 查看是否安装成功 </p><h4 id="6-申请GitHub"><a href="#6-申请GitHub" class="headerlink" title="6.申请GitHub"></a>6.申请GitHub</h4><h4 id="7-发布博客"><a href="#7-发布博客" class="headerlink" title="7.发布博客"></a>7.发布博客</h4><p> 发布更新博客 </p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> hexo d -g</span></code></pre><p>然后等个几分钟，访问你的域名就可以看到你的网站了 </p><p>注：从github上获取数据的办法有很多，就不一一阐述 </p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
      <category>Blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js生成一个不重复的ID的函数的进化之路</title>
    <link href="/2019/06/12/js%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84ID%E7%9A%84%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/"/>
    <url>/2019/06/12/js%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84ID%E7%9A%84%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p>在MongoDB中的ObjectID，可以理解为是一个不会重复的ID，这里有个链接<a href="http://blog.csdn.net/xiamizy/article/details/41521025" target="_blank" rel="noopener">http://blog.csdn.net/xiamizy/article/details/41521025</a> 感兴趣可以去研究一下。 </p><h2 id="我今天要做的就是做一个不重复ID的生成器"><a href="#我今天要做的就是做一个不重复ID的生成器" class="headerlink" title="我今天要做的就是做一个不重复ID的生成器"></a>我今天要做的就是做一个不重复ID的生成器</h2><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 生成一个用不重复的ID</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GenNonDuplicateID</span>(<span class="hljs-params"></span>):<span class="hljs-title">String</span></span>&#123;  &#125;</code></pre><a id="more"></a><h2 id="先看看下面的几个方法"><a href="#先看看下面的几个方法" class="headerlink" title="先看看下面的几个方法"></a>先看看下面的几个方法</h2><h3 id="1-生成-0-1-的随机数的Math-random-例如"><a href="#1-生成-0-1-的随机数的Math-random-例如" class="headerlink" title="1.生成[0,1)的随机数的Math.random,例如"></a>1.生成[0,1)的随机数的Math.random,例如</h3><pre><code class="hljs javascript"><span class="hljs-comment">//我这次运行生成的是：0.5834165740043102</span><span class="hljs-built_in">Math</span>.random()</code></pre><h3 id="2-获取当前时间戳Date-now"><a href="#2-获取当前时间戳Date-now" class="headerlink" title="2.获取当前时间戳Date.now"></a>2.获取当前时间戳Date.now</h3><pre><code class="hljs javascript"><span class="hljs-comment">//现在时间戳是1482645606622</span><span class="hljs-built_in">Date</span>.now() = <span class="hljs-number">1521009303858</span></code></pre><h3 id="3-将10进制转换为其他进制的字符串-Number-toString"><a href="#3-将10进制转换为其他进制的字符串-Number-toString" class="headerlink" title="3.将10进制转换为其他进制的字符串 Number.toString"></a>3.将10进制转换为其他进制的字符串 Number.toString</h3><pre><code class="hljs javascript"><span class="hljs-comment">//将1482645606622转换成二进制：10101100100110100100100001001000011011110</span>(<span class="hljs-number">1482645606622</span>).toString(<span class="hljs-number">2</span>)<span class="hljs-comment">//转换成16进制：159349090de MongDB中的ObjectID就是24位16进制数</span>(<span class="hljs-number">1482645606622</span>).toString(<span class="hljs-number">16</span>)；<span class="hljs-comment">//最大进制支持转为36进制，使用字符是0-9a-z ：ix48wvry</span>(<span class="hljs-number">1482645606622</span>).toString(<span class="hljs-number">36</span>)</code></pre><h2 id="GenNonDuplicateID的自我进化"><a href="#GenNonDuplicateID的自我进化" class="headerlink" title="GenNonDuplicateID的自我进化"></a>GenNonDuplicateID的自我进化</h2><h3 id="1-随机数版本-v0-0-1"><a href="#1-随机数版本-v0-0-1" class="headerlink" title="1.随机数版本 v0.0.1"></a>1.随机数版本 v0.0.1</h3><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 生成一个用不重复的ID</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GenNonDuplicateID</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.random().toString()&#125;<span class="hljs-comment">//生成一个类似 0.1283460319177394的ID</span>GenNonDuplicateID()</code></pre><h3 id="2-随机数版本16进制版本-v0-0-2"><a href="#2-随机数版本16进制版本-v0-0-2" class="headerlink" title="2.随机数版本16进制版本 v0.0.2"></a>2.随机数版本16进制版本 v0.0.2</h3><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 生成一个用不重复的ID</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GenNonDuplicateID</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.random().toString(<span class="hljs-number">16</span>)&#125;<span class="hljs-comment">//函数将生成类似 0.c1615913fa915 的ID</span>GenNonDuplicateID()</code></pre><h3 id="3-随机数版本36进制版本-v0-0-3"><a href="#3-随机数版本36进制版本-v0-0-3" class="headerlink" title="3.随机数版本36进制版本 v0.0.3"></a>3.随机数版本36进制版本 v0.0.3</h3><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 生成一个用不重复的ID</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GenNonDuplicateID</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.random().toString(<span class="hljs-number">36</span>)&#125;<span class="hljs-comment">//函数将生成类似 0.hefy7uw6ddzwidkwcmxkzkt9 的ID</span>GenNonDuplicateID()</code></pre><h3 id="4-随机数版本36进制版本-去掉”0-”-v0-0-4"><a href="#4-随机数版本36进制版本-去掉”0-”-v0-0-4" class="headerlink" title="4.随机数版本36进制版本 去掉”0.” v0.0.4"></a>4.随机数版本36进制版本 去掉”0.” v0.0.4</h3><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 生成一个用不重复的ID</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GenNonDuplicateID</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.random().toString(<span class="hljs-number">36</span>).substr(<span class="hljs-number">3</span>)&#125;<span class="hljs-comment">//函数将生成类似 8dlv9vabygks2cbg1spds4i 的ID</span>GenNonDuplicateID()</code></pre><p><strong>然而用一个随机数作为ID，随着使用次数的累积，必然会出现相同的两个ID</strong> </p><h3 id="5-引入时间戳-的36微进制版本-v0-1-1"><a href="#5-引入时间戳-的36微进制版本-v0-1-1" class="headerlink" title="5.引入时间戳 的36微进制版本 v0.1.1"></a>5.引入时间戳 的36微进制版本 v0.1.1</h3><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 生成一个用不重复的ID</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GenNonDuplicateID</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">let</span> idStr = <span class="hljs-built_in">Date</span>.now().toString(<span class="hljs-number">36</span>)  idStr += <span class="hljs-built_in">Math</span>.random().toString(<span class="hljs-number">36</span>).substr(<span class="hljs-number">3</span>)  <span class="hljs-keyword">return</span> idStr&#125;<span class="hljs-comment">//函数将生成类似 ix49sfsnt7514k5wpflyb5l2vtok9y66r 的ID</span>GenNonDuplicateID()</code></pre><h3 id="6-引入时间戳-的36微进制版本-加入随机数长度控制-v0-1-2"><a href="#6-引入时间戳-的36微进制版本-加入随机数长度控制-v0-1-2" class="headerlink" title="6.引入时间戳 的36微进制版本 加入随机数长度控制 v0.1.2"></a>6.引入时间戳 的36微进制版本 加入随机数长度控制 v0.1.2</h3><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 生成一个用不重复的ID</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GenNonDuplicateID</span>(<span class="hljs-params">randomLength</span>)</span>&#123;  <span class="hljs-keyword">let</span> idStr = <span class="hljs-built_in">Date</span>.now().toString(<span class="hljs-number">36</span>)  idStr += <span class="hljs-built_in">Math</span>.random().toString(<span class="hljs-number">36</span>).substr(<span class="hljs-number">3</span>,randomLength)  <span class="hljs-keyword">return</span> idStr&#125;<span class="hljs-comment">// GenNonDuplicateID(3) 将生成类似 ix49wl2978w 的ID</span>GenNonDuplicateID(<span class="hljs-number">3</span>)</code></pre><p>这样生成的ID前面几位总是相同，看着不爽，于是再改改 </p><h3 id="7-引入时间戳-随机数前置-36进制-加入随机数长度控制-v0-1-3"><a href="#7-引入时间戳-随机数前置-36进制-加入随机数长度控制-v0-1-3" class="headerlink" title="7. 引入时间戳 随机数前置 36进制 加入随机数长度控制 v0.1.3"></a>7. 引入时间戳 随机数前置 36进制 加入随机数长度控制 v0.1.3</h3><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 生成一个用不重复的ID</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GenNonDuplicateID</span>(<span class="hljs-params">randomLength</span>)</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Number</span>(<span class="hljs-built_in">Math</span>.random().toString().substr(<span class="hljs-number">3</span>,randomLength) + <span class="hljs-built_in">Date</span>.now()).toString(<span class="hljs-number">36</span>)&#125;<span class="hljs-comment">//GenNonDuplicateID()将生成 rfmipbs8ag0kgkcogc 类似的ID</span>GenNonDuplicateID()</code></pre><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ID生成器-Twitter的雪花算法</title>
    <link href="/2019/06/12/ID%E7%94%9F%E6%88%90%E5%99%A8-Twitter%E7%9A%84%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/"/>
    <url>/2019/06/12/ID%E7%94%9F%E6%88%90%E5%99%A8-Twitter%E7%9A%84%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>上代码:</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Twitter_Snowflake&lt;br&gt;</span><span class="hljs-comment"> * SnowFlake的结构如下(每部分用-分开):&lt;br&gt;</span><span class="hljs-comment"> * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt;</span><span class="hljs-comment"> * 1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0&lt;br&gt;</span><span class="hljs-comment"> * 41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截)</span><span class="hljs-comment"> * 得到的值），这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下下面程序IdWorker类的startTime属性）。41位的时间截，可以使用69年，年T = (1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69&lt;br&gt;</span><span class="hljs-comment"> * 10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId&lt;br&gt;</span><span class="hljs-comment"> * 12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号&lt;br&gt;</span><span class="hljs-comment"> * 加起来刚好64位，为一个Long型。&lt;br&gt;</span><span class="hljs-comment"> * SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右。</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SnowflakeIdWorker</span> </span>&#123;    <span class="hljs-comment">// ==============================Fields===========================================</span>    <span class="hljs-comment">/** 开始时间截 (2015-01-01) */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> twepoch = <span class="hljs-number">1489111610226L</span>;    <span class="hljs-comment">/** 机器id所占的位数 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> workerIdBits = <span class="hljs-number">5L</span>;    <span class="hljs-comment">/** 数据标识id所占的位数 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> dataCenterIdBits = <span class="hljs-number">5L</span>;    <span class="hljs-comment">/** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> maxWorkerId = -<span class="hljs-number">1L</span> ^ (-<span class="hljs-number">1L</span> &lt;&lt; workerIdBits);    <span class="hljs-comment">/** 支持的最大数据标识id，结果是31 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> maxDataCenterId = -<span class="hljs-number">1L</span> ^ (-<span class="hljs-number">1L</span> &lt;&lt; dataCenterIdBits);    <span class="hljs-comment">/** 序列在id中占的位数 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> sequenceBits = <span class="hljs-number">12L</span>;    <span class="hljs-comment">/** 机器ID向左移12位 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> workerIdShift = sequenceBits;    <span class="hljs-comment">/** 数据标识id向左移17位(12+5) */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> dataCenterIdShift = sequenceBits + workerIdBits;    <span class="hljs-comment">/** 时间截向左移22位(5+5+12) */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> timestampLeftShift = sequenceBits + workerIdBits + dataCenterIdBits;    <span class="hljs-comment">/** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> sequenceMask = -<span class="hljs-number">1L</span> ^ (-<span class="hljs-number">1L</span> &lt;&lt; sequenceBits);    <span class="hljs-comment">/** 工作机器ID(0~31) */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> workerId;    <span class="hljs-comment">/** 数据中心ID(0~31) */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> dataCenterId;    <span class="hljs-comment">/** 毫秒内序列(0~4095) */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> sequence = <span class="hljs-number">0L</span>;    <span class="hljs-comment">/** 上次生成ID的时间截 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> lastTimestamp = -<span class="hljs-number">1L</span>;    <span class="hljs-comment">//==============================Constructors=====================================</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 构造函数</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> workerId 工作ID (0~31)</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dataCenterId 数据中心ID (0~31)</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SnowflakeIdWorker</span><span class="hljs-params">(<span class="hljs-keyword">long</span> workerId, <span class="hljs-keyword">long</span> dataCenterId)</span> </span>&#123;        <span class="hljs-keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(String.format(<span class="hljs-string">"workerId can't be greater than %d or less than 0"</span>, maxWorkerId));        &#125;        <span class="hljs-keyword">if</span> (dataCenterId &gt; maxDataCenterId || dataCenterId &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(String.format(<span class="hljs-string">"dataCenterId can't be greater than %d or less than 0"</span>, maxDataCenterId));        &#125;        <span class="hljs-keyword">this</span>.workerId = workerId;        <span class="hljs-keyword">this</span>.dataCenterId = dataCenterId;    &#125;    <span class="hljs-comment">// ==============================Methods==========================================</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获得下一个ID (该方法是线程安全的)</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> SnowflakeId</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">long</span> <span class="hljs-title">nextId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">long</span> timestamp = timeGen();        <span class="hljs-comment">//如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常</span>        <span class="hljs-keyword">if</span> (timestamp &lt; lastTimestamp) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(                    String.format(<span class="hljs-string">"Clock moved backwards.  Refusing to generate id for %d milliseconds"</span>, lastTimestamp - timestamp));        &#125;        <span class="hljs-comment">//如果是同一时间生成的，则进行毫秒内序列</span>        <span class="hljs-keyword">if</span> (lastTimestamp == timestamp) &#123;            sequence = (sequence + <span class="hljs-number">1</span>) &amp; sequenceMask;            <span class="hljs-comment">//毫秒内序列溢出</span>            <span class="hljs-keyword">if</span> (sequence == <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">//阻塞到下一个毫秒,获得新的时间戳</span>                timestamp = tilNextMillis(lastTimestamp);            &#125;        &#125;        <span class="hljs-comment">//时间戳改变，毫秒内序列重置</span>        <span class="hljs-keyword">else</span> &#123;            sequence = <span class="hljs-number">0L</span>;        &#125;        <span class="hljs-comment">//上次生成ID的时间截</span>        lastTimestamp = timestamp;        <span class="hljs-comment">//移位并通过或运算拼到一起组成64位的ID</span>        <span class="hljs-keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) <span class="hljs-comment">//</span>                | (dataCenterId &lt;&lt; dataCenterIdShift) <span class="hljs-comment">//</span>                | (workerId &lt;&lt; workerIdShift) <span class="hljs-comment">//</span>                | sequence;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 阻塞到下一个毫秒，直到获得新的时间戳</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lastTimestamp 上次生成ID的时间截</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 当前时间戳</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">long</span> <span class="hljs-title">tilNextMillis</span><span class="hljs-params">(<span class="hljs-keyword">long</span> lastTimestamp)</span> </span>&#123;        <span class="hljs-keyword">long</span> timestamp = timeGen();        <span class="hljs-keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;            timestamp = timeGen();        &#125;        <span class="hljs-keyword">return</span> timestamp;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 返回以毫秒为单位的当前时间</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 当前时间(毫秒)</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">long</span> <span class="hljs-title">timeGen</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> System.currentTimeMillis();    &#125;    <span class="hljs-comment">//==============================Test=============================================</span>    <span class="hljs-comment">/** 测试 */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(System.currentTimeMillis());        SnowflakeIdWorker idWorker = <span class="hljs-keyword">new</span> SnowflakeIdWorker(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);        <span class="hljs-keyword">long</span> startTime = System.nanoTime();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50000</span>; i++) &#123;            <span class="hljs-keyword">long</span> id = idWorker.nextId();            System.out.println(id);        &#125;        System.out.println((System.nanoTime()-startTime)/<span class="hljs-number">1000000</span>+<span class="hljs-string">"ms"</span>);    &#125;&#125;</code></pre><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Id</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Id</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java高效读取大文件</title>
    <link href="/2019/06/12/Java%E9%AB%98%E6%95%88%E8%AF%BB%E5%8F%96%E5%A4%A7%E6%96%87%E4%BB%B6/"/>
    <url>/2019/06/12/Java%E9%AB%98%E6%95%88%E8%AF%BB%E5%8F%96%E5%A4%A7%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a><strong>1、概述</strong></h2><p>本教程将演示如何用Java高效地读取大文件。 </p><h2 id="2、在内存中读取"><a href="#2、在内存中读取" class="headerlink" title="2、在内存中读取"></a><strong>2、在内存中读取</strong></h2><p>读取文件行的标准方式是在内存中读取，Guava 和Apache Commons IO都提供了如下所示快速读取文件行的方法： </p><pre><code class="hljs java">Files.readLines(<span class="hljs-keyword">new</span> File(path), Charsets.UTF_8); FileUtils.readLines(<span class="hljs-keyword">new</span> File(path));</code></pre><p>这种方法带来的问题是文件的所有行都被存放在内存中，当文件足够大时很快就会导致程序抛出<em>OutOfMemoryError</em> 异常。 </p><a id="more"></a><p>例如：<strong>读取一个大约1G的文件：</strong> </p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">givenUsingGuava_whenIteratingAFile_thenWorks</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    String path = ...    Files.readLines(<span class="hljs-keyword">new</span> File(path), Charsets.UTF_8);&#125;</code></pre><p>这种方式开始时只占用很少的内存：<em>（大约消耗了0Mb内存）</em> </p><pre><code class="hljs java">[main] INFO  org.baeldung.java.CoreJavaIoUnitTest - Total Memory: <span class="hljs-number">128</span> Mb[main] INFO  org.baeldung.java.CoreJavaIoUnitTest - Free Memory: <span class="hljs-number">116</span> Mb</code></pre><p>然而，<strong>当文件全部读到内存中后</strong>，我们最后可以看到<em>（大约消耗了2GB内存）</em>： </p><pre><code class="hljs java">[main] INFO  org.baeldung.java.CoreJavaIoUnitTest - Total Memory: <span class="hljs-number">2666</span> Mb[main] INFO  org.baeldung.java.CoreJavaIoUnitTest - Free Memory: <span class="hljs-number">490</span> Mb</code></pre><p>这意味这一过程大约耗费了2.1GB的内存——原因很简单：现在文件的所有行都被存储在内存中。 </p><p><strong>把文件所有的内容都放在内存中很快会耗尽可用内存</strong>——不论实际可用内存有多大，这点是显而易见的。 </p><p>此外，<strong>我们通常不需要把文件的所有行一次性地放入内存中</strong>——相反，我们只需要遍历文件的每一行，然后做相应的处理，处理完之后把它扔掉。所以，这正是我们将要做的——通过行迭代，而不是把所有行都放在内存中。 </p><h2 id="3、文件流"><a href="#3、文件流" class="headerlink" title="3、文件流"></a><strong>3、文件流</strong></h2><p>现在让我们看下这种解决方案——我们将使用java.util.Scanner类扫描文件的内容，一行一行连续地读取： </p><pre><code class="hljs java">FileInputStream inputStream = <span class="hljs-keyword">null</span>;Scanner sc = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">try</span> &#123;    inputStream = <span class="hljs-keyword">new</span> FileInputStream(path);    sc = <span class="hljs-keyword">new</span> Scanner(inputStream, <span class="hljs-string">"UTF-8"</span>);    <span class="hljs-keyword">while</span> (sc.hasNextLine()) &#123;        String line = sc.nextLine();        <span class="hljs-comment">// System.out.println(line);</span>    &#125;    <span class="hljs-comment">// note that Scanner suppresses exceptions</span>    <span class="hljs-keyword">if</span> (sc.ioException() != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">throw</span> sc.ioException();    &#125;&#125; <span class="hljs-keyword">finally</span> &#123;    <span class="hljs-keyword">if</span> (inputStream != <span class="hljs-keyword">null</span>) &#123;        inputStream.close();    &#125;    <span class="hljs-keyword">if</span> (sc != <span class="hljs-keyword">null</span>) &#123;        sc.close();    &#125;&#125;</code></pre><p>这种方案将会遍历文件中的所有行——允许对每一行进行处理，而不保持对它的引用。总之<strong>没有把它们存放在内存中</strong>：<em>（大约消耗了150MB内存）</em> </p><pre><code class="hljs java">[main] INFO  org.baeldung.java.CoreJavaIoUnitTest - Total Memory: <span class="hljs-number">763</span> Mb[main] INFO  org.baeldung.java.CoreJavaIoUnitTest - Free Memory: <span class="hljs-number">605</span> Mb</code></pre><h2 id="4、Apache-Commons-IO流"><a href="#4、Apache-Commons-IO流" class="headerlink" title="4、Apache Commons IO流"></a><strong>4、Apache Commons IO流</strong></h2><p>同样也可以使用Commons IO库实现，利用该库提供的自定义LineIterator: </p><pre><code class="hljs java">LineIterator it = FileUtils.lineIterator(theFile, <span class="hljs-string">"UTF-8"</span>);<span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">while</span> (it.hasNext()) &#123;        String line = it.nextLine();        <span class="hljs-comment">// do something with line</span>    &#125;&#125; <span class="hljs-keyword">finally</span> &#123;    LineIterator.closeQuietly(it);&#125;</code></pre><p>由于整个文件不是全部存放在内存中，这也就导致相当保守的内存消耗：<em>（大约消耗了150MB内存）</em> </p><pre><code class="hljs java">[main] INFO  o.b.java.CoreJavaIoIntegrationTest - Total Memory: <span class="hljs-number">752</span> Mb[main] INFO  o.b.java.CoreJavaIoIntegrationTest - Free Memory: <span class="hljs-number">564</span> Mb</code></pre><h2 id="5、结论"><a href="#5、结论" class="headerlink" title="5、结论"></a><strong>5、结论</strong></h2><p>这篇短文介绍了如何<strong>在不重复读取与不耗尽内存的情况下处理大文件</strong>——这为大文件的处理提供了一个有用的解决办法。 </p><p>所有这些例子的实现和代码片段都可以在我的<a href="http://link.zhihu.com/?target=https%3A//github.com/euigenp/tutorials/tree/master/core-java%23readme">github项目</a>上获取到——这是一个基于Eclipse的项目，所以它应该很容易被导入和运行。 </p><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>restful接口设计规范总结</title>
    <link href="/2019/06/12/restful%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93/"/>
    <url>/2019/06/12/restful%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p><strong>这篇 文章主要是借鉴他人，但是自己很想总结出一套规范，以供向我这样的新手使用，用来规范代码，如果有什么好的提议，请不吝赐教，本篇文章长期更新！</strong> </p><h3 id="一、重要概念："><a href="#一、重要概念：" class="headerlink" title="一、重要概念："></a>一、重要概念：</h3><blockquote><p>REST,即Representational State Transfer的缩写。我对这个词组的翻译是”表现层状态转化”。     </p><p><strong>Resource</strong>（资源） ：对象的单个实例。 例如，一只动物。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。     </p><p><strong>集合</strong>：对象的集合。 例如，动物。     </p><p><strong>第三方</strong>：使用我们接口的开发者     </p><p><strong>表现层（Representation）</strong>     </p><p>“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。     </p><p><strong>状态转化（State Transfer）</strong>     </p><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。     </p><p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。     </p><p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。     </p><p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。     </p></blockquote><p>综合上面的解释，我们总结一下什么是RESTful架构： </p><p>　（1）每一个URI代表一种资源； </p><p>　（2）客户端和服务器之间，传递这种资源的某种表现层； </p><p>　（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。 </p><a id="more"></a><h3 id="二、REST接口规范"><a href="#二、REST接口规范" class="headerlink" title="二、REST接口规范"></a>二、REST接口规范</h3><h4 id="1、动作"><a href="#1、动作" class="headerlink" title="1、动作"></a>1、动作</h4><p>GET （SELECT）：从服务器检索特定资源，或资源列表。<br>POST （CREATE）：在服务器上创建一个新的资源。<br>PUT （UPDATE）：更新服务器上的资源，提供整个资源。<br>PATCH （UPDATE）：更新服务器上的资源，仅提供更改的属性。<br>DELETE （DELETE）：从服务器删除资源。 </p><p>首先是四个半种动作：<br>post、delete、put/patch、get<br>因为put/patch只能算作一类，所以将patch归为半个。 </p><p>另外还有有两个较少知名的HTTP动词：<br>HEAD - 检索有关资源的元数据，例如数据的哈希或上次更新时间。<br>OPTIONS - 检索关于客户端被允许对资源做什么的信息。 </p><h4 id="2、路径（接口命名）"><a href="#2、路径（接口命名）" class="headerlink" title="2、路径（接口命名）"></a>2、路径（接口命名）</h4><p>路径又称”终点”（endpoint），表示API的具体网址。 </p><p>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。 </p><p>举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。 </p><p>接口尽量使用名词，禁止使用动词，下面是一些例子。 </p><pre><code class="hljs properties"><span class="hljs-attr">GET</span>         <span class="hljs-string">/zoos：列出所有动物园</span><span class="hljs-attr">POST</span>        <span class="hljs-string">/zoos：新建一个动物园</span><span class="hljs-attr">GET</span>         <span class="hljs-string">/zoos/ID：获取某个指定动物园的信息</span><span class="hljs-attr">PUT</span>         <span class="hljs-string">/zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</span><span class="hljs-attr">PATCH</span>       <span class="hljs-string">/zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</span><span class="hljs-attr">DELETE</span>      <span class="hljs-string">/zoos/ID：删除某个动物园</span><span class="hljs-attr">GET</span>         <span class="hljs-string">/zoos/ID/animals：列出某个指定动物园的所有动物</span><span class="hljs-attr">DELETE</span>      <span class="hljs-string">/zoos/ID/animals/ID：删除某个指定动物园的指定动物</span></code></pre><p>反例： </p><pre><code class="hljs properties"><span class="hljs-attr">/getAllCars</span><span class="hljs-attr">/createNewCar</span><span class="hljs-attr">/deleteAllRedCars</span></code></pre><p>再比如，某个URI是/posts/show/1，其中show是动词，这个URI就设计错了，正确的写法应该是/posts/1，然后用GET方法表示show。 </p><p>如果某些动作是HTTP动词表示不了的，你就应该把动作做成一种资源。比如网上汇款，从账户1向账户2汇款500元，错误的URI是： </p><blockquote><p>　　POST /accounts/1/transfer/500/to/2     </p></blockquote><p>正确的写法是把动词transfer改成名词transaction，资源不能是动词，但是可以是一种服务： </p><blockquote><p>　　POST /transaction HTTP/1.1<br>　　Host: 127.0.0.1<br>　　from=1&amp;to=2&amp;amount=500.00     </p></blockquote><p>理清资源的层次结构，比如业务针对的范围是学校，那么学校会是一级资源(/school)，老师(/school/teachers)，学生(/school/students)就是二级资源。 </p><h4 id="3、版本（Versioning）"><a href="#3、版本（Versioning）" class="headerlink" title="3、版本（Versioning）"></a>3、版本（Versioning）</h4><p>应该将API的版本号放入URL。如： </p><pre><code class="hljs properties"><span class="hljs-attr">https</span>:<span class="hljs-string">//api.example.com/v1/</span></code></pre><p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。 </p><h4 id="4、过滤信息（Filtering）"><a href="#4、过滤信息（Filtering）" class="headerlink" title="4、过滤信息（Filtering）"></a>4、过滤信息（Filtering）</h4><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。<br>下面是一些常见的参数。 </p><pre><code class="hljs properties"><span class="hljs-meta">?limit</span>=<span class="hljs-string">10：指定返回记录的数量</span><span class="hljs-meta">?offset</span>=<span class="hljs-string">10：指定返回记录的开始位置。</span><span class="hljs-meta">?page_number</span>=<span class="hljs-string">2&amp;page_size=100：指定第几页，以及每页的记录数。</span><span class="hljs-meta">?sortby</span>=<span class="hljs-string">name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</span><span class="hljs-meta">?animal_type_id</span>=<span class="hljs-string">1：指定筛选条件</span><span class="hljs-attr">参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，</span><span class="hljs-attr">GET</span> <span class="hljs-string">/zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</span></code></pre><h4 id="5、状态码（Status-Codes）"><a href="#5、状态码（Status-Codes）" class="headerlink" title="5、状态码（Status Codes）"></a>5、状态码（Status Codes）</h4><p>状态码范围 </p><pre><code class="hljs properties"><span class="hljs-attr">1xx</span> <span class="hljs-string">信息，请求收到，继续处理。范围保留用于底层HTTP的东西，你很可能永远也用不到。</span><span class="hljs-attr">2xx</span> <span class="hljs-string">成功，行为被成功地接受、理解和采纳</span><span class="hljs-attr">3xx</span> <span class="hljs-string">重定向，为了完成请求，必须进一步执行的动作</span><span class="hljs-attr">4xx</span> <span class="hljs-string">客户端错误，请求包含语法错误或者请求无法实现。范围保留用于响应客户端做出的错误，例如。他们提供不良数据或要求不存在的东西。这些请求应该是幂等的，而不是更改服务器的状态。</span><span class="hljs-attr">5xx</span> <span class="hljs-string">范围的状态码是保留给服务器端错误用的。这些错误常常是从底层的函数抛出来的，甚至</span><span class="hljs-attr">开发人员也通常没法处理，发送这类状态码的目的以确保客户端获得某种响应。</span><span class="hljs-attr">当收到5xx响应时，客户端不可能知道服务器的状态，所以这类状态码是要尽可能的避免。</span></code></pre><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。 </p><pre><code class="hljs properties"><span class="hljs-attr">200</span> <span class="hljs-string">OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</span><span class="hljs-attr">201</span> <span class="hljs-string">CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</span><span class="hljs-attr">202</span> <span class="hljs-string">Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</span><span class="hljs-attr">204</span> <span class="hljs-string">NO CONTENT - [DELETE]：用户删除数据成功。</span><span class="hljs-attr">400</span> <span class="hljs-string">INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</span><span class="hljs-attr">401</span> <span class="hljs-string">Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</span><span class="hljs-attr">403</span> <span class="hljs-string">Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</span><span class="hljs-attr">404</span> <span class="hljs-string">NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</span><span class="hljs-attr">406</span> <span class="hljs-string">Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</span><span class="hljs-attr">410</span> <span class="hljs-string">Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</span><span class="hljs-attr">422</span> <span class="hljs-string">Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</span><span class="hljs-attr">500</span> <span class="hljs-string">INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</span><span class="hljs-attr">502</span> <span class="hljs-string">网关错误</span><span class="hljs-attr">503</span> <span class="hljs-string">Service Unavailable</span><span class="hljs-attr">504</span> <span class="hljs-string">网关超时</span></code></pre><p>参考资料： </p><p>RESTful API 设计指南–阮一峰：<a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/05/restful_api.html</a> </p><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Restful</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Restful</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>String拼接操作”+”的优化</title>
    <link href="/2019/06/12/String%E6%8B%BC%E6%8E%A5%E6%93%8D%E4%BD%9C%E2%80%9D-%E2%80%9D%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <url>/2019/06/12/String%E6%8B%BC%E6%8E%A5%E6%93%8D%E4%BD%9C%E2%80%9D-%E2%80%9D%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>很多讲Java优化的文章都会强调对String拼接的优化。倒不用特意记，本质上在于对不可变类优势和劣势的理解上。 </p><p>需要关注的是编译器对String拼接做出的优化，在简单场景下的性能能够与StringBuilder相当，复杂场景下仍然有较大的性能问题。网上关于这一问题讲的非常乱；如果我讲的有什么纰漏，也欢迎指正。 </p><blockquote><p>本文用到了反编译工具jad。在查阅网上关于String拼接操作的优化时发现了这个工具，能同时反编译出来源码和字节码，亲测好用，<a href="https://link.juejin.im/?target=https%3A%2F%2Fvaraneckas.com%2Fjad%2F">点我下载</a>。     </p></blockquote><a id="more"></a><h1 id="String拼接的性能问题"><a href="#String拼接的性能问题" class="headerlink" title="String拼接的性能问题"></a>String拼接的性能问题</h1><p>优化之前，每次用”+”拼接，都会生成一个新的String。特别在循环拼接字符串的场景下，性能损失是极其严重的： </p><ol><li>空间浪费：每次拼接的结果都需要创建新的不可变类     </li><li>时间浪费：创建的新不可变类需要初始化；产生大量“短命”垃圾，影响 young gc甚至full gc     </li></ol><h1 id="所谓简单场景"><a href="#所谓简单场景" class="headerlink" title="所谓简单场景"></a>所谓简单场景</h1><blockquote><p>简单场景和复杂场景是我乱起的名字，帮助理解编译器的优化方案。     </p></blockquote><p>简单场景可理解为在一句中完成拼接： </p><pre><code class="hljs java"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;String sentence = “Hello” + “world” + String.valueOf(i) + “\n”;System.out.println(sentence);</code></pre><p>利用jad可看到优化结果： </p><pre><code class="hljs java"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;String sentence = (<span class="hljs-keyword">new</span> StringBuilder()).append(“Hello”).append(“world”).append(String.valueOf(i)).append(“\n”).toString();System.out.println(sentence);</code></pre><p>是不是很神奇，竟然把String的拼接操作优化成了StringBuilder#append()！ </p><p>此时，可以认为已经将简单场景的空间性能、时间性能优化到最优（仅针对String拼接操作而言），看起来编译器已经完成了必要的优化。你可以测试一下，简单场景下的性能能够与StringBuilder相当。但是——“但是”以前的都是废话——编译器的优化对于复杂场景的帮助却很有限了。 </p><h1 id="所谓复杂场景"><a href="#所谓复杂场景" class="headerlink" title="所谓复杂场景"></a>所谓复杂场景</h1><p>所谓复杂场景，可理解为“编译器不确定（或很难确定，于是不做分析）要进行多少次字符串拼接后才需要转换回String”。可能表述不准确，理解个大概就好。 </p><p>我们分析一个最简单的复杂场景： </p><pre><code class="hljs java">String sentence = “”;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000000</span>; i++) &#123;  sentence += “Hello” + “world” + String.valueOf(i) + “\n”;&#125;System.out.println(sentence);</code></pre><h2 id="理想的优化方案"><a href="#理想的优化方案" class="headerlink" title="理想的优化方案"></a>理想的优化方案</h2><p>当然，无论什么场景，程序猿都可以手动优化： </p><ul><li>在性能敏感的场景使用StringBuilder完成拼接。     </li><li>在性能不敏感的场景使用更方便的String。     </li></ul><blockquote><p>PS：别吐槽，这样的API设计是合理的，<strong>在合适的地方做合适的事</strong>。     </p></blockquote><p>理想目标是把这件事交给javac和JIT： </p><ul><li>设定一个拼接次数的阈值，超过阈值就启动优化（对于javac有一个编译期的阈值，JIT有一个运行期的阈值，以分阶段优化）。     </li><li>优化时，在拼接前生成StringBuilder对象，将拼接操作换成StringBuilder#append()，继续使用该对象，直至“需要”String对象时，使用StringBuilder#toString()“懒加载”新的String对象。     </li></ul><p>该优化方案的难度在于代码分析：机器很难知道到底何时“需要”String对象，所以也很难在合适的位置注入代码完成“懒加载”。 </p><p>虽然很难实现，但还是给出理想的优化结果，以供实际方案对比： </p><pre><code class="hljs java">String sentence = “”;StringBuilder sentenceSB = <span class="hljs-keyword">new</span> StringBuilder(sentence);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000000</span>; i++) &#123;  sentenceSB.append(“Hello”).append(“world”).append(String.valueOf(i)).append(“\n”);&#125;sentence = sentenceSB.toString();System.out.println(sentence);</code></pre><h2 id="实际的优化方案"><a href="#实际的优化方案" class="headerlink" title="实际的优化方案"></a>实际的优化方案</h2><p>利用jad查看实际的优化结果： </p><pre><code class="hljs java">String sentence = “”;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000000</span>; i++) &#123;  sentence = (<span class="hljs-keyword">new</span> StringBuilder()).append(sentence).append(“Hello”).append(“world”).append(String.valueOf(i)).append(“\n”).toString();&#125;System.out.println(sentence);</code></pre><p>可以看到，实际上编译器的优化只能达到简单场景的最优：仅优化字符串拼接的一句。这种优化程度，对于上述复杂场景的性能提升很有限，循环时还是会生成大量短命垃圾，特别是字符串拼接到很大的时候，空间和时间上都是致命的。 </p><p>通过对理想方案的分析，我们也能理解编译器优化的无奈之处：编译器无法（或很难）通过代码分析判断何时是最晚进行懒加载的时机。为什么呢？我们将代码换个形式可能更容易理解： </p><pre><code class="hljs java">String sentence = “”;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000000</span>; i++) &#123;  sentence = sentence + “Hello” + “world” + String.valueOf(i) + “\n”;&#125;System.out.println(sentence);</code></pre><p>观察第3行的代码，等式右侧引用了sentence。我肉眼知道这句话只完成了字符串拼接，机器呢？最起码，现在的机器还很难通过代码判断。 </p><blockquote><p>待以后将人工智能与编译优化结合起来，就算只能以90%的概率完成优化，也是非常cool的。     </p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个问题我没有做性能测试。其实也没必要过于深究，与其让编译器以隐晦的方式完成优化，不如用代码进行主动、清晰的优化，让代码能够“自解释”。 </p><p>那么，如果需要优化，使用StringBuilder吧。 </p><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>String</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>String</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用BigDecimal进行精确运算</title>
    <link href="/2019/06/12/%E4%BD%BF%E7%94%A8BigDecimal%E8%BF%9B%E8%A1%8C%E7%B2%BE%E7%A1%AE%E8%BF%90%E7%AE%97/"/>
    <url>/2019/06/12/%E4%BD%BF%E7%94%A8BigDecimal%E8%BF%9B%E8%A1%8C%E7%B2%BE%E7%A1%AE%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p>首先我们先来看如下代码示例： </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test_1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(<span class="hljs-number">0.06</span>+<span class="hljs-number">0.01</span>);        System.out.println(<span class="hljs-number">1.0</span>-<span class="hljs-number">0.42</span>);        System.out.println(<span class="hljs-number">4.015</span>*<span class="hljs-number">100</span>);        System.out.println(<span class="hljs-number">303.1</span>/<span class="hljs-number">1000</span>);    &#125;    &#125;</code></pre><p>运行结果如下。         </p><p>​         0.06999999999999999         </p><p>​         0.5800000000000001         </p><p>​         401.49999999999994         </p><p>​         0.30310000000000004         </p><p>​         你认为你看错了，但结果却是是这样的。问题在哪里呢？原因在于我们的计算机是二进制的。浮点数没有办法是用二进制进行精确表示。我们的CPU表示浮点数由两个部分组成：指数和尾数，这样的表示方法一般都会失去一定的精确度，有些浮点数运算也会产生一定的误差。如：2.4的二进制表示并非就是精确的2.4。反而最为接近的二进制表示是 2.3999999999999999。浮点数的值实际上是由一个特定的数学公式计算得到的。         </p><a id="more"></a><p>​          其实java的float只能用来进行科学计算或工程计算，在大多数的商业计算中，一般采用java.math.BigDecimal类来进行精确计算。         </p><p>​          在使用BigDecimal类来进行计算的时候，主要分为以下步骤：         </p><p>​             1、用float或者double变量构建BigDecimal对象。         </p><p>​             2、通过调用BigDecimal的加，减，乘，除等相应的方法进行算术运算。         </p><p>​             3、把BigDecimal对象转换成float，double，int等类型。         </p><p>​          一般来说，可以使用BigDecimal的构造方法或者静态方法的valueOf()方法把基本类型的变量构建成BigDecimal对象。         </p><pre><code class="hljs java">BigDecimal b1 = <span class="hljs-keyword">new</span> BigDecimal(Double.toString(<span class="hljs-number">0.48</span>));BigDecimal b2 = BigDecimal.valueOf(<span class="hljs-number">0.48</span>);</code></pre><p>   对于常用的加，减，乘，除，BigDecimal类提供了相应的成员方法。         </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">add</span><span class="hljs-params">(BigDecimal value)</span></span>;                        <span class="hljs-comment">//加法</span><span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">subtract</span><span class="hljs-params">(BigDecimal value)</span></span>;                   <span class="hljs-comment">//减法 </span><span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">multiply</span><span class="hljs-params">(BigDecimal value)</span></span>;                   <span class="hljs-comment">//乘法</span><span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">divide</span><span class="hljs-params">(BigDecimal value)</span></span>;                     <span class="hljs-comment">//除法</span></code></pre><p> 进行相应的计算后，我们可能需要将BigDecimal对象转换成相应的基本数据类型的变量，可以使用floatValue()，doubleValue()等方法。                 </p><p>​          下面是一个工具类，该工具类提供加，减，乘，除运算。 </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Arith</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 提供精确加法计算的add方法</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value1 被加数</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value2 加数</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 两个参数的和</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">double</span> value1,<span class="hljs-keyword">double</span> value2)</span></span>&#123;        BigDecimal b1 = <span class="hljs-keyword">new</span> BigDecimal(Double.valueOf(value1));        BigDecimal b2 = <span class="hljs-keyword">new</span> BigDecimal(Double.valueOf(value2));        <span class="hljs-keyword">return</span> b1.add(b2).doubleValue();    &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">     * 提供精确减法运算的sub方法</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value1 被减数</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value2 减数</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 两个参数的差</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-keyword">double</span> value1,<span class="hljs-keyword">double</span> value2)</span></span>&#123;        BigDecimal b1 = <span class="hljs-keyword">new</span> BigDecimal(Double.valueOf(value1));        BigDecimal b2 = <span class="hljs-keyword">new</span> BigDecimal(Double.valueOf(value2));        <span class="hljs-keyword">return</span> b1.subtract(b2).doubleValue();    &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">     * 提供精确乘法运算的mul方法</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value1 被乘数</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value2 乘数</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 两个参数的积</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-keyword">double</span> value1,<span class="hljs-keyword">double</span> value2)</span></span>&#123;        BigDecimal b1 = <span class="hljs-keyword">new</span> BigDecimal(Double.valueOf(value1));        BigDecimal b2 = <span class="hljs-keyword">new</span> BigDecimal(Double.valueOf(value2));        <span class="hljs-keyword">return</span> b1.multiply(b2).doubleValue();    &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">     * 提供精确的除法运算方法div</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value1 被除数</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value2 除数</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> scale 精确范围</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 两个参数的商</span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IllegalAccessException</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-keyword">double</span> value1,<span class="hljs-keyword">double</span> value2,<span class="hljs-keyword">int</span> scale)</span> <span class="hljs-keyword">throws</span> IllegalAccessException</span>&#123;        <span class="hljs-comment">//如果精确范围小于0，抛出异常信息</span>        <span class="hljs-keyword">if</span>(scale&lt;<span class="hljs-number">0</span>)&#123;                     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalAccessException(<span class="hljs-string">"精确度不能小于0"</span>);        &#125;        BigDecimal b1 = <span class="hljs-keyword">new</span> BigDecimal(Double.valueOf(value1));        BigDecimal b2 = <span class="hljs-keyword">new</span> BigDecimal(Double.valueOf(value2));        <span class="hljs-keyword">return</span> b1.divide(b2, scale).doubleValue();        &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java开发人员最常犯的10个错误</title>
    <link href="/2019/06/12/Java%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E6%9C%80%E5%B8%B8%E7%8A%AF%E7%9A%8410%E4%B8%AA%E9%94%99%E8%AF%AF/"/>
    <url>/2019/06/12/Java%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E6%9C%80%E5%B8%B8%E7%8A%AF%E7%9A%8410%E4%B8%AA%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="一、把数组转成-ArrayList"><a href="#一、把数组转成-ArrayList" class="headerlink" title="一、把数组转成     ArrayList"></a>一、把数组转成     <code>ArrayList</code></h2><p>为了将数组转换为ArrayList，开发者经常会这样做： </p><pre><code class="hljs java">List&lt;String&gt; list = Arrays.asList(arr);</code></pre><p>使用     <code>Arrays.asList()</code>方法可以得到一个ArrayList，但是得到这个     <code>ArrayList</code>其实是定义在Arrays类中的一个私有的静态内部类。这个类虽然和     <code>java.util.ArrayList</code>同名，但是并不是同一个类。     <code>java.util.Arrays.ArrayList</code>类中实现了     <code>set()</code>,      <code>get()</code>,      <code>contains()</code>等方法，但是并没有定义向其中增加元素的方法。也就是说通过     <code>Arrays.asList()</code>得到的ArrayList的大小是固定的。 </p><p>如果在开发过程中，想得到一个真正的ArrayList对象（     <code>java.util.ArrayList</code>的实例），可以通过以下方式： </p><pre><code class="hljs java">ArrayList&lt;String&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(arr));</code></pre><pre><code>`  java.util.ArrayList`中包含一个可以接受集合类型参数的构造函数。因为     `  java.util.Arrays.ArrayList`这个内部类继承了AbstractList类，所以，该类也是Collection的子类。 </code></pre><a id="more"></a><h2 id="二、判断一个数组是否包含某个值"><a href="#二、判断一个数组是否包含某个值" class="headerlink" title="二、判断一个数组是否包含某个值"></a>二、判断一个数组是否包含某个值</h2><p>在判断一个数组中是否包含某个值的时候，开发者经常这样做： </p><pre><code class="hljs java">Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(arr));<span class="hljs-keyword">return</span> set.contains(targetValue);</code></pre><p>在<a href="http://www.hollischuang.com/archives/1269" target="_blank" rel="noopener">在Java中如何高效的判断数组中是否包含某个元素</a>一文中，深入分析过，以上方式虽然可以实现功能，但是效率却比较低。因为将数组压入Collection类型中，首先要将数组元素遍历一遍，然后再使用集合类做其他操作。 </p><p>在判断一个数组是否包含某个值的时候，推荐使用for循环遍历的形式或者使用Apache Commons类库中提供的     <code>ArrayUtils</code>类的     <code>contains</code>方法。 </p><h2 id="三、在循环中删除列表中的元素"><a href="#三、在循环中删除列表中的元素" class="headerlink" title="三、在循环中删除列表中的元素"></a>三、在循环中删除列表中的元素</h2><p>在讨论这个问题之前，先考虑以下代码的输出结果： </p><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>,<span class="hljs-string">"c"</span>,<span class="hljs-string">"d"</span>));<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;list.size();i++)&#123;    list.remove(i);&#125;System.out.println(list);</code></pre><p>输出结果： </p><pre><code class="hljs bash">[b,d]</code></pre><p>以上代码的目的是想遍历删除list中所有元素，但是结果却没有成功。原因是忽略了一个关键的问题：当一个元素被删除时，列表的大小缩小并且下标也会随之变化，所以当你想要在一个循环中用下标删除多个元素的时候，它并不会正常的生效。 </p><p>也有些人知道以上代码的问题就由于数组下标变换引起的。所以，他们想到使用增强for循环的形式： </p><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>,<span class="hljs-string">"c"</span>,<span class="hljs-string">"d"</span>));<span class="hljs-keyword">for</span>(String s:list)&#123;    <span class="hljs-keyword">if</span>(s.equals(<span class="hljs-string">"a"</span>))&#123;        list.remove(s);    &#125;&#125;</code></pre><p>但是，很不幸的是，以上代码会抛出     <code>ConcurrentModificationException</code>，有趣的是，如果在remove操作后增加一个break，代码就不会报错： </p><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>,<span class="hljs-string">"c"</span>,<span class="hljs-string">"d"</span>));<span class="hljs-keyword">for</span>(String s:list)&#123;    <span class="hljs-keyword">if</span>(s.equals(<span class="hljs-string">"a"</span>))&#123;        list.remove(s);        <span class="hljs-keyword">break</span>;    &#125;&#125;</code></pre><p>在<a href="http://www.hollischuang.com/archives/33" target="_blank" rel="noopener">Java中的fail-fast机制</a>一文中，深入分析了几种在遍历数组的同时删除其中元素的方法以及各种方法存在的问题。其中就介绍了上面的代码出错的原因。 </p><blockquote><p>迭代器（Iterator）是工作在一个独立的线程中，并且拥有一个 mutex 锁。 迭代器被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 迭代器会马上抛出         <code>java.util.ConcurrentModificationException</code> 异常。     </p></blockquote><p>所以，正确的在遍历过程中删除元素的方法应该是使用Iterator： </p><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>, <span class="hljs-string">"d"</span>));Iterator&lt;String&gt; iter = list.iterator();<span class="hljs-keyword">while</span> (iter.hasNext()) &#123;    String s = iter.next();    <span class="hljs-keyword">if</span> (s.equals(<span class="hljs-string">"a"</span>)) &#123;        iter.remove();    &#125;&#125;</code></pre><pre><code>`  next()`方法必须在调用     `  remove()`方法之前调用。如果在循环过程中先调用     `  remove()`，再调用     `  next()`，就会导致异常     `  ConcurrentModificationException`。原因如上。 </code></pre><h2 id="四、HashTable-和-HashMap-的选择"><a href="#四、HashTable-和-HashMap-的选择" class="headerlink" title="四、HashTable 和 HashMap 的选择"></a>四、HashTable 和 HashMap 的选择</h2><p>了解算法的人可能对HashTable比较熟悉，因为他是一个数据结构的名字。但在Java里边，用HashMap来表示这样的数据结构。Hashtable和 HashMap的一个关键性的不同是，HashTable是同步的，而HashMap不是。所以通常不需要HashTable，HashMap用的更多。 </p><p><a href="http://www.hollischuang.com/archives/82" target="_blank" rel="noopener">HashMap完全解读</a>、<a href="http://www.hollischuang.com/archives/442" target="_blank" rel="noopener">Java中常见亲属比较</a>等文章中介绍了他们的区别和如何选择。 </p><h2 id="五、使用原始集合类型"><a href="#五、使用原始集合类型" class="headerlink" title="五、使用原始集合类型"></a>五、使用原始集合类型</h2><p>在Java里边，原始类型和无界通配符类型很容易混合在一起。以Set为例，Set是一个原始类型，而Set&lt; ? &gt;是一个无界通配符类型。 （可以把原始类型理解为没有使用泛型约束的类型） </p><p>考虑下面使用原始类型List作为参数的代码： </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(List list, Object o)</span></span>&#123;    list.add(o);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;    List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();    add(list, <span class="hljs-number">10</span>);    String s = list.get(<span class="hljs-number">0</span>);&#125;</code></pre><p>上面的代码将会抛出异常： </p><pre><code>`  java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String` </code></pre><p>使用原始集合类型是很危险的，因为原始集合类型跳过了泛型类型检查，是不安全的。Set、Set&lt; ? &gt;和Set&lt; Object &gt;之间有很大差别。关于泛型，可以参考下列文章：<a href="http://www.hollischuang.com/archives/1182" target="_blank" rel="noopener">《成神之路-基础篇》Java基础知识——泛型</a> </p><h2 id="六、访问级别"><a href="#六、访问级别" class="headerlink" title="六、访问级别"></a>六、访问级别</h2><p>程序员们经常使用     <code>public</code>作为类中的字段的修饰符，因为这样可以很简单的通过引用得到值，但这并不是好的设计，按照经验，分配给成员变量的访问级别应该尽可能的低。参考<a href="http://www.hollischuang.com/archives/1334" target="_blank" rel="noopener">Java中的四种访问级别</a> </p><h2 id="七、-ArrayList与-LinkedList的选择"><a href="#七、-ArrayList与-LinkedList的选择" class="headerlink" title="七、     ArrayList与     LinkedList的选择"></a>七、     <code>ArrayList</code>与     <code>LinkedList</code>的选择</h2><p>当程序员们不知道     <code>ArrayList</code>与     <code>LinkedList</code>的区别时，他们经常使用ArrayList，因为它看起来比较熟悉。然而，它们之前有巨大的性能差别。在<a href="http://www.hollischuang.com/archives/1349" target="_blank" rel="noopener">ArrayList vs LinkedList vs Vector 区别</a>、<a href="http://www.hollischuang.com/archives/442" target="_blank" rel="noopener">Java中常见亲属比较</a>等文章中介绍过，简而言之，如果有大量的增加删除操作并且没有很多的随机访问元素的操作，应该首先     <code>LinkedList</code>。（     <code>LinkedList</code>更适合从中间插入或者删除（链表的特性）） </p><h2 id="八、可变与不可变"><a href="#八、可变与不可变" class="headerlink" title="八、可变与不可变"></a>八、可变与不可变</h2><p>在<a href="http://www.hollischuang.com/archives/1246" target="_blank" rel="noopener">为什么Java要把字符串设计成不可变的</a>一文中介绍过，不可变对象有许多的优点，比如简单，安全等等。同时，也有人提出疑问：既然不可变有这么多好处，为什么不把所有类都搞成不可变的呢？ </p><p>通常情况下，可变对象可以用来避免产生过多的中间对象。一个经典的实例就是连接大量的字符串，如果使用不可变的字符串，将会产生大量的需要进行垃圾回收的对象。这会浪费CPU大量的时间，使用可变对象才是正确的方案(比如     <code>StringBuilder</code>)。 </p><pre><code class="hljs java">String result=<span class="hljs-string">""</span>;<span class="hljs-keyword">for</span>(String s: arr)&#123;    result = result + s;&#125;</code></pre><p><a href="http://stackoverflow.com/questions/23616211/why-we-need-mutable-classes" target="_blank" rel="noopener">StackOverflow</a>中也有关于这个的讨论。 </p><h2 id="九、父类和子类的构造函数"><a href="#九、父类和子类的构造函数" class="headerlink" title="九、父类和子类的构造函数"></a>九、父类和子类的构造函数</h2><p>上图的代码中有两处编译时错误，原因其实很简单，主要和构造函数有关。首先，我们都知道： </p><blockquote><p>如果一个类没有定义构造函数，编译器将会插入一个无参数的默认构造函数。     </p><p>如果一个类中定义了一个带参数的构造函数，那么编译器就不会再帮我们创建无参的构造函数。 </p></blockquote><p>上面的Super类中定义了一个带参数的构造函数。编译器将不会插入默认的无参数构造函数。 </p><p>我们还应该知道： </p><blockquote><p>子类的所有构造函数（无论是有参还是无参）在执行时，都会调用父类的无参构造函数。     </p></blockquote><p>所以，编译器试图调用Super类中的无参构造函数。但是父类默认的构造函数未定义，编译器就会报出这个错误信息。 </p><p>要解决这个问题，可以简单的通过 </p><ul><li><p>1)在父类中添加一个Super()构造方法，就像这样：         </p><p>public Super(){}         </p></li><li><p>2)移除自定义的父类构造函数         </p></li><li><p>3)在子类的构造函数中调用父类的super(value)。         </p></li></ul><h2 id="十、””还是构造函数"><a href="#十、””还是构造函数" class="headerlink" title="十、””还是构造函数"></a>十、””还是构造函数</h2><p>关于这个问题，也是程序员经常出现困惑的地方，在<a href="http://www.hollischuang.com/archives/1249" target="_blank" rel="noopener">该如何创建字符串，使用” “还是构造函数？</a>中也介绍过. </p><blockquote><p>如果你只需要创建一个字符串，你可以使用双引号的方式，如果你需要在堆中创建一个新的对象，你可以选择构造函数的方式。     </p></blockquote><p>在     <code>String d = new String(&quot;abcd&quot;)</code>时，因为字面值“abcd”已经是字符串类型，那么使用构造函数方式只会创建一个额外没有用处的对象。 </p><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis分布式锁的正确实现方式</title>
    <link href="/2019/06/12/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <url>/2019/06/12/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分布式锁一般有三种实现方式：1. 数据库乐观锁；2. 基于Redis的分布式锁；3. 基于ZooKeeper的分布式锁。本篇博客将介绍第二种方式，基于Redis实现分布式锁。虽然网上已经有各种介绍Redis分布式锁实现的博客，然而他们的实现却有着各种各样的问题，为了避免误人子弟，本篇博客将详细介绍如何正确地实现Redis分布式锁。</p><hr><h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><a id="more"></a><p>首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：</p><ul><li>互斥性。在任意时刻，只有一个客户端能持有锁。</li><li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li><li>具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。</li><li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="组件依赖"><a href="#组件依赖" class="headerlink" title="组件依赖"></a>组件依赖</h3><p>首先我们要通过Maven引入Jedis开源组件，在pom.xml文件加入下面的代码：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="加锁代码"><a href="#加锁代码" class="headerlink" title="加锁代码"></a>加锁代码</h3><h4 id="正确姿势"><a href="#正确姿势" class="headerlink" title="正确姿势"></a>正确姿势</h4><p>Talk is cheap, show me the code。先展示代码，再带大家慢慢解释为什么这样实现：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisTool</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String LOCK_SUCCESS = <span class="hljs-string">"OK"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SET_IF_NOT_EXIST = <span class="hljs-string">"NX"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="hljs-string">"PX"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 尝试获取分布式锁</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> jedis Redis客户端</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockKey 锁</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> requestId 请求标识</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expireTime 超期时间</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否获取成功</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryGetDistributedLock</span><span class="hljs-params">(Jedis jedis, String lockKey, String requestId, <span class="hljs-keyword">int</span> expireTime)</span> </span>&#123;        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);        <span class="hljs-keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><p>可以看到，我们加锁就一行代码：jedis.set(String key, String value, String nxxx, String expx, int time)，这个set()方法一共有五个形参：</p><p><strong>第一个为key</strong>，我们使用key来当锁，因为key是唯一的。</p><p><strong>第二个为value</strong>，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。</p><p><strong>第三个为nxxx</strong>，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；</p><p><strong>第四个为expx</strong>，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。</p><p><strong>第五个为time</strong>，与第四个参数相呼应，代表key的过期时间。</p><p>总的来说，执行上面的set()方法就只会导致两种结果：</p><ol><li>当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。</li><li>已有锁存在，不做任何操作。</li></ol><p>心细的童鞋就会发现了，我们的加锁代码满足我们可靠性里描述的三个条件。首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。</p><p>最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。由于我们只考虑Redis单机部署的场景，所以容错性我们暂不考虑。</p><h4 id="错误示例1"><a href="#错误示例1" class="headerlink" title="错误示例1"></a>错误示例1</h4><p>比较常见的错误示例就是使用jedis.setnx()和jedis.expire()组合实现加锁，代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wrongGetLock1</span><span class="hljs-params">(Jedis jedis, String lockKey, String requestId, <span class="hljs-keyword">int</span> expireTime)</span> </span>&#123;    Long result = jedis.setnx(lockKey, requestId);    <span class="hljs-keyword">if</span> (result == <span class="hljs-number">1</span>) &#123;        <span class="hljs-comment">// 若在这里程序突然崩溃，则无法设置过期时间，将发生死锁</span>        jedis.expire(lockKey, expireTime);    &#125;&#125;</code></pre><p>setnx()方法作用就是SET IF NOT EXIST，expire()方法就是给锁加一个过期时间。乍一看好像和前面的set()方法结果一样，然而由于这是两条Redis命令，不具有原子性，如果程序在执行完setnx()之后突然崩溃，导致锁没有设置过期时间。那么将会发生死锁。网上之所以有人这样实现，是因为低版本的jedis并不支持多参数的set()方法。</p><h4 id="错误示例2"><a href="#错误示例2" class="headerlink" title="错误示例2"></a>错误示例2</h4><p>这一种错误示例就比较难以发现问题，而且实现也比较复杂。实现思路：使用jedis.setnx()命令实现加锁，其中key是锁，value是锁的过期时间。</p><p>执行过程：</p><ol><li>通过setnx()方法尝试加锁，如果当前锁不存在，返回加锁成功。</li><li>如果锁已经存在则获取锁的过期时间，和当前时间比较，如果锁已经过期，则设置新的过期时间，返回加锁成功。</li></ol><p>代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">wrongGetLock2</span><span class="hljs-params">(Jedis jedis, String lockKey, <span class="hljs-keyword">int</span> expireTime)</span> </span>&#123;    <span class="hljs-keyword">long</span> expires = System.currentTimeMillis() + expireTime;    String expiresStr = String.valueOf(expires);    <span class="hljs-comment">// 如果当前锁不存在，返回加锁成功</span>    <span class="hljs-keyword">if</span> (jedis.setnx(lockKey, expiresStr) == <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">// 如果锁存在，获取锁的过期时间</span>    String currentValueStr = jedis.get(lockKey);    <span class="hljs-keyword">if</span> (currentValueStr != <span class="hljs-keyword">null</span> &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis()) &#123;        <span class="hljs-comment">// 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间</span>        String oldValueStr = jedis.getSet(lockKey, expiresStr);        <span class="hljs-keyword">if</span> (oldValueStr != <span class="hljs-keyword">null</span> &amp;&amp; oldValueStr.equals(currentValueStr)) &#123;            <span class="hljs-comment">// 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才有权利加锁</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;    &#125;    <span class="hljs-comment">// 其他情况，一律返回加锁失败</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre><p>那么这段代码问题在哪里？1. 由于是客户端自己生成过期时间，所以需要强制要求分布式下每个客户端的时间必须同步。 2. 当锁过期的时候，如果多个客户端同时执行jedis.getSet()方法，那么虽然最终只有一个客户端可以加锁，但是这个客户端的锁的过期时间可能被其他客户端覆盖。3. 锁不具备拥有者标识，即任何客户端都可以解锁。</p><h3 id="解锁代码"><a href="#解锁代码" class="headerlink" title="解锁代码"></a>解锁代码</h3><h4 id="正确姿势-1"><a href="#正确姿势-1" class="headerlink" title="正确姿势"></a>正确姿势</h4><p>还是先展示代码，再带大家慢慢解释为什么这样实现：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisTool</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Long RELEASE_SUCCESS = <span class="hljs-number">1L</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 释放分布式锁</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> jedis Redis客户端</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockKey 锁</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> requestId 请求标识</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否释放成功</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseDistributedLock</span><span class="hljs-params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;        String script = <span class="hljs-string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));        <span class="hljs-keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><p>可以看到，我们解锁只需要两行代码就搞定了！第一行代码，我们写了一个简单的Lua脚本代码，上一次见到这个编程语言还是在《黑客与画家》里，没想到这次居然用上了。第二行代码，我们将Lua代码传到jedis.eval()方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。eval()方法是将Lua代码交给Redis服务端执行。</p><p>那么这段Lua代码的功能是什么呢？其实很简单，首先获取锁对应的value值，检查是否与requestId相等，如果相等则删除锁（解锁）。那么为什么要使用Lua语言来实现呢？因为要确保上述操作是原子性的。关于非原子性会带来什么问题，可以阅读【解锁代码-错误示例2】 。那么为什么执行eval()方法可以确保原子性，源于Redis的特性，下面是官网对eval命令的部分解释：</p><p>简单来说，就是在eval命令执行Lua代码的时候，Lua代码将被当成一个命令去执行，并且直到eval命令执行完成，Redis才会执行其他命令。</p><h4 id="错误示例1-1"><a href="#错误示例1-1" class="headerlink" title="错误示例1"></a>错误示例1</h4><p>最常见的解锁代码就是直接使用jedis.del()方法删除锁，这种不先判断锁的拥有者而直接解锁的方式，会导致任何客户端都可以随时进行解锁，即使这把锁不是它的。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wrongReleaseLock1</span><span class="hljs-params">(Jedis jedis, String lockKey)</span> </span>&#123;    jedis.del(lockKey);&#125;</code></pre><h4 id="错误示例2-1"><a href="#错误示例2-1" class="headerlink" title="错误示例2"></a>错误示例2</h4><p>这种解锁代码乍一看也是没问题，甚至我之前也差点这样实现，与正确姿势差不多，唯一区别的是分成两条命令去执行，代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wrongReleaseLock2</span><span class="hljs-params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;    <span class="hljs-comment">// 判断加锁与解锁是不是同一个客户端</span>    <span class="hljs-keyword">if</span> (requestId.equals(jedis.get(lockKey))) &#123;        <span class="hljs-comment">// 若在此时，这把锁突然不是这个客户端的，则会误解锁</span>        jedis.del(lockKey);    &#125;&#125;</code></pre><p>如代码注释，问题在于如果调用jedis.del()方法的时候，这把锁已经不属于当前客户端的时候会解除他人加的锁。那么是否真的有这种场景？答案是肯定的，比如客户端A加锁，一段时间之后客户端A解锁，在执行jedis.del()之前，锁突然过期了，此时客户端B尝试加锁成功，然后客户端A再执行del()方法，则将客户端B的锁给解除了。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了如何使用Java代码正确实现Redis分布式锁，对于加锁和解锁也分别给出了两个比较经典的错误示例。其实想要通过Redis实现分布式锁并不难，只要保证能满足可靠性里的四个条件。互联网虽然给我们带来了方便，只要有问题就可以google，然而网上的答案一定是对的吗？其实不然，所以我们更应该时刻保持着质疑精神，多想多验证。</p><p>如果你的项目中Redis是多机部署的，那么可以尝试使用Redisson实现分布式锁，这是Redis官方提供的Java组件。</p><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>brew安装常用软件</title>
    <link href="/2019/06/12/brew%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/"/>
    <url>/2019/06/12/brew%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>1  安装mysql</p><p>a)  brew install mysql</p><p>安装完后会提示：</p><p>To have launchd start mysql now and restart at login:</p><p>  brew services start mysql</p><p>Or, if you don’t want/need a background service you can just run:</p><p>  mysql.server start</p><p>根据需要选择自己要的</p><p>这样就安装完了，执行mysql.server start，服务就起来了，可以用</p><p>mysql -uroot 进去看看</p> <a id="more"></a><p>之前还以为要初始化mysql， 实际上是不用的，那样只是重新在别的地方安装了一个db起来而已</p><p>不过密码还是要修改一下</p><p>cd /usr/local/opt/mysql/</p><p>./bin/mysql_secure_installation </p><p>然后按照提示进行修改密码即可</p><p>2 安装redis</p><p>brew install redis</p><p>To have launchd start redis now and restart at login:</p><p>  brew services start redis</p><p>Or, if you don’t want/need a background service you can just run:</p><p>  redis-server /usr/local/etc/redis.conf</p><p>redis 配置文件的位置<br>/usr/local/etc/redis.conf</p><p>3 安装zookeeper</p><p>brew info zookeeper</p><p>brew install zookeeper</p><p>安装完毕提示：</p><p>To have launchd start zookeeper now and restart at login:</p><p>  brew services start zookeeper</p><p>Or, if you don’t want/need a background service you can just run:</p><p>  zkServer start</p><p>配置文件地址：</p><p>/usr/local/etc/zookeeper/zoo.cfg </p><p>4 安装activemq</p><p>brew install activemq</p><p>To have launchd start activemq now and restart at login:</p><p>  brew services start activemq</p><p>Or, if you don’t want/need a background service you can just run:</p><p>  activemq start</p><p>5 安装nginx</p><p>brew info nginx</p><p>brew install nginx</p><p>装完以后提示：</p><p>The default port has been set in /usr/local/etc/nginx/nginx.conf to 8080 so that</p><p>nginx can run without sudo.</p><p>nginx will load all files in /usr/local/etc/nginx/servers/.</p><p>To have launchd start nginx now and restart at login:</p><p>  brew services start nginx</p><p>Or, if you don’t want/need a background service you can just run:</p><p>  nginx</p>]]></content>
    
    
    <categories>
      
      <category>Mac</category>
      
      <category>Homebrew</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mac</tag>
      
      <tag>Homebrew</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shadowsocks-Go一键安装脚本</title>
    <link href="/2019/06/11/Shadowsocks-Go%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC/"/>
    <url>/2019/06/11/Shadowsocks-Go%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>本脚本适用环境：<br>系统支持：CentOS，Debian，Ubuntu<br>内存要求：≥128M </p><p>关于本脚本：<br>一键安装 Go 版的 shadowsocks 最新版本 1.1.5。据说 go 版本有 buff 。与 <a href="http://lib.csdn.net/base/python" target="_blank" rel="noopener">Python</a> 版不同的是，其客户端程序能使用多个服务端配置，本脚本安装的是服务端程序。作者默认推荐 aes-128-cfb 加密，基于一致性，脚本使用了 aes-256-cfb 加密方式</p><a id="more"></a><p>默认配置：<br>服务器端口：自己设定（如不设定，默认为 8989）<br>客户端端口：1080<br>密码：自己设定（如不设定，默认为teddysun.com）<br>客户端下载：<br><a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks-windows/releases</a><br>使用方法：<br>使用root用户登录，运行以下命令：<br>wget –no-check-certificate <a href="https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-go.sh" target="_blank" rel="noopener">https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-go.sh</a><br>chmod +x shadowsocks-go.sh<br>./shadowsocks-go.sh 2&gt;&amp;1 | tee shadowsocks-go.log </p><p>安装完成后，脚本提示如下：<br>Congratulations, shadowsocks-go install completed!<br>Your Server IP:your_server_ip<br>Your Server Port:your_server_port<br>Your Password:your_password<br>Your Local Port:1080<br>Your Encryption Method:aes-256-cfb </p><p>Welcome to visit:<a href="https://teddysun.com/392.html" target="_blank" rel="noopener">https://teddysun.com/392.html</a><br>Enjoy it! </p><p>卸载方法：<br>使用 root 用户登录，运行以下命令：<br>./shadowsocks-go.sh uninstall </p><p>其他事项：<br>客户端配置的参考链接：<a href="https://teddysun.com/339.html" target="_blank" rel="noopener">https://teddysun.com/339.html</a><br>安装完成后即已后台启动 shadowsocks-go ，运行：<br>/etc/init.d/shadowsocks status </p><p>可以查看 shadowsocks-go 进程是否已经启动。<br>本脚本安装完成后，已将 shadowsocks-go 加入开机自启动。<br>统一回复：<br>在 Bandwagonhost 的 VPS 上出现 Trace/breakpoint trap 现象的，初步认为是 Bandwagonhost 的系统问题。<br>经过<a href="http://lib.csdn.net/base/softwaretest" target="_blank" rel="noopener">测试</a>发现，和版本升级无关，唯独在 Bandwagonhost 才会出现这个现象。建议换成 libev 版，或者将系统换为 CentOS 7 可以解决该问题。<br>本人不是 Shadowsocks Go 作者，安装程序均来自于这里。<br>使用命令：<br>启动：/etc/init.d/shadowsocks start<br>停止：/etc/init.d/shadowsocks stop<br>重启：/etc/init.d/shadowsocks restart<br>状态：/etc/init.d/shadowsocks status<br>多用户多端口配置文件 sample（2015年01月08日）：<br>配置文件路径：/etc/shadowsocks/config.json<br>{<br>“port_password”:{<br>“8989”:”password0”,<br>“9001”:”password1”,<br>“9002”:”password2”,<br>“9003”:”password3”,<br>“9004”:”password4”<br>},<br>“method”:”aes-256-cfb”,<br>“timeout”:600<br>} </p><p>官方版本的 sample ，详见这里。<br>更多版本 Shadowsocks 服务端一键安装脚本：<br>ShadowsocksR 版一键安装脚本（CentOS，Debian，Ubuntu）<br>Shadowsocks Python 版一键安装脚本（CentOS，Debian，Ubuntu）<br>CentOS 下 shadowsocks-libev 一键安装脚本<br>Debian 下 shadowsocks-libev 一键安装脚本 </p><p>附：</p><pre><code class="hljs go">## <span class="hljs-keyword">go</span>一键安装脚本 ########################################################################!/usr/bin/env bashPATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATH#=================================================================##  System Required:  CentOS, Debian, Ubuntu                      ##  Description: One click Install Shadowsocks-<span class="hljs-keyword">go</span> server          ##  Author: Teddysun &lt;i@teddysun.com&gt;                            ##  Thanks: @cyfdecyf &lt;https:<span class="hljs-comment">//twitter.com/cyfdecyf&gt;              #</span>#  Intro:  https:<span class="hljs-comment">//teddysun.com/392.html                        #</span>#==================================================================clearechoecho <span class="hljs-string">"#############################################################"</span>echo <span class="hljs-string">"# One click Install Shadowsocks-go server                  #"</span>echo <span class="hljs-string">"# Intro: https://teddysun.com/392.html                      #"</span>echo <span class="hljs-string">"# Author: Teddysun &lt;i@teddysun.com&gt;                        #"</span>echo <span class="hljs-string">"# Github: https://github.com/shadowsocks/shadowsocks-go    #"</span>echo <span class="hljs-string">"#############################################################"</span>echo#Current foldercur_dir=<span class="hljs-string">`pwd`</span># Make sure only root can run our scriptrootness()&#123;    <span class="hljs-keyword">if</span> [[ $EUID -ne <span class="hljs-number">0</span> ]]; then      echo <span class="hljs-string">"Error:This script must be run as root!"</span> <span class="hljs-number">1</span>&gt;&amp;<span class="hljs-number">2</span>      exit <span class="hljs-number">1</span>    fi&#125;#Check systemcheck_sys()&#123;    local checkType=$<span class="hljs-number">1</span>    local value=$<span class="hljs-number">2</span>    local release=<span class="hljs-string">''</span>    local systemPackage=<span class="hljs-string">''</span>    <span class="hljs-keyword">if</span> [[ -f /etc/redhat-release ]]; then        release=<span class="hljs-string">"centos"</span>        systemPackage=<span class="hljs-string">"yum"</span>    elif cat /etc/issue | grep -q -E -i <span class="hljs-string">"debian"</span>; then        release=<span class="hljs-string">"debian"</span>        systemPackage=<span class="hljs-string">"apt"</span>    elif cat /etc/issue | grep -q -E -i <span class="hljs-string">"ubuntu"</span>; then        release=<span class="hljs-string">"ubuntu"</span>        systemPackage=<span class="hljs-string">"apt"</span>    elif cat /etc/issue | grep -q -E -i <span class="hljs-string">"centos|red hat|redhat"</span>; then        release=<span class="hljs-string">"centos"</span>        systemPackage=<span class="hljs-string">"yum"</span>    elif cat /proc/version | grep -q -E -i <span class="hljs-string">"debian"</span>; then        release=<span class="hljs-string">"debian"</span>        systemPackage=<span class="hljs-string">"apt"</span>    elif cat /proc/version | grep -q -E -i <span class="hljs-string">"ubuntu"</span>; then        release=<span class="hljs-string">"ubuntu"</span>        systemPackage=<span class="hljs-string">"apt"</span>    elif cat /proc/version | grep -q -E -i <span class="hljs-string">"centos|red hat|redhat"</span>; then        release=<span class="hljs-string">"centos"</span>        systemPackage=<span class="hljs-string">"yum"</span>    fi    <span class="hljs-keyword">if</span> [[ $&#123;checkType&#125; == <span class="hljs-string">"sysRelease"</span> ]]; then        <span class="hljs-keyword">if</span> [ <span class="hljs-string">"$value"</span> == <span class="hljs-string">"$release"</span> ]; then            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">else</span>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>        fi    elif [[ $&#123;checkType&#125; == <span class="hljs-string">"packageManager"</span> ]]; then        <span class="hljs-keyword">if</span> [ <span class="hljs-string">"$value"</span> == <span class="hljs-string">"$systemPackage"</span> ]; then            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">else</span>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>        fi    fi&#125;# Get versiongetversion()&#123;    <span class="hljs-keyword">if</span> [[ -s /etc/redhat-release ]]; then        grep -oE  <span class="hljs-string">"[0-9.]+"</span> /etc/redhat-release    <span class="hljs-keyword">else</span>        grep -oE  <span class="hljs-string">"[0-9.]+"</span> /etc/issue    fi&#125;# CentOS versioncentosversion()&#123;    <span class="hljs-keyword">if</span> check_sys sysRelease centos; then        local code=$<span class="hljs-number">1</span>        local version=<span class="hljs-string">"$(getversion)"</span>        local main_ver=$&#123;version%%.*&#125;        <span class="hljs-keyword">if</span> [ <span class="hljs-string">"$main_ver"</span> == <span class="hljs-string">"$code"</span> ]; then            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">else</span>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>        fi    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>    fi&#125;# is <span class="hljs-number">64</span>bit or notis_64bit()&#123;    <span class="hljs-keyword">if</span> [ <span class="hljs-string">`getconf WORD_BIT`</span> = <span class="hljs-string">'32'</span> ] &amp;&amp; [ <span class="hljs-string">`getconf LONG_BIT`</span> = <span class="hljs-string">'64'</span> ] ; then        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>    fi&#125;# Disable selinuxdisable_selinux()&#123;    <span class="hljs-keyword">if</span> [ -s /etc/selinux/config ] &amp;&amp; grep <span class="hljs-string">'SELINUX=enforcing'</span> /etc/selinux/config; then        sed -i <span class="hljs-string">'s/SELINUX=enforcing/SELINUX=disabled/g'</span> /etc/selinux/config        setenforce <span class="hljs-number">0</span>    fi&#125;get_ip()&#123;    local IP=$( ip addr | egrep -o <span class="hljs-string">'[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;'</span> | egrep -v <span class="hljs-string">"^192\.168|^172\.1[6-9]\.|^172\.2[0-9]\.|^172\.3[0-2]\.|^10\.|^127\.|^255\.|^0\."</span> | head -n <span class="hljs-number">1</span> )    [ -z $&#123;IP&#125; ] &amp;&amp; IP=$( wget -qO- -t1 -T2 ipv4.icanhazip.com )    [ -z $&#123;IP&#125; ] &amp;&amp; IP=$( wget -qO- -t1 -T2 ipinfo.io/ip )    [ ! -z $&#123;IP&#125; ] &amp;&amp; echo $&#123;IP&#125; || echo&#125;# Pre-installation settingspre_install()&#123;    <span class="hljs-keyword">if</span> ! check_sys packageManager yum &amp;&amp; ! check_sys packageManager apt; then        echo <span class="hljs-string">"Error: Your OS is not supported. please change OS to CentOS/Debian/Ubuntu and try again."</span>        exit <span class="hljs-number">1</span>    fi    # Set shadowsocks-<span class="hljs-keyword">go</span> config password    echo <span class="hljs-string">"Please input password for shadowsocks-go:"</span>    read -p <span class="hljs-string">"(Default password: teddysun.com):"</span> shadowsockspwd    [ -z <span class="hljs-string">"$&#123;shadowsockspwd&#125;"</span> ] &amp;&amp; shadowsockspwd=<span class="hljs-string">"teddysun.com"</span>    echo    echo <span class="hljs-string">"---------------------------"</span>    echo <span class="hljs-string">"password = $&#123;shadowsockspwd&#125;"</span>    echo <span class="hljs-string">"---------------------------"</span>    echo    # Set shadowsocks-<span class="hljs-keyword">go</span> config port    while <span class="hljs-literal">true</span>    do    echo -e <span class="hljs-string">"Please input port for shadowsocks-go [1-65535]:"</span>    read -p <span class="hljs-string">"(Default port: 8989):"</span> shadowsocksport    [ -z <span class="hljs-string">"$&#123;shadowsocksport&#125;"</span> ] &amp;&amp; shadowsocksport=<span class="hljs-string">"8989"</span>    expr $&#123;shadowsocksport&#125; + <span class="hljs-number">0</span> &amp;&gt;/dev/null    <span class="hljs-keyword">if</span> [ $? -eq <span class="hljs-number">0</span> ]; then        <span class="hljs-keyword">if</span> [ $&#123;shadowsocksport&#125; -ge <span class="hljs-number">1</span> ] &amp;&amp; [ $&#123;shadowsocksport&#125; -le <span class="hljs-number">65535</span> ]; then            echo            echo <span class="hljs-string">"---------------------------"</span>            echo <span class="hljs-string">"port = $&#123;shadowsocksport&#125;"</span>            echo <span class="hljs-string">"---------------------------"</span>            echo            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">else</span>            echo <span class="hljs-string">"Input error, please input correct number"</span>        fi    <span class="hljs-keyword">else</span>        echo <span class="hljs-string">"Input error, please input correct number"</span>    fi    done    get_char()&#123;        SAVEDSTTY=<span class="hljs-string">`stty -g`</span>        stty -echo        stty cbreak        dd <span class="hljs-keyword">if</span>=/dev/tty bs=<span class="hljs-number">1</span> count=<span class="hljs-number">1</span> <span class="hljs-number">2</span>&gt; /dev/null        stty -raw        stty echo        stty $SAVEDSTTY    &#125;    echo    echo <span class="hljs-string">"Press any key to start...or Press Ctrl+C to cancel"</span>    char=<span class="hljs-string">`get_char`</span>    #Install necessary dependencies    <span class="hljs-keyword">if</span> check_sys packageManager yum; then        yum install -y wget unzip gzip curl    elif check_sys packageManager apt; then        apt-get -y update        apt-get install -y wget unzip gzip curl    fi    echo&#125;# Download shadowsocks-<span class="hljs-keyword">go</span>download_files()&#123;    cd $&#123;cur_dir&#125;    <span class="hljs-keyword">if</span> is_64bit; then        <span class="hljs-keyword">if</span> ! wget --no-check-certificate -c https:<span class="hljs-comment">//github.com/shadowsocks/shadowsocks-go/releases/download/1.1.5/shadowsocks-server-linux64-1.1.5.gz; then</span>            echo <span class="hljs-string">"Failed to download shadowsocks-server-linux64-1.1.5.gz"</span>            exit <span class="hljs-number">1</span>        fi        gzip -d shadowsocks-server-linux64<span class="hljs-number">-1.1</span><span class="hljs-number">.5</span>.gz        <span class="hljs-keyword">if</span> [ $? -eq <span class="hljs-number">0</span> ]; then            echo <span class="hljs-string">"Decompress shadowsocks-server-linux64-1.1.5.gz success."</span>        <span class="hljs-keyword">else</span>            echo <span class="hljs-string">"Decompress shadowsocks-server-linux64-1.1.5.gz failed! Please check gzip command."</span>            exit <span class="hljs-number">1</span>        fi        mv -f shadowsocks-server-linux64<span class="hljs-number">-1.1</span><span class="hljs-number">.5</span> /usr/bin/shadowsocks-server    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">if</span> ! wget --no-check-certificate -c https:<span class="hljs-comment">//github.com/shadowsocks/shadowsocks-go/releases/download/1.1.5/shadowsocks-server-linux32-1.1.5.gz; then</span>            echo <span class="hljs-string">"Failed to download shadowsocks-server-linux32-1.1.5.gz"</span>            exit <span class="hljs-number">1</span>        fi        gzip -d shadowsocks-server-linux32<span class="hljs-number">-1.1</span><span class="hljs-number">.5</span>.gz        <span class="hljs-keyword">if</span> [ $? -eq <span class="hljs-number">0</span> ]; then            echo <span class="hljs-string">"Decompress shadowsocks-server-linux32-1.1.5.gz success."</span>        <span class="hljs-keyword">else</span>            echo <span class="hljs-string">"Decompress shadowsocks-server-linux32-1.1.5.gz failed! Please check gzip command."</span>            exit <span class="hljs-number">1</span>        fi        mv -f shadowsocks-server-linux32<span class="hljs-number">-1.1</span><span class="hljs-number">.5</span> /usr/bin/shadowsocks-server    fi    # Download start script    <span class="hljs-keyword">if</span> check_sys packageManager yum; then        <span class="hljs-keyword">if</span> ! wget --no-check-certificate -O /etc/init.d/shadowsocks https:<span class="hljs-comment">//raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-go; then</span>            echo <span class="hljs-string">"Failed to download shadowsocks-go auto start script!"</span>            exit <span class="hljs-number">1</span>        fi    elif check_sys packageManager apt; then        <span class="hljs-keyword">if</span> ! wget --no-check-certificate -O /etc/init.d/shadowsocks https:<span class="hljs-comment">//raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-go-debian; then</span>            echo <span class="hljs-string">"Failed to download shadowsocks-go auto start script!"</span>            exit <span class="hljs-number">1</span>        fi    fi&#125;# Config shadowsocksconfig_shadowsocks()&#123;    <span class="hljs-keyword">if</span> [ ! -d /etc/shadowsocks ]; then        mkdir -p /etc/shadowsocks    fi    cat &gt; /etc/shadowsocks/config.json&lt;&lt;-EOF&#123;    <span class="hljs-string">"server"</span>:<span class="hljs-string">"0.0.0.0"</span>,    <span class="hljs-string">"server_port"</span>:$&#123;shadowsocksport&#125;,    <span class="hljs-string">"local_port"</span>:<span class="hljs-number">1080</span>,    <span class="hljs-string">"password"</span>:<span class="hljs-string">"$&#123;shadowsockspwd&#125;"</span>,    <span class="hljs-string">"method"</span>:<span class="hljs-string">"aes-256-cfb"</span>,    <span class="hljs-string">"timeout"</span>:<span class="hljs-number">600</span>&#125;EOF&#125;# Firewall setfirewall_set()&#123;    echo <span class="hljs-string">"firewall set start..."</span>    <span class="hljs-keyword">if</span> centosversion <span class="hljs-number">6</span>; then        /etc/init.d/iptables status &gt; /dev/null <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> [ $? -eq <span class="hljs-number">0</span> ]; then            iptables -L -n | grep -i $&#123;shadowsocksport&#125; &gt; /dev/null <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> [ $? -ne <span class="hljs-number">0</span> ]; then                iptables -I INPUT -m state --state NEW -m tcp -p tcp --dport $&#123;shadowsocksport&#125; -j ACCEPT                iptables -I INPUT -m state --state NEW -m udp -p udp --dport $&#123;shadowsocksport&#125; -j ACCEPT                /etc/init.d/iptables save                /etc/init.d/iptables restart            <span class="hljs-keyword">else</span>                echo <span class="hljs-string">"port $&#123;shadowsocksport&#125; has been set up."</span>            fi        <span class="hljs-keyword">else</span>            echo <span class="hljs-string">"WARNING: iptables looks like shutdown or not installed, please manually set it if necessary."</span>        fi    elif centosversion <span class="hljs-number">7</span>; then        systemctl status firewalld &gt; /dev/null <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> [ $? -eq <span class="hljs-number">0</span> ]; then            firewall-cmd --permanent --zone=public --add-port=$&#123;shadowsocksport&#125;/tcp            firewall-cmd --permanent --zone=public --add-port=$&#123;shadowsocksport&#125;/udp            firewall-cmd --reload        <span class="hljs-keyword">else</span>            echo <span class="hljs-string">"Firewalld looks like not running, try to start..."</span>            systemctl start firewalld            <span class="hljs-keyword">if</span> [ $? -eq <span class="hljs-number">0</span> ]; then                firewall-cmd --permanent --zone=public --add-port=$&#123;shadowsocksport&#125;/tcp                firewall-cmd --permanent --zone=public --add-port=$&#123;shadowsocksport&#125;/udp                firewall-cmd --reload            <span class="hljs-keyword">else</span>                echo <span class="hljs-string">"WARNING: Try to start firewalld failed. please enable port $&#123;shadowsocksport&#125; manually if necessary."</span>            fi        fi    fi    echo <span class="hljs-string">"firewall set completed..."</span>&#125;# Install Shadowsocks-<span class="hljs-keyword">go</span>install()&#123;    <span class="hljs-keyword">if</span> [ -s /usr/bin/shadowsocks-server ]; then        echo <span class="hljs-string">"shadowsocks-go install success!"</span>        chmod +x /usr/bin/shadowsocks-server        chmod +x /etc/init.d/shadowsocks        <span class="hljs-keyword">if</span> check_sys packageManager yum; then            chkconfig --add shadowsocks            chkconfig shadowsocks on        elif check_sys packageManager apt; then            update-rc.d -f shadowsocks defaults        fi        /etc/init.d/shadowsocks start        <span class="hljs-keyword">if</span> [ $? -eq <span class="hljs-number">0</span> ]; then            echo <span class="hljs-string">"Shadowsocks-go start success!"</span>        <span class="hljs-keyword">else</span>            echo <span class="hljs-string">"Shadowsocks-go start failed!"</span>        fi    <span class="hljs-keyword">else</span>        echo        echo <span class="hljs-string">"Shadowsocks-go install failed!"</span>        exit <span class="hljs-number">1</span>    fi    clear    echo    echo <span class="hljs-string">"Congratulations, Shadowsocks-go install completed!"</span>    echo -e <span class="hljs-string">"Your Server IP: \033[41;37m $(get_ip) \033[0m"</span>    echo -e <span class="hljs-string">"Your Server Port: \033[41;37m $&#123;shadowsocksport&#125; \033[0m"</span>    echo -e <span class="hljs-string">"Your Password: \033[41;37m $&#123;shadowsockspwd&#125; \033[0m"</span>    echo -e <span class="hljs-string">"Your Local Port: \033[41;37m 1080 \033[0m"</span>    echo -e <span class="hljs-string">"Your Encryption Method: \033[41;37m aes-256-cfb \033[0m"</span>    echo    echo <span class="hljs-string">"Welcome to visit:https://teddysun.com/392.html"</span>    echo <span class="hljs-string">"Enjoy it!"</span>    echo&#125;# Uninstall Shadowsocks-<span class="hljs-keyword">go</span>uninstall_shadowsocks_go()&#123;    printf <span class="hljs-string">"Are you sure uninstall shadowsocks-go? (y/n) "</span>    printf <span class="hljs-string">"\n"</span>    read -p <span class="hljs-string">"(Default: n):"</span> answer    [ -z $&#123;answer&#125; ] &amp;&amp; answer=<span class="hljs-string">"n"</span>    <span class="hljs-keyword">if</span> [ <span class="hljs-string">"$&#123;answer&#125;"</span> == <span class="hljs-string">"y"</span> ] || [ <span class="hljs-string">"$&#123;answer&#125;"</span> == <span class="hljs-string">"Y"</span> ]; then        ps -ef | grep -v grep | grep -i <span class="hljs-string">"shadowsocks-server"</span> &gt; /dev/null <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> [ $? -eq <span class="hljs-number">0</span> ]; then            /etc/init.d/shadowsocks stop        fi        <span class="hljs-keyword">if</span> check_sys packageManager yum; then            chkconfig --del shadowsocks        elif check_sys packageManager apt; then            update-rc.d -f shadowsocks remove        fi        # <span class="hljs-built_in">delete</span> config file        rm -rf /etc/shadowsocks        # <span class="hljs-built_in">delete</span> shadowsocks        rm -f /etc/init.d/shadowsocks        rm -f /usr/bin/shadowsocks-server        echo <span class="hljs-string">"Shadowsocks-go uninstall success!"</span>    <span class="hljs-keyword">else</span>        echo        echo <span class="hljs-string">"Uninstall cancelled, nothing to do..."</span>        echo    fi&#125;# Install Shadowsocks-<span class="hljs-keyword">go</span>install_shadowsocks_go()&#123;    rootness    disable_selinux    pre_install    download_files    config_shadowsocks    <span class="hljs-keyword">if</span> check_sys packageManager yum; then        firewall_set    fi    install&#125;# Initialization stepaction=$<span class="hljs-number">1</span>[ -z $<span class="hljs-number">1</span> ] &amp;&amp; action=install<span class="hljs-keyword">case</span> <span class="hljs-string">"$action"</span> in    install|uninstall)    $&#123;action&#125;_shadowsocks_go    ;;    *)    echo <span class="hljs-string">"Arguments error! [$&#123;action&#125;]"</span>    echo <span class="hljs-string">"Usage: `basename $0` &#123;install|uninstall&#125;"</span>    ;;esac</code></pre><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Shadowsocks</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shadowsocks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java根据URL将网页转存为PDF文件</title>
    <link href="/2019/06/10/Java%E6%A0%B9%E6%8D%AEURL%E5%B0%86%E7%BD%91%E9%A1%B5%E8%BD%AC%E5%AD%98%E4%B8%BAPDF%E6%96%87%E4%BB%B6/"/>
    <url>/2019/06/10/Java%E6%A0%B9%E6%8D%AEURL%E5%B0%86%E7%BD%91%E9%A1%B5%E8%BD%AC%E5%AD%98%E4%B8%BAPDF%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><p>添加以下依赖：</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- url转pdf --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.xhtmlrenderer<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>flying-saucer-pdf-itext5<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>9.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><a id="more"></a><p>UrlToPdfUtil.java：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.FileOutputStream;<span class="hljs-keyword">import</span> java.io.OutputStream; <span class="hljs-keyword">import</span> org.xhtmlrenderer.pdf.ITextFontResolver;<span class="hljs-keyword">import</span> org.xhtmlrenderer.pdf.ITextRenderer; <span class="hljs-keyword">import</span> com.itextpdf.text.pdf.BaseFont; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UrlToPdfUtil</span> </span>&#123;     <span class="hljs-comment">//private static final String OUT_PUT_PDF_PATH = "/home/data/pdf/"; //pdf文件的存放路径（Linux）</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String OUT_PUT_PDF_PATH = <span class="hljs-string">"C:/Users/Administrator/Desktop/pdf/"</span>; <span class="hljs-comment">//pdf文件的存放路径（windows）</span>     <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@Title</span> 网页转存为PDF文件</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> url 链接地址</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> outputFileName 转存的PDF文件名</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">urlToPdf</span><span class="hljs-params">(String url, String outputFileName)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            String folder = outputFileName.substring(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>);            String outputFile = OUT_PUT_PDF_PATH + folder +<span class="hljs-string">"/"</span>+ outputFileName;            java.io.File targetFile = <span class="hljs-keyword">new</span> java.io.File(outputFile);            <span class="hljs-keyword">if</span> (!targetFile.getParentFile().exists()) &#123;                targetFile.getParentFile().mkdirs(); <span class="hljs-comment">// 创建父级文件路径</span>            &#125;            OutputStream os = <span class="hljs-keyword">new</span> FileOutputStream(outputFile);            ITextRenderer renderer = <span class="hljs-keyword">new</span> ITextRenderer();            renderer.setDocument(url);            ITextFontResolver fontResolver = renderer.getFontResolver();            <span class="hljs-comment">//fontResolver.addFont("/usr/share/fonts/chinese/simsun.ttc", BaseFont.IDENTITY_H, BaseFont.EMBEDDED); //Linux</span>            fontResolver.addFont(<span class="hljs-string">"c:/Windows/Fonts/simsun.ttc"</span>, BaseFont.IDENTITY_H, BaseFont.NOT_EMBEDDED); <span class="hljs-comment">//windows</span>            renderer.layout();            renderer.createPDF(os);            os.close();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        urlToPdf(<span class="hljs-string">"http://www.lrfun.com/toPdf.html"</span>, <span class="hljs-string">"201905098888888.pdf"</span>);    &#125;&#125;</code></pre><h4 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h4><p>1.字体限制，要使用simsun字体（<a href="http://www.lrfun.com/uploadfile/file/20190509/2019050915011034736.zip" target="_blank" rel="noopener">可点击下载</a>），下载自行安装吧；</p><p>2.需要转为PDF的网页，必须遵守W3C标准，也就是说每个标签都必须闭合（如：img等标签的结尾必须要添加“/”），否则就会报错，详细请参考文件：<a href="http://www.lrfun.com/toPdf.html" target="_blank" rel="noopener">http://www.lrfun.com/toPdf.html</a></p><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP协议状态码详解</title>
    <link href="/2019/06/10/HTTP%E5%8D%8F%E8%AE%AE%E7%8A%B6%E6%80%81%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
    <url>/2019/06/10/HTTP%E5%8D%8F%E8%AE%AE%E7%8A%B6%E6%80%81%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>常见 </p><p>200 – 服务器成功返回网页<br>404 – 请求的网页不存在<br>500 – 服务器内部错误 </p><p>0（特别说明） </p><p>0表示无法访问，或者说与服务器没有连接成功，但不一定是0就表示失败，有些时候访问本地资源成功了也会是0，比如Android的webviewajax访问本地资源时，responseCode就是0。 </p><a id="more"></a><p>1xx（临时响应） </p><p>表示临时响应并需要请求者继续执行操作的状态代码。 </p><p>代码 说明<br>100 （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。<br>101 （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。 </p><p>2xx （成功） </p><p>表示成功处理了请求的状态代码。 </p><p>代码 说明<br>200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。<br>201 （已创建） 请求成功并且服务器创建了新的资源。<br>202 （已接受） 服务器已接受请求，但尚未处理。<br>203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。<br>204 （无内容） 服务器成功处理了请求，但没有返回任何内容。<br>205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。<br>206 （部分内容） 服务器成功处理了部分 GET 请求。 </p><p>3xx （重定向） </p><p>表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 </p><p>代码 说明<br>300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。<br>301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。<br>302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。<br>303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。<br>304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。<br>305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。<br>307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 </p><p>4xx（请求错误） </p><p>这些状态代码表示请求可能出错，妨碍了服务器的处理。 </p><p>代码 说明<br>400 （错误请求） 服务器不理解请求的语法。<br>401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br>403 （禁止） 服务器拒绝请求。<br>404 （未找到） 服务器找不到请求的网页。<br>405 （方法禁用） 禁用请求中指定的方法。<br>406 （不接受） 无法使用请求的内容特性响应请求的网页。<br>407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。<br>408 （请求超时） 服务器等候请求时发生超时。<br>409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。<br>410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。<br>411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。<br>412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。<br>413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。<br>414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。<br>415 （不支持的媒体类型） 请求的格式不受请求页面的支持。<br>416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。<br>417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。 </p><p>5xx（服务器错误） </p><p>这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 </p><p>代码 说明<br>500 （服务器内部错误） 服务器遇到错误，无法完成请求。<br>501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。<br>502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。<br>503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。<br>504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 </p><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Http</category>
      
      <category>Status</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Http</tag>
      
      <tag>Status</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB多数据源配置</title>
    <link href="/2019/06/10/MongoDB%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE/"/>
    <url>/2019/06/10/MongoDB%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>SpringBoot对常用的数据库支持外，对NoSQL 数据库也进行了封装自动化。<br>这一篇主要讲springboot与mongo多数据源相关的配置</p><h3 id="1、mongo的介绍"><a href="#1、mongo的介绍" class="headerlink" title="1、mongo的介绍"></a>1、mongo的介绍</h3><p>MongoDB是一个高性能，开源，无模式的文档型数据库，是当前NoSql数据库中比较热门的一种。它在许多场景下可用于替代传统的关系型数据库或键/值存储方式,这里不再多做说明。详细介绍参考<br><a href="http://blog.csdn.net/liusong0605/article/details/10554395" target="_blank" rel="noopener">mongo入门</a></p><a id="more"></a><h3 id="2、项目构建"><a href="#2、项目构建" class="headerlink" title="2、项目构建"></a>2、项目构建</h3><p>添加pom文件</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="3、在application-properties中添加配置"><a href="#3、在application-properties中添加配置" class="headerlink" title="3、在application.properties中添加配置"></a>3、在application.properties中添加配置</h3><pre><code class="hljs properties"><span class="hljs-comment">##start mongodb for basic</span><span class="hljs-comment">#----------------------------------------------</span><span class="hljs-meta">basic.mongodb.host</span>= <span class="hljs-string">127.0.0.1</span><span class="hljs-meta">basic.mongodb.port</span>= <span class="hljs-string">27017</span><span class="hljs-meta">basic.mongodb.database</span>= <span class="hljs-string">basic</span><span class="hljs-comment">#----------------------------------------------</span><span class="hljs-comment">##end mongodb for spirit</span><span class="hljs-comment">##start mongodb for basic</span><span class="hljs-comment">#----------------------------------------------</span><span class="hljs-meta">order.mongodb.host</span>= <span class="hljs-string">127.0.0.2</span><span class="hljs-meta">order.mongodb.port</span>= <span class="hljs-string">27017</span><span class="hljs-meta">order.mongodb.database</span>= <span class="hljs-string">order</span><span class="hljs-comment">#----------------------------------------------</span><span class="hljs-comment">##end mongodb for spirit</span></code></pre><h3 id="4、配置相应的数据源"><a href="#4、配置相应的数据源" class="headerlink" title="4、配置相应的数据源"></a>4、配置相应的数据源</h3><p>这里我们采用mongoTemplate这种模式去做mongo的相关操作</p><p>先写一个基础的抽象类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractMongoConfigure</span> </span>&#123;    <span class="hljs-keyword">private</span> String host, database;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> port;    <span class="hljs-comment">/*</span><span class="hljs-comment">       * Method that creates MongoDbFactory</span><span class="hljs-comment">       * Common to both of the MongoDb connections</span><span class="hljs-comment">       */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> MongoDbFactory <span class="hljs-title">mongoDbFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SimpleMongoDbFactory(<span class="hljs-keyword">new</span> MongoClient(host, port), database);    &#125;    <span class="hljs-comment">/*</span><span class="hljs-comment">     * Factory method to create the MongoTemplate</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> MongoTemplate <span class="hljs-title">getMongoTemplate</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getHost</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> host;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHost</span><span class="hljs-params">(String host)</span> </span>&#123;        <span class="hljs-keyword">this</span>.host = host;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDatabase</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> database;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDatabase</span><span class="hljs-params">(String database)</span> </span>&#123;        <span class="hljs-keyword">this</span>.database = database;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPort</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> port;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> </span>&#123;        <span class="hljs-keyword">this</span>.port = port;    &#125;&#125;</code></pre><h3 id="3-1-接下来第一个库的封装"><a href="#3-1-接下来第一个库的封装" class="headerlink" title="3.1)接下来第一个库的封装"></a>3.1)接下来第一个库的封装</h3><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableMongoRepositories</span>(basePackages = &#123;<span class="hljs-string">"com.sunliangliang.service.basic"</span>&#125;, mongoTemplateRef = <span class="hljs-string">"basicMongoTemplate"</span>)<span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"basic.mongodb"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicMongoConfigure</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMongoConfigure</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@Bean</span>(name = <span class="hljs-string">"basicMongoTemplate"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> MongoTemplate <span class="hljs-title">getMongoTemplate</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MongoTemplate(mongoDbFactory());    &#125;&#125;</code></pre><p>其中 basePackages 的值是该库应用于相应的基础包，prefix即为相应的applications中的配置值</p><h4 id="3-2-接下来第两个库的封装"><a href="#3-2-接下来第两个库的封装" class="headerlink" title="3.2)接下来第两个库的封装"></a>3.2)接下来第两个库的封装</h4><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableMongoRepositories</span>(basePackages = &#123;<span class="hljs-string">"com.sunliangliang.service.order"</span>&#125;, mongoTemplateRef = <span class="hljs-string">"orderMongoTemplate"</span>)<span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"order.mongodb"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderMongoConfigure</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMongoConfigure</span></span>&#123;    <span class="hljs-meta">@Primary</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@Bean</span>(name = <span class="hljs-string">"orderMongoTemplate"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> MongoTemplate <span class="hljs-title">getMongoTemplate</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MongoTemplate(mongoDbFactory());    &#125;&#125;</code></pre><p>封装完成后接下来进行相应实体的配置</p><h3 id="4、创建数据实体"><a href="#4、创建数据实体" class="headerlink" title="4、创建数据实体"></a>4、创建数据实体</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> id;    <span class="hljs-keyword">private</span> String username;    <span class="hljs-keyword">private</span> String password;    <span class="hljs-keyword">private</span> String nickname;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">long</span> id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> username;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;        <span class="hljs-keyword">this</span>.username = username;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPassword</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> password;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPassword</span><span class="hljs-params">(String password)</span> </span>&#123;        <span class="hljs-keyword">this</span>.password = password;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getNickname</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> nickname;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNickname</span><span class="hljs-params">(String nickname)</span> </span>&#123;        <span class="hljs-keyword">this</span>.nickname = nickname;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;&#125;</code></pre><h3 id="4、添加对实体的操作"><a href="#4、添加对实体的操作" class="headerlink" title="4、添加对实体的操作"></a>4、添加对实体的操作</h3><p>在这里我写了一个公用的接口用于基础的增删改查</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BaseService</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-function">Boolean <span class="hljs-title">save</span><span class="hljs-params">(T entity)</span></span>;    <span class="hljs-function">Boolean <span class="hljs-title">update</span><span class="hljs-params">(T entity)</span></span>;    <span class="hljs-function">Boolean <span class="hljs-title">delete</span><span class="hljs-params">(Long id)</span></span>;    <span class="hljs-function">T <span class="hljs-title">getById</span><span class="hljs-params">(Long id)</span></span>;    <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">listAll</span><span class="hljs-params">()</span></span>;    <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">listAll</span><span class="hljs-params">(T entity)</span></span>;&#125;</code></pre><p>接下来接口的实现</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfoService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BaseService</span>&lt;<span class="hljs-title">UserInfo</span>&gt;</span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-meta">@Qualifier</span>(<span class="hljs-string">"basicMongoTemplate"</span>)    <span class="hljs-keyword">private</span> MongoTemplate mongoTemplate;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">save</span><span class="hljs-params">(UserInfo entity)</span> </span>&#123;        mongoTemplate.save(entity);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">update</span><span class="hljs-params">(UserInfo entity)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">delete</span><span class="hljs-params">(Long id)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserInfo <span class="hljs-title">getById</span><span class="hljs-params">(Long id)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserInfo&gt; <span class="hljs-title">listAll</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> mongoTemplate.findAll(UserInfo<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserInfo&gt; <span class="hljs-title">listAll</span><span class="hljs-params">(UserInfo entity)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre><p>注意此处@Qualifier(“basicMongoTemplate”)中即为相应的具体实现类。</p><p>这里只写了添加和查询列表的实现，其他的查询相应的api即可</p><pre><code class="hljs java"><span class="hljs-meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">SpringBootTest</span></span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">UserInfoServiceTest</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserInfoService userInfoService;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        UserInfo userInfo = <span class="hljs-keyword">new</span> UserInfo();        userInfo.setAge(<span class="hljs-number">23</span>);        userInfo.setId(<span class="hljs-number">1000l</span>);        userInfo.setName(<span class="hljs-string">"管理员"</span>);        userInfo.setNickname(<span class="hljs-string">"hehe"</span>);        userInfo.setPassword(<span class="hljs-string">"123456"</span>);        userInfo.setUsername(<span class="hljs-string">"admin"</span>);        userInfoService.save(userInfo);    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        userInfoService.listAll();    &#125;&#125;</code></pre><p>若库不存在，会自动生成相应的库和文档</p><p>另一个order相关库的配置就不再这里写了</p><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA操作MongoDB工具类分享</title>
    <link href="/2019/06/10/JAVA%E6%93%8D%E4%BD%9CMongoDB%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%88%86%E4%BA%AB/"/>
    <url>/2019/06/10/JAVA%E6%93%8D%E4%BD%9CMongoDB%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<p>最近做了个用MongoDB存储的项目，由于MongoDB对开发人员不开放，由DBA统一管理。因此，自己抽时间写了个MongoDB的查询机。便于查询项目中的数据，方便维护和分析问题。总结了一些java操作MongoDB的方法。本文没有使用spring-data来操作MongoDB。而是直接使用MongoDB for java的原始API。现在介绍一下工具类。 </p><h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h1><p>MongoDB的安装，不多做介绍。 </p><p>MongoDB的java驱动 </p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mongodb<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mongo-java-driver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.11.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><a id="more"></a><h1 id="2-封装实体介绍"><a href="#2-封装实体介绍" class="headerlink" title="2.封装实体介绍"></a>2.封装实体介绍</h1><ul><li><p>MongoDBCursor——MongoDB条件查询封装实体（支持limit，skip，sort）     </p></li><li><p>MongoDBEntity——MongoDB集合封装实体     </p></li><li><p>MongoDBUpdate——MongoDB更新封装实体 </p><p>​    </p></li></ul><p>MongoDBCursor </p><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.mongodb.BasicDBObject;<span class="hljs-keyword">import</span> com.mongodb.DBObject; <span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.LinkedHashMap;<span class="hljs-keyword">import</span> java.util.Map; <span class="hljs-comment">/**</span><span class="hljs-comment"> * MongoDB条件查询封装实体（支持limit，skip，sort）</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: alex</span><span class="hljs-comment"> * <span class="hljs-doctag">@time</span>: 14-1-21 下午5:00</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span>: 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MongoDBCursor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MongoDBEntity</span> </span>&#123;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * skip属性</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> skip;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * limit属性</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> limit = <span class="hljs-number">100</span>;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 排序属性</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; sort = <span class="hljs-keyword">new</span> LinkedHashMap&lt;String, Object&gt;();     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 自定义查询字段属性</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; customFieldMap = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSkip</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> skip;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSkip</span><span class="hljs-params">(<span class="hljs-keyword">int</span> skip)</span> </span>&#123;        <span class="hljs-keyword">this</span>.skip = skip;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLimit</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> limit;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLimit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> limit)</span> </span>&#123;        <span class="hljs-keyword">this</span>.limit = limit;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">getSort</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> sort;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSort</span><span class="hljs-params">(Map&lt;String, Object&gt; sort)</span> </span>&#123;        <span class="hljs-keyword">this</span>.sort = sort;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> DBObject <span class="hljs-title">getSortObject</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.sort == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        DBObject dbo = <span class="hljs-keyword">new</span> BasicDBObject();        <span class="hljs-keyword">for</span> (String k : sort.keySet()) &#123;            dbo.put(k, Integer.valueOf(sort.get(k).toString()));        &#125;        <span class="hljs-keyword">return</span> dbo;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">getCustomFieldMap</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> customFieldMap;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCustomFieldMap</span><span class="hljs-params">(Map&lt;String, Object&gt; customFieldMap)</span> </span>&#123;        <span class="hljs-keyword">this</span>.customFieldMap = customFieldMap;    &#125;&#125;</code></pre><p> MongoDBEntity </p><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.mongodb.DB; <span class="hljs-keyword">import</span> java.util.Map; <span class="hljs-comment">/**</span><span class="hljs-comment"> * MongoDB集合封装实体</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: alex</span><span class="hljs-comment"> * <span class="hljs-doctag">@time</span>: 14-1-20 下午2:57</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span>: 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MongoDBEntity</span> </span>&#123;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * mongo数据库</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> DB db;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 集合名字</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> String collectionName;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 字段封装Map</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> Map&lt;String,Object&gt; fieldMap;     <span class="hljs-function"><span class="hljs-keyword">public</span> DB <span class="hljs-title">getDb</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> db;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDb</span><span class="hljs-params">(DB db)</span> </span>&#123;        <span class="hljs-keyword">this</span>.db = db;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCollectionName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> collectionName;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCollectionName</span><span class="hljs-params">(String collectionName)</span> </span>&#123;        <span class="hljs-keyword">this</span>.collectionName = collectionName;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">getFieldMap</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> fieldMap;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFieldMap</span><span class="hljs-params">(Map&lt;String, Object&gt; fieldMap)</span> </span>&#123;        <span class="hljs-keyword">this</span>.fieldMap = fieldMap;    &#125;&#125;</code></pre><p>MongoDBUpdate  </p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Map; <span class="hljs-comment">/**</span><span class="hljs-comment"> * MongoDB更新封装实体</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: alex</span><span class="hljs-comment"> * <span class="hljs-doctag">@time</span>: 14-1-21 下午5:00</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span>: 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MongoDBUpdate</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MongoDBEntity</span> </span>&#123;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * where查询Map</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; whereMap;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * value查询Map</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; valueMap;     <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">getWhereMap</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> whereMap;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWhereMap</span><span class="hljs-params">(Map&lt;String, Object&gt; whereMap)</span> </span>&#123;        <span class="hljs-keyword">this</span>.whereMap = whereMap;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">getValueMap</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> valueMap;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValueMap</span><span class="hljs-params">(Map&lt;String, Object&gt; valueMap)</span> </span>&#123;        <span class="hljs-keyword">this</span>.valueMap = valueMap;    &#125;&#125;</code></pre><h1 id="3-MongoDB操作类"><a href="#3-MongoDB操作类" class="headerlink" title="3.MongoDB操作类"></a>3.MongoDB操作类</h1><ul><li>MongoDBCommonUtil——MongoDB集合操作工作类     </li><li>MongoDBUtil——MongoDBCRUD操作封装工具类     </li></ul><p>MongoDBCommonUtil </p><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.mongodb.*;<span class="hljs-keyword">import</span> org.bson.types.BasicBSONList;<span class="hljs-keyword">import</span> org.bson.types.ObjectId; <span class="hljs-keyword">import</span> java.util.*; <span class="hljs-comment">/**</span><span class="hljs-comment"> * MongoDBCRUD操作封装工具类</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: alex</span><span class="hljs-comment"> * <span class="hljs-doctag">@time</span>: 14-1-21 下午3:16</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span>: 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MongoDBUtil</span> </span>&#123;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 按主键查询单个实体</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id            主键</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBCursor 查询实体</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> DBObject</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DBObject <span class="hljs-title">findById</span><span class="hljs-params">(MongoDBCursor mongoDBCursor, String id)</span> </span>&#123;        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();        map.put(<span class="hljs-string">"_id"</span>, <span class="hljs-keyword">new</span> ObjectId(id));        mongoDBCursor.setFieldMap(map);        <span class="hljs-keyword">return</span> findOne(mongoDBCursor);    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 按条件查询单个</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBCursor 查询实体</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> DBObject</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DBObject <span class="hljs-title">findOne</span><span class="hljs-params">(MongoDBCursor mongoDBCursor)</span> </span>&#123;        DBObject dbObject = getMapped(mongoDBCursor.getFieldMap());        <span class="hljs-keyword">return</span> MongoDBCommonUtil.getCollection(mongoDBCursor).findOne(dbObject);    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 查询全部</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBCursor 查询实体</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;DBObject&gt; <span class="hljs-title">findAll</span><span class="hljs-params">(MongoDBCursor mongoDBCursor)</span> </span>&#123;        mongoDBCursor.setFieldMap(<span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;());        <span class="hljs-keyword">return</span> find(mongoDBCursor);    &#125;      <span class="hljs-comment">/**</span><span class="hljs-comment">     * 按条件查询</span><span class="hljs-comment">     * 支持skip，limit,sort</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBCursor 查询实体</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;DBObject&gt; <span class="hljs-title">find</span><span class="hljs-params">(MongoDBCursor mongoDBCursor)</span> </span>&#123;        DBObject dbObject = getMapped(mongoDBCursor.getFieldMap());        BasicDBObjectBuilder customField = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">//自定义查询字段</span>        <span class="hljs-keyword">if</span>(mongoDBCursor.getCustomFieldMap() != <span class="hljs-keyword">null</span> &amp;&amp; mongoDBCursor.getCustomFieldMap().size() &gt; <span class="hljs-number">0</span>) &#123;            customField = <span class="hljs-keyword">new</span> BasicDBObjectBuilder();            <span class="hljs-keyword">for</span>(Map.Entry&lt;String, Object&gt; field : mongoDBCursor.getCustomFieldMap().entrySet()) &#123;                customField.add(field.getKey(),field.getValue());            &#125;        &#125;        <span class="hljs-keyword">return</span> find(mongoDBCursor, dbObject, customField);    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 查询（私有方法,检查是否含有skip，limit，sort）</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dbObject      查询条件</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBCursor 查询实体</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;DBObject&gt; <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">final</span> MongoDBCursor mongoDBCursor, DBObject dbObject,BasicDBObjectBuilder customField)</span> </span>&#123;        MongoDBCursorPreparer cursorPreparer = mongoDBCursor == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : <span class="hljs-keyword">new</span> MongoDBCursorPreparer() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> DBCursor <span class="hljs-title">prepare</span><span class="hljs-params">(DBCursor dbCursor)</span> </span>&#123;                <span class="hljs-keyword">if</span> (mongoDBCursor == <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">return</span> dbCursor;                &#125;                <span class="hljs-keyword">if</span> (mongoDBCursor.getLimit() &lt;= <span class="hljs-number">0</span> &amp;&amp; mongoDBCursor.getSkip() &lt;= <span class="hljs-number">0</span> &amp;&amp; mongoDBCursor.getSortObject() == <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">return</span> dbCursor;                &#125;                DBCursor cursorToUse = dbCursor;                <span class="hljs-keyword">if</span> (mongoDBCursor.getSkip() &gt; <span class="hljs-number">0</span>) &#123;                    cursorToUse = cursorToUse.skip(mongoDBCursor.getSkip());                &#125;                <span class="hljs-keyword">if</span> (mongoDBCursor.getLimit() &gt; <span class="hljs-number">0</span>) &#123;                    cursorToUse = cursorToUse.limit(mongoDBCursor.getLimit());                &#125;                <span class="hljs-keyword">if</span> (mongoDBCursor.getSortObject() != <span class="hljs-keyword">null</span>) &#123;                    cursorToUse = cursorToUse.sort(mongoDBCursor.getSortObject());                &#125;                <span class="hljs-keyword">return</span> cursorToUse;            &#125;        &#125;;        <span class="hljs-keyword">return</span> find(mongoDBCursor, dbObject, cursorPreparer,customField);    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 查询（私有方法，真正的查询操作）</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> query       查询条件</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBCursor  查询实体</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cursorPreparer 查询转换接口</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;DBObject&gt; <span class="hljs-title">find</span><span class="hljs-params">(MongoDBCursor mongoDBCursor, DBObject query, MongoDBCursorPreparer cursorPreparer,BasicDBObjectBuilder customField)</span> </span>&#123;        DBCursor dbCursor = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span>(customField == <span class="hljs-keyword">null</span>) &#123;            dbCursor = MongoDBCommonUtil.getCollection(mongoDBCursor).find(query);        &#125; <span class="hljs-keyword">else</span> &#123;            dbCursor = MongoDBCommonUtil.getCollection(mongoDBCursor).find(query,customField.get());        &#125;        <span class="hljs-keyword">if</span> (cursorPreparer != <span class="hljs-keyword">null</span>) &#123;            dbCursor = cursorPreparer.prepare(dbCursor);        &#125;        <span class="hljs-keyword">return</span> dbCursor.toArray();    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * Count查询</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBCursor 查询实体</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 总数</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">count</span><span class="hljs-params">(MongoDBCursor mongoDBCursor)</span> </span>&#123;        DBObject dbObject = getMapped(mongoDBCursor.getFieldMap());        <span class="hljs-keyword">return</span> MongoDBCommonUtil.getCollection(mongoDBCursor).count(dbObject);     &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 把参数Map转换DBObject</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> map 查询条件</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> DBObject</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DBObject <span class="hljs-title">getMapped</span><span class="hljs-params">(Map&lt;String, Object&gt; map)</span> </span>&#123;        DBObject dbObject = <span class="hljs-keyword">new</span> BasicDBObject();        Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; iterable = map.entrySet().iterator();        <span class="hljs-keyword">while</span> (iterable.hasNext()) &#123;            Map.Entry&lt;String, Object&gt; entry = iterable.next();            Object value = entry.getValue();            String key = entry.getKey();            <span class="hljs-keyword">if</span> (key.startsWith(<span class="hljs-string">"$"</span>) &amp;&amp; value <span class="hljs-keyword">instanceof</span> Map) &#123;                BasicBSONList basicBSONList = <span class="hljs-keyword">new</span> BasicBSONList();                Map&lt;String, Object&gt; conditionsMap = ((Map) value);<span class="hljs-comment">//                Set&lt;String&gt; keys = conditionsMap.keySet();</span>                <span class="hljs-keyword">for</span> (String k : conditionsMap.keySet()) &#123;                    Object conditionsValue = conditionsMap.get(k);                    <span class="hljs-keyword">if</span> (conditionsValue <span class="hljs-keyword">instanceof</span> Collection) &#123;                        conditionsValue = convertArray(conditionsValue);                    &#125;                    DBObject dbObject2 = <span class="hljs-keyword">new</span> BasicDBObject(k, conditionsValue);                    basicBSONList.add(dbObject2);                &#125;                value = basicBSONList;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> Collection) &#123;                value = convertArray(value);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!key.startsWith(<span class="hljs-string">"$"</span>) &amp;&amp; value <span class="hljs-keyword">instanceof</span> Map) &#123;                value = getMapped(((Map) value));            &#125;            dbObject.put(key, value);        &#125;        <span class="hljs-keyword">return</span> dbObject;    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 转换成Object[]</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 待转换实体</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Object[]</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object[] convertArray(Object value) &#123;        Object[] values = ((Collection) value).toArray();        <span class="hljs-keyword">return</span> values;    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 添加操作</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBEntity 实体</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(MongoDBEntity mongoDBEntity)</span> </span>&#123;        DBObject dbObject = <span class="hljs-keyword">new</span> BasicDBObject(mongoDBEntity.getFieldMap());        MongoDBCommonUtil.getCollection(mongoDBEntity).insert(dbObject);    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 批量处理添加操作</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> list          批量字段数据</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBEntity 实体</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(MongoDBEntity mongoDBEntity, List&lt;Map&lt;String, Object&gt;&gt; list)</span> </span>&#123;        <span class="hljs-keyword">for</span> (Map&lt;String, Object&gt; map : list) &#123;            mongoDBEntity.setFieldMap(map);            add(mongoDBEntity);        &#125;    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 删除操作</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBEntity 实体</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(MongoDBEntity mongoDBEntity)</span> </span>&#123;        DBObject dbObject = <span class="hljs-keyword">new</span> BasicDBObject(mongoDBEntity.getFieldMap());        MongoDBCommonUtil.getCollection(mongoDBEntity).remove(dbObject);    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 删除操作,根据主键</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id            主键</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBEntity 实体</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(MongoDBEntity mongoDBEntity, String id)</span> </span>&#123;        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();        map.put(<span class="hljs-string">"_id"</span>, <span class="hljs-keyword">new</span> ObjectId(id));        mongoDBEntity.setFieldMap(map);        delete(mongoDBEntity);    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 删除全部</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBEntity 实体</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteAll</span><span class="hljs-params">(MongoDBEntity mongoDBEntity)</span> </span>&#123;        MongoDBCommonUtil.getCollection(mongoDBEntity).drop();    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 修改操作</span><span class="hljs-comment">     * 会用一个新文档替换现有文档,文档key结构会发生改变</span><span class="hljs-comment">     * 比如原文档&#123;"_id":"123","name":"zhangsan","age":12&#125;当根据_id修改age</span><span class="hljs-comment">     * value为&#123;"age":12&#125;新建的文档name值会没有,结构发生了改变</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBUpdate 更新实体</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(MongoDBUpdate mongoDBUpdate)</span> </span>&#123;        executeUpdate(mongoDBUpdate, <span class="hljs-keyword">new</span> UpdateCallback() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> DBObject <span class="hljs-title">doCallback</span><span class="hljs-params">(DBObject valueDBObject)</span> </span>&#123;                <span class="hljs-keyword">return</span> valueDBObject;            &#125;        &#125;);    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 修改操作,使用$set修改器</span><span class="hljs-comment">     * 用来指定一个键值,如果键不存在,则自动创建,会更新原来文档, 不会生成新的, 结构不会发生改变</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBUpdate 更新实体</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateSet</span><span class="hljs-params">(MongoDBUpdate mongoDBUpdate)</span> </span>&#123;        executeUpdate(mongoDBUpdate, <span class="hljs-keyword">new</span> UpdateCallback() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> DBObject <span class="hljs-title">doCallback</span><span class="hljs-params">(DBObject valueDBObject)</span> </span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BasicDBObject(<span class="hljs-string">"$set"</span>, valueDBObject);            &#125;        &#125;);    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 修改操作,使用$inc修改器</span><span class="hljs-comment">     * 修改器键的值必须为数字</span><span class="hljs-comment">     * 如果键存在增加或减少键的值, 如果不存在创建键</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBUpdate 更新实体</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateInc</span><span class="hljs-params">(MongoDBUpdate mongoDBUpdate)</span> </span>&#123;        executeUpdate(mongoDBUpdate, <span class="hljs-keyword">new</span> UpdateCallback() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> DBObject <span class="hljs-title">doCallback</span><span class="hljs-params">(DBObject valueDBObject)</span> </span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BasicDBObject(<span class="hljs-string">"$inc"</span>, valueDBObject);            &#125;        &#125;);    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 修改(私有方法)</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBUpdate  更新实体</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> updateCallback 更新回调</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">executeUpdate</span><span class="hljs-params">(MongoDBUpdate mongoDBUpdate, UpdateCallback updateCallback)</span> </span>&#123;        DBObject whereDBObject = <span class="hljs-keyword">new</span> BasicDBObject(mongoDBUpdate.getWhereMap());        DBObject valueDBObject = <span class="hljs-keyword">new</span> BasicDBObject(mongoDBUpdate.getValueMap());        valueDBObject = updateCallback.doCallback(valueDBObject);        MongoDBCommonUtil.getCollection(mongoDBUpdate).update(whereDBObject, valueDBObject);    &#125;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//获取操作DB</span>            DB db = MongoDBCommonUtil.getDB(<span class="hljs-string">"192.168.227.170"</span>, <span class="hljs-number">20011</span>,<span class="hljs-string">"lagd"</span>,<span class="hljs-string">"lagd_rw"</span>,<span class="hljs-string">"lagd_pwd"</span>);            MongoDBCursor mongoDBCursor = <span class="hljs-keyword">new</span> MongoDBCursor();            mongoDBCursor.setDb(db);     <span class="hljs-comment">//赋值DB</span>            mongoDBCursor.setCollectionName(<span class="hljs-string">"lagd_data_dictionary"</span>);   <span class="hljs-comment">//赋值集合名</span>            <span class="hljs-comment">//封装查询条件</span>            Map&lt;String, Object&gt; fieldMap = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();            fieldMap.put(<span class="hljs-string">"type"</span>,<span class="hljs-string">"dataSource"</span>);            mongoDBCursor.setFieldMap(fieldMap);            <span class="hljs-comment">//赋值skip</span>            mongoDBCursor.setSkip(<span class="hljs-number">1</span>);            <span class="hljs-comment">//赋值limit</span>            mongoDBCursor.setLimit(<span class="hljs-number">1</span>);            <span class="hljs-comment">//封装Sort</span>            Map&lt;String, Object&gt; sortMap = <span class="hljs-keyword">new</span> LinkedHashMap&lt;String, Object&gt;();            sortMap.put(<span class="hljs-string">"key"</span>,<span class="hljs-number">1</span>);            mongoDBCursor.setSort(sortMap);            <span class="hljs-comment">//查询</span>            List&lt;DBObject&gt; result = MongoDBUtil.find(mongoDBCursor);            <span class="hljs-keyword">for</span>(DBObject dbObject : result)&#123;                <span class="hljs-keyword">for</span>(String key : dbObject.keySet())&#123;                    System.out.println(<span class="hljs-string">"key="</span> + key + <span class="hljs-string">";  value="</span> + dbObject.get(key));                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p> MongoDBUtil </p><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.mongodb.*;<span class="hljs-keyword">import</span> org.bson.types.BasicBSONList;<span class="hljs-keyword">import</span> org.bson.types.ObjectId; <span class="hljs-keyword">import</span> java.util.*; <span class="hljs-comment">/**</span><span class="hljs-comment"> * MongoDBCRUD操作封装工具类</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: alex</span><span class="hljs-comment"> * <span class="hljs-doctag">@time</span>: 14-1-21 下午3:16</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span>: 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MongoDBUtil</span> </span>&#123;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 按主键查询单个实体</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id            主键</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBCursor 查询实体</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> DBObject</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DBObject <span class="hljs-title">findById</span><span class="hljs-params">(MongoDBCursor mongoDBCursor, String id)</span> </span>&#123;        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();        map.put(<span class="hljs-string">"_id"</span>, <span class="hljs-keyword">new</span> ObjectId(id));        mongoDBCursor.setFieldMap(map);        <span class="hljs-keyword">return</span> findOne(mongoDBCursor);    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 按条件查询单个</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBCursor 查询实体</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> DBObject</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DBObject <span class="hljs-title">findOne</span><span class="hljs-params">(MongoDBCursor mongoDBCursor)</span> </span>&#123;        DBObject dbObject = getMapped(mongoDBCursor.getFieldMap());        <span class="hljs-keyword">return</span> MongoDBCommonUtil.getCollection(mongoDBCursor).findOne(dbObject);    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 查询全部</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBCursor 查询实体</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;DBObject&gt; <span class="hljs-title">findAll</span><span class="hljs-params">(MongoDBCursor mongoDBCursor)</span> </span>&#123;        mongoDBCursor.setFieldMap(<span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;());        <span class="hljs-keyword">return</span> find(mongoDBCursor);    &#125;      <span class="hljs-comment">/**</span><span class="hljs-comment">     * 按条件查询</span><span class="hljs-comment">     * 支持skip，limit,sort</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBCursor 查询实体</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;DBObject&gt; <span class="hljs-title">find</span><span class="hljs-params">(MongoDBCursor mongoDBCursor)</span> </span>&#123;        DBObject dbObject = getMapped(mongoDBCursor.getFieldMap());        BasicDBObjectBuilder customField = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">//自定义查询字段</span>        <span class="hljs-keyword">if</span>(mongoDBCursor.getCustomFieldMap() != <span class="hljs-keyword">null</span> &amp;&amp; mongoDBCursor.getCustomFieldMap().size() &gt; <span class="hljs-number">0</span>) &#123;            customField = <span class="hljs-keyword">new</span> BasicDBObjectBuilder();            <span class="hljs-keyword">for</span>(Map.Entry&lt;String, Object&gt; field : mongoDBCursor.getCustomFieldMap().entrySet()) &#123;                customField.add(field.getKey(),field.getValue());            &#125;        &#125;        <span class="hljs-keyword">return</span> find(mongoDBCursor, dbObject, customField);    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 查询（私有方法,检查是否含有skip，limit，sort）</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dbObject      查询条件</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBCursor 查询实体</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;DBObject&gt; <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">final</span> MongoDBCursor mongoDBCursor, DBObject dbObject,BasicDBObjectBuilder customField)</span> </span>&#123;        MongoDBCursorPreparer cursorPreparer = mongoDBCursor == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : <span class="hljs-keyword">new</span> MongoDBCursorPreparer() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> DBCursor <span class="hljs-title">prepare</span><span class="hljs-params">(DBCursor dbCursor)</span> </span>&#123;                <span class="hljs-keyword">if</span> (mongoDBCursor == <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">return</span> dbCursor;                &#125;                <span class="hljs-keyword">if</span> (mongoDBCursor.getLimit() &lt;= <span class="hljs-number">0</span> &amp;&amp; mongoDBCursor.getSkip() &lt;= <span class="hljs-number">0</span> &amp;&amp; mongoDBCursor.getSortObject() == <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">return</span> dbCursor;                &#125;                DBCursor cursorToUse = dbCursor;                <span class="hljs-keyword">if</span> (mongoDBCursor.getSkip() &gt; <span class="hljs-number">0</span>) &#123;                    cursorToUse = cursorToUse.skip(mongoDBCursor.getSkip());                &#125;                <span class="hljs-keyword">if</span> (mongoDBCursor.getLimit() &gt; <span class="hljs-number">0</span>) &#123;                    cursorToUse = cursorToUse.limit(mongoDBCursor.getLimit());                &#125;                <span class="hljs-keyword">if</span> (mongoDBCursor.getSortObject() != <span class="hljs-keyword">null</span>) &#123;                    cursorToUse = cursorToUse.sort(mongoDBCursor.getSortObject());                &#125;                <span class="hljs-keyword">return</span> cursorToUse;            &#125;        &#125;;        <span class="hljs-keyword">return</span> find(mongoDBCursor, dbObject, cursorPreparer,customField);    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 查询（私有方法，真正的查询操作）</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> query       查询条件</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBCursor  查询实体</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cursorPreparer 查询转换接口</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;DBObject&gt; <span class="hljs-title">find</span><span class="hljs-params">(MongoDBCursor mongoDBCursor, DBObject query, MongoDBCursorPreparer cursorPreparer,BasicDBObjectBuilder customField)</span> </span>&#123;        DBCursor dbCursor = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span>(customField == <span class="hljs-keyword">null</span>) &#123;            dbCursor = MongoDBCommonUtil.getCollection(mongoDBCursor).find(query);        &#125; <span class="hljs-keyword">else</span> &#123;            dbCursor = MongoDBCommonUtil.getCollection(mongoDBCursor).find(query,customField.get());        &#125;        <span class="hljs-keyword">if</span> (cursorPreparer != <span class="hljs-keyword">null</span>) &#123;            dbCursor = cursorPreparer.prepare(dbCursor);        &#125;        <span class="hljs-keyword">return</span> dbCursor.toArray();    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * Count查询</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBCursor 查询实体</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 总数</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">count</span><span class="hljs-params">(MongoDBCursor mongoDBCursor)</span> </span>&#123;        DBObject dbObject = getMapped(mongoDBCursor.getFieldMap());        <span class="hljs-keyword">return</span> MongoDBCommonUtil.getCollection(mongoDBCursor).count(dbObject);     &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 把参数Map转换DBObject</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> map 查询条件</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> DBObject</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DBObject <span class="hljs-title">getMapped</span><span class="hljs-params">(Map&lt;String, Object&gt; map)</span> </span>&#123;        DBObject dbObject = <span class="hljs-keyword">new</span> BasicDBObject();        Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; iterable = map.entrySet().iterator();        <span class="hljs-keyword">while</span> (iterable.hasNext()) &#123;            Map.Entry&lt;String, Object&gt; entry = iterable.next();            Object value = entry.getValue();            String key = entry.getKey();            <span class="hljs-keyword">if</span> (key.startsWith(<span class="hljs-string">"$"</span>) &amp;&amp; value <span class="hljs-keyword">instanceof</span> Map) &#123;                BasicBSONList basicBSONList = <span class="hljs-keyword">new</span> BasicBSONList();                Map&lt;String, Object&gt; conditionsMap = ((Map) value);<span class="hljs-comment">//                Set&lt;String&gt; keys = conditionsMap.keySet();</span>                <span class="hljs-keyword">for</span> (String k : conditionsMap.keySet()) &#123;                    Object conditionsValue = conditionsMap.get(k);                    <span class="hljs-keyword">if</span> (conditionsValue <span class="hljs-keyword">instanceof</span> Collection) &#123;                        conditionsValue = convertArray(conditionsValue);                    &#125;                    DBObject dbObject2 = <span class="hljs-keyword">new</span> BasicDBObject(k, conditionsValue);                    basicBSONList.add(dbObject2);                &#125;                value = basicBSONList;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> Collection) &#123;                value = convertArray(value);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!key.startsWith(<span class="hljs-string">"$"</span>) &amp;&amp; value <span class="hljs-keyword">instanceof</span> Map) &#123;                value = getMapped(((Map) value));            &#125;            dbObject.put(key, value);        &#125;        <span class="hljs-keyword">return</span> dbObject;    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 转换成Object[]</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 待转换实体</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Object[]</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object[] convertArray(Object value) &#123;        Object[] values = ((Collection) value).toArray();        <span class="hljs-keyword">return</span> values;    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 添加操作</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBEntity 实体</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(MongoDBEntity mongoDBEntity)</span> </span>&#123;        DBObject dbObject = <span class="hljs-keyword">new</span> BasicDBObject(mongoDBEntity.getFieldMap());        MongoDBCommonUtil.getCollection(mongoDBEntity).insert(dbObject);    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 批量处理添加操作</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> list          批量字段数据</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBEntity 实体</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(MongoDBEntity mongoDBEntity, List&lt;Map&lt;String, Object&gt;&gt; list)</span> </span>&#123;        <span class="hljs-keyword">for</span> (Map&lt;String, Object&gt; map : list) &#123;            mongoDBEntity.setFieldMap(map);            add(mongoDBEntity);        &#125;    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 删除操作</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBEntity 实体</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(MongoDBEntity mongoDBEntity)</span> </span>&#123;        DBObject dbObject = <span class="hljs-keyword">new</span> BasicDBObject(mongoDBEntity.getFieldMap());        MongoDBCommonUtil.getCollection(mongoDBEntity).remove(dbObject);    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 删除操作,根据主键</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id            主键</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBEntity 实体</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(MongoDBEntity mongoDBEntity, String id)</span> </span>&#123;        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();        map.put(<span class="hljs-string">"_id"</span>, <span class="hljs-keyword">new</span> ObjectId(id));        mongoDBEntity.setFieldMap(map);        delete(mongoDBEntity);    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 删除全部</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBEntity 实体</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteAll</span><span class="hljs-params">(MongoDBEntity mongoDBEntity)</span> </span>&#123;        MongoDBCommonUtil.getCollection(mongoDBEntity).drop();    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 修改操作</span><span class="hljs-comment">     * 会用一个新文档替换现有文档,文档key结构会发生改变</span><span class="hljs-comment">     * 比如原文档&#123;"_id":"123","name":"zhangsan","age":12&#125;当根据_id修改age</span><span class="hljs-comment">     * value为&#123;"age":12&#125;新建的文档name值会没有,结构发生了改变</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBUpdate 更新实体</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(MongoDBUpdate mongoDBUpdate)</span> </span>&#123;        executeUpdate(mongoDBUpdate, <span class="hljs-keyword">new</span> UpdateCallback() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> DBObject <span class="hljs-title">doCallback</span><span class="hljs-params">(DBObject valueDBObject)</span> </span>&#123;                <span class="hljs-keyword">return</span> valueDBObject;            &#125;        &#125;);    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 修改操作,使用$set修改器</span><span class="hljs-comment">     * 用来指定一个键值,如果键不存在,则自动创建,会更新原来文档, 不会生成新的, 结构不会发生改变</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBUpdate 更新实体</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateSet</span><span class="hljs-params">(MongoDBUpdate mongoDBUpdate)</span> </span>&#123;        executeUpdate(mongoDBUpdate, <span class="hljs-keyword">new</span> UpdateCallback() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> DBObject <span class="hljs-title">doCallback</span><span class="hljs-params">(DBObject valueDBObject)</span> </span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BasicDBObject(<span class="hljs-string">"$set"</span>, valueDBObject);            &#125;        &#125;);    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 修改操作,使用$inc修改器</span><span class="hljs-comment">     * 修改器键的值必须为数字</span><span class="hljs-comment">     * 如果键存在增加或减少键的值, 如果不存在创建键</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBUpdate 更新实体</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateInc</span><span class="hljs-params">(MongoDBUpdate mongoDBUpdate)</span> </span>&#123;        executeUpdate(mongoDBUpdate, <span class="hljs-keyword">new</span> UpdateCallback() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> DBObject <span class="hljs-title">doCallback</span><span class="hljs-params">(DBObject valueDBObject)</span> </span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BasicDBObject(<span class="hljs-string">"$inc"</span>, valueDBObject);            &#125;        &#125;);    &#125;     <span class="hljs-comment">/**</span><span class="hljs-comment">     * 修改(私有方法)</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mongoDBUpdate  更新实体</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> updateCallback 更新回调</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">executeUpdate</span><span class="hljs-params">(MongoDBUpdate mongoDBUpdate, UpdateCallback updateCallback)</span> </span>&#123;        DBObject whereDBObject = <span class="hljs-keyword">new</span> BasicDBObject(mongoDBUpdate.getWhereMap());        DBObject valueDBObject = <span class="hljs-keyword">new</span> BasicDBObject(mongoDBUpdate.getValueMap());        valueDBObject = updateCallback.doCallback(valueDBObject);        MongoDBCommonUtil.getCollection(mongoDBUpdate).update(whereDBObject, valueDBObject);    &#125;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//获取操作DB</span>            DB db = MongoDBCommonUtil.getDB(<span class="hljs-string">"192.168.227.170"</span>, <span class="hljs-number">20011</span>,<span class="hljs-string">"lagd"</span>,<span class="hljs-string">"lagd_rw"</span>,<span class="hljs-string">"lagd_pwd"</span>);            MongoDBCursor mongoDBCursor = <span class="hljs-keyword">new</span> MongoDBCursor();            mongoDBCursor.setDb(db);     <span class="hljs-comment">//赋值DB</span>            mongoDBCursor.setCollectionName(<span class="hljs-string">"lagd_data_dictionary"</span>);   <span class="hljs-comment">//赋值集合名</span>            <span class="hljs-comment">//封装查询条件</span>            Map&lt;String, Object&gt; fieldMap = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();            fieldMap.put(<span class="hljs-string">"type"</span>,<span class="hljs-string">"dataSource"</span>);            mongoDBCursor.setFieldMap(fieldMap);            <span class="hljs-comment">//赋值skip</span>            mongoDBCursor.setSkip(<span class="hljs-number">1</span>);            <span class="hljs-comment">//赋值limit</span>            mongoDBCursor.setLimit(<span class="hljs-number">1</span>);            <span class="hljs-comment">//封装Sort</span>            Map&lt;String, Object&gt; sortMap = <span class="hljs-keyword">new</span> LinkedHashMap&lt;String, Object&gt;();            sortMap.put(<span class="hljs-string">"key"</span>,<span class="hljs-number">1</span>);            mongoDBCursor.setSort(sortMap);            <span class="hljs-comment">//自定义查询字段</span>            Map&lt;String, Object&gt; customFieldMap =  <span class="hljs-keyword">new</span> LinkedHashMap&lt;String, Object&gt;();            customFieldMap.put(<span class="hljs-string">"type"</span>,<span class="hljs-string">"1"</span>);            customFieldMap.put(<span class="hljs-string">"key"</span>,<span class="hljs-string">"1"</span>);            customFieldMap.put(<span class="hljs-string">"value"</span>,<span class="hljs-string">"1"</span>);            mongoDBCursor.setCustomFieldMap(customFieldMap);            <span class="hljs-comment">//查询</span>            List&lt;DBObject&gt; result = MongoDBUtil.find(mongoDBCursor);            <span class="hljs-keyword">for</span>(DBObject dbObject : result)&#123;                <span class="hljs-keyword">for</span>(String key : dbObject.keySet())&#123;                    System.out.println(<span class="hljs-string">"键："</span> + key + <span class="hljs-string">";  值："</span> + dbObject.get(key));                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>MongoDBCursorPreparer </p><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.mongodb.DBCursor; <span class="hljs-comment">/**</span><span class="hljs-comment"> * 查询转换接口定义</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: alex</span><span class="hljs-comment"> * <span class="hljs-doctag">@time</span>: 14-1-21 下午4:55</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span>: 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MongoDBCursorPreparer</span> </span>&#123;     <span class="hljs-function">DBCursor <span class="hljs-title">prepare</span><span class="hljs-params">(DBCursor cursor)</span></span>;&#125;</code></pre><p>UpdateCallback </p><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.mongodb.DBObject; <span class="hljs-comment">/**</span><span class="hljs-comment"> * MongoDB更新操作接口定义</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: alex</span><span class="hljs-comment"> * <span class="hljs-doctag">@time</span>: 14-1-21 下午5:25</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span>: 1.0</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UpdateCallback</span> </span>&#123;     <span class="hljs-function">DBObject <span class="hljs-title">doCallback</span><span class="hljs-params">(DBObject valueDBObject)</span></span>;&#125;</code></pre><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>MongoDB</category>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS7搭建ngrok服务器</title>
    <link href="/2019/06/10/CentOS7%E6%90%AD%E5%BB%BAngrok%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2019/06/10/CentOS7%E6%90%AD%E5%BB%BAngrok%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>ngrok是一个反向代理，它能够让你本地的web服务或tcp服务通过公共的端口和外部建立一个安全的通道， 使得外网可以访问本地的计算机服务。也就是说，我们提供的服务（比如web站点）无需搭建在外部服务器， 只要通过ngrok把站点映射出去，别人即可直接访问到我们的服务。</p><p>有做过微信公众号开发的人，对它应该不陌生。因为用户跟微信公众号产生的交互行为，微信会把用户的相关信息推送到我们自己的服务器， 如果服务在本地，那微信当然无法推送给我们，这使得开发功能的时候调试相当麻烦。我们可以使用ngrok把本地站点映射出去，解决这个问题。</p><p>另外如果我们想把本地开发时候的系统临时给外网用户看，无需部署到服务器上面去就可以，非常方便。</p><p>ngrok是开源的，官网地址：<a href="https://github.com/inconshreveable/ngrok" target="_blank" rel="noopener">https://github.com/inconshreveable/ngrok</a></p><p>下面，我们开始搭建ngrok服务。操作系统为CentOS 7.2</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>搭建ngrok服务需要有一个外网服务器及一个域名解析到外网服务器上，我已经有了一个<code>xncoding.com</code>域名，并且拥有一台腾讯云主机。</p><p>在腾讯云主机的域名解析处，配置2个A记录，比如我新建2个<code>ngrok.xncoding.com</code> 和 <code>*.ngrok.xncoding.com</code> 解析到vps服务器上。</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymn9j8enj30tq0de0tm.jpg" srcset="/img/loading.gif" alt="img"></p><h2 id="搭建ngrok服务"><a href="#搭建ngrok服务" class="headerlink" title="搭建ngrok服务"></a>搭建ngrok服务</h2><h3 id="安装go语言环境"><a href="#安装go语言环境" class="headerlink" title="安装go语言环境"></a>安装go语言环境</h3><p>ngrok是基于go语言开发的，所以需要先安装go语言开发环境，CentOS可以使用yum安装：</p><pre><code class="hljs bash">yum install golang</code></pre><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>默认的git版本太低了，需要升级到git2.5，具体步骤如下：</p><pre><code class="hljs bash">sudo yum remove gitsudo yum install epel-releasesudo yum install https://centos7.iuscommunity.org/ius-release.rpmsudo yum install git2u</code></pre><p><code>git --version</code>，返回 <code>git version 2.5.0</code>，安装成功。</p><h3 id="下载ngrok源码"><a href="#下载ngrok源码" class="headerlink" title="下载ngrok源码"></a>下载ngrok源码</h3><p>新建一个目录，并clone一份源码：</p><pre><code class="hljs bash">mkdir ~/go/src/github.com/inconshreveable<span class="hljs-built_in">cd</span> ~/go/src/github.com/inconshreveablegit <span class="hljs-built_in">clone</span> https://github.com/inconshreveable/ngrok.git<span class="hljs-built_in">export</span> GOPATH=~/go/src/github.com/inconshreveable/ngrok</code></pre><h3 id="生成自签名证书"><a href="#生成自签名证书" class="headerlink" title="生成自签名证书"></a>生成自签名证书</h3><p>使用ngrok.com官方服务时，我们使用的是官方的SSL证书。自己建立ngrok服务，需要我们生成自己的证书，并提供携带该证书的ngrok客户端。</p><p>证书生成过程需要有自己的一个基础域名，比如我的就是<code>ngrok.xncoding.com</code>。</p><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> ngrok$ openssl genrsa -out rootCA.key 2048$ openssl req -x509 -new -nodes -key rootCA.key -subj <span class="hljs-string">"/CN=ngrok.xncoding.com"</span> -days 5000 -out rootCA.pem$ openssl genrsa -out device.key 2048$ openssl req -new -key device.key -subj <span class="hljs-string">"/CN=ngrok.xncoding.com"</span> -out device.csr$ openssl x509 -req -<span class="hljs-keyword">in</span> device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000</code></pre><p>执行完成以上命令后，在ngrok目录下，会新生成6个文件：</p><pre><code class="hljs bash">-rw-r--r-- 1 root root   1001 Dec 29 11:53 device.crt-rw-r--r-- 1 root root    903 Dec 29 11:44 device.csr-rw-r--r-- 1 root root   1675 Dec 29 11:44 device.key-rw-r--r-- 1 root root   1679 Dec 29 11:44 rootCA.key-rw-r--r-- 1 root root   1119 Dec 29 11:44 rootCA.pem-rw-r--r-- 1 root root     17 Dec 29 11:53 rootCA.srl</code></pre><p>我们在编译可执行文件之前，需要把生成的证书分别替换到 <code>assets/client/tls</code>和<code>assets/server/tls</code>中， 这两个目录分别存放着ngrok和ngrokd的默认证书。</p><pre><code class="hljs bash">$ cp rootCA.pem assets/client/tls/ngrokroot.crt$ cp device.crt assets/server/tls/snakeoil.crt$ cp device.key assets/server/tls/snakeoil.key</code></pre><h3 id="使用lets-encrypt免费证书"><a href="#使用lets-encrypt免费证书" class="headerlink" title="使用lets encrypt免费证书"></a>使用lets encrypt免费证书</h3><p>如果想让浏览器不弹出提示，最好不要使用自签名证书，现在lets encrypt推出泛域名证书了，所以可以先申请个免费域名证书。</p><p>客户端用证书 ：</p><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ngrokcp /etc/letsencrypt/live/xncoding.com/chain.pem assets/client/tls/ngrokroot.crt</code></pre><p>服务器端用证书：</p><pre><code class="hljs bash">cp /etc/letsencrypt/live/xncoding.com/cert.pem assets/server/tls/snakeoil.crtcp /etc/letsencrypt/live/xncoding.com/privkey.pem assets/server/tls/snakeoil.key</code></pre><h3 id="编译ngrokd和ngrok"><a href="#编译ngrokd和ngrok" class="headerlink" title="编译ngrokd和ngrok"></a>编译ngrokd和ngrok</h3><p>首先需要知道，ngrokd 为服务端的执行文件，ngrok为客户端的执行文件。</p><p>接下来我们来编译ngrokd，在ngrok目录下，执行如下命令：</p><pre><code class="hljs bash">$ make release-server</code></pre><p>编译过程需要等待一会，因为需要通过git安装相关依赖包。如果提示没有权限，使用 sudo 命令来安装。</p><p>由于客户端的平台版本较多，我们需要交叉编译来选择生成的平台。 以windows、arm、linux版本编译，如下：</p><pre><code class="hljs bash">$ GOOS=linux GOARCH=amd64 make release-client$ GOOS=windows GOARCH=amd64 make release-client$ GOOS=linux GOARCH=arm make release-client</code></pre><p>不同平台使用不同的 GOOS 和 GOARCH，GOOS为go编译出来的操作系统 (windows,linux,darwin)，GOARCH, 对应的构架 (386,amd64,arm)</p><p>通过上面的步骤，将生成所有客户端文件，客户端文件放在对于的文件夹中，如windows 64位的为：windows_amd64，linux客户端在bin目录下的ngrok文件。</p><p>完成之后，把相应的客户端文件使用SFTP或其他方式分发到客户端电脑上面，比如我用的windows电脑，就把<code>windows_amd64/ngrok.exe</code>文件复制过去。</p><h3 id="启动ngrokd服务器"><a href="#启动ngrokd服务器" class="headerlink" title="启动ngrokd服务器"></a>启动ngrokd服务器</h3><p>请将 bin/ngrokd 放入PATH环境变量中，启动命令：</p><pre><code class="hljs bash">nohup ngrokd -domain=ngrok.xncoding.com -httpAddr=:5442 -httpsAddr=:5443 -tunnelAddr=<span class="hljs-string">":4443"</span> &amp;</code></pre><p><code>-domain</code>为你的服务域名，<code>-httpAddr</code>为http服务端口地址，访问形式为<code>xxx.ngrok.xncoding.com:5442</code>，也可设置为80默认端口，<code>-httpsAddr</code>为https服务，同上。</p><p>ngrokd还会开一个端口用来跟客户端通讯（可通过<code>-tunnelAddr=&quot;:xxx&quot;</code> 指定），如果你配置了 iptables 规则，需要放行这个通讯端口(4443)上的 TCP 协议。</p><pre><code class="hljs bash">firewall-cmd --zone=public --add-port=4443/tcp --permanentfirewall-cmd --reload</code></pre><h3 id="Nginx配置80端口转发"><a href="#Nginx配置80端口转发" class="headerlink" title="Nginx配置80端口转发"></a>Nginx配置80端口转发</h3><p>我们在微信开发时候不允许使用端口访问，那么最好使用nginx反向代理转发，首先申请一个<code>demo.ngrok.xncoding.com</code>的免费证书，然后修改nginx配置如下：</p><pre><code class="hljs bash">server &#123;    listen       80;    server_name  demo.ngrok.xncoding.com;    <span class="hljs-built_in">return</span>       301 https://demo.ngrok.xncoding.com<span class="hljs-variable">$request_uri</span>;&#125;server &#123;    listen       443 ssl http2;    server_name  demo.ngrok.xncoding.com;    charset utf-8;    ssl_certificate /etc/letsencrypt/live/demo.ngrok.xncoding.com/fullchain.pem;    ssl_certificate_key /etc/letsencrypt/live/demo.ngrok.xncoding.com/privkey.pem;    ssl_trusted_certificate /etc/letsencrypt/live/demo.ngrok.xncoding.com/chain.pem;    access_log /var/<span class="hljs-built_in">log</span>/nginx/ngrok.log main;    error_log /var/<span class="hljs-built_in">log</span>/nginx/ngrok_error.log error;    location / &#123;        proxy_pass http://127.0.0.1:5442;        proxy_redirect off;        proxy_set_header Host       <span class="hljs-variable">$http_host</span>:5442;        proxy_set_header X-Real-IP  <span class="hljs-variable">$remote_addr</span>;        proxy_set_header X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;    &#125;&#125;</code></pre><p>但是！这里就有一个很烦躁的地方了，ngrokd 里面有一层自己的 Host 处理，于是 <code>proxy_set_header Host</code> 必须带上 ngrokd 所监听的端口， 否则就算请求被转发到对应端口上， ngrokd 也不会正确的处理。</p><h3 id="启用客户端"><a href="#启用客户端" class="headerlink" title="启用客户端"></a>启用客户端</h3><p>在刚刚复制过来的ngrok.exe客户端文件夹中，新建一个客户端配置<code>ngrok.cfg</code>：</p><pre><code class="hljs bash">server_addr: <span class="hljs-string">"ngrok.xncoding.com:4443"</span>trust_host_root_certs: <span class="hljs-literal">false</span></code></pre><p>本地启动一个SpringBoot的WEB工程，端口8092，然后通过下面命令启动客户端：</p><pre><code class="hljs bash">ngrok.exe -subdomain demo -config=ngrok.cfg -<span class="hljs-built_in">log</span>=log.txt 8092</code></pre><p>看到下面的画面说明连接成功了：</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymnc8ceij30lb06oglu.jpg" srcset="/img/loading.gif" alt="img"></p><p>访问页面，浏览器中输入：<code>https://demo.ngrok.xncoding.com</code>，成功访问本地SpringBoot站点内容。</p><p>浏览器输入：<code>127.0.0.1:4040</code> 查看页面请求情况：</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymndmltvj30q10fu0uv.jpg" srcset="/img/loading.gif" alt="img"></p><h2 id="烦恼的事情"><a href="#烦恼的事情" class="headerlink" title="烦恼的事情"></a>烦恼的事情</h2><p>带上端口号又会导致了另一个操蛋的问题：你请求的时候是<code>demo.ngrok.xncoding.com</code>， 你在 web 应用中获取到的 Host 是 <code>demo.ngrok.xncoding.com:5442</code>， 如果你的程序里面有基于 Request Host 的重定向，就会被重定向到 <code>demo.ngrok.xncoding.com:5442</code> 下面去。</p><p>要完美的解决这个端口的问题，就需要让 ngrokd 直接监听 80 端口，或者使用Docker容器的端口映射来解决。</p><h2 id="使用Docker"><a href="#使用Docker" class="headerlink" title="使用Docker"></a>使用Docker</h2><p>上面我讲到自己手动搭建的时候出现的端口问题，没办法解决。 一般80端口早就被占用了，不可能就给你ngrok使用，最完美的方式是使用Docker + Nginx的方式。</p><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p>参考我的这篇<a href="https://www.xncoding.com/2017/04/01/docker/docker01.html" target="_blank" rel="noopener">Docker入门</a>来安装docker。</p><h3 id="构建镜象"><a href="#构建镜象" class="headerlink" title="构建镜象"></a>构建镜象</h3><p>这里使用的是<a href="https://github.com/hteen/docker-ngrok" target="_blank" rel="noopener">hteen/docker-ngrok</a></p><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/hteen/docker-ngrok.git<span class="hljs-built_in">cd</span> docker-ngrokdocker build -t hteen/ngrok .</code></pre><p>这里需要等待一段时间下载</p><h3 id="Docker容器的https"><a href="#Docker容器的https" class="headerlink" title="Docker容器的https"></a>Docker容器的https</h3><p>关于 https 的支持</p><p>由于 ngrok 工作是通过分配 subdomain 的方式，所以我们实际使用到的域名都是 <code>ngrok.xncoding.com</code>的子域名， 如 <code>demo.ngrok.xncoding.com</code> 如果要对这个子域名启用 https 服务，那么至少需要三点支持：</p><ol><li>ngrok 支持 https， 这个默认就是开启的</li><li><code>demo.ngrok.xncoding.com</code> 也需要有证书或包含在一个泛域名证书中</li><li>浏览器（或其他终端）信任 <code>demo.ngrok.xncoding.com</code> 的根证书</li></ol><p>好消息是现在lets encrypt支持通配符域名了，所以很简单，具体怎么申请，请参考我博客中的nginx相关文章。</p><p>这里请先申请<code>ngrok.xncoding.com</code>的通配符证书。</p><p>申请好之后，增加配置<code>/etc/nginx/conf.d/ngrok.conf</code> 添加反向代理配置：</p><pre><code class="hljs bash">map <span class="hljs-variable">$scheme</span> <span class="hljs-variable">$proxy_port</span> &#123;    <span class="hljs-string">"http"</span>  <span class="hljs-string">"5442"</span>;    <span class="hljs-string">"https"</span> <span class="hljs-string">"5443"</span>;    default <span class="hljs-string">"5442"</span>;&#125;server &#123;    listen      80;    listen      443;    server_name ngrok.xncoding.com *.ngrok.xncoding.com;    location / &#123;        proxy_pass  <span class="hljs-variable">$scheme</span>://127.0.0.1:<span class="hljs-variable">$proxy_port</span>;    &#125;    ssl on;    ssl_certificate /etc/letsencrypt/live/ngrok.xncoding.com/fullchain.pem;    ssl_certificate_key /etc/letsencrypt/live/ngrok.xncoding.com/privkey.pem;    proxy_set_header    X-Real-IP <span class="hljs-variable">$remote_addr</span>;    proxy_set_header    Host <span class="hljs-variable">$http_host</span>;    proxy_set_header    X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;    access_log off;    log_not_found off;&#125;</code></pre><h3 id="运行镜象"><a href="#运行镜象" class="headerlink" title="运行镜象"></a>运行镜象</h3><p>上一步已经申请<code>ngrok.xncoding.com</code>这个域名的通配符lets encrypt证书，然后修改脚本<code>server.sh</code></p><pre><code class="hljs bash">-tlsKey=/etc/letsencrypt/live/ngrok.xncoding.com/privkey.pem -tlsCrt=/etc/letsencrypt/live/ngrok.xncoding.com/fullchain.pem</code></pre><p>也就是将之前的证书变量改成你实际的证书路径即可。</p><p>然后运行：</p><pre><code class="hljs bash">docker run -idt --name ngrok-server \-p 5442:80 -p 5443:443 -p 4443:4443 \-v /data/ngrok:/myfiles \-e DOMAIN=<span class="hljs-string">'ngrok.xncoding.com'</span> -e HTTP_ADDR=<span class="hljs-string">':80'</span> -e HTTPS_ADDR=<span class="hljs-string">':443'</span> hteen/ngrok /bin/sh /server.sh</code></pre><p>如果在腾讯云主机上面，还需要本级防火墙放行4443端口，以及在腾讯云安全组中也要放开4443端口。</p><pre><code class="hljs bash"><span class="hljs-comment"># 1.查看已开放的端口(默认不开放任何端口)</span>firewall-cmd --list-ports<span class="hljs-comment"># 2.开启4443端口</span>firewall-cmd --zone=public --add-port=4443/tcp --permanent<span class="hljs-comment"># 3.重启防火墙</span>systemctl restart firewalld</code></pre><p>这里会把主机的5442端口映射到Docker容器中的80端口，讲5443端口映射到443端口，同时将本机的/data/ngrok文件夹映射到docker容器的/myfiles目录。</p><p>运行后，会要等一段时间，因为要编译客户端。一直等到/data/ngrok/目录里面有/bin目录就OK了。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>因为ngrok有心跳机制，每次心跳均会产生日志，所以以docker方式运行，会产生很多日志。实测试中，大概每个星期会产生100M的日志文件。</p><p>查年docker日志文件位置<code>sudo docker inspect &lt;id&gt; | grep LogPath</code></p><p>查看大小<code>sudo ls -lh /var/lib/docker/containers/&lt;id&gt;/&lt;id&gt;-json.log</code></p><h3 id="运行客户端"><a href="#运行客户端" class="headerlink" title="运行客户端"></a>运行客户端</h3><p>在<code>/data/ngrok/bin/</code>目录下会生成客户端程序，每个平台的版本都有。以windows64位来说， 在windows_amd64目录下，拷贝到自己的windows电脑上。</p><p>新建配置文件ngrok.cfg，跟ngrok.exe同级目录，里面的内容跟之前讲的一样：</p><pre><code class="hljs bash">server_addr: <span class="hljs-string">"ngrok.xncoding.com:4443"</span>trust_host_root_certs: <span class="hljs-literal">false</span></code></pre><p>然后打开windows的命令行，cd到<code>ngrok.exe</code>所在的目录中，到这个运行：</p><pre><code class="hljs bash">ngrok -config=ngrok.cfg -subdomain=demo -<span class="hljs-built_in">log</span>=log.txt 8092</code></pre><p>或者为了方便，在<code>ngrok.exe</code>所在的目录中新建一个<code>run.bat</code>文件，内容如下：</p><pre><code class="hljs plain">@echo offngrok.exe -config&#x3D;ngrok.cfg -subdomain&#x3D;demo -log&#x3D;log.txt 8092</code></pre><p>上面的subdomain是你想去访问域名前缀，后面的端口是你本机应用启动端口。</p><p>看到下面的结果表示成功了：</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymngjdqwj30ke0cbdgh.jpg" srcset="/img/loading.gif" alt="img"></p><p>然后再打开<code>http://demo.ngrok.xncoding.com</code>看看，发现不会像之前那样出现端口了。</p><h2 id="国内免费的ngrok"><a href="#国内免费的ngrok" class="headerlink" title="国内免费的ngrok"></a>国内免费的ngrok</h2><p>如果你自己没VPS，或者你机子上面80端口已经被nginx占用不想搞了，就直接使用免费的ngrok吧， 我推荐你使用<a href="https://www.ngrok.cc/" target="_blank" rel="noopener">https://www.ngrok.cc/</a>。</p><p>比如我自己弄了个<code>yidao620.free.ngrok.cc</code>，启动本地客户端后，映射到本地的8092端口了，也还不错。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://morongs.github.io/2016/12/28/dajian-ngrok/" target="_blank" rel="noopener">从零教你搭建ngrok服务器</a></li><li><a href="https://www.jianshu.com/p/4b03fb532145" target="_blank" rel="noopener">ngrok使用自己的证书通过https访问</a></li><li><a href="https://yii.im/posts/pretty-self-hosted-ngrokd/" target="_blank" rel="noopener">搭建并配置优雅的 ngrok 服务实现内网穿透</a></li><li><a href="https://blog.fengcl.com/2017/05/24/how-to-use-docker-build-ngrok-to-network-penetrate/" target="_blank" rel="noopener">使用Docker搭建Ngrok服务器实现内网穿透</a></li><li><a href="https://fengqi.me/unix/409.html" target="_blank" rel="noopener">搭建自己的Ngrok服务器, 并与Nginx并存</a></li></ul><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>CentOS</category>
      
      <category>Linux</category>
      
      <category>Ngrok</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CentOS</tag>
      
      <tag>Linux</tag>
      
      <tag>Ngrok</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建线程池的两种办法</title>
    <link href="/2019/06/10/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%8A%9E%E6%B3%95/"/>
    <url>/2019/06/10/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>线程池，其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，</p><p>无需反复创建线程而消耗过多资源。</p><p>我们详细的解释一下为什么要使用线程池？</p><p>在java中，如果每个请求到达就创建一个新线程，开销是相当大的。在实际使用中，创建和销毁线程花费的时间和消耗的系统资源都相当大，</p><p>甚至可能要比在处理实际的用户请求的时间和资源要多的多。除了创建和销毁线程的开销之外，活动的线程也需要消耗系统资源。</p><p>如果在一个jvm里创建太多的线程，可能会使系统由于过度消耗内存或“切换过度”而导致系统资源不足。为了防止资源不足，</p><p>需要采取一些办法来限制任何给定时刻处理的请求数目，尽可能减少创建和销毁线程的次数，特别是一些资源耗费比较大的线程的创建和销毁，</p><p>尽量利用已有对象来进行服务。</p><p>线程池主要用来解决线程生命周期开销问题和资源不足问题。通过对多个任务重复使用线程，线程创建的开销就被分摊到了多个任务上了，</p><p>而且由于在请求到达时线程已经存在，所以消除了线程创建所带来的延迟。这样，就可以立即为请求服务，使用应用程序响应更快。另外，</p><p>通过适当的调整线程中的线程数目可以防止出现资源不足的情况。</p><a id="more"></a><h6 id="使用线程池方式–Runnable接口"><a href="#使用线程池方式–Runnable接口" class="headerlink" title="使用线程池方式–Runnable接口"></a><strong>使用线程池方式–Runnable接口</strong></h6><blockquote><p>通常，线程池都是通过线程池工厂创建，再调用线程池中的方法获取线程，再通过线程去执行任务方法。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPoolDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//创建线程池对象</span>        ExecutorService service = Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<span class="hljs-comment">//包含2个线程对象</span>        <span class="hljs-comment">//创建Runnable实例对象</span>        MyRunnable r = <span class="hljs-keyword">new</span> MyRunnable();        <span class="hljs-comment">//自己创建线程对象的方式</span>        <span class="hljs-comment">//Thread t = new Thread(r);</span>        <span class="hljs-comment">//t.start(); ---&gt; 调用MyRunnable中的run()</span>        <span class="hljs-comment">//从线程池中获取线程对象,然后调用MyRunnable中的run()</span>        service.submit(r);        <span class="hljs-comment">//再获取个线程对象，调用MyRunnable中的run()</span>        service.submit(r);        service.submit(r);        service.submit(r);        <span class="hljs-comment">//注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。将使用完的线程又归还到了线程池中</span>        <span class="hljs-comment">//关闭线程池</span>        service.shutdown();    &#125;&#125;</code></pre><p>Runnable接口实现类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"我要一个教练"</span>);        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">2000</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(<span class="hljs-string">"教练来了： "</span> + Thread.currentThread().getName());        System.out.println(<span class="hljs-string">"教我游泳,教完后，教练回到了游泳池"</span>);    &#125;&#125;</code></pre><h6 id="使用线程池方式—Callable接口"><a href="#使用线程池方式—Callable接口" class="headerlink" title="使用线程池方式—Callable接口"></a><strong>使用线程池方式—Callable接口</strong></h6><blockquote><p>与Runnable接口功能相似，用来指定线程的任务。其中的call()方法，用来返回线程任务执行完毕后的结果，call方法可抛出异常。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<span class="hljs-keyword">import</span> java.util.concurrent.Executors;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPoolDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//创建线程池对象</span>        ExecutorService service = Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<span class="hljs-comment">//包含2个线程对象</span>        <span class="hljs-comment">//创建Callable对象</span>        MyCallable c = <span class="hljs-keyword">new</span> MyCallable();        <span class="hljs-comment">//从线程池中获取线程对象,然后调用MyRunnable中的run()</span>        service.submit(c);        <span class="hljs-comment">//再获取个教练</span>        service.submit(c);        service.submit(c);        <span class="hljs-comment">//注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。将使用完的线程又归还到了线程池中</span>        <span class="hljs-comment">//关闭线程池</span>        <span class="hljs-comment">//service.shutdown();</span>    &#125;&#125;</code></pre><p>Callable接口实现类,call方法可抛出异常、返回线程任务执行完毕后的结果</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">"我要一个教练:call"</span>);        Thread.sleep(<span class="hljs-number">2000</span>);        System.out.println(<span class="hljs-string">"教练来了： "</span> + Thread.currentThread().getName());        System.out.println(<span class="hljs-string">"教我游泳,教完后,教练回到了游泳池"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>线程</category>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现多线程的两种方式</title>
    <link href="/2019/06/10/%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/2019/06/10/%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>Thread类：</p><p>Thread是程序中的执行线程。java虚拟机允许应用程序并发地的运行多个执行线程。</p><h5 id="1-进程与线程的关系"><a href="#1-进程与线程的关系" class="headerlink" title="1.进程与线程的关系"></a><strong>1.进程与线程的关系</strong></h5><p>进程：进程指正在运行的程序。确切的来说，当一个程序进入内存运行，即变成一个进程，进程是处于运行过程中的程序，并且具有一定独立功能。</p><p>线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，</p><p>　　　这个应用程序也可以称之为多线程程序。</p><p>简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程。</p><p>​    <a id="more"></a></p><h5 id="2-多线程两种实现方式"><a href="#2-多线程两种实现方式" class="headerlink" title="2.多线程两种实现方式"></a><strong>2.多线程两种实现方式</strong></h5><p>创建线程有两种方法</p><pre><code>一种方法是将类声明为 Thread 的子类。该子类应重写 Thread 类的 run 方法。创建对象，开启线程。</code></pre><p> run方法相当于其他线程的main方法。</p><pre><code>另一种方法是声明一个实现 Runnable 接口的类。该类然后实现 run 方法。</code></pre><p> 然后创建Runnable的子类对象，传入到某个线程的构造方法中，开启线程。</p><h6 id="2-1-创建线程方式一继承Thread类"><a href="#2-1-创建线程方式一继承Thread类" class="headerlink" title="2.1.创建线程方式一继承Thread类"></a><strong>2.1.创建线程方式一继承Thread类</strong></h6><p>创建线程的步骤：</p><p>1 定义一个类继承Thread。</p><p>2 重写run方法。</p><p>3 创建子类对象，就是创建线程对象。</p><p>4 调用start方法，开启线程并让线程执行，同时还会告诉jvm去调用run方法。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//创建自定义线程对象</span>        MyThread mt = <span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">"新的线程！"</span>);        <span class="hljs-comment">//开启新线程</span>        mt.start();        <span class="hljs-comment">//在主方法中执行for循环</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            System.out.println(<span class="hljs-string">"for==main线程！"</span> + i);        &#125;    &#125;&#125;</code></pre><p>自定义线程类</p><h6 id=""><a href="#" class="headerlink" title=""></a></h6><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    <span class="hljs-comment">//定义指定线程名称的构造方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-comment">//调用父类的String参数的构造方法，指定线程的名称</span>        <span class="hljs-keyword">super</span>(name);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 重写run方法，完成该线程执行的逻辑</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            System.out.println(getName() + <span class="hljs-string">"：正在执行！"</span> + i);        &#125;    &#125;&#125;</code></pre><h6 id="2-2-创建线程方式—实现Runnable接口"><a href="#2-2-创建线程方式—实现Runnable接口" class="headerlink" title="2.2.创建线程方式—实现Runnable接口"></a><strong>2.2.创建线程方式—实现Runnable接口</strong></h6><p>创建线程的另一种方法是声明实现 Runnable 接口的类。</p><p>该类然后实现 run 方法。然后创建Runnable的子类对象，传入到某个线程的构造方法中，开启线程。</p><p>1、定义类实现Runnable接口。</p><p>2、覆盖接口中的run方法。。</p><p>3、创建Thread类的对象</p><p>4、将Runnable接口的子类对象作为参数传递给Thread类的构造函数。</p><p>5、调用Thread类的start方法开启线程。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//创建线程执行目标类对象</span>        Runnable runn = <span class="hljs-keyword">new</span> MyRunnable();        <span class="hljs-comment">//将Runnable接口的子类对象作为参数传递给Thread类的构造函数</span>        Thread thread = <span class="hljs-keyword">new</span> Thread(runn);        Thread thread2 = <span class="hljs-keyword">new</span> Thread(runn);        <span class="hljs-comment">//开启线程</span>        thread.start();        thread2.start();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            System.out.println(<span class="hljs-string">"main线程：正在执行！"</span> + i);        &#125;    &#125;&#125;</code></pre><p>自定义线程执行任务类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-comment">//定义线程要执行的run方法逻辑</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            System.out.println(<span class="hljs-string">"我的线程：正在执行！"</span> + i);        &#125;    &#125;&#125;</code></pre><h5 id="3-多线程两种实现方式的区别"><a href="#3-多线程两种实现方式的区别" class="headerlink" title="3.多线程两种实现方式的区别"></a><strong>3.多线程两种实现方式的区别</strong></h5><p>第二种方式实现Runnable接口避免了单继承的局限性，所以较为常用。实现Runnable接口的方式，更加的符合面向对象，线程分为两部分，</p><p>一部分线程对象，一部分线程任务。继承Thread类，线程对象和线程任务耦合在一起。一旦创建Thread类的子类对象，既是线程对象，</p><p>有又有线程任务。实现runnable接口，将线程任务单独分离出来封装成对象，类型就是Runnable接口类型。Runnable接口对线程对象和线程任务进行解耦。</p><h5 id="4-线程的匿名内部类使用"><a href="#4-线程的匿名内部类使用" class="headerlink" title="4. 线程的匿名内部类使用"></a><strong>4. 线程的匿名内部类使用</strong></h5><p>方式1：创建线程对象时，直接重写Thread类中的run方法</p><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread() &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">40</span>; x++) &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"...X...."</span> + x);        &#125;    &#125;&#125;.start();</code></pre><p>方式2：使用匿名内部类的方式实现Runnable接口，重新Runnable接口中的run方法</p><pre><code class="hljs java">Runnable r = <span class="hljs-keyword">new</span> Runnable() &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">40</span>; x++) &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"...Y...."</span> + x);        &#125;    &#125;&#125;;<span class="hljs-keyword">new</span> Thread(r).start();</code></pre>]]></content>
    
    
    <categories>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mac资源共享</title>
    <link href="/2019/06/10/mac%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/"/>
    <url>/2019/06/10/mac%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h4 id="PDFelement-Pro-For-Mac强大的PDF编辑工具V6-8-0"><a href="#PDFelement-Pro-For-Mac强大的PDF编辑工具V6-8-0" class="headerlink" title="PDFelement Pro For Mac强大的PDF编辑工具V6.8.0"></a>PDFelement Pro For Mac强大的PDF编辑工具V6.8.0</h4><p>软件介绍：</p><p>Wondershare PDFelement Pro（PDFelement 6 Pro ）是一款安全强大，简单好用的PDF解决方案。拥有您使用PDF所需的一切。</p><p>功能介绍：</p><p>特性：</p><p>PDF编辑器</p><p>编辑，删除，剪切，复制，粘贴和插入PDF文本和图像。</p><p>改变字体属性（类型，大小和风格，对齐）。</p><p>插入，更新或删除自定义水印和背景。</p><p>使用高级格式应用贝茨编号。 （独家！）</p><p>插入，更新或删除页眉和页脚（包括页码和日期）。</p><p>插入和编辑超链接。</p><p>标记和注释PDF</p><a id="more"></a><p>添加评论，粘滞便笺，文本框，文本呼出，邮票，添加/编辑链接，徒手画。</p><p>突出显示，强调或突破上下文。</p><p>创建和管理预建和自定义邮票库。</p><p>创建和编辑表单</p><p>填写PDF表格。</p><p>自动表单字段识别自动创建表单。</p><p>从交互式字段对象（如按钮，复选框，单选按钮，列表框和下拉列表）中创建可填写的PDF表单。</p><p>访问预先构建，可自定义的可填写表单的集合。</p><p>支持在PDF上创建，编辑和添加数字签名。</p><p>数据提取（独家！）</p><p>从数字和扫描的PDF表格中自动提取数据。</p><p>从数字和扫描的PDF格式的批量数据提取到CSV电子表格。</p><p>标记并提取扫描PDF的选定表单域中的数据。</p><p>从PDF格式导出或导入表单数据。</p><p>OCR（独家！）</p><p>OCR（光学字符识别）使您能够编辑和转换扫描的PDF文件或图片中的字符。</p><p>OCR有助于从扫描的PDF表单或发票中提取数据。</p><p>PDF / A（独家！）</p><p>支持PDF / A作为一个可用的输出格式与ISO标准长期归档。</p><p>PDF转换器</p><p>除标准版支持的Word，Excel，PPT和Image等普通输出格式外，Pro版本还支持将PDF文件转换为EPUB，HTML，Text，RTF等格式。</p><p>使用OCR技术将扫描的PDF转换为可编辑和可搜索的文档。</p><p>转换后保留文本，图像，图形，字体和嵌入式元素的原始布局。</p><p>页面管理</p><p>管理文档中的页面（重新组织，插入，提取，裁剪，旋转和删除页面）。</p><p>创建和组合PDF</p><p>支持输入格式：pdf / html / webarchive / rtf / txt / jpeg / jpg / png / bmp / gif。</p><p>将不同的格式文件组合成一个新的PDF。</p><p>由PDFelement创建的文件是100％兼容和Adobe Reader和其他PDF阅读器访问。</p><p>安全并共享PDF</p><p>设置密码以防止未经授权的用户打开PDF。</p><p>应用权限。通过为文档设置权限，限制用户访问PDF打印，复制，编辑和提取。</p><p>编辑PDF中的敏感文本和图像。 （独家！）</p><p>发送PDF格式的电子邮件附件。</p><p>支持直接打印和电子邮件编辑的PDF。</p><p>将您的PDF文件保存到流行的云存储服务（Google Drive，Dropbox和Evernote）。</p><p>软件兼容性：</p><p>OS X 10.12或更高版本</p><p>软件语言：</p><p>多国语言（Chinese/English）</p><p>链接: <a href="https://pan.baidu.com/s/1l8L-qN7rewdeCuWt1dSlcw" target="_blank" rel="noopener">https://pan.baidu.com/s/1l8L-qN7rewdeCuWt1dSlcw</a> 提取码: dfn2 </p><h4 id="RazorSQL-For-Mac支持多种数据库的数据库管理工具-V8-3-4"><a href="#RazorSQL-For-Mac支持多种数据库的数据库管理工具-V8-3-4" class="headerlink" title="RazorSQL For Mac支持多种数据库的数据库管理工具 V8.3.4"></a>RazorSQL For Mac支持多种数据库的数据库管理工具 V8.3.4</h4><p>软件介绍：</p><p>RazorSQL 是一款优秀的数据库管理客户端，具有数据库连接、SQL编辑和查询、数据库管理、导入/导出数据等等功能。</p><p>功能介绍：</p><p>RazorSQL 是一款优秀的数据库管理客户端，具有数据库连接、SQL编辑和查询、数据库管理、导入/导出数据等等功能。</p><p>支持主流的30多种数据库，如：Cassandra、Oracle、SQLite、MS SQL Server、MySQL、MongoDB等。</p><p>软件兼容性：</p><p>OS X 10.12或更高版本</p><p>软件语言：</p><p>英文语言（English）</p><p>链接: <a href="https://pan.baidu.com/s/1_80dXs_NW0ZAp3_umhXQiw" target="_blank" rel="noopener">https://pan.baidu.com/s/1_80dXs_NW0ZAp3_umhXQiw</a> 提取码: vn9k </p><h4 id="Microsoft-Office-For-Mac办公软件-V2019-16-25-19051201"><a href="#Microsoft-Office-For-Mac办公软件-V2019-16-25-19051201" class="headerlink" title="Microsoft Office For Mac办公软件 V2019 16.25.19051201"></a>Microsoft Office For Mac办公软件 V2019 16.25.19051201</h4><p>软件介绍：</p><p>Office For Mac包含全新的Word，Excel,PowerPoint，Outlook和OneNote，完全支持Retina，支持中文，大量功能更新，非常强大！</p><p>功能介绍：</p><p>全新的、富有时代气息的 Word、Excel、PowerPoint、Outlook 和 OneNote — 将熟悉的 Office 与你钟爱的独有 Mac 功能相结合，让你可以快速上手。</p><p>无论身处何处，你都能随时创建精美的文档，深入获取各类信息，从容自信地展示。</p><p>Office 应用程序功能强大，借助 Office 应用程序，你可以在平板电脑、手机和 Web 上随时完成工作。</p><p>内置工具能更好地支持团队协作，团队成员可以共享、审阅和共同编辑文档、演示文稿和笔记，让你的团队更高效紧密合作。</p><p>软件兼容性：<br>OS X 10.12或更高版本</p><p><strong>支持10.14系统</strong></p><p>软件语言：</p><p>多国语言（Chinese/English）</p><p>链接: <a href="https://pan.baidu.com/s/14QibV7ruW1CJd7QADnAKog" target="_blank" rel="noopener">https://pan.baidu.com/s/14QibV7ruW1CJd7QADnAKog</a> 提取码: ne4p</p><h4 id="Sketch-For-Mac矢量绘图工具-V54-1"><a href="#Sketch-For-Mac矢量绘图工具-V54-1" class="headerlink" title="Sketch For Mac矢量绘图工具 V54.1"></a>Sketch For Mac矢量绘图工具 V54.1</h4><p>软件介绍：</p><p>Sketch 是Mac上一个强大、创新、易使用的矢量绘图软件。Sketch 简约的设计是基于无限的规模和层次的绘图空间，丰富的调色板、面板、菜单、窗口和控件。虽然使用简单，但是它提供了功能强大的矢量绘图和文字工具，如完美的布尔运算、符号，和强大的标尺、参考线和网格。</p><p>功能介绍：<br>简单但功能强大的接口</p><ul><li>优化的视网膜和非Retina显示屏</li><li>强大的造型，多重阴影，多个填充，渐变，混合，模糊，噪点多…</li><li>灵活的布尔操作简单的图形组合成复杂的形状</li><li>画板及切片出口多个图像出一个单一的文件</li><li>自动@ 2X出口的视网膜图形<br>独特的颜色（与RGB和HSB模式）和字体选择器</li><li>美丽的原生文本渲染和文本样式</li><li>向量和像素变焦，拉近与无限的矢量精度或个别像素</li><li>多站和径向渐变编辑右侧的画布中。强大的所见即所得的渲染。</li><li>PDF，EPS和SVG的进口和出口的支持</li><li>共享与链接图层样式的自动更新彼此</li><li>功能强大，易于使用的矢量工具<br>此外，设计师在以下几个方面将享受以下功能：<br>　　为Web和UI设计</li><li>复制CSS样式到剪贴板（包括梯度！ ）</li><li>切片：将出口作为画布上的图像区域</li><li>960px网格，用更先进的网格选项的支持</li><li>多页的单个文件里面支持<br>用于图标设计师</li><li>画板，画板每一个是自己的小帆布</li><li>iOS的图标模板</li><li>像素网格</li><li>像素效果，如高斯和运动模糊</li></ul><p>现V53以上的版本，已经支持中文了</p><p>汉化安装说明： 点这里 <a href="https://u14254589.pipipan.com/fs/14254589-234413612" target="_blank" rel="noopener">汉化包下载</a></p><p>1.下载汉化 Sketchl18N-master 压缩包</p><p>2.找到 SketchI18N.sketchplugin 双击安装（前提你装好了 Sketch）</p><p>3.提示安装成功后点 OK 进入sketch</p><p>4.在 Sketch 中按快捷键 control command + x 实现（也可以在菜单栏中 Plugins 中找到 Sketchl 18N）</p><p>5.汉化成功</p><p>软件兼容性：<br>OS X 10.13或更高版本</p><p>软件语言：<br>多国语言（Chinese/English）</p><p>链接: <a href="https://pan.baidu.com/s/1PcQavpmtNZ5WdT5c4uMp_Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1PcQavpmtNZ5WdT5c4uMp_Q</a> 提取码: 4x1n 复制这段内容后打开百度网盘手机App，操作更方便哦</p><h4 id="OmniFocus-For-Mac最优秀的GTD效率工具-V3-3-2"><a href="#OmniFocus-For-Mac最优秀的GTD效率工具-V3-3-2" class="headerlink" title="OmniFocus For Mac最优秀的GTD效率工具 V3.3.2"></a>OmniFocus For Mac最优秀的GTD效率工具 V3.3.2</h4><p>软件介绍：</p><p>OmniFocus 是一款IOS 和Mac平台上最强大的书籍与事务管理方法“Getting Things Done”工具，你可以有条理有逻辑的安排好你的工作和生活。主要协助您捕捉并管理各项事务与点子，发挥生产力；您可以用它来储存、管理及处理各项动作或任务，而任务或各项目可被指派到相关的专案中，同时OmniFocus也提供了视觉提示来提醒您下一步该执行的动作。</p><p>功能介绍：</p><p>OmniFocus的开发概念是来自David Allen的书籍与事务管理方法“Getting Things Done”，主要协助您捕捉并管理各项事务与点子，发挥生产力；您可以用它来储存、管理及处理各项动作或任务，而任务或各项目可被指派到相关的专案中，同时OmniFocus也提供了视觉提示来提醒您下一步该执行的动作。</p><p>OmniFocus可输入kGTD文件的资料、与iCal同步、透过Mail加入任务、使用Spotlight来存取各项任务、过滤专案与任务、支援档案附件…等等。开发人员在产品网页也提供了产品概观与示范影片，供使用者参考。Capture-快速方便记录你所有需要做的事件到你的收件箱中，直到你准备去处理和组织他们。Organize-在OmniFocus中使用强大的contexts特点进行分类的工作模式。</p><p>Sync-你在Mac上没有完成你的目标，你可以把他们一起带走。在OmniFocus里，你能够把你的任务数据库同步到服务器或者磁盘里。如果你有iPhone，那就更方便了，直接把所有Mac的任务数据直接同步在iPhone和iPad上。</p><p>软件兼容性：</p><p>OS X 10.13或更高版本</p><p>软件语言：</p><p>多国语言（Chinese/English）</p><p>链接: <a href="https://pan.baidu.com/s/1eKH2kA-Z85RKe-wGz2CgnA" target="_blank" rel="noopener">https://pan.baidu.com/s/1eKH2kA-Z85RKe-wGz2CgnA</a> 提取码: 81iu </p><h4 id="Launchey-For-Mac灵活的菜单栏快捷工具-V2-0-9b"><a href="#Launchey-For-Mac灵活的菜单栏快捷工具-V2-0-9b" class="headerlink" title="Launchey For Mac灵活的菜单栏快捷工具 V2.0.9b"></a>Launchey For Mac灵活的菜单栏快捷工具 V2.0.9b</h4><p>软件介绍：</p><p>Launchey是一个轻量级的菜单启动程序，让你启动任何应用程序在您的Mac的菜单栏。你可以选择哪些应用程序是可见的Launchey的菜单栏菜单，选择5个最喜欢的，你就可以直接在你的Mac的菜单栏显示。Launchey让您启动您最喜爱的应用程序设置全局热键。</p><p>功能介绍：</p><p>特征：</p><p>可定制的菜单，</p><p>可定制的热键，</p><p>直接在菜单栏中显示应用，</p><p>可定制的应用程序，</p><p>在启动时启动，</p><p>快速轻巧，</p><p>使用最新的Apple技术构建，</p><p>专为OS X El Capitan设计。</p><p>软件兼容性：</p><p>OS X 10.12或更高版本</p><p>软件语言：</p><p>英文语言（English）</p><p>链接: <a href="https://pan.baidu.com/s/1LwS_tKeLJ5bKxCICy1TQdA" target="_blank" rel="noopener">https://pan.baidu.com/s/1LwS_tKeLJ5bKxCICy1TQdA</a> 提取码: 6rma</p><h4 id="uTools-For-Mac你的生产力工具集-V0-6-1-beta"><a href="#uTools-For-Mac你的生产力工具集-V0-6-1-beta" class="headerlink" title="uTools For Mac你的生产力工具集 V0.6.1-beta"></a>uTools For Mac你的生产力工具集 V0.6.1-beta</h4><p>软件介绍：</p><p>uTools是一个极简、插件化、跨平台的现代桌面软件。通过自由选配丰富的插件，打造你得心应手的工具集合。</p><p>当你熟悉它后，能够为你节约大量时间，让你可以更加专注地改变世界。</p><p>功能介绍：</p><p>快速启动</p><p>强大的快速启动，比你想象的更加深入。对中文语义的友好支持，首字母检索等。</p><p>自动识别</p><p>uTools支持多种输入源呼出插件，例如：字符输入、文件拖拽、截图粘贴，亦能够自动识别输入内容进入相应插件，如json、时间戳、base64等。</p><p>数据同步</p><p>uTools各插件产生的数据将保存到本地数据库中。为了便于在不同设备之间共享数据，或是预防重装系统造成数据丢失，我们提供云端数据备份同步服务，登录后可一键开启。</p><p>高度自由</p><p>uTools 一切皆插件的设计，可以允许你高度自由的定义自己的开发工具，现在你也可以扩展第三方插件或者开发属于自己的插件。</p><p>软件兼容性：</p><p>OS X 10.12或更高版本</p><p>软件语言：</p><p>多国语言（Chinese/English）</p><p>链接: <a href="https://pan.baidu.com/s/1ZUjcSggBZrkJCrs2lVdCMA" target="_blank" rel="noopener">https://pan.baidu.com/s/1ZUjcSggBZrkJCrs2lVdCMA</a> 提取码: vcwa</p><h4 id="Remote-Desktop-Manager-For-Mac优秀的远程桌面管理应用-V2019-1-3-0"><a href="#Remote-Desktop-Manager-For-Mac优秀的远程桌面管理应用-V2019-1-3-0" class="headerlink" title="Remote Desktop Manager For Mac优秀的远程桌面管理应用 V2019.1.3.0"></a>Remote Desktop Manager For Mac优秀的远程桌面管理应用 V2019.1.3.0</h4><p>软件介绍：</p><p>Devolutions Remote Desktop Manager是一款功能强大直观的远程桌面管理应用，使您可以在用户友好的界面中管理所有远程连接，帐户凭据和其他信息。专门针对网络和系统管理员，以及需要将所有远程连接，密码和其他凭据保存在同一屋檐下的用户。</p><p>功能介绍：</p><p>功能丰富，易于与管理应用程序一起工作</p><p>它的组织良好的界面和易于使用的功能将使您在使用远程桌面管理器之前不需要大量的时间它。</p><p>绝对使用远程桌面管理器企业版的所有条目都必须手工完成，无论我们是在谈论凭证，组还是其他更高级的设置。</p><p>但是，作为补偿，一旦配置了会话，就可以利用其批量编辑功能，使您可以跨多个会话更改设置。</p><p>轻松管理您的远程连接并保存您的所有密码和凭据</p><p>此外，远程桌面管理器企业版还支持RDP，SSH，Web，VNC，Telnet，ICA / HDX，TeamViewer，LogMeIn等大量连接，以及25种VPN类型的附加功能。</p><p>就安全性而言，远程桌面管理器企业版具有内置的密码管理器，密码分析器和SSH密钥生成器。它还使您能够保存和管理所有密码，并从其他现有密码管理器导入数据。</p><p>系统和网络管理员的综合和有用的工具</p><p>关于其管理工具，远程桌面管理器企业版集成了用于Citrix XenServer，VMware，Microsoft终端服务器和Hyper-V的控制台，以及远程关闭，局域网唤醒和库存报告功能。</p><p>考虑到所有因素，远程桌面管理器企业版提供了一个简化的管理环境和大量的功能，使其成为任何系统和网络管理员与多个远程连接和凭证工作的必备应用程序。</p><p>软件兼容性：</p><p>OS X 10.12或更高版本</p><p>软件语言：</p><p>英文语言（English）</p><p>链接: <a href="https://pan.baidu.com/s/1rmHryFLYZiIh-CIh49tA1A" target="_blank" rel="noopener">https://pan.baidu.com/s/1rmHryFLYZiIh-CIh49tA1A</a> 提取码: ihd3</p><h4 id="Things-For-Mac强大的GTD效率工具-V3-9-0"><a href="#Things-For-Mac强大的GTD效率工具-V3-9-0" class="headerlink" title="Things For Mac强大的GTD效率工具 V3.9.0"></a>Things For Mac强大的GTD效率工具 V3.9.0</h4><p>软件介绍：</p><p>Things Mac版是MAC OS平台上的文件管理工具，在一种优雅和直观的方式来帮助组织你的任务。Things for Mac结合了强大的功能与简单的使用界面，通过使用标签和智能过滤栏来更好的为你工作。</p><p>十分简洁易用。</p><p>您会立即注意到 Things 中的所有功能是如此完美地融合在一起，从而为您带来整洁、集中的体验。没有不必要的铃声和哨声，以及检查器窗口和弹出对话框。只有您和您的待办事项。</p><p>一切都以您的待办事项为中心。</p><p>Things 中的待办事项比较特别。在列表中，它们会以最紧凑的形式显示复选框和标题。但将它们展开后，它们就会变为一张漂亮的白纸，上面有您想做的各种事情 – 并且如果您需要，还可以包括您的检查列表、标签、提醒事项以及截止日期。</p><p>一些超酷的功能。</p><p>例如“按类型查看” – 这是浏览列表和查找待办事项的极佳方式。或者自然语言日期解析器 – 只需输入“明天”、“4 天后”或“下周三”，就会跳到所有正确的结果。</p><p>一款制作相当精良的 macOS 应用。</p><p>Things 可与所有 macOS 技术完全集成： Touch Bar、今天小部件、共享扩展、 Handoff、日历、提醒事项和 AppleScript。或许还包括几项我们忘记列出的技术。</p><p>各种出色的功能数不胜数。</p><p>每个人都有自己喜欢的功能，不可能将其全部列出。</p><p>功能介绍：</p><p>如果您是初次使用 Things，请参照以下的基本工作流程：</p><p>1.收集想法</p><p>快速记录您的想法：与 Siri 交谈或者使用系统范围的键盘快捷键来启动“快速创建”。</p><p>2.分类</p><p>为您的每个目标创建一个项目。根据您的责任区域群组各项目，例如“家庭”、“工作”或“健康”。定期审查这些项目，从而顺利实现各目标。</p><p>3.计划时间</p><p>有效管理您的时间 – 同时查看您的待办事项和日历事件，并相应地对每周进行计划。创建重复的待办事项以确保始终如一。</p><p>4.充实生活每一天</p><p>每天早晨查看您的“今天”列表，然后马上行动。之前计划的待办事项会自动显示在其中。在您进行每天的工作时，这是您唯一需要查看的列表。</p><p>5.自定义工作流程</p><p>您可以利用标签为待办事项分配自定义类别：标记“重要”待办事项、“日常”待办事项、需要在“办公室”完成的待办事项以及与“凯特”一起完成的待办事项。既可以按标签轻松筛选列表，也可以在所有列表中搜索标签。</p><p>软件兼容性：</p><p>OS X 10.12或更高版本</p><p>软件语言：</p><p>多国语言（Chinese/English）</p><p>链接: <a href="https://pan.baidu.com/s/17vMxzdK3yCNgIaALor7w7A" target="_blank" rel="noopener">https://pan.baidu.com/s/17vMxzdK3yCNgIaALor7w7A</a> 提取码: d4x9</p><h4 id="Things-For-Mac强大的GTD效率工具-V3-9-1"><a href="#Things-For-Mac强大的GTD效率工具-V3-9-1" class="headerlink" title="Things For Mac强大的GTD效率工具 V3.9.1"></a>Things For Mac强大的GTD效率工具 V3.9.1</h4><p>软件介绍：</p><p>Things Mac版是MAC OS平台上的文件管理工具，在一种优雅和直观的方式来帮助组织你的任务。Things for Mac结合了强大的功能与简单的使用界面，通过使用标签和智能过滤栏来更好的为你工作。</p><p>十分简洁易用。</p><p>您会立即注意到 Things 中的所有功能是如此完美地融合在一起，从而为您带来整洁、集中的体验。没有不必要的铃声和哨声，以及检查器窗口和弹出对话框。只有您和您的待办事项。</p><p>一切都以您的待办事项为中心。</p><p>Things 中的待办事项比较特别。在列表中，它们会以最紧凑的形式显示复选框和标题。但将它们展开后，它们就会变为一张漂亮的白纸，上面有您想做的各种事情 – 并且如果您需要，还可以包括您的检查列表、标签、提醒事项以及截止日期。</p><p>一些超酷的功能。</p><p>例如“按类型查看” – 这是浏览列表和查找待办事项的极佳方式。或者自然语言日期解析器 – 只需输入“明天”、“4 天后”或“下周三”，就会跳到所有正确的结果。</p><p>一款制作相当精良的 macOS 应用。</p><p>Things 可与所有 macOS 技术完全集成： Touch Bar、今天小部件、共享扩展、 Handoff、日历、提醒事项和 AppleScript。或许还包括几项我们忘记列出的技术。</p><p>各种出色的功能数不胜数。</p><p>每个人都有自己喜欢的功能，不可能将其全部列出。</p><p>功能介绍：</p><p>如果您是初次使用 Things，请参照以下的基本工作流程：</p><p>1.收集想法</p><p>快速记录您的想法：与 Siri 交谈或者使用系统范围的键盘快捷键来启动“快速创建”。</p><p>2.分类</p><p>为您的每个目标创建一个项目。根据您的责任区域群组各项目，例如“家庭”、“工作”或“健康”。定期审查这些项目，从而顺利实现各目标。</p><p>3.计划时间</p><p>有效管理您的时间 – 同时查看您的待办事项和日历事件，并相应地对每周进行计划。创建重复的待办事项以确保始终如一。</p><p>4.充实生活每一天</p><p>每天早晨查看您的“今天”列表，然后马上行动。之前计划的待办事项会自动显示在其中。在您进行每天的工作时，这是您唯一需要查看的列表。</p><p>5.自定义工作流程</p><p>您可以利用标签为待办事项分配自定义类别：标记“重要”待办事项、“日常”待办事项、需要在“办公室”完成的待办事项以及与“凯特”一起完成的待办事项。既可以按标签轻松筛选列表，也可以在所有列表中搜索标签。</p><p>软件截图：</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/ac9085_67e22147e15b4713a652948afefca293_mv2_nj7cje.jpg" srcset="/img/loading.gif" alt="img"></p><p>软件兼容性：</p><p>OS X 10.12或更高版本</p><p>软件语言：</p><p>多国语言（Chinese/English）</p><p>下载破解版本：</p><p>链接: <a href="https://pan.baidu.com/s/1Hw0wnFeuf2RWOpRz5Z1uEw" target="_blank" rel="noopener">https://pan.baidu.com/s/1Hw0wnFeuf2RWOpRz5Z1uEw</a> 提取码: g37n</p><h4 id="TechSmith-Snagit-For-Mac超强截屏神器-V2019-1-3"><a href="#TechSmith-Snagit-For-Mac超强截屏神器-V2019-1-3" class="headerlink" title="TechSmith Snagit For Mac超强截屏神器 V2019.1.3"></a>TechSmith Snagit For Mac超强截屏神器 V2019.1.3</h4><p>软件介绍：<br>Snagit for mac(TechSmith Snagit)这是一款很好用的Mac OS系统截屏工具，你可以使用此工具轻松抓取图像、文本和影音等多种内容形式，内置强大编辑器，捕捉、编辑一步到位。</p><p>功能介绍：<br>Snagit 帮助您通过视频和图像提高交流的水平和质量。您可快速提供更好的反馈，鼓励团队合作，以及改变合伙方式，从而完成工作。您可采集任何图像，然后用各种特效对其进行强化或快速创建计算机屏幕图像视频。根据需要选择特效，方便地自定义任意截屏。<br>您可使用 Snagit 的各种标记工具加亮一个区域，或者将注意力吸引到某个特殊的点上。您也可通过录制屏幕和快速裁剪不需要的部分来快速创建视频。使用 Snagit 制作的所有内容都能方便地与任何人分享。</p><p>软件兼容性：<br>OS X 10.12或更高版本</p><p>软件语言：<br>英文语言（English）​</p><p>链接: <a href="https://pan.baidu.com/s/1YsJxqDOqXvuTzpqMD9pq8Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1YsJxqDOqXvuTzpqMD9pq8Q</a> 提取码: 7bba</p><h4 id="Better-And-Better-For-Mac一款包含很多功能等长截图的macOS工具-V1-6-63"><a href="#Better-And-Better-For-Mac一款包含很多功能等长截图的macOS工具-V1-6-63" class="headerlink" title="Better And Better For Mac一款包含很多功能等长截图的macOS工具 V1.6.63"></a>Better And Better For Mac一款包含很多功能等长截图的macOS工具 V1.6.63</h4><p>软件介绍：</p><p>BetterAndBetter 是一款集合众多优秀功能的 macOS 软件。包含🖱️鼠标、⌨️键盘、触摸板、情景模式、蓝牙解锁、自动切换输入法、🔉 打字音效等功能，出色的创意和强大的功能将极大提升你的 macOS 使用体验。</p><p>功能介绍：</p><p>触摸板模块</p><p>这个模块是手势识别应用程序，在 MacBook 系列里自带的触摸板上，软件会监听你几个手指，做不同的手势动作，如果手势被识别，BetterAndBetter 将执行已经制定规则的相应操作。</p><p>目前 BetterAndBetter 可以模拟按键，执行软件预设的命令，执行 apple script。</p><p>其中有一个开关是开启二指绘图功能，意思是按住一个手指，另一个手指在左侧轻拍一下，就可以用单指绘图了，相当于按住鼠标右键做拖移动作，就会执行鼠标模块里面的某些功能。</p><p>选择手势时如果选择黑名单，就会在你选择的程序里所有的手势不起作用。</p><p>鼠标模块</p><p>这个模块是鼠标手势识别应用程序。按住右键部分是在按住鼠标右键的同时使用鼠标进行的运动。 如果手势被识别，BetterAndBetter 将执行某些操作。</p><p>组合按键部分，是指按住鼠标右键，然后配合菜单里指示的动作去自定义执行动作。</p><p>其他按键部分，是指按住其他按键，然后配合相应菜单里指示的动作去自定义执行动作。</p><p>手势相似度，意思是你鼠标画的轨迹和数据库里已经设置的轨迹比对的吻合程度，这个值一般设定为 75–95，具体可以根据自己的实际操作以后的感觉来设定。</p><p>鼠标加速度滑块，你可以根据自己的习惯调节鼠标的加速度，数值为零时就是关闭鼠标的加速度。</p><p>自动跳窗模块</p><p>这个模块类似 popclip 这个软件，按住鼠标左键，然后拖移去选择文本或者在 Finder 里面去选择文件，软件会根据不同的情况自动跳出不同的窗口，点击已经跳出的窗口，就可以执行相应的动作</p><p>因为有 2 个表格，所以先点击一个表格，然后在按“+”等按钮。表格里的内容都是可以修改的，特别提醒的是这两个表格里面的行是可以拖移的，以此来调整跳窗的先后次序。</p><p>需要特别解释的是状态栏，有 ⌘C，⌘V，⌘X和⌘，它的意思是在激活的 App 里的复制，粘贴，剪切按钮是点亮的，对应的标识才会出现在跳窗里，⌘ 表示在任何情况下都会出现在跳窗里。</p><p>在选择文本时有以下三种情况下会跳出窗口：</p><p>鼠标拖拽划选；</p><p>在文本上面双击鼠标；</p><p>鼠标没有移动的情况下，在能输入的地方隔开 0.6 秒以上的两次点击鼠标。</p><p>在选择文件时也有以下三种情况下会跳出窗口：</p><p>鼠标拖拽划选在 Finder 程序的空白处；</p><p>桌面上双击鼠标；</p><p>在鼠标没有移动的情况下，在文件或者目录上面隔开 0.6 秒以上的两次点击鼠标。</p><p>边角触发模块</p><p>这个模块是可以设定在不同的桌面时，左键或右键点击屏膜的四个角，可以分别设置一些动作，这些动作有快捷键，预设动作和 applescript 三种。</p><p>窗口管理</p><p>当你移动窗口时，会自动出来八个提示框，分别代表分屏的位置。</p><p>吸附功能：当你用鼠标把一个窗口拖移向屏膜左边或者右边，当窗口的一边接近屏膜边缘时，在相应位置会出现一条黄色的线，此时松开鼠标按键，窗口就会吸附在屏幕一侧。当鼠标移动到已经有窗口吸附的屏膜的左边或者右边时，鼠标下被吸附的窗口就会自动弹出来。鼠标离开这个窗口时，窗口又会吸附在屏幕的两边，注意：窗口宽度等于屏幕宽度的窗口是不会被吸附的。</p><p>工具箱模块</p><p>蓝牙解锁</p><p>这个模块是在需要输入系统密码时，通过检测已经配对的蓝牙设备是否能连接，能连接就自动输入密码。只有从睡眠，屏保，和关闭屏膜中恢复时需要检测蓝牙的，在其他需要系统密码时都是不经过蓝牙检测，就直接输入密码的，比如在偏好设置需要密码时。</p><p>登录时拍照，如果激活这个按钮，就是从睡眠，屏保，和关闭屏膜中恢复时一方面检测蓝牙设备，同时打开自带的摄像头进行拍照，如果最后没有检测到蓝牙设备，就把照片存储在你所选择的目录，而且你自己可以打开 icloud 同步，那样就把照片马上送到了云端了，你就能知道谁动了你的Mac。</p><p>剪切板管理</p><p>BetterAndBetter 可以记住你最近使用过的十个剪切板内容，你还可以在工具箱模块增加三个固定的剪切板内容。</p><p>有两种触发模式：</p><p>在自动跳窗里，在跳出来的窗口里点击”✄”的图标；</p><p>在快捷键模块里有一个可以自定义的快捷键。</p><p>两种模式都会弹出一个剪切板管理的窗口。</p><p>也有两种执行方式：</p><p>用鼠标点击已经跳出窗口的任意一行；</p><p>按对应的数字键，调用固定的剪切板内容需要先按住Fn键，再按相应的数字键。</p><p>更多功能…..</p><p><a href="http://i.youku.com/i/UNjIyODg4NTU4NA==?spm=a2hzp.8244740.0.0" target="_blank" rel="noopener"><strong>点击这里官方视頻教程</strong></a><br>软件兼容性：</p><p>OS X 10.12或更高版本</p><p>软件语言：</p><p>多国语言（Chinese/English）</p><p>链接: <a href="https://pan.baidu.com/s/1KH1m4WsoRcRlwf9wQIPikA" target="_blank" rel="noopener">https://pan.baidu.com/s/1KH1m4WsoRcRlwf9wQIPikA</a> 提取码: yrtn</p><h4 id="SQLPro-Studio-For-Mac数据库客户端-V2019-05-10-00"><a href="#SQLPro-Studio-For-Mac数据库客户端-V2019-05-10-00" class="headerlink" title="SQLPro Studio For Mac数据库客户端 V2019.05.10.00"></a>SQLPro Studio For Mac数据库客户端 V2019.05.10.00</h4><p>软件介绍：</p><p>SQLPro Studio Mac版是一款Mac上优秀的数据库客户端，SQLPro Studio支持Postgres，MySQL，Microsoft SQL Server，Oracle等主流数据库，可以方便易用的管理数据库，很不错！</p><p>功能介绍：</p><p>　　功能特点</p><p>　　+智能感知/ SQL自动完成。</p><p>　　+语法与定制主题突出。</p><p>　　+基于选项卡的用户界面。</p><p>　　+快速访问表和列。</p><p>　　+SQL美化/格式化。</p><p>　　+支持的NTLMv2。</p><p>　　+支持Netbios的。</p><p>　　+主密码的支持，以提高安全性。</p><p>　　SQLPro Studio支持以下数据库服务器：</p><ul><li>MySQL的＆MariaDB的</li></ul><p>　　+PostgreSQL</p><p>　　+的Microsoft SQL Server（2005及以上）</p><p>　　+甲骨文（8i和以上）</p><p>软件兼容性：<br>OS X 10.12或更高版本</p><p>软件语言：</p><p>英文语言（English）</p><p>链接: <a href="https://pan.baidu.com/s/1haEku9VhVnpGsEM6pshVLg" target="_blank" rel="noopener">https://pan.baidu.com/s/1haEku9VhVnpGsEM6pshVLg</a> 提取码: zv8q</p><h4 id="NeatDownloadManager-For-Mac一款免费好用的多线程下载工具-V1-0"><a href="#NeatDownloadManager-For-Mac一款免费好用的多线程下载工具-V1-0" class="headerlink" title="NeatDownloadManager For Mac一款免费好用的多线程下载工具 V1.0"></a>NeatDownloadManager For Mac一款免费好用的多线程下载工具 V1.0</h4><p>软件介绍：</p><p>NeatDownloadManager Mac版是Mac平台上的一款免费好用的多线程下载工具。NeatDownloadManager Mac版使用动态分段算法下载文件，支持HTTP，HTTPS和FTP协议，HTTP和代理身份验证。</p><p>功能介绍：</p><p>NeatDownloadManager Mac版支持暂停/恢复功能以及更新过期下载连接，NeatDownloadManager Mac版具有浏览器扩展，可以用于随时捕获下载链接和从在线视频网站上下载视频。</p><p>软件兼容性：</p><p>OS X 10.12或更高版本</p><p>软件语言：</p><p>英文语言（English）</p><p>链接: <a href="https://pan.baidu.com/s/1zgSoATpucEGD0dQcZW4Ilg" target="_blank" rel="noopener">https://pan.baidu.com/s/1zgSoATpucEGD0dQcZW4Ilg</a> 提取码: 7yy6</p><h4 id="Dash-For-Mac编程文档管理工具-V4-6-3"><a href="#Dash-For-Mac编程文档管理工具-V4-6-3" class="headerlink" title="Dash For Mac编程文档管理工具 V4.6.3"></a>Dash For Mac编程文档管理工具 V4.6.3</h4><p>软件介绍：</p><p>Dash for mac是使用与Mac OS平台的软件编程文档管理工具，可以浏览API文档，以及管理代码片段工具。Dash自带了丰富的API文档，涉及各种主流的编程语言和框架。</p><p>功能介绍：</p><p>可以浏览API文档，以及管理代码片段工具。Dash自带了丰富的API文档，涉及各种主流的编程语言和框架，包括:ActionScript, Android, C++, CAppuccino, Cocos2D, Cocos3D, Corona, CSS, Django, Groovy, HTML, Java, JavaFX, JavaScript, jQuery, Kobold2D, Lua, MySQL, Node.js, Man Pages, Perl, PHP, Python, Ruby, Ruby on Rails, Scala, Sparrow, SQLite, Unity 3D, WordPress, XSLT, XUL。</p><p>利用Dash的代码片段管理功能，你可以把日常使用频繁的代码保存起来，然后为其设置一个独一无二的缩写，这样一来原本需要一遍又一遍的敲击键盘重复录入的繁琐工作，就可以交给Dash来轻松搞定。</p><p>软件兼容性：</p><p>OS X 10.12或更高版本</p><p>软件语言：</p><p>英文语言（English）</p><p>链接: <a href="https://pan.baidu.com/s/1BPILqRQPln1RdKIwr1LWDw" target="_blank" rel="noopener">https://pan.baidu.com/s/1BPILqRQPln1RdKIwr1LWDw</a> 提取码: vn26</p><h4 id="One-Switch-For-Mac集合一键切换系统各项功能工具-V1-3"><a href="#One-Switch-For-Mac集合一键切换系统各项功能工具-V1-3" class="headerlink" title="One Switch For Mac集合一键切换系统各项功能工具 V1.3"></a>One Switch For Mac集合一键切换系统各项功能工具 V1.3</h4><p>软件介绍：</p><p>One Switch是一款小巧的应用程序，旨在通过快速访问一些重要的交换机来提高您的效率。它可以从菜单栏打开，只需点击几下即可切换某些系统功能。</p><p>功能介绍：</p><p>隐藏桌面图标</p><p>只需单击一下即可隐藏凌乱的桌面。</p><p>暗模式</p><p>随时切换暗模式。</p><p>保持清醒</p><p>防止Mac睡眠或显示屏幕保护程序。</p><p>屏幕保护程序</p><p>有时您需要手动打开它。</p><p>AirPods</p><p>只需一秒钟即可将AirPods与Mac连接</p><p>软件截图：</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/1554394646_one-switch_02_aif4of.jpg" srcset="/img/loading.gif" alt="img"></p><p>软件兼容性：</p><p>OS X 10.12或更高版本</p><p>软件语言：</p><p>多国语言（Chinese/English）</p><p>链接: <a href="https://pan.baidu.com/s/1Pagw3SkhRQ6epHiBnbr1NA" target="_blank" rel="noopener">https://pan.baidu.com/s/1Pagw3SkhRQ6epHiBnbr1NA</a> 提取码: kbdr</p><h4 id="Money-Pro-For-Mac强大的个人财务管理工具-V2-1-00"><a href="#Money-Pro-For-Mac强大的个人财务管理工具-V2-1-00" class="headerlink" title="Money Pro For Mac强大的个人财务管理工具 V2.1.00"></a>Money Pro For Mac强大的个人财务管理工具 V2.1.00</h4><p>软件介绍：</p><p>Money for mac是一款Mac平台上好用的个人财务管理工具，可以轻松的处理收入和消费的记录和核算。号称Mac平台上最好的个人理财软件。</p><p>功能介绍：</p><p>Money易于使用的个人全面财务管理应用。它将您的个人财务分类清晰管理，个人收入明细以完善的图表形式来表示。它旨在帮助你控制你的财务支出，在Mac上轻松方便的记帐还可与iphone同步。</p><p>　　一个漂亮的界面。</p><p>　　管理你不同的帐户来平衡支出。</p><p>　　智能调度。</p><p>　　提供多种高级财务报告。</p><p>　　简易的预算规划。</p><p>　　投资跟踪。</p><p>软件截图：</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/ac9085_7a0598addb9449f88af591314de6fd48_mv2_guneqx.jpg" srcset="/img/loading.gif" alt="img"></p><p>软件兼容性：</p><p>OS X 10.12或更高版本</p><p>软件语言：</p><p>多国语言（Chinese/English）</p><p>链接: <a href="https://pan.baidu.com/s/1CLzuDlVzFgfxwysv0Hjkfw" target="_blank" rel="noopener">https://pan.baidu.com/s/1CLzuDlVzFgfxwysv0Hjkfw</a> 提取码: i2wk</p><h4 id="Fantastical-For-Mac优雅的日历工具-V2-5-9"><a href="#Fantastical-For-Mac优雅的日历工具-V2-5-9" class="headerlink" title="Fantastical For Mac优雅的日历工具 V2.5.9"></a>Fantastical For Mac优雅的日历工具 V2.5.9</h4><p>软件介绍：</p><p>Fantastical的设计者Flexibits结合了Fantastical的传统优势，实现了完整的桌面体验，给用户带来了全新的Fantastical 2。</p><p>功能介绍：</p><p>Fantastical的设计者Flexibits结合了Fantastical的传统优势，实现了完整的桌面体验，给用户带来了全新的Fantastical 2。Fantastical 2与前一代的最大区别在于，Fantastical 2现在作为一个完整的App可以让用户在独立窗口中查看全天、周、月、年界面。它的界面窗口使用了智能双面板设计，左侧显示正在运行的议程，右侧显示完整的日历。且Fantastical 2还具有自定义日历这一大特色，它还同时支持Mac上已建立的iCloud、Google以及Yahoo等的日历服务。</p><p>软件截图：</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/1508348004_fantastical_01_oqiar5.jpg" srcset="/img/loading.gif" alt="img"></p><p>软件兼容性：</p><p>OS X 10.12或更高版本</p><p>软件语言：</p><p>英文语言（English）</p><p>链接: <a href="https://pan.baidu.com/s/1sSQkDDrZDI65_EAEw5TqDw" target="_blank" rel="noopener">https://pan.baidu.com/s/1sSQkDDrZDI65_EAEw5TqDw</a> 提取码: ksjx</p><h4 id="Amadeus-Pro-For-Mac强大的音乐编辑器-V2-6-0"><a href="#Amadeus-Pro-For-Mac强大的音乐编辑器-V2-6-0" class="headerlink" title="Amadeus Pro For Mac强大的音乐编辑器 V2.6.0"></a>Amadeus Pro For Mac强大的音乐编辑器 V2.6.0</h4><p>软件介绍：</p><p>Amadeus pro for mac是Mac os平台上的一款功能非常强大的Mac音乐编辑器，Amadeus Pro Version for mac是一款强大的多轨音频编辑器，支持多种格式，如MP3, AAC, Ogg Vorbis, Apple Lossless, AIFF, Wave等。</p><p>功能介绍：</p><p>　　【１】多轨编辑</p><p>　　Amadeus Pro是一个功能齐全的多轨音频编辑器。每首曲目可以分割成多个相互独立又容易拖曳的音频剪辑。此外，音频单位可以应用于实时的个别曲目，而无需任何破坏性编辑。</p><p>　　【２】批处理</p><p>　　如果你想转换成MP3文件，让Amadeus Pro来！强大的批量处理器不仅允许你转换大量任何格式的文件，还可以处理任何序列的音效。</p><p>　　【３】维修中心</p><p>　　方便的维修中心，可让您寻找并修复裂缝，只需一次简单的鼠标点击。此外，Amadeus Pro强大的降噪功能让您轻松地摆脱恼人的嘶嘶声。</p><p>　　【4】功能介绍</p><p>　将唱片或磁带转换到CD</p><p>　　Amadeus Pro的强大的去噪和修复功能，可以轻易将您最喜爱的录音或老唱片里恼人的嘶嘶声去除</p><p>　　分割成多个音轨录制</p><p>　　只需鼠标轻轻点击就能Amadeus Pro能将您的录音刻录到CD上</p><p>　　专用均衡器可以将声音做旧处理</p><p>　　【5】强大的批处理功能</p><p>　　支持转换为以下文件格式：AIFF, WAVE, Mp3, Ogg Vorbis, Mp4, M4a (AAC和Apple原声), FLAC, Apple CAF, QuickTime, SoundDesigner II, Next, Mp2 (只读)。</p><p>　　允许您申请任意序列的音响效果集合。</p><p>　　保留元数据（艺术家，歌名，专辑封面等）</p><p>　　【6】音效</p><p>　　全力支持两个音频单元和VST音频插件。扩展和定制功能能满足您的各种特殊要求。</p><p>　　建成程序最常用的效果（多波段图形均衡器，音量正常化，淡入/淡出，回音，速度和音调的变化等）</p><p>软件截图：</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/1600x1000bb_tuzdk9.jpg" srcset="/img/loading.gif" alt="img"></p><p>软件兼容性：</p><p>OS X 10.12或更高版本</p><p>软件语言：</p><p>英文语言（English）</p><p>链接: <a href="https://pan.baidu.com/s/1HISK5fVwuKObgsJ9AxFztw" target="_blank" rel="noopener">https://pan.baidu.com/s/1HISK5fVwuKObgsJ9AxFztw</a> 提取码: 8vyk</p><h4 id="Drive-Scope-For-Mac硬盘检测分析工具-V1-2-5"><a href="#Drive-Scope-For-Mac硬盘检测分析工具-V1-2-5" class="headerlink" title="Drive Scope For Mac硬盘检测分析工具 V1.2.5"></a>Drive Scope For Mac硬盘检测分析工具 V1.2.5</h4><p>软件介绍：</p><p>Drive Scope是由Micromat发布的新程序，它被定义为“SMART市场最完整的实用程序”。它与SSD和HDD（但不是RAID）兼容，并收集和分析Mac驱动器的状态。</p><p>功能介绍：</p><p>Drive Scope硬盘驱动器（和固态硬盘）是Mac中最易出故障的组件。出于这个原因，事实上，驱动器制造商已经在驱动器中内置了自我监控，分析和报告技术。（a.k.a.SMART）大多数实用程序几乎不会泄露这些信息的表面，只需报告基本要素：通过或失败。通常，一旦发生整体故障，就没有足够的时间从驱动器获取重要数据。使用Drive Scope，您可以了解连接到Mac的大多数驱动器的运行状况。</p><p>Drive Health</p><p>使用Drive Scope，您可以看到Drive的健康状况的完整图片。有关驱动器正在监控的每个方面的详细信息可供查看。查看有助于驱动器运行状况的每个属性 – 详细信息。查看哪些属性导致整体故障，哪些属性仅仅是信息性的。</p><p>控制测试</p><p>通常，只要方便，驱动器就会检查它的SMART属性。使用Drive Scope，您可以手动触发驱动器的内部测试，以确保SMART数据尽可能地保持最新状态。检查驱动器上次使用驱动器测试日志进行测试的时间。</p><p>信息</p><p>首次打开Drive Scope时，将显示一个信息页面，其中汇总了有关驱动器的所有重要信息。请参阅Drive Scope的高级运行状况评估，以及遇到的错误数量，以及特定于驱动器的型号和容量信息。</p><p>软件截图：</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/1524289844_drive-scope_01_dov15u.jpg" srcset="/img/loading.gif" alt="img"></p><p>软件兼容性：</p><p>OS X 10.12或更高版本</p><p>软件语言：</p><p>英文语言（English）</p><p>链接: <a href="https://pan.baidu.com/s/1DRBX83HI7lkXEfsxaLzm7Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1DRBX83HI7lkXEfsxaLzm7Q</a> 提取码: 83as</p><h4 id="Downie-For-Mac在线视频下载超级工具-V3-7-3"><a href="#Downie-For-Mac在线视频下载超级工具-V3-7-3" class="headerlink" title="Downie For Mac在线视频下载超级工具 V3.7.3"></a>Downie For Mac在线视频下载超级工具 V3.7.3</h4><p>软件介绍：<br>Downie for Mac是一个超级易于使用的视频下载工具，支持YouTube，Vimeo 等超过170个视频网站。它不会因为大量的选项而让用户困扰 - 它使用起来非常简单。最新破解版，实测支持国内的优酷，爱奇艺和土豆以及国外的Youtube，如果你对视频下载有强烈的需求，那么Downie 是一个简单易用的视频下载工具。</p><p>功能介绍：<br>Downie for mac可能看起来像一个简单的拖放和拖放应用程序。它被设计为简单易用 - 只需拖放链接到Downie，它就会下载该网站上的视频。</p><p>软件截图：</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/ac9085_471bf0b8fdda4ce6b3d61805fe535569_mv2_u5jxdy.png" srcset="/img/loading.gif" alt="img"></p><p>软件兼容性：<br>OS X 10.12或更高版本</p><p>软件语言：<br>多国语言（Chinese/English）</p><p>链接: <a href="https://pan.baidu.com/s/1M5so-5pc-oMS6SsrlSowow" target="_blank" rel="noopener">https://pan.baidu.com/s/1M5so-5pc-oMS6SsrlSowow</a> 提取码: w9mk</p><h4 id="Squash-For-Mac小巧实用的是图片压缩工具-V2-0-4"><a href="#Squash-For-Mac小巧实用的是图片压缩工具-V2-0-4" class="headerlink" title="Squash For Mac小巧实用的是图片压缩工具 V2.0.4"></a>Squash For Mac小巧实用的是图片压缩工具 V2.0.4</h4><p>软件介绍：</p><p>Squash是一款小巧的图片压缩软件，在不影响图片质量的前提下，可以大大的减少图片的大小。可以进行动态图片压缩、jpg图片压缩、PNG图片压缩、GIF动态图片压缩，小巧实用的一款软件！</p><p>功能介绍：</p><p>Squash (was Squish) 是降低文件大小压缩您的图片一个超级简单的应用程序！不要失去质量，或最终以颗粒状或可怕的图像。把保持他们现有的分辨率和质量，只是减少文件大小！无论你的理由，挤是伟大的优化图像：</p><p>发送电子邮件附件减少文件大小。</p><p>通过优化计算机上的大型照片集节省空间。</p><p>优化网站和电子邮件活动的形象，使他们立即加载在线。</p><p>缓慢的互联网？在挤滴图像保存时间上传到脸谱网或推特！</p><p>软件兼容性：</p><p>OS X 10.12或更高版本</p><p>软件语言：</p><p>英文语言（English）</p><p>链接: <a href="https://pan.baidu.com/s/1o8RjKaEHA3PmSxvSvaADUA" target="_blank" rel="noopener">https://pan.baidu.com/s/1o8RjKaEHA3PmSxvSvaADUA</a> 提取码: 51es</p><h4 id="PDF-Squeezer-For-Mac压缩工具-V3-10-3"><a href="#PDF-Squeezer-For-Mac压缩工具-V3-10-3" class="headerlink" title="PDF Squeezer For Mac压缩工具 V3.10.3"></a>PDF Squeezer For Mac压缩工具 V3.10.3</h4><p>软件介绍：</p><p>PDF Squeezer for Mac是Mac OS平台上的一款 PDF 简易压缩工具，在PDF文件过大的时候，PDF Squeezer 可以移除不相干的信息和压缩图像的方式来缩减PDF文件的大小。可以帮助您节省带宽费用、数字存储费用以及网络传输时间。</p><p>功能介绍：</p><p>轻轻松松将 PDF 文件拖拽至应用程序窗口或图标即可</p><p>选择预设滤器，亦可以创建自定义滤器</p><p>批量压缩多个文件</p><p>支持受密码保护的 PDF 文件</p><p>一键压缩’自动压缩并存储</p><p>软件截图：</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/ac9085_f11f8cd687e245a18d229803ac0b8557_mv2_tf2ibs.jpg" srcset="/img/loading.gif" alt="img"></p><p>测试系统语言：</p><p>macOS Sierra/macOS High Sierra简体中文</p><p>软件语言：</p><p>多国语言（Chinese/English）</p><p>链接: <a href="https://pan.baidu.com/s/1dgGOwwlxiW5GC6ftsMHuNw" target="_blank" rel="noopener">https://pan.baidu.com/s/1dgGOwwlxiW5GC6ftsMHuNw</a> 提取码: rnd3</p><h4 id="NXPowerLite-Desktop-For-Mac多格式文档压缩工具-V8-0-7"><a href="#NXPowerLite-Desktop-For-Mac多格式文档压缩工具-V8-0-7" class="headerlink" title="NXPowerLite Desktop For Mac多格式文档压缩工具 V8.0.7"></a>NXPowerLite Desktop For Mac多格式文档压缩工具 V8.0.7</h4><p>软件介绍：</p><p>NXPowerLite将压缩PDF，JPEG，Microsoft PowerPoint和Word文件，简单有效，同时很容易作为电子邮件附件。</p><p>功能介绍：</p><p>NXPowerLite Desktop for Mac是一款文档压缩工具，可以简单有效地压缩PDF，JPEG，Microsoft PowerPoint和Word文件，使它们易于以附件形式发送电子邮件。对于压缩不好的文件尤其有效。优化的文件保持相同的格式 – PDF仍然是一个PDF。它看起来和感觉与原始相同，只是小得多。您可以通过选择文件并使用Finder中的“优化和电子邮件”来优化和自动将文件附加到新电子邮件中。Mac或Windows注册密钥的一个关键用于NXPowerLite桌面将与Mac或Windows版本兼容，所以如果您切换平台，您可以继续使用NXPowerLite。 这也意味着，如果您购买多用户许可证，则无需事先指定每个平台的数量。</p><p>软件截图：</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/nxpowerlite-mac-8-main-dialog_c3iffz.png" srcset="/img/loading.gif" alt="img"></p><p>软件兼容性：</p><p>OS X 10.12或更高版本</p><p>软件语言：</p><p>英文语言（English）</p><p>链接: <a href="https://pan.baidu.com/s/1KHvef1XlAt6RlQjrPvwwHg" target="_blank" rel="noopener">https://pan.baidu.com/s/1KHvef1XlAt6RlQjrPvwwHg</a> 提取码: 5mig</p><h4 id="UninstallPKG-For-Mac实用的PKG完全卸载工具-V1-1-6"><a href="#UninstallPKG-For-Mac实用的PKG完全卸载工具-V1-1-6" class="headerlink" title="UninstallPKG For Mac实用的PKG完全卸载工具 V1.1.6"></a>UninstallPKG For Mac实用的PKG完全卸载工具 V1.1.6</h4><p>软件介绍：</p><p>UninstallPKG是一款Mac上实用的PKG完全卸载工具，顾名思义，这是一款PKG安装包卸载工具，可以搜索扫描 Mac 上安装的所有 PKG 程序，然后完全卸载删除，节省磁盘空间，比如 Office for Mac 等软件就可以用这款软件帮助快速完全的卸载，非常的方便！</p><p>功能介绍：</p><p>UninstallPKG允许您完全删除所谓的“软件包”(文件扩展名，pkg)和所有从您的Mac上安装的内容，它可以通过删除不需要的功能，例如未使用的打印机驱动程序，或者完全删除您不再使用的应用程序来回收宝贵的磁盘空间。卸载程序还可以通过删除已经部分删除的应用程序中的遗留文件，从而保持Mac的干净。它可以一次性删除Office 2011所有37290个文件，或者完全删除Java或Flash插件之类的东西。它还可以在卸载应用程序之后，将其从Dock和LoginItems目录中删除，并删除所生成的文件(首选项等)。</p><p>软件兼容性：</p><p>OS X 10.12或更高版本</p><p>软件语言：</p><p>多国语言（Chinese/English）</p><p>下载破解版本：</p><p>链接: <a href="https://pan.baidu.com/s/1edSKHjQTQu99svPMKCtAMA" target="_blank" rel="noopener">https://pan.baidu.com/s/1edSKHjQTQu99svPMKCtAMA</a> 提取码: 17kx</p><h4 id="Navicat-Premium-For-Mac强大的数据库管理工具-V12-1-22"><a href="#Navicat-Premium-For-Mac强大的数据库管理工具-V12-1-22" class="headerlink" title="Navicat Premium For Mac强大的数据库管理工具 V12.1.22"></a>Navicat Premium For Mac强大的数据库管理工具 V12.1.22</h4><p>软件介绍：</p><p>Navicat是最优秀的数据库图形化管理客户端，支持MySQL、SQL Server、SQLite、Oracle 和 PostgreSQL 等数据库，支持数据库建模，正向和反向工程，数据同步等功能，而Premium版本是包含了Navicat所有功能的最强大版本，是首选的数据库客户端工具！</p><p>功能介绍：</p><p>Navicat Premium 结合了其他 Navicat 成员的功能。有了不同数据库类型的连接能力，Navicat Premium 支持在 MySQL、SQL Server、SQLite、Oracle 及 PostgreSQL 之间传输数据。包括存储过程，事件，触发器，函数，视图等。</p><p>Navicat Premium 适用于三种平台 - Microsoft Windows、Mac OS X 及 Linux。它可以让用户连接本机或远程服务器、提供一些实用的数据库工具如数据模型工具、数据同步、结构同步、导入、导出、备份、还原及报表以协助管理数据。</p><p>软件兼容性：</p><p>OS X 10.12或更高版本</p><p>软件语言：</p><p>英文语言（English）</p><p>链接: <a href="https://pan.baidu.com/s/1DgDwQmM9Sixmw9vlQPUPcw" target="_blank" rel="noopener">https://pan.baidu.com/s/1DgDwQmM9Sixmw9vlQPUPcw</a> 提取码: 899w</p><h4 id="Axure-RP-9-Pro-Edition-For-Mac交互式原型设计工具-V9-0-0-3650"><a href="#Axure-RP-9-Pro-Edition-For-Mac交互式原型设计工具-V9-0-0-3650" class="headerlink" title="Axure RP 9 Pro Edition For Mac交互式原型设计工具 V9.0.0.3650"></a>Axure RP 9 Pro Edition For Mac交互式原型设计工具 V9.0.0.3650</h4><p>软件介绍：</p><p>Axure RP 9 for Mac破解版是专为快速原型设计而生，它可以辅助产品经理快速设计完整的产品原型，并结合批注，说明以及流程图，框架图等元素将产品完整地表述给各方面设计人员，如UI 、UE等等，并在讨论中不断完善。</p><p>功能介绍：</p><p>强大的原型，无需编码</p><p>使用条件逻辑，动态内容，动画，数学函数和数据驱动的交互创建简单的点击图或功能强大的丰富原型，无需编写任何代码。</p><p>很容易分享单击一个按钮，axure rp将您的图表和原型发布到云端或本地的 Axure Share 。只需发送一个链接（和密码），其他人就可以在浏览器中查看您的项目。在移动设备上，使用适用于iOS和Android的浏览器或Axure Share App。</p><p>DIAGRAMMING +文档创建流程图，线框，模型，用户旅程，角色，创意板等。从内置或自定义库中快速拖放元素以创建图表。然后，使用填充，渐变，线条样式和文本格式设置样式。</p><p>注释您的图表和原型以指定功能，跟踪任务或存储项目信息。将您的笔记整理到不同的受众群体的不同字段中。选择要在HTML中或在包含屏幕截图的自动生成的Word文档中显示哪些注释。</p><p>更轻松的团队协作axure rp允许多人同时处理同一文件，使您的团队更容易协同工作。在Axure共享或SVN上创建团队项目，并使用签入和签出系统来管理更改。团队项目还会记录每次签到时的备注更改历史记录。</p><p>软件兼容性：</p><p>OS X 10.12或更高版本</p><p>软件语言：</p><p>多国语言（Chinese/English）</p><p>下载破解版本：</p><p>链接: <a href="https://pan.baidu.com/s/1dLfSxialAvRSk4tXlb-a0g" target="_blank" rel="noopener">https://pan.baidu.com/s/1dLfSxialAvRSk4tXlb-a0g</a> 提取码: d52e</p><h4 id="Polarr-Photo-Editor-Pro-For-Mac泼辣修图-V5-5-1"><a href="#Polarr-Photo-Editor-Pro-For-Mac泼辣修图-V5-5-1" class="headerlink" title="Polarr Photo Editor Pro For Mac泼辣修图 V5.5.1"></a>Polarr Photo Editor Pro For Mac泼辣修图 V5.5.1</h4><p>软件介绍：</p><p>泼辣修图Mac版是一款Mac OS平台上的修图软件，泼辣修图本身是一款非常出名的在线修图工具，现在泼辣修图继泼辣修图移动端之后，推出了泼辣修图Mac版。</p><p>功能介绍：</p><p>泼辣修图 Mac 版体积之小令人惊讶，仅有 4MB 的大小，却可并发出超高的性能表现，支持JPEG、带透明效果的PNG，以及大多数RAW图片，RAW图片最大可支持 4200 万像素，这样的表现还不会占用系统太多的硬件资源，而且耗电量也不高。</p><p>软件内核采用了 Webkit，方便用户对操作窗口进行随意调整，而且修图中支持 Trackpad 手势缩放控制。整个界面设计和功能都和 iOS 版一致，但并没有像 iOS 版那样提供滤镜内购包，如果你想使用这款客户端，就必须一次性买单，所有的滤镜包都会收入囊中，我觉得开发者能在这一点上再灵活一些，将滤镜包做成内购形式会更得用户支持！</p><p>使用泼辣修图你不必像 Pixelmator 那样费劲周转，就像妹子们用的美图秀秀一样，软件所有的功能都会修图而生，你可以在最短时间内修出一张完美的图片。</p><p>软件兼容性：<br>OS X 10.13或更高版本</p><p>软件语言：</p><p>多国语言（Chinese/English）</p><h4 id="Aimersoft-Video-Converter-Ultimate-For-Mac全能视频转换工具-V11-0-1-2"><a href="#Aimersoft-Video-Converter-Ultimate-For-Mac全能视频转换工具-V11-0-1-2" class="headerlink" title="Aimersoft Video Converter Ultimate For Mac全能视频转换工具 V11.0.1.2"></a>Aimersoft Video Converter Ultimate For Mac全能视频转换工具 V11.0.1.2</h4><p>软件介绍：<br>Aimersoft Video Converter Ultimate for Mac是一款Mac OS X下时尚、直观、非常迅速的一体化视频/音频转换器，DVD截取器，DVD刻录机，网页视频下载器和设备转化系统。</p><p>功能介绍：<br>1、轻松下载，编辑和转化任何规格和高清视频格式<br>2、在保持DVD原有质量的情况下截取，复制，编辑和刻录DVD<br>3、将您喜欢的音频从视频和DVD中截取出来并进行编辑和格式转换<br>4、将影音文件保存转移到各种可携式装置内，包括IPhone, Android等<br>5、将AVI,MP4,MOV,M4V,MKV等格式的2D视频转换为3D，打造属于自己的3D世界。</p><p>软件兼容性：<br>OS X 10.12或更高版本</p><p>软件语言：</p><p>英文语言（English）</p><p>链接: <a href="https://pan.baidu.com/s/1eb6ZoGjUrxrjVd9K1iI76Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1eb6ZoGjUrxrjVd9K1iI76Q</a> 提取码: ettx</p><h4 id="Bettertouchtool-For-Mac鼠标Magic-Mouse增强工具-V3-02"><a href="#Bettertouchtool-For-Mac鼠标Magic-Mouse增强工具-V3-02" class="headerlink" title="Bettertouchtool For Mac鼠标Magic Mouse增强工具 V3.02"></a>Bettertouchtool For Mac鼠标Magic Mouse增强工具 V3.02</h4><p>软件介绍：</p><p>Bettertouchtool for mac 这是专为Mac用户开发的 Magic Mouse 鼠标功能增强制作的软件。你可以通过 bettertouchtool for mac 对你的 Magic Mouse 设置多种手势功能，还可以对单个或者全局的软件进行操作功能定制。总体来说是一款非常强大的Magic Mouse 辅助软件。</p><p>功能介绍：</p><p>1.可实现不用点击而是触摸的方式操作。</p><p>2.支持多种手势，1个，2个，3个手指的操作。</p><p>3.支持缩放操作。</p><p>4.可以实现对全局和单个软件的操作定制。</p><p>你还可以对TouchPad可以进行相同的设置。也可以调节鼠标移动缓慢的问题。实现控制之后你会发现 Magic Mouse 的功能比MouseZoom要强大的多。</p><p>软件兼容性：</p><p>OS X 10.12或更高版本</p><p>软件语言：</p><p>英文语言（English）</p><p>链接: <a href="https://pan.baidu.com/s/1RdJwPUNyk0CivSk64mHcXw" target="_blank" rel="noopener">https://pan.baidu.com/s/1RdJwPUNyk0CivSk64mHcXw</a> 提取码: xe4s</p><h4 id="CleanMyMac-X-For-Mac强大实用的系统清理工具-V4-4-2"><a href="#CleanMyMac-X-For-Mac强大实用的系统清理工具-V4-4-2" class="headerlink" title="CleanMyMac X For Mac强大实用的系统清理工具 V4.4.2"></a>CleanMyMac X For Mac强大实用的系统清理工具 V4.4.2</h4><p>软件介绍：</p><p>CleanMyMac 系列最新X测试版本，CleanMyMac应该是世界上最容易使用且最强大的Mac实用系统清理工具，CleanMyMac X是一款集所有功能于一身的先进程序卸载清理器，只需两个简单步骤就可以把系统里那些乱七八糟的无用文件统统清理掉，节省宝贵的磁盘空间。</p><p>功能介绍：</p><p>作为CleanMyMac的升级版，它可以流畅地与系统性能相结合，静默清理、记录更新、清洁缓存、快速和安全删除、卸载应用程序和清空回收站等重要功能。节省硬盘空间，提高电脑的速度，CleanMyMac 3会使您的Mac更出色</p><p>点击右下角的“Scan”按钮，CleanMyMac将对整个系统进行扫描.</p><p>Caches：系统缓存文件，清理缓存文件后应用程序加载速度将会变得很快。</p><p>Logs：系统和应用程序的日志文件.</p><p>Language Files：通过此项你可以把你应用程序里面不常用的语言全都给删除，在右下角可以选择你需要删除好的语言。</p><p>CleanMyMac为你喜欢的东西腾出空间。CleanMyMac拥有一系列巧妙的新功能，它可以让你安全、智能地扫描和清理整个系统，删除大量未使用的文件，缩小iPhoto库的大小，卸载不需要的应用程序，或者修复那些开始不正常工作的应用程序，从一个地方管理所有的扩展，并做更多的工作–所有这些都来自一个新设计的漂亮简单的界面。</p><p>链接:<a href="https://pan.baidu.com/s/1XUY3etjrfcdd0KJ-J6EMfA" target="_blank" rel="noopener">https://pan.baidu.com/s/1XUY3etjrfcdd0KJ-J6EMfA</a>  密码:avj7</p><h4 id="OnyX-For-Mac系统维护优化工具-V3-6-4"><a href="#OnyX-For-Mac系统维护优化工具-V3-6-4" class="headerlink" title="OnyX For Mac系统维护优化工具 V3.6.4"></a>OnyX For Mac系统维护优化工具 V3.6.4</h4><p>软件介绍：<br>OnyX 可以帮助你检视启动的磁盘信息和文件系统的结构信息，而且可以运行很多的系统维护子程序，比如配置Finder,Dock, Dashboard, Exposé, Safari, Login window中的一些隐藏的功能。</p><p>功能介绍：<br>OnyX 是一种多功能实用的OS X，它允许您验证启动盘的系统文件的结构，运行系统维护的相关任务，配置Finder，隐藏参数对接，聚光灯，和一些苹果自己的应用程序，删除缓存，删除一定数量文件和文件夹可能成为累赘，和更多。</p><p>软件兼容性：<br>OS X 10.13或更高版本</p><p>软件语言：<br>多国语言（Chinese/English）</p><p>链接: <a href="https://pan.baidu.com/s/1Oqam_kPoS0MJOl-JawL72w" target="_blank" rel="noopener">https://pan.baidu.com/s/1Oqam_kPoS0MJOl-JawL72w</a> 提取码: mcta</p><h4 id="macOS-Mojave-下的破解失效或崩溃的解决方法"><a href="#macOS-Mojave-下的破解失效或崩溃的解决方法" class="headerlink" title="macOS Mojave 下的破解失效或崩溃的解决方法"></a>macOS Mojave 下的破解失效或崩溃的解决方法</h4><p><strong>Mac**</strong>开启关闭<strong><strong>SIP</strong></strong>（系统完整性保护）**</p><p><strong>1. 如何查看SIP状态</strong></p><p>在终端中输入csrutil status，就可以看到是enabled还是disabled。（只要显示 disabled 说明已经禁用SIP）</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/001_fa6bge.png" srcset="/img/loading.gif" alt=""></p><p><strong>2. 如何关闭SIP</strong></p><p>a 重启MAC，按住cmd+R直到屏幕上出现苹果的标志和进度条，进入Recovery模式</p><p>b 在屏幕最上方的工具栏找到实用工具（左数第3个），打开终端，输入：csrutil disable</p><p>c 关掉终端，重启MAC</p><p><strong>3. 如何开启SIP</strong></p><p>与关闭的步骤类似，只是在2b中输入csrutil enable 即可</p><h4 id="10个-macOS-小技巧"><a href="#10个-macOS-小技巧" class="headerlink" title="10个 macOS 小技巧"></a>10个 macOS 小技巧</h4><p><strong>1.教你打出苹果logo</strong></p><p>快捷键：option+shift+K</p><p><strong>2.如何设置网红屏保</strong></p><p>站内搜索 fliqlo,下载后双击打开即可，记得设置「开机前闲置时间」哦，如果设置为两分钟，那么你的电脑在没有任何操作的情况下，两分钟之后屏保就会自动显示了。</p><p><strong>3.快速清除废纸篓垃圾</strong></p><p>使用下面的快捷键可以让你不用打开废纸篓，也不用要求你是否确认删除，直接可将废纸篓垃圾清空。</p><p>快捷键:「⌘+Option+Shift+Delete」</p><p><strong>4.更精确的调节音量和亮度</strong></p><p>Mac上的调节音量或者亮度只有16格，精确度不够高，有时调节一个单位还是不能满足我们的需求，这时候我们就需要更高精度的调节。</p><p>快捷键：Option + Shift + 音量键（亮度键）</p><p><strong>5.更精确的复制内容</strong></p><p>如果你用 Mac 自带的预览复制 PDF 中的内容时，它会选中你鼠标开始到结束之间的所有内容，但是对于表格来说，我们有时不必要复制所有内容，这时我们可以按住「option」键再选择所需的内容。</p><p><strong>6.移动或删除菜单栏图标</strong></p><p>如果你的状态菜单栏的图标比较多的话，想要删除的话怎么办呢？这时可以按住「command」键，再拖动相应的图标，移出菜单栏即可删除。</p><p><strong>7.放大你的屏幕</strong></p><p>设置：点击左上角苹果logo「」-&gt;「系统偏好设置」-&gt;「辅助功能」-&gt;选择「缩放」-&gt;勾选「配合修饰键使用滚动手势来缩放」</p><p>使用：按住「control」键，两个手指在触摸板上向上或者向下移动即可进行放大或缩小</p><p><strong>8.你可能不知道的截屏技巧</strong></p><p>全屏截图：shift+command+3</p><p>部分截屏：shift+command+4</p><p>下面才是关键：部分截屏时配合空格还有两种截屏方式</p><p>1.shift+command+4+「空格」 选取固定窗口</p><p>2.shift+command+4后框选后按住「空格」键拖动选框 自定义选择窗口</p><p><strong>9.开启分屏显示功能</strong></p><p>有时候需要两个窗口同时打开协同工作时，这个功能就非常的有帮助了，</p><p>你只需要三指按压软件窗口的最大化按钮直到出现分屏即可。</p><p><strong>10.屏幕太小？那就多开几个窗口</strong></p><p>一个屏幕不够用的时候，我们可以再新建几个空白屏幕，这时我们只需四指在触摸板向上滑动，点击最右侧的「+号」即可。删除的话只需将鼠标移到每一个屏幕上，出现「叉号」并点击删除即可。</p><h4 id="Mac-软件安装问题解决"><a href="#Mac-软件安装问题解决" class="headerlink" title="Mac 软件安装问题解决"></a>Mac 软件安装问题解决</h4><p>在 Mac 上安装非 App Store 软件时，可能会遇到一些这样或那样的问题，这篇文章就 Mac 从 .dmg 安装软件时可能遇到的问题提一些解决方法。</p><p><strong>状况一.双击 .dmg 安装软件出现以下情况：</strong></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/2_qc1omp.jpg" srcset="/img/loading.gif" alt="img"></p><p>解决方法：这种情况可能是 .dmg 文件在下载过程中出现了未知错误或者没有下载完全，解决方法是重新下载 .dmg 安装包。</p><p><strong>状况二.双击 .dmg 安装软件出现：打不开“XXXX”，因为它来自身份不明的开发者。</strong></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/3_m8shm7.jpg" srcset="/img/loading.gif" alt="img"></p><p><strong>或者，“XXXX”已损坏，打不开。您应该将它移到废纸篓。</strong></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/4_ihdffi.jpg" srcset="/img/loading.gif" alt="img"></p><p>解决方法：打开 系统偏好设置 — 安全性与隐私 — 通用</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/5_fx56mv.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/6_c4lp6p.jpg" srcset="/img/loading.gif" alt="img"></p><p>点按锁按钮以进行更改（会要求输入密码），</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/7_n9c1oc.jpg" srcset="/img/loading.gif" alt="img"></p><p>在 “允许从以下位置下载应用：” 选择 “任何来源” ，</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/8_tven3i.jpg" srcset="/img/loading.gif" alt="img"></p><p>最后将锁按钮锁上。</p><p>有的 Mac 在 “允许从以下位置下载的应用” 并没有 “任何来源” 这个选项，</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/10_gnobok.jpg" srcset="/img/loading.gif" alt="img"></p><p>这就需要多进行一个步骤：</p><p>找到“终端”这个应用并打开，将 sudo spctl –master-disable 这句命令复制并粘贴到终端，回车，输入密码（用户开机密码，密码是不显示的，输入完回车即可）。</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/13_n4c0tv.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/11_amxk2p.jpg" srcset="/img/loading.gif" alt="img"></p><p>再打开 系统偏好设置 — 安全性与隐私 — 通用 — 允许从以下位置下载的应用 ，系统已经选择 “任何来源” 选项。</p><p>对于 “XXXX”已损坏，打不开。您应该将它移到废纸篓。 这个问题，还有一个解决方法，不过不如上面这个彻底，还是介绍一下。</p><p>将 <code>xattr -r -d com.apple.quarantine</code> 命令复制粘贴到终端，同时在一旁打开 访达（Finder），在边栏里选择应用程序，然后将出现这个问题的应用往终端里拖拽，释放鼠标，回车，问题解决。</p><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>资源</category>
      
      <category>mac</category>
      
    </categories>
    
    
    <tags>
      
      <tag>资源</tag>
      
      <tag>mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随谈2</title>
    <link href="/2019/03/27/%E9%9A%8F%E8%B0%882/"/>
    <url>/2019/03/27/%E9%9A%8F%E8%B0%882/</url>
    
    <content type="html"><![CDATA[<p>年轻时总是逢人就说自己的理想 </p><p>那个时候没有顾忌 </p><p>随心所欲的可以高谈阔论 </p><p>没有任何束缚 </p><p>总觉得凭借自己的一腔热血 </p><p>梦想这东西并不是遥不可及 </p><a id="more"></a><p>后来只和几个要好的朋友谈谈未来 </p><p>开始有所保留 </p><p>总觉得未来这事情不需要太多人知道 </p><p>只要默默努力就好 </p><p>总是相信只要努力 </p><p>未来并不是那么遥遥无期 </p><p>现在再也不和任何人讨论生活 </p><p>才开始明白 </p><p>其实生活是自己的 </p><p>和他人无关 </p><p>只会在夜深人静的时候仍然敲打这键盘 </p><p>把这一天未完成的事情做完 </p><p>原来生活就是每天重复做着一些琐碎的事情 </p><p>从年少无知到成人的世界 </p><p>从闹腾任性的个性到成熟冷静 </p><p>我们终究还是变了 </p><p>唯愿初心不变 </p><p>年轻时候的梦依旧在心中</p>]]></content>
    
    
    <categories>
      
      <category>文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文章</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随谈</title>
    <link href="/2019/03/27/%E9%9A%8F%E8%B0%88/"/>
    <url>/2019/03/27/%E9%9A%8F%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<p>曾经我也坐在工位笑别人， </p><p>那个人那么傻， 不就是被辞职了么，为什么要跳楼？</p><p>笑他傻，笑他看不懂，笑他想不开， 笑他不配做一个合格的丈夫， 不配为人之父…</p><a id="more"></a><p>但是今天我才发现，</p><p>是的，被离职是一件简简单单的事情，</p><p>家里的妻儿，未出生的花蕾，年迈的父母，</p><p>我也想不出能用什么面容来面对他们，</p><p>我担心我沮丧的心情会带给妻子压力，</p><p>我担心我失落的表情让父母有压力， </p><p>我担心我没办法照顾好妻儿。</p><p>一份好的工作对我来说是多么的幸福？</p><p>一份我喜欢的工作是对我的生活以及家庭的生活多大的保障？</p><p>但是现在呢？ </p><p>我几乎一无所有，不对我还有我爱的和爱我的家人…</p><p>如果不是他们，哪里还有这么幸福的我呢？ </p><p>但是我怎么能保障他们的生活呢… </p><p>或许我开始慢慢懂了，慢慢懂了那跳下去的一瞬间是多么的轻松，</p><p>或许下一秒就已经后悔了， 我还有我的家人们啊，</p><p>但是已经晚了， 我没有办法选择我现在就停止在半空中等待大家救援我， </p><p>但是那一瞬间真的很轻松，</p><p> 前所未有的放松，</p><p>让我很享受跳下来的这个过程， </p><p>甚至在跳下来的途中，</p><p>我能看到10楼的夫妻在争吵，</p><p>我能看到9楼的那个小伙子正在拼命的提升自己…</p><p>在下落的过程中我很享受， </p><p>享受的每一秒甚至每一毫秒…</p><p>慢慢的， </p><p>我的泪落从双眼涌出， </p><p>我爱的妻子，将承担这我遗留下的一切，</p><p>我完美的家庭就此破灭，</p><p>妻子将一辈子沉浸在悲伤中…</p><p>还有我的孩子…</p><p>我的年迈的父母亲， </p><p>我不能倒下，</p><p>我是一个七尺男儿，</p><p>我要为自己的家庭奋斗，</p><p>我要努力的照顾好这个世界上一直默默为我支持打气的他们…</p><p>我还有很多事没有做…</p><p>我不能就此倒下…</p><p>但是又有什么用呢…</p><p>我还在努力的往下掉…</p><p>直到下一刻…</p><p>我彻底摆脱了这个属于我的而且只属于我的世界…</p><p>我彻底摆脱了这个不属于我而且不属于任何人的世界…</p>]]></content>
    
    
    <categories>
      
      <category>文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文章</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS下安装FreeTDS</title>
    <link href="/2019/03/15/CentOS%E4%B8%8B%E5%AE%89%E8%A3%85FreeTDS/"/>
    <url>/2019/03/15/CentOS%E4%B8%8B%E5%AE%89%E8%A3%85FreeTDS/</url>
    
    <content type="html"><![CDATA[<h5 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h5><blockquote><p>官方网站：<a href="http://www.freetds.org" target="_blank" rel="noopener">http://www.freetds.org</a></p><p>下载地址：<a href="http://ibiblio.org/pub/Linux/ALPHA/freetds/stable/freetds-stable.tgz" target="_blank" rel="noopener">http://ibiblio.org/pub/Linux/ALPHA/freetds/stable/freetds-stable.tgz</a></p><p>这个软件能够用Linux和Unix连接MS SQLServer和Sybase数据库</p></blockquote><h5 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h5><ol><li><p>首先下载FreeTDS安装包到服务器</p><pre><code class="hljs shell">wget -c http://ibiblio.org/pub/Linux/ALPHA/freetds/stable/freetds-stable.tgz</code></pre><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymrluiwrj319s08mdjy.jpg" srcset="/img/loading.gif" alt="1"></p><a id="more"></a></li><li><p>解压</p><pre><code class="hljs shell">tar -zxvf freetds-stable.tgz</code></pre><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymrmqhzqj30xf0k2435.jpg" srcset="/img/loading.gif" alt="2"></p></li><li><p>编译安装</p><ol><li><p>因为是编译安装所以确保机器有安装gcc（可使用yum进行安装）</p><pre><code class="hljs shell">yum install gcc-c++yum install ncurses-devel</code></pre></li><li><p>开始安装</p><pre><code class="hljs shell">cd freetds-0.91/./configure --prefix=/usr/local/freetds --with-tdsver=8.0 --enable-msdblibmake &amp;&amp; makeinstall</code></pre><p>`解释：</p><pre><code>安装freetds到目录/usr/local/freetds：--prefix=/usr/local/freetds支持MSSQL2000：--with-tdsver=8.0 --enable-msdblib`</code></pre></li></ol><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymrnq2tqj318f02ydgf.jpg" srcset="/img/loading.gif" alt="3"></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymrp4l6oj30o40pm10k.jpg" srcset="/img/loading.gif" alt="4"></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymrri8e3j31a30pbe34.jpg" srcset="/img/loading.gif" alt="5"></p></li><li><p>FreeTDS默认安装在/usr/local/freetds目录当中，库文件在相应的lib目录下。</p><p><code>vim /etc/ld.so.conf</code>加入一行 <code>/usr/local/freetds/lib</code></p></li><li><p>然后运行以下指令使更改生效：</p><pre><code class="hljs bash">ldconfig</code></pre></li><li><p>测试连接</p><p><code>tsql -H MSSQL服务器服务IP -p 1433 -U MSSQL服务器登陆帐号 －P MSSQL服务器登陆密码</code></p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash">  tsql -H XXXXXX-p 1433 -U sa -P XXXXXX -D <span class="hljs-built_in">test</span>  </span>locale is "zh_CN.utf8"  locale charset is "UTF-8"  Default database being set to test  <span class="hljs-meta">1&gt;</span><span class="bash"> select @@version  </span><span class="hljs-meta">2&gt;</span><span class="bash"> go  </span>  Microsoft SQL Server 2008 R2 (RTM) - 10.50.1600.1 (Intel X86)          Apr  2 2010 15:53:02          Copyright (c) Microsoft Corporation          Data Center Edition on Windows NT 5.1 &lt;X86&gt; (Build 2600: Service Pack 3)    (1 row affected)</code></pre><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p> <strong>Adaptive Server connection failed</strong></p><pre><code class="hljs shell">locale is "en_US.UTF-8"locale charset is "UTF-8"using default charset "UTF-8"Error 20017 (severity 9):        Unexpected EOF from the server        OS error 115, "Operation now in progress"Error 20002 (severity 9):        Adaptive Server connection failedThere was a problem connecting to the server</code></pre><p>执行<code>tsql -C</code></p><pre><code class="hljs shell">[root@thinkpa freetds-0.91]# tsql -CCompile-time settings (established with the "configure" script)                            Version: freetds v0.91             freetds.conf directory: /usr/local/etc     MS db-lib source compatibility: no        Sybase binary compatibility: no                      Thread safety: yes                      iconv library: yes                        TDS version: 5.0                              iODBC: no                           unixodbc: no              SSPI "trusted" logins: no                           Kerberos: no</code></pre><p>发现freetds的版本是5.0，考虑到可能是freetds版本的问题</p><p>两种解决方式：</p><ol><li><p>修改全局TDS 版本号</p><p>找到<code>/usr/local/etc/freetds.conf</code>修改<code>[global]</code>下面的<code>tds version</code>为<code>8.0</code></p></li><li><p>连接时修改tds版本号</p><p><code>TDSVER=7.0 tsql -H</code></p><p>整个连接命令则变为：</p><p><code>tsql -H MSSQL服务器服务IP -p 1433 -U MSSQL服务器登陆帐号 －P MSSQL服务器登陆密码</code></p><p><strong>Adaptive Server connection failed</strong></p></li></ol><pre><code class="hljs shell">"Cannot open server 'xxxxxxx' requested by the login. Client with IP    address 'xxxxxxxxx' is not allowed to access the server.  To enable       access, use the Windows Azure Management Portal or run                   sp_set_firewall_rule on the master database to create a firewall       rule for this IP address or address range.  It may take up to five       minutes for this change to take effect."Error 20002 (severity 9):        Adaptive Server connection failed</code></pre><p>这个毋庸置疑了，找管理员开通白名单再访问吧！</p></li></ol><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>FreeTDS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FreeTDS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin-基本数据类型</title>
    <link href="/2019/03/15/Kotlin-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2019/03/15/Kotlin-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h5 id="Kotlin-基本数据类型"><a href="#Kotlin-基本数据类型" class="headerlink" title="Kotlin 基本数据类型"></a>Kotlin 基本数据类型</h5><blockquote><p>Kotlin 的基本数值类型包括 Byte、Short、Int、Long、Float、Double 等。不同于Java的是，字符不属于数值类型，是一个独立的数据类型。</p></blockquote><table><thead><tr><th>类型</th><th>位宽度</th></tr></thead><tbody><tr><td>Double</td><td>64</td></tr><tr><td>Float</td><td>32</td></tr><tr><td>Long</td><td>64</td></tr><tr><td>Int</td><td>32</td></tr><tr><td>Short</td><td>16</td></tr><tr><td>Byte</td><td>8</td></tr></tbody></table><a id="more"></a><h5 id="字面常量"><a href="#字面常量" class="headerlink" title="字面常量"></a>字面常量</h5><p>下面是所有类型的字面常量：</p><ul><li>十进制：123</li><li>长整型以大写的 L 结尾：123L</li><li>16 进制以 0x 开头：0x0F</li><li>2 进制以 0b 开头：0b00001011</li><li>注意：8进制不支持</li></ul><p>Kotlin 同时也支持传统符号表示的浮点数值：</p><ul><li>Doubles 默认写法: <code>123.5</code>, <code>123.5e10</code></li><li>Floats 使用 f 或者 F 后缀：<code>123.5f</code></li></ul><p>你可以使用下划线使数字常量更易读：</p><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> oneMillion = <span class="hljs-number">1_000_000</span><span class="hljs-keyword">val</span> creditCardNumber = <span class="hljs-number">1234_5678_9012_3456L</span><span class="hljs-keyword">val</span> socialSecurityNumber = <span class="hljs-number">999_99_9999L</span><span class="hljs-keyword">val</span> hexBytes = <span class="hljs-number">0xFF_EC_DE_5E</span><span class="hljs-keyword">val</span> bytes = <span class="hljs-number">0b11010010_01101001_10010100_10010010</span></code></pre><h5 id="比较两个数字"><a href="#比较两个数字" class="headerlink" title="比较两个数字"></a>比较两个数字</h5><p>Kotlin 中没有基础数据类型，只有封装的数字类型，你每定义的一个变量，其实 Kotlin 帮你封装了一个对象，这样可以保证不会出现空指针。数字类型也一样，所有在比较两个数字的时候，就有比较数据大小和比较两个对象是否相同的区别了。</p><p>在 Kotlin 中，三个等号 === 表示比较对象地址，两个 == 表示比较两个值大小。</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;    <span class="hljs-keyword">val</span> a: <span class="hljs-built_in">Int</span> = <span class="hljs-number">10000</span>    println(a === a) <span class="hljs-comment">// true，值相等，对象地址相等</span>    <span class="hljs-comment">//经过了装箱，创建了两个不同的对象</span>    <span class="hljs-keyword">val</span> boxedA: <span class="hljs-built_in">Int</span>? = a    <span class="hljs-keyword">val</span> anotherBoxedA: <span class="hljs-built_in">Int</span>? = a    <span class="hljs-comment">//虽然经过了装箱，但是值是相等的，都是10000</span>    println(boxedA === anotherBoxedA) <span class="hljs-comment">//  false，值相等，对象地址不一样</span>    println(boxedA == anotherBoxedA) <span class="hljs-comment">// true，值相等</span>&#125;</code></pre><h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><p>由于不同的表示方式，较小类型并不是较大类型的子类型，较小的类型不能隐式转换为较大的类型。 这意味着在不进行显式转换的情况下我们不能把 Byte 型值赋给一个 Int 变量。</p><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> b: <span class="hljs-built_in">Byte</span> = <span class="hljs-number">1</span> <span class="hljs-comment">// OK, 字面值是静态检测的</span><span class="hljs-keyword">val</span> i: <span class="hljs-built_in">Int</span> = b <span class="hljs-comment">// 错误</span></code></pre><p>我们可以代用其toInt()方法。</p><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> b: <span class="hljs-built_in">Byte</span> = <span class="hljs-number">1</span> <span class="hljs-comment">// OK, 字面值是静态检测的</span><span class="hljs-keyword">val</span> i: <span class="hljs-built_in">Int</span> = b.toInt() <span class="hljs-comment">// OK</span></code></pre><p>每种数据类型都有下面的这些方法，可以转化为其它的类型：</p><pre><code class="hljs kotlin">toByte(): <span class="hljs-built_in">Byte</span>toShort(): <span class="hljs-built_in">Short</span>toInt(): <span class="hljs-built_in">Int</span>toLong(): <span class="hljs-built_in">Long</span>toFloat(): <span class="hljs-built_in">Float</span>toDouble(): <span class="hljs-built_in">Double</span>toChar(): <span class="hljs-built_in">Char</span></code></pre><p>有些情况下也是可以使用自动类型转化的，前提是可以根据上下文环境推断出正确的数据类型而且数学操作符会做相应的重载。例如下面是正确的：</p><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> l = <span class="hljs-number">1L</span> + <span class="hljs-number">3</span> <span class="hljs-comment">// Long + Int =&gt; Long</span></code></pre><h5 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h5><p>对于Int和Long类型，还有一系列的位操作符可以使用，分别是：</p><pre><code class="hljs kotlin">shl(bits) – 左移位 (Java’s &lt;&lt;)shr(bits) – 右移位 (Java’s &gt;&gt;)ushr(bits) – 无符号右移位 (Java’s &gt;&gt;&gt;)and(bits) – 与or(bits) – 或xor(bits) – 异或inv() – 反向</code></pre><h5 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h5><p>和 Java 不一样，Kotlin 中的 Char 不能直接和数字操作，Char 必需是单引号 <strong>‘</strong> 包含起来的。比如普通字符 ‘0’，’a’。</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">check</span><span class="hljs-params">(c: <span class="hljs-type">Char</span>)</span></span> &#123;    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 错误：类型不兼容</span>        <span class="hljs-comment">// ……</span>    &#125;&#125;</code></pre><p>字符字面值用单引号括起来: ‘1’。 特殊字符可以用反斜杠转义。 支持这几个转义序列：\t、 \b、\n、\r、&#39;、&quot;、\ 和 $。 编码其他字符要用 Unicode 转义序列语法：’\uFF00’。</p><p>我们可以显式把字符转换为 Int 数字：</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">decimalDigitValue</span><span class="hljs-params">(c: <span class="hljs-type">Char</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;    <span class="hljs-keyword">if</span> (c !<span class="hljs-keyword">in</span> <span class="hljs-string">'0'</span>..<span class="hljs-string">'9'</span>)        <span class="hljs-keyword">throw</span> IllegalArgumentException(<span class="hljs-string">"Out of range"</span>)    <span class="hljs-keyword">return</span> c.toInt() - <span class="hljs-string">'0'</span>.toInt() <span class="hljs-comment">// 显式转换为数字</span>&#125;</code></pre><p>当需要可空引用时，像数字、字符会被装箱。装箱操作不会保留同一性。</p><h5 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h5><p>布尔用 Boolean 类型表示，它有两个值：true 和 false。</p><p>若需要可空引用布尔会被装箱。</p><p>内置的布尔运算有：</p><pre><code class="hljs kotlin">|| – 短路逻辑或&amp;&amp; – 短路逻辑与! - 逻辑非</code></pre><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>数组用类 Array 实现，并且还有一个 size 属性及 get 和 set 方法，由于使用 [] 重载了 get 和 set 方法，所以我们可以通过下标很方便的获取或者设置数组对应位置的值。</p><p>数组的创建两种方式：一种是使用函数arrayOf()；另外一种是使用工厂函数。如下所示，我们分别是两种方式创建了两个数组：</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;    <span class="hljs-comment">//[1,2,3]</span>    <span class="hljs-keyword">val</span> a = arrayOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)    <span class="hljs-comment">//[0,2,4]</span>    <span class="hljs-keyword">val</span> b = Array(<span class="hljs-number">3</span>, &#123; i -&gt; (i * <span class="hljs-number">2</span>) &#125;)    <span class="hljs-comment">//读取数组内容</span>    println(a[<span class="hljs-number">0</span>])    <span class="hljs-comment">// 输出结果：1</span>    println(b[<span class="hljs-number">1</span>])    <span class="hljs-comment">// 输出结果：2</span>&#125;</code></pre><p>如上所述，[] 运算符代表调用成员函数 get() 和 set()。</p><p>注意: 与 Java 不同的是，Kotlin 中数组是不型变的（invariant）。</p><p>除了类Array，还有ByteArray, ShortArray, IntArray，用来表示各个类型的数组，省去了装箱操作，因此效率更高，其用法同Array一样：</p><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> x: IntArray = intArrayOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)x[<span class="hljs-number">0</span>] = x[<span class="hljs-number">1</span>] + x[<span class="hljs-number">2</span>]</code></pre><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>和 Java 一样，String 是不可变的。方括号 [] 语法可以很方便的获取字符串中的某个字符，也可以通过 for 循环来遍历：</p><pre><code class="hljs kotlin"><span class="hljs-keyword">for</span> (c <span class="hljs-keyword">in</span> str) &#123;    println(c)&#125;</code></pre><p>Kotlin 支持三个引号 “”” 扩起来的字符串，支持多行字符串，比如：</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;    <span class="hljs-keyword">val</span> text = <span class="hljs-string">"""</span><span class="hljs-string">    多行字符串</span><span class="hljs-string">    多行字符串</span><span class="hljs-string">    """</span><span class="hljs-string">    println(text)   // 输出有一些前置空格</span><span class="hljs-string">&#125;</span></code></pre><p>String 可以通过 trimMargin() 方法来删除多余的空白。</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;    <span class="hljs-keyword">val</span> text = <span class="hljs-string">"""</span><span class="hljs-string">    |多行字符串</span><span class="hljs-string">    |Kotlin教程</span><span class="hljs-string">    |多行字符串</span><span class="hljs-string">    |Kotlin</span><span class="hljs-string">    """</span>.trimMargin()    println(text)    <span class="hljs-comment">// 前置空格删除了</span>&#125;</code></pre><p>默认 | 用作边界前缀，但你可以选择其他字符并作为参数传入，比如 trimMargin(“&gt;”)。</p><h5 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h5><p>字符串可以包含模板表达式 ，即一些小段代码，会求值并把结果合并到字符串中。 模板表达式以美元符（$）开头，由一个简单的名字构成:</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;    <span class="hljs-keyword">val</span> i = <span class="hljs-number">10</span>    <span class="hljs-keyword">val</span> s = <span class="hljs-string">"i = <span class="hljs-variable">$i</span>"</span> <span class="hljs-comment">// 求值结果为 "i = 10"</span>    println(s)&#125;</code></pre><p>或者用花括号扩起来的任意表达式:</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;    <span class="hljs-keyword">val</span> s = <span class="hljs-string">"kotlin"</span>    <span class="hljs-keyword">val</span> str = <span class="hljs-string">"<span class="hljs-variable">$s</span>.length is <span class="hljs-subst">$&#123;s.length&#125;</span>"</span> <span class="hljs-comment">// 求值结果为 "kotlin.length is 6"</span>    println(str)&#125;</code></pre><p>原生字符串和转义字符串内部都支持模板。 如果你需要在原生字符串中表示字面值 $ 字符（它不支持反斜杠转义），你可以用下列语法：</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;    <span class="hljs-keyword">val</span> price = <span class="hljs-string">"""</span><span class="hljs-string">    <span class="hljs-subst">$&#123;<span class="hljs-string">'$'</span>&#125;</span>9.99</span><span class="hljs-string">    """</span><span class="hljs-string">    println(price)  // 求值结果为 $9.99</span><span class="hljs-string">&#125;</span></code></pre><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin-基础语法</title>
    <link href="/2019/03/14/Kotlin-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2019/03/14/Kotlin-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h5 id="Kotlin基础语法"><a href="#Kotlin基础语法" class="headerlink" title="Kotlin基础语法"></a>Kotlin基础语法</h5><p>Kotlin文件以.kt为后缀</p><h5 id="Kotlin包声明"><a href="#Kotlin包声明" class="headerlink" title="Kotlin包声明"></a>Kotlin包声明</h5><p>代码文件的开头一般为包的声明</p><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.kotlin01.main<span class="hljs-keyword">import</span> java.util.*<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Kotlin01</span> </span>&#123;&#125;</code></pre><p>kotlin源文件不需要相匹配的目录和包，源文件可以放在任何文件目录。</p><a id="more"></a><p>以上例中 test() 的全名是 com.kotlin01.main.test、Kotlin01的全名是 com.kotlin01.main.Kotlin01。</p><p>如果没有指定包，默认为 <strong>default</strong> 包。</p><h6 id="默认导入"><a href="#默认导入" class="headerlink" title="默认导入"></a>默认导入</h6><p>有多个包会默认导入到每个 Kotlin 文件中：</p><ul><li><p>kotlin.*</p></li><li><p>kotlin.annotation.*</p></li><li><p>kotlin.collections.*</p></li><li><p>kotlin.comparisons.*</p></li><li><p>kotlin.io.*</p></li><li><p>kotlin.ranges.*</p></li><li><p>kotlin.sequences.*</p></li><li><p>kotlin.text.*</p></li></ul><h5 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h5><p>函数定义使用关键字 fun，参数格式为：参数 : 类型</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sum</span><span class="hljs-params">(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;   <span class="hljs-comment">// Int 参数，返回值 Int</span>    <span class="hljs-keyword">return</span> a + b&#125;</code></pre><p>表达式作为函数体，返回类型自动推断：</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sum</span><span class="hljs-params">(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>)</span></span> = a + b<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sum</span><span class="hljs-params">(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = a + b   <span class="hljs-comment">// public 方法则必须明确写出返回类型</span></code></pre><p>无返回值的函数(Java中的void)：</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printSum</span><span class="hljs-params">(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Unit</span> &#123;     print(a + b)&#125;<span class="hljs-comment">// 如果是返回 Unit类型，则可以省略(对于public方法也是这样)：</span><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printSum</span><span class="hljs-params">(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>)</span></span> &#123;     print(a + b)&#125;</code></pre><h6 id="可变长参数函数"><a href="#可变长参数函数" class="headerlink" title="可变长参数函数"></a>可变长参数函数</h6><p>函数的变长参数可以用 <strong>vararg</strong> 关键字进行标识：</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">vars</span><span class="hljs-params">(<span class="hljs-keyword">vararg</span> v:<span class="hljs-type">Int</span>)</span></span>&#123;    <span class="hljs-keyword">for</span>(vt <span class="hljs-keyword">in</span> v)&#123;        print(vt)    &#125;&#125;<span class="hljs-comment">// 测试</span><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;    vars(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)  <span class="hljs-comment">// 输出12345</span>&#125;</code></pre><h6 id="lambda-匿名函数"><a href="#lambda-匿名函数" class="headerlink" title="lambda(匿名函数)"></a>lambda(匿名函数)</h6><p>lambda表达式使用实例：</p><pre><code class="hljs plain">&#x2F;&#x2F; 测试fun main(args: Array&lt;String&gt;) &#123;    val sumLambda: (Int, Int) -&gt; Int &#x3D; &#123;x,y -&gt; x+y&#125;    println(sumLambda(1,2))  &#x2F;&#x2F; 输出 3&#125;</code></pre><h5 id="定义常量与变量"><a href="#定义常量与变量" class="headerlink" title="定义常量与变量"></a>定义常量与变量</h5><p>可变变量定义：var 关键字</p><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt;</code></pre><p>不可变变量定义：val 关键字，只能赋值一次的变量(类似Java中final修饰的变量)</p><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt;</code></pre><p>常量与变量都可以没有初始化值,但是在引用前必须初始化</p><p>编译器支持自动类型判断,即声明时可以不指定类型,由编译器判断。</p><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> a: <span class="hljs-built_in">Int</span> = <span class="hljs-number">1</span><span class="hljs-keyword">val</span> b = <span class="hljs-number">1</span>       <span class="hljs-comment">// 系统自动推断变量类型为Int</span><span class="hljs-keyword">val</span> c: <span class="hljs-built_in">Int</span>      <span class="hljs-comment">// 如果不在声明时初始化则必须提供变量类型</span>c = <span class="hljs-number">1</span>           <span class="hljs-comment">// 明确赋值</span><span class="hljs-keyword">var</span> x = <span class="hljs-number">5</span>        <span class="hljs-comment">// 系统自动推断变量类型为Int</span>x += <span class="hljs-number">1</span>           <span class="hljs-comment">// 变量可修改</span></code></pre><h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><p>Kotlin 支持单行和多行注释，实例如下：</p><pre><code class="hljs kotlin"><span class="hljs-comment">// 这是一个单行注释</span><span class="hljs-comment">/* 这是一个多行的</span><span class="hljs-comment">   块注释。 */</span></code></pre><p>与 Java 不同, <strong>Kotlin 中的块注释允许嵌套</strong>。</p><h5 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h5><p>$ 表示一个变量名或者变量值</p><p>$varName 表示变量值</p><p>${varName.fun()} 表示变量的方法返回值:</p><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><span class="hljs-comment">// 模板中的简单名称：</span><span class="hljs-keyword">val</span> s1 = <span class="hljs-string">"a is <span class="hljs-variable">$a</span>"</span> a = <span class="hljs-number">2</span><span class="hljs-comment">// 模板中的任意表达式：</span><span class="hljs-keyword">val</span> s2 = <span class="hljs-string">"<span class="hljs-subst">$&#123;s1.replace(<span class="hljs-string">"is"</span>, <span class="hljs-string">"was"</span>)&#125;</span>, but now is <span class="hljs-variable">$a</span>"</span></code></pre><h5 id="NULL检查机制"><a href="#NULL检查机制" class="headerlink" title="NULL检查机制"></a>NULL检查机制</h5><p>Kotlin的空安全设计对于声明可为空的参数，在使用时要进行空判断处理，有两种处理方式，字段后加!!像Java一样抛出空异常，另一种字段后加?可不做处理返回值为 null或配合?:做空判断处理</p><pre><code class="hljs kotlin"><span class="hljs-comment">//类型后面加?表示可为空</span><span class="hljs-keyword">var</span> age: String? = <span class="hljs-string">"23"</span> <span class="hljs-comment">//抛出空指针异常</span><span class="hljs-keyword">val</span> ages = age!!.toInt()<span class="hljs-comment">//不做处理返回 null</span><span class="hljs-keyword">val</span> ages1 = age?.toInt()<span class="hljs-comment">//age为空返回-1</span><span class="hljs-keyword">val</span> ages2 = age?.toInt() ?: -<span class="hljs-number">1</span></code></pre><p>当一个引用可能为 null 值时, 对应的类型声明必须明确地标记为可为 null。</p><p>当 str 中的字符串内容不是一个整数时, 返回 null:</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">parseInt</span><span class="hljs-params">(str: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Int</span>? &#123;  <span class="hljs-comment">// ...</span>&#125;</code></pre><p>以下实例演示如何使用一个返回值可为 null 的函数:</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;  <span class="hljs-keyword">if</span> (args.size &lt; <span class="hljs-number">2</span>) &#123;    print(<span class="hljs-string">"Two integers expected"</span>)    <span class="hljs-keyword">return</span>  &#125;  <span class="hljs-keyword">val</span> x = parseInt(args[<span class="hljs-number">0</span>])  <span class="hljs-keyword">val</span> y = parseInt(args[<span class="hljs-number">1</span>])  <span class="hljs-comment">// 直接使用 `x * y` 会导致错误, 因为它们可能为 null.</span>  <span class="hljs-keyword">if</span> (x != <span class="hljs-literal">null</span> &amp;&amp; y != <span class="hljs-literal">null</span>) &#123;    <span class="hljs-comment">// 在进行过 null 值检查之后, x 和 y 的类型会被自动转换为非 null 变量</span>    print(x * y)  &#125;&#125;</code></pre><h5 id="类型检测及自动类型转换"><a href="#类型检测及自动类型转换" class="headerlink" title="类型检测及自动类型转换"></a>类型检测及自动类型转换</h5><p>我们可以使用 is 运算符检测一个表达式是否某类型的一个实例(类似于Java中的<strong>instanceof</strong>关键字)。</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getStringLength</span><span class="hljs-params">(obj: <span class="hljs-type">Any</span>)</span></span>: <span class="hljs-built_in">Int</span>? &#123;  <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> String) &#123;    <span class="hljs-comment">// 做过类型判断以后，obj会被系统自动转换为String类型</span>    <span class="hljs-keyword">return</span> obj.length   &#125;  <span class="hljs-comment">//在这里还有一种方法，与Java中instanceof不同，使用!is</span>  <span class="hljs-comment">// if (obj !is String)&#123;</span>  <span class="hljs-comment">//   // XXX</span>  <span class="hljs-comment">// &#125;</span>  <span class="hljs-comment">// 这里的obj仍然是Any类型的引用</span>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>&#125;</code></pre><p>或者</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getStringLength</span><span class="hljs-params">(obj: <span class="hljs-type">Any</span>)</span></span>: <span class="hljs-built_in">Int</span>? &#123;  <span class="hljs-keyword">if</span> (obj !<span class="hljs-keyword">is</span> String)    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>  <span class="hljs-comment">// 在这个分支中, `obj` 的类型会被自动转换为 `String`</span>  <span class="hljs-keyword">return</span> obj.length&#125;</code></pre><p>甚至还可以</p><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getStringLength</span><span class="hljs-params">(obj: <span class="hljs-type">Any</span>)</span></span>: <span class="hljs-built_in">Int</span>? &#123;  <span class="hljs-comment">// 在 `&amp;&amp;` 运算符的右侧, `obj` 的类型会被自动转换为 `String`</span>  <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> String &amp;&amp; obj.length &gt; <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> obj.length  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>&#125;</code></pre><h5 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h5><p>区间表达式由具有操作符形式 <strong>..</strong> 的 rangeTo 函数辅以 in 和 !in 形成。</p><p>区间是为任何可比较类型定义的，但对于整型原生类型，它有一个优化的实现。以下是使用区间的一些示例:</p><pre><code class="hljs kotlin"><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">4</span>) print(i) <span class="hljs-comment">// 输出“1234”</span><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">4</span>..<span class="hljs-number">1</span>) print(i) <span class="hljs-comment">// 什么都不输出</span><span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">10</span>) &#123; <span class="hljs-comment">// 等同于 1 &lt;= i &amp;&amp; i &lt;= 10</span>    println(i)&#125;<span class="hljs-comment">// 使用 step 指定步长</span><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">4</span> step <span class="hljs-number">2</span>) print(i) <span class="hljs-comment">// 输出“13”</span><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">4</span> downTo <span class="hljs-number">1</span> step <span class="hljs-number">2</span>) print(i) <span class="hljs-comment">// 输出“42”</span><span class="hljs-comment">// 使用 until 函数排除结束元素</span><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span> until <span class="hljs-number">10</span>) &#123;   <span class="hljs-comment">// i in [1, 10) 排除了 10</span>     println(i)&#125;</code></pre><h5 id="实例测试"><a href="#实例测试" class="headerlink" title="实例测试"></a>实例测试</h5><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;print(<span class="hljs-string">"循环输出："</span>)<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">4</span>) print(i) <span class="hljs-comment">// 输出“1234”</span>println(<span class="hljs-string">"\n----------------"</span>)print(<span class="hljs-string">"设置步长："</span>)<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">4</span> step <span class="hljs-number">2</span>) print(i) <span class="hljs-comment">// 输出“13”</span>println(<span class="hljs-string">"\n----------------"</span>)print(<span class="hljs-string">"使用 downTo："</span>)<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">4</span> downTo <span class="hljs-number">1</span> step <span class="hljs-number">2</span>) print(i) <span class="hljs-comment">// 输出“42”</span>println(<span class="hljs-string">"\n----------------"</span>)print(<span class="hljs-string">"使用 until："</span>)<span class="hljs-comment">// 使用 until 函数排除结束元素</span><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span> until <span class="hljs-number">4</span>) &#123;   <span class="hljs-comment">// i in [1, 4) 排除了 4</span>print(i)&#125;println(<span class="hljs-string">"\n----------------"</span>)&#125;</code></pre><p>输出结果</p><pre><code class="hljs kotlin">循环输出：<span class="hljs-number">1234</span>----------------设置步长：<span class="hljs-number">13</span>----------------使用 downTo：<span class="hljs-number">42</span>----------------使用 until：<span class="hljs-number">123</span>----------------</code></pre><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ympc3t20j314k0m7qb1.jpg" srcset="/img/loading.gif" alt="result"></p><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin-环境安装</title>
    <link href="/2019/03/14/Kotlin-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2019/03/14/Kotlin-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h5 id="Kotlin是什么？"><a href="#Kotlin是什么？" class="headerlink" title="Kotlin是什么？"></a>Kotlin是什么？</h5><blockquote><p>Kotlin 是一个用于现代多平台应用的静态编程语言，由 <a href="https://baike.baidu.com/item/JetBrains" target="_blank" rel="noopener">JetBrains</a> 开发。</p><p>Kotlin可以编译成Java字节码，也可以编译成JavaScript，方便在没有JVM的设备上运行。</p><p>Kotlin已正式成为Android官方支持开发语言。</p></blockquote><a id="more"></a><blockquote><p>Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，被称之为 Android 世界的Swift，由 JetBrains 设计开发并开源。</p><p>Kotlin 可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。</p><p>在Google I/O 2017中，Google 宣布 Kotlin 成为 Android 官方开发语言。</p></blockquote><p>答案来自网络😂</p><h5 id="Kotlin开发环境搭建"><a href="#Kotlin开发环境搭建" class="headerlink" title="Kotlin开发环境搭建"></a>Kotlin开发环境搭建</h5><p>首先您能进来读这篇文章，就说明您已经在了解或者已经了解了Kotlin了，那更不用我来介绍怎么下载安装IntelliJ IDEA、Eclipse这类软件了。</p><p>由于我们经常使用的IntelliJ IDEA或者是Android Studio都已经自带，所以不做阐述。</p><p>当然也可以<a href="https://www.kotlincn.net/docs/tutorials/command-line.html" target="_blank" rel="noopener">下载独立的编译器</a>。</p><p>因为我在项目中用到比较多的还是Eclipse，所以在这里主要描述Eclipse安装Kotlin。</p><p>1、打开Eclipse，在菜单栏找到 <em>Help -&gt; Eclipse Marketplace…</em> 在search选项卡输入Kotlin进行搜索，然后选中第一条记录点击<em>install</em>安装</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymmjcs1xj30tr0l4gs6.jpg" srcset="/img/loading.gif" alt="install"></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymmlf0i0j30tr0l4k05.jpg" srcset="/img/loading.gif" alt="licenses"></p><p>或者使用老套一点的方式用site来安装：找到Eclipse的<em>help -&gt; Install New SoftWare…</em> 在<em>work with</em>输入 <a href="https://dl.bintray.com/jetbrains/kotlin/eclipse-plugin/last/" target="_blank" rel="noopener">https://dl.bintray.com/jetbrains/kotlin/eclipse-plugin/last/</a> 回车选中安装</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymmmqud0j31600kbgs6.jpg" srcset="/img/loading.gif" alt="site"></p><p>重启Eclipse完成安装。</p><h5 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h5><p>1、首先创建一个新的Kotlin工程：选择Eclipse的 <em>File -&gt; New -&gt; Kotlin Project</em> </p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymmpurylj31740ntgpk.jpg" srcset="/img/loading.gif" alt="main"><br><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymmr66epj314k0oswir.jpg" srcset="/img/loading.gif" alt="println"><br><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymms9h96j31480rfdns.jpg" srcset="/img/loading.gif" alt="run"><br><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymmvdzavj313g0p4aen.jpg" srcset="/img/loading.gif" alt="hello Kotlin"></p><p>完成！！！</p><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>成人漫画</title>
    <link href="/2019/01/14/%E6%88%90%E4%BA%BA%E6%BC%AB%E7%94%BB/"/>
    <url>/2019/01/14/%E6%88%90%E4%BA%BA%E6%BC%AB%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<h5 id="欢迎来到-成人世界"><a href="#欢迎来到-成人世界" class="headerlink" title="欢迎来到 成人世界"></a><strong>欢迎来到</strong> <strong>成人世界</strong></h5><p><strong>一份</strong></p><p><strong>成年人生存指南</strong></p><p><strong>送给你</strong></p><a id="more"></a><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymsgr86mj30rs1ccn0c.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymsj58d0j30rs1cc790.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymsk4c7oj30rs1ccju4.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymsmxx78j30rs1cc419.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymsqlg04j30rs1cc0x3.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymstq3n6j30rs1oyn22.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymsvqg86j30rs1ly795.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymswoim8j30rs1cc0vw.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymsxjlvij30rs1nqq6r.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymsy15gzj30rs1ccn0z.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymszhptrj30rs1cctch.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymt0cvjlj30rs1cctb0.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymt1b3f4j30rs1fcn05.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymt2a5cwj30rs1g5aeb.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymt365tvj30rs1bx429.jpg" srcset="/img/loading.gif" alt="img"></p><p>成年人的世界总是复杂的</p><p>人与人之间充斥着各种潜规则</p><p>希望这些道理</p><p>你现在知道还不算晚</p>]]></content>
    
    
    <categories>
      
      <category>文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>成人漫画</tag>
      
      <tag>十八岁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cola-ui的使用</title>
    <link href="/2019/01/11/cola-ui%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2019/01/11/cola-ui%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="cola-ui"><a href="#cola-ui" class="headerlink" title="cola-ui"></a>cola-ui</h1><blockquote><p>官方：<a href="http://www.cola-ui.com" target="_blank" rel="noopener">http://www.cola-ui.com</a></p><p>教程位置：<a href="http://www.cola-ui.com/guide/model" target="_blank" rel="noopener">http://www.cola-ui.com/guide/model</a></p><p>API: <a href="http://www.cola-ui.com/api/cola.html" target="_blank" rel="noopener">http://www.cola-ui.com/api/cola.html</a> , <a href="http://legacy.cola-ui.com" target="_blank" rel="noopener">http://legacy.cola-ui.com</a></p><p>组件地址：<a href="http://www.cola-ui.com/docs/button" target="_blank" rel="noopener">http://www.cola-ui.com/docs/button</a></p><p>源码地址：<a href="https://github.com/Cola-Org/cola-ui" target="_blank" rel="noopener">https://github.com/Cola-Org/cola-ui</a></p></blockquote><h2 id="文档修订相关"><a href="#文档修订相关" class="headerlink" title="文档修订相关"></a>文档修订相关</h2><table><thead><tr><th align="center">版本</th><th align="center">内容</th><th align="center">修改人</th><th align="center">修改时间</th></tr></thead><tbody><tr><td align="center">V1.0</td><td align="center">初版</td><td align="center">刘晓东</td><td align="center">2018-12-24</td></tr></tbody></table><h2 id="产品简介"><a href="#产品简介" class="headerlink" title="产品简介"></a>产品简介</h2><ul><li>Cola UI是支持双向数据绑定的一站式前端UI框架。采用了精简的MVVM架构，在确保灵活性的同时尽可能降低对开发者的技术要求。</li><li>Cola UI遵循Mobile First的策略，特别适合于移动设备应用开发。</li><li>Cola UI整合了jQuery和Semantic UI，同时提供更多常用的List、Table、Tree等高级控件。</li></ul><a id="more"></a><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>==以上内容都是通过cola-ui官网获得的资料，绝大多数的开发内容可以参考cola-ui官网提供的API进行查阅==</p><p><strong>本文档主要针对于camsi工程中用到的功能或特性，且可能不存在于cola-ui官网提供的API进行整理和说明</strong></p><h3 id="组成结构"><a href="#组成结构" class="headerlink" title="组成结构"></a>组成结构</h3><p>==通常要基于camsi工程在浏览器渲染出来的页面由三个部分组成，例如：simple01.jade、M.js、simple01Model.js==</p><h4 id="Jade"><a href="#Jade" class="headerlink" title="Jade"></a>Jade</h4><p>==Jade 是一个高性能的模板引擎，它深受 Haml影响，它是用 JavaScript 实现的，并且可以供 <a href="http://nodejs.org/" target="_blank" rel="noopener">Node</a> 使用，你也可以<a href="http://naltatis.github.io/jade-syntax-docs/" target="_blank" rel="noopener">在此试用</a>，这里推荐<a href="http://www.nooong.com/docs/jade_chinese.htm" target="_blank" rel="noopener">Jade入门中文文档</a>==</p><pre><code class="hljs jade">extends &#x2F;_pageblock bodyv-boxflex-box.content(style&#x3D;&quot;overflow: auto&quot;)c-table(bind&#x3D;&quot;simple01s&quot; dataType&#x3D;&quot;Simple01&quot;)column(property&#x3D;&quot;name&quot;)append scriptsscript(src&#x3D;&quot;simple01Model.js&quot;)script(src&#x3D;&quot;simple01.js&quot;)</code></pre><p>dataType的值应该与Js中定义的dataType的值以及Model.js中定义的dataType的值相等</p><h4 id="Js"><a href="#Js" class="headerlink" title="Js"></a>Js</h4><p>==不做描述==</p><pre><code class="hljs javascript">cola(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model</span>) </span>&#123;model.dataType($DataType.Simple01);model.describe(<span class="hljs-string">"simple01s"</span>, &#123;dataType : <span class="hljs-string">"Simple01"</span>,provider : &#123;url : <span class="hljs-string">"controller/simple01Service/findPagination?from=&#123;&#123;$from&#125;&#125;&amp;limit=&#123;&#123;$limit&#125;&#125;"</span>,pageSize : <span class="hljs-number">10</span>,sendJson : <span class="hljs-literal">true</span>,loadMode: <span class="hljs-string">'manual'</span>&#125;&#125;);model.set(<span class="hljs-string">"title"</span>, <span class="hljs-string">"[(#&#123;simple01&#125;)]"</span>);model.action(&#123;test : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;cola.alert(<span class="hljs-string">'test'</span>)&#125;&#125;);&#125;);</code></pre><p>所有正规的操作包括事件都应该编写在==cola(function(model) { })==中，其中首先需要使用dataType定义当前Js中所有用到的DataType，使用==model.describe==交互后台数据到当前指定model，使用==model.set(“”, “”)==向model交互数据，页面所有用到的事件方法应该存在于==model.action({})==中。</p><h4 id="Model-js"><a href="#Model-js" class="headerlink" title="Model.js"></a>Model.js</h4><p>==由cola-ui定义的前端模型==</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> $DataType = &#123;Simple01: &#123;name: <span class="hljs-string">"Simple01"</span>,properties : &#123;name : &#123;caption : <span class="hljs-string">"[(#&#123;name&#125;)]"</span>,dataType : <span class="hljs-string">"string"</span>&#125;&#125;&#125;&#125;;</code></pre><p>==caption==用来标志当前字段的前端显示文本，使用==[(#{ })]==取到当前字段对应的当前语言的国际化翻译。</p><h3 id="表单相关"><a href="#表单相关" class="headerlink" title="表单相关"></a>表单相关</h3><h4 id="表单对国际化的处理"><a href="#表单对国际化的处理" class="headerlink" title="表单对国际化的处理"></a>表单对国际化的处理</h4><blockquote><p>在正常情况下，dataType可能会被公用，然后每个字段在每个不同的地方显示的文本标识不一样，这时候可以使用==caption==属性进行操作，例如：==caption=ll.l(“name”)==<strong>前面提到在Js中国际化使用的是==[(#{ })]==</strong></p></blockquote><h4 id="表单对日期格式的处理"><a href="#表单对日期格式的处理" class="headerlink" title="表单对日期格式的处理"></a>表单对日期格式的处理</h4><blockquote><p>通常需要将当前日期字段进行格式化只需要下面代码即可：</p></blockquote><pre><code class="hljs jade">field(property&#x3D;&quot;birthday&quot;)labelc-datepicker(displayFormat&#x3D;&quot;yyyy-MM-dd&quot; inputFormat&#x3D;&quot;yyyy-MM-dd&quot;)</code></pre><p>将datatype类型为Date的birthday字段的文本显示和选择的日期格式调整为”yyyy-MM-dd”</p><h4 id="表单对枚举值的处理"><a href="#表单对枚举值的处理" class="headerlink" title="表单对枚举值的处理"></a>表单对枚举值的处理</h4><blockquote><p>我们经常会把一些常规的数据做成枚举值存放在数据库，并把页面的文本输入框改变成为下拉项</p></blockquote><p>页面元素</p><pre><code class="hljs jade">field(property&#x3D;&quot;status&quot;)    label    c-dropdown(c-items&#x3D;&quot;dictionary(&#39;10000&#39;)&quot;)</code></pre><p>引入Js</p><pre><code class="hljs jade">script(src&#x3D;basecodeCP + &quot;controller&#x2F;basecode&#x2F;codeDetail&#x2F;findCodeDetails?baseCodeIds&#x3D;10000&quot;)</code></pre><p>或者</p><pre><code class="hljs jade">script(src&#x3D;&quot;controller&#x2F;basecode&#x2F;codeDetail&#x2F;findCodeDetails?baseCodeIds&#x3D;10000&quot;)</code></pre><p>这样页面会去加载枚举值代码为10000的对应status存放的id对应的文本显示到当前字段，并为当前字段提供下拉项</p><h4 id="表单对文本域的处理"><a href="#表单对文本域的处理" class="headerlink" title="表单对文本域的处理"></a>表单对文本域的处理</h4><blockquote><p>类似于备注，通常都是用文本框来显示</p></blockquote><pre><code class="hljs jade">fields.cols-1    field(property&#x3D;&quot;remark&quot;)        label        c-textarea(rows&#x3D;&quot;3&quot;)</code></pre><p>首先定义当前字段独占一列，使用==c-textarea(rows=”3”)==表名当前字段独占三列</p><h4 id="表单对只读的处理"><a href="#表单对只读的处理" class="headerlink" title="表单对只读的处理"></a>表单对只读的处理</h4><blockquote><p>正常场景并不是表单中列出的所有的字段都是手动输入的，比如ID，我们可以使用==readOnly=”true”==对每个field进行只读控制，也可以将==readOnly=”true”==放在c-form属性里面来控制整个表单只读</p></blockquote><h4 id="表单对省市县级联的处理"><a href="#表单对省市县级联的处理" class="headerlink" title="表单对省市县级联的处理"></a>表单对省市县级联的处理</h4><p>Jade</p><pre><code class="hljs jade">field(property&#x3D;&quot;country&quot;    label    c-dropdown(c-items&#x3D;&quot;dictionary(&#39;CountryCode&#39;)&quot; onSelectData&#x3D;&quot;onCountrySelect&quot;)(property&#x3D;&quot;province&quot; caption&#x3D;ll.l(&quot;province&quot;) c-readOnly&#x3D;&quot;queryCondition.country !&#x3D; &#39;CHN&#39;&quot;)    label    c-dropdown(c-items&#x3D;&quot;provinces&quot; textProperty&#x3D;&quot;name&quot; assignment&#x3D;&quot;province&#x3D;kind&quot; onSelectData&#x3D;&quot;onProvinceSel&quot;)field(property&#x3D;&quot;city&quot; caption&#x3D;ll.l(&quot;city&quot;) c-readOnly&#x3D;&quot;queryCondition.country !&#x3D; &#39;CHN&#39;&quot;)    label    c-dropdown(c-items&#x3D;&quot;cities&quot; textProperty&#x3D;&quot;name&quot; assignment&#x3D;&quot;city&#x3D;kind&quot; beforeOpen&#x3D;&quot;beforeCityOpen&quot; onSelectData&#x3D;&quot;onCitySel&quot;)field(property&#x3D;&quot;county&quot; caption&#x3D;ll.l(&quot;county&quot;) c-readOnly&#x3D;&quot;queryCondition.country !&#x3D; &#39;CHN&#39;&quot;)    label    c-dropdown(c-items&#x3D;&quot;counties&quot; textProperty&#x3D;&quot;name&quot; assignment&#x3D;&quot;county&#x3D;kind&quot; beforeOpen&#x3D;&quot;beforeCountyOpen&quot;)</code></pre><p>引入数据字典</p><pre><code class="hljs jade">script(src&#x3D;&quot;controller&#x2F;basecode&#x2F;codeDetail&#x2F;findCodeDetails?baseCodeIds&#x3D;CountryCode&quot;)</code></pre><p>Js</p><pre><code class="hljs javascript">cola(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model</span>) </span>&#123;model.describe(<span class="hljs-string">"provinces"</span>, &#123;provider: &#123;url: <span class="hljs-string">"controller/basecode/codeDetail/findCachedCodeDetails"</span>,parameter: &#123;baseCodeId: <span class="hljs-string">"Address"</span>,parentId: <span class="hljs-string">"NULL"</span>&#125;&#125;&#125;);model.set(<span class="hljs-string">"title"</span>, <span class="hljs-string">"[(#&#123;simple01&#125;)]"</span>);model.set(<span class="hljs-string">"queryCondition"</span>, &#123;<span class="hljs-string">"country"</span>:<span class="hljs-string">"CHN"</span>&#125;);model.action(&#123;beforeCityOpen: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">var</span> province = model.get(<span class="hljs-string">"queryCondition.province"</span>);$.ajax(<span class="hljs-string">"controller/basecode/codeDetail/findCachedCodeDetails?baseCodeId=Address&amp;parentId="</span> + province, &#123;type: <span class="hljs-string">"get"</span>, <span class="hljs-attr">async</span>: <span class="hljs-literal">false</span>&#125;).done(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>&#123;<span class="hljs-keyword">if</span> (result) &#123;model.set(<span class="hljs-string">"cities"</span>, result);&#125;&#125;);&#125;,beforeCountyOpen: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">var</span> city = model.get(<span class="hljs-string">"queryCondition.city"</span>);$.ajax(<span class="hljs-string">"controller/basecode/codeDetail/findCachedCodeDetails?baseCodeId=Address&amp;parentId="</span> + city, &#123;type: <span class="hljs-string">"get"</span>, <span class="hljs-attr">async</span>: <span class="hljs-literal">false</span>&#125;).done(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>&#123;<span class="hljs-keyword">if</span> (result) &#123;model.set(<span class="hljs-string">"counties"</span>, result);&#125;&#125;);&#125;,onProvinceSel: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">self, arg</span>) </span>&#123;<span class="hljs-keyword">var</span> queryCondition = model.get(<span class="hljs-string">"queryCondition"</span>);<span class="hljs-keyword">if</span>(queryCondition.get(<span class="hljs-string">"province"</span>) != arg.data.get(<span class="hljs-string">"kind"</span>))&#123;queryCondition.set(<span class="hljs-string">"city"</span>, <span class="hljs-string">""</span>);queryCondition.set(<span class="hljs-string">"county"</span>, <span class="hljs-string">""</span>);&#125;&#125;,onCitySel: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">self, arg</span>) </span>&#123;<span class="hljs-keyword">var</span> queryCondition = model.get(<span class="hljs-string">"queryCondition"</span>);<span class="hljs-keyword">if</span>(queryCondition.get(<span class="hljs-string">"city"</span>) != arg.data.get(<span class="hljs-string">"kind"</span>))&#123;queryCondition.set(<span class="hljs-string">"county"</span>, <span class="hljs-string">""</span>);&#125;&#125;,onCountrySelect: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">self, arg</span>) </span>&#123;<span class="hljs-keyword">var</span> selectedItem = arg.data;<span class="hljs-keyword">if</span>(<span class="hljs-string">"CHN"</span> != selectedItem.key) &#123;model.get(<span class="hljs-string">"queryCondition"</span>).set(<span class="hljs-string">"province"</span>, <span class="hljs-string">""</span>);model.get(<span class="hljs-string">"queryCondition"</span>).set(<span class="hljs-string">"city"</span>, <span class="hljs-string">""</span>);model.get(<span class="hljs-string">"queryCondition"</span>).set(<span class="hljs-string">"county"</span>, <span class="hljs-string">""</span>);&#125;&#125;&#125;);&#125;);</code></pre><h3 id="表格相关"><a href="#表格相关" class="headerlink" title="表格相关"></a>表格相关</h3><h4 id="表格对枚举值的处理"><a href="#表格对枚举值的处理" class="headerlink" title="表格对枚举值的处理"></a>表格对枚举值的处理</h4><blockquote><p>通常我们都是在表单录入数据，在表格中进行简约展示，所以在表单中录入的下拉枚举值我们需要在表格中使用的时候必须使用获取到的枚举值进行翻译</p></blockquote><pre><code class="hljs jade">column(property&#x3D;&quot;status&quot;)    template    div(c-bind&#x3D;&quot;translate(&#39;10000&#39;,$default)&quot;)</code></pre><h4 id="表格对行内编辑的处理"><a href="#表格对行内编辑的处理" class="headerlink" title="表格对行内编辑的处理"></a>表格对行内编辑的处理</h4><blockquote><p>在对于处理一些简单数据的时候我们可以不需要弹出一个复杂的编辑框对当前行的数据进行编辑处理，可以直接在表格进行行内编辑</p></blockquote><pre><code class="hljs jade">c-table(bind&#x3D;&quot;simple01s&quot; dataType&#x3D;&quot;Simple01&quot; readOnly&#x3D;&quot;false&quot;)</code></pre><h5 id="表格行编辑对下拉项的处理"><a href="#表格行编辑对下拉项的处理" class="headerlink" title="表格行编辑对下拉项的处理"></a>表格行编辑对下拉项的处理</h5><blockquote><p>在表单编辑我们可以去选择一个下拉项做为数据值，当然在表格行编辑也可以</p></blockquote><pre><code class="hljs jade">column(property&#x3D;&quot;status&quot;)    template(name&#x3D;&quot;edit&quot;)        c-dropdown(bind&#x3D;&quot;$default&quot; c-items&#x3D;&quot;dictionary(&#39;10000&#39;)&quot;)</code></pre><p>最后代码整理为</p><pre><code class="hljs jade">column(property&#x3D;&quot;status&quot;)    template(name&#x3D;&quot;edit&quot;)    c-dropdown(bind&#x3D;&quot;$default&quot; c-items&#x3D;&quot;dictionary(&#39;10000&#39;)&quot;)    template    div(c-bind&#x3D;&quot;translate(&#39;10000&#39;,$default)&quot;)</code></pre><h4 id="表格添加操作列的处理"><a href="#表格添加操作列的处理" class="headerlink" title="表格添加操作列的处理"></a>表格添加操作列的处理</h4><blockquote><p>通常我们需要在表格的最后一列添加一行操作列来处理当前行的数据</p></blockquote><pre><code class="hljs jade">c-table(bind&#x3D;&quot;simple in simple01s&quot; dataType&#x3D;&quot;Simple01&quot;)    column(caption&#x3D;ll.l(&quot;operation&quot;))        template            div                a.cell-link(c-onclick&#x3D;&quot;view(simple)&quot;)&#x3D;ll.l(&quot;view&quot;)</code></pre><h4 id="表格联动的处理"><a href="#表格联动的处理" class="headerlink" title="表格联动的处理"></a>表格联动的处理</h4><blockquote><p>很多场景下，我们的数据和数据都是有关联关系，比如一本书对应书籍的出版社的详细信息，这时候针对不同的书本信息联动到出版社的详细信息</p></blockquote><p>因为此处是两个表的关联，所以需要定义两个dataType</p><p>cModel.js</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> $DataType = &#123;A: &#123;name: <span class="hljs-string">"A"</span>,properties : &#123;name : &#123;caption : <span class="hljs-string">"[(#&#123;name&#125;)]"</span>,dataType : <span class="hljs-string">"string"</span>,&#125;&#125;&#125;,B : &#123;name : <span class="hljs-string">"B"</span>,properties : &#123;name : &#123;caption : <span class="hljs-string">"[(#&#123;name&#125;)]"</span>,dataType : <span class="hljs-string">"string"</span>&#125;&#125;&#125;&#125;;</code></pre><p>c.jade</p><pre><code class="hljs jade">c-table(bind&#x3D;&quot;as&quot; dataType&#x3D;&quot;a&quot;)column(property&#x3D;&quot;name&quot;)c-table(bind&#x3D;&quot;as#.bs&quot; dataType&#x3D;&quot;b&quot;)column(property&#x3D;&quot;name&quot;)</code></pre><p>c.js</p><pre><code class="hljs js">cola(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model</span>) </span>&#123;model.dataType($DataType.B);$DataType.A.properties.bs = &#123;dataType: <span class="hljs-string">"B"</span>,aggregated: <span class="hljs-literal">true</span>,provider: &#123;url: <span class="hljs-string">"controller/B/find"</span>,sendJson: <span class="hljs-literal">true</span>,parameter: &#123;<span class="hljs-string">"name"</span>: <span class="hljs-string">"&#123;&#123;@name&#125;&#125;"</span>&#125;&#125;&#125;model.dataType($DataType.A);model.describe(<span class="hljs-string">"as"</span>, &#123;dataType : <span class="hljs-string">"A"</span>,provider : &#123;url : <span class="hljs-string">"controller/C/findPagination?from=&#123;&#123;$from&#125;&#125;&amp;limit=&#123;&#123;$limit&#125;&#125;"</span>,pageSize : <span class="hljs-number">10</span>,sendJson : <span class="hljs-literal">true</span>,loadMode: <span class="hljs-string">'manual'</span>&#125;&#125;);model.set(<span class="hljs-string">"title"</span>, <span class="hljs-string">"[(#&#123;C&#125;)]"</span>);model.action(&#123;&#125;);&#125;);</code></pre><p>在关联中可以使用==parameter:{“name”:”“}==方式拿到父表中当前选中行的name的值</p><h4 id="表格数据加载的处理"><a href="#表格数据加载的处理" class="headerlink" title="表格数据加载的处理"></a>表格数据加载的处理</h4><blockquote><p>在某些场景下我们可以让表格数据直接加载到页面，也可以使用事件来触发加载数据</p></blockquote><pre><code class="hljs javascript">loadMode: <span class="hljs-string">'manual'</span></code></pre><p>可以通过loadMode来控制表单是否在页面加载的时候加载数据到页面：manual手工加载，注释掉loadMode缺省自动加载数据</p><h3 id="面板Panel-相关"><a href="#面板Panel-相关" class="headerlink" title="面板Panel 相关"></a>面板Panel 相关</h3><h4 id="在panel头位置添加按钮"><a href="#在panel头位置添加按钮" class="headerlink" title="在panel头位置添加按钮"></a>在panel头位置添加按钮</h4><pre><code class="hljs jade">c-panel#panelDemo(caption&#x3D;ll.l(&quot;panel&quot;))    template(name&#x3D;&quot;tools&quot;)       div          c-button.primary(caption&#x3D;ll.l(&quot;add&quot;) click&#x3D;&quot;add&quot;)</code></pre><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="预加载处理"><a href="#预加载处理" class="headerlink" title="预加载处理"></a>预加载处理</h4><blockquote><p>通常我们会在页面加载完成的时候自动触发一部分方法或者set一部分数据值到指定属性</p></blockquote><pre><code class="hljs javas">cola.ready(function() &#123;cola.widget(&quot;panelDemo&quot;).collapse(); &#x2F;&#x2F; 在加载完页面之后 折叠id为panelDemo的面板&#125;);</code></pre><p>代码应该放在==cola(function (model) { })==</p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>Ui</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cola-ui</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>幂等</title>
    <link href="/2018/10/09/%E5%B9%82%E7%AD%89/"/>
    <url>/2018/10/09/%E5%B9%82%E7%AD%89/</url>
    
    <content type="html"><![CDATA[<p>幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。</p><p>在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0/301912" target="_blank" rel="noopener">函数</a>不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“setTrue()”函数就是一个幂等函数,无论多次执行，其结果都是一样的.更复杂的操作幂等保证是利用唯一交易号(流水号)实现.</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在数学里，<strong>幂等</strong>有两种主要的定义。</p><p>在某二元运算下，<strong>幂等元素</strong>是指被自己重复运算(或对于函数是为复合)的结果等于它自己的元素。例如，乘法下唯一两个幂等实数为0和1。</p><p>某一元运算为<strong>幂等</strong>的时，其作用在任一元素两次后会和其作用一次的结果相同。例如，高斯符号便是幂等的。</p><p>一元运算的定义是二元运算定义的特例</p><h3 id="二元运算"><a href="#二元运算" class="headerlink" title="二元运算"></a>二元运算</h3><p>设<em>S</em>为一具有作用于其自身的二元运算的集合，则<em>S</em>的元素<em>s</em>称为幂等的(相对于*)当</p><p><em>s</em> <em>*s</em> = <em>s</em>.</p><p>特别的是，任一单位元都是幂等的。若<em>S</em>的所有元素都是幂等的话，则其二元运算*被称做是幂等的。例如，联集和交集的运算便都是幂等的。</p><h3 id="一元运算"><a href="#一元运算" class="headerlink" title="一元运算"></a>一元运算</h3><p>设<em>f</em>为一由<em>X</em>映射至<em>X</em>的一元运算，则<em>f</em>为幂等的，当对于所有在<em>X</em>内的<em>x</em>，</p><p><em>f</em>(<em>f</em>(<em>x</em>)) = <em>f</em>(<em>x</em>).</p><p>特别的是，恒等函数一定是幂等的，且任一<a href="https://baike.baidu.com/item/%E5%B8%B8%E6%95%B0%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">常数函数</a>也都是幂等的。</p><p>注意当考虑一由<em>X</em>至<em>X</em>的所有函数所组成的集合<em>S</em>时。在<em>f</em>在一元运算下为幂等的若且唯若在二元运算下，<em>f</em>相对于其复合运算(标记为<em>o</em>)会是幂等的。这可以写成<em>f</em> o <em>f</em> = <em>f</em>。</p><h2 id="一般例子"><a href="#一般例子" class="headerlink" title="一般例子"></a>一般例子</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>如上述所说，恒等函数和常数函数总会是幂等的。较不当然的例子有实数或复数引数的绝对值函数，以及实数引数的高斯符号。</p><p>将一拓扑空间<em>X</em>内各子集<em>U</em>映射至<em>U</em>闭包的函数在<em>X</em>的幂集上是幂等的。这是闭包运算元的一个例子；所有个闭包运算元都会是幂等函数。</p><h3 id="环的幂等元素"><a href="#环的幂等元素" class="headerlink" title="环的幂等元素"></a>环的幂等元素</h3><p>定义上，环的幂等元素为一相对于环乘法为幂等的元素。可以定义一于环幂等上的偏序：若e和f为幂等的，当ef= fe= e时，标记为e≤ f。依其顺序，0会是最小幂等元素，而1为最大幂等元素。</p><p>若<em>e</em>在环<em>R</em>内为幂等的，则<em>eRe</em>一样会是个乘法单位元为<em>e</em>的环。</p><p>两个幂等元素<em>e</em>和<em>f</em>被称为<em>正交的<em>当</em>ef</em>=<em>fe</em>=0。在此一情形下，<em>e</em>+<em>f</em>也是幂等的，且有<em>e</em> ≤ <em>e</em> + <em>f</em>和<em>f</em> ≤ <em>e</em> + <em>f</em>。</p><p>若<em>e</em>在环<em>R</em>内为幂等的，则<em>f</em> = 1 − <em>e</em>也会是幂等的，且<em>e</em>和<em>f</em>正交。</p><p>一在<em>R</em>内的幂等元素<em>e</em>称为<em>核心的<em>，若对所有在</em>R<em>内的</em>x<em>，</em>ex</em>=<em>xe<em>。在此情形之下，</em>Re<em>会是个乘法单位元为</em>e<em>的环。</em>R<em>的核心幂等元素和</em>R<em>的分解为环的直和有很直接的关接。若</em>R<em>为环</em>R<em>1、…、</em>R<strong>n<em>的直和，则环</em>R</strong>i<em>的单位元在</em>R<em>内为核心幂等的，相互正交，且其总和为1。相反地，给出</em>R<em>内给相互正交且总和为1的核心幂等元素</em>e<em>1、…、</em>e<strong>n<em>，则</em>R<em>会是环</em>Re<em>1、…、</em>Re</strong>n<em>的直和。所有较有趣的是，每一于</em>R<em>内的核心幂等</em>e<em>都会给出一</em>R<em>的分解－</em>Re<em>和</em>R</em>(1 − <em>e</em>)的直和。</p><p>任一不等于0和1的幂等元素都是零因子(因为<em>e</em>(1 − <em>e</em>) = 0)。这表示了整环及除环都不会存在此种幂等元素。局部环也没有此种幂等元素，但理由有点不同。唯一包含于一环的雅各布森根内的幂等元素只有0。共四元数环内会有一幂等元素组成的悬链曲面。</p><p><em>所有</em>元素都幂等的环称做布尔环。可证明在每一此类环内，乘法都是可交换的，且每一元素都有其各自的加法逆元。</p><h3 id="其他例子"><a href="#其他例子" class="headerlink" title="其他例子"></a>其他例子</h3><p>幂等运算也可以在布林代数内找到。逻辑和与<a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E6%88%96" target="_blank" rel="noopener">逻辑或</a>便都是幂等运算。</p><p>在<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0" target="_blank" rel="noopener">线性代数</a>里，<a href="https://baike.baidu.com/item/%E6%8A%95%E5%B0%84" target="_blank" rel="noopener">投射</a>是幂等的。亦即，每一将向量投射至一子空间V(不需正交)上的<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E7%AE%97%E5%AD%90" target="_blank" rel="noopener">线性算子</a>，都是幂等的。</p><p>一幂等半环为其<em>加法</em>(非乘法)为幂等的<a href="https://baike.baidu.com/item/%E5%8D%8A%E7%8E%AF" target="_blank" rel="noopener">半环</a>。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>幂等</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10招强化Linux安全的技能</title>
    <link href="/2018/09/14/10%E6%8B%9B%E5%BC%BA%E5%8C%96Linux%E5%AE%89%E5%85%A8%E7%9A%84%E6%8A%80%E8%83%BD/"/>
    <url>/2018/09/14/10%E6%8B%9B%E5%BC%BA%E5%8C%96Linux%E5%AE%89%E5%85%A8%E7%9A%84%E6%8A%80%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h3 id="1-找出不必要的服务"><a href="#1-找出不必要的服务" class="headerlink" title="1.找出不必要的服务"></a>1.找出不必要的服务</h3><p>很明显，服务器上跑的服务，并不是每个都有用的。强烈建议检查并关掉不需要的服务，从而减少风险（多跑一个服务，就可能多几个漏洞）。</p><p>查询运行在<strong>runlevel 3</strong>的服务列表：</p><pre><code class="hljs plain">[alter@alter ~]# &#x2F;sbin&#x2F;chkconfig --list |grep &#39;3:on&#39;</code></pre><a id="more"></a><p>关闭指定的服务：</p><pre><code class="hljs plain">[alter@alter ~]# chkconfig ip6tables off</code></pre><hr><p>疑问：为什么查询<strong>runlevel 3</strong>的服务？<br>Linux系统有7个运行级别(runlevel)，分别如下：<br>runlevel 0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动；<br>runlevel 1：单用户工作状态，root权限，用于系统维护，禁止远程登陆；<br>runlevel 2：多用户状态(没有NFS)；<br>runlevel 3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式。这个运行级别的服务会启动httpd，系统提供web server服务，所以主要查看这个运行级别的服务；<br>runlevel 4：系统未使用，保留；<br>runlevel 5：X11控制台，登陆后进入图形GUI模式；<br>runlevel 6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动；</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymrkisisj30eq0q6ajx.jpg" srcset="/img/loading.gif" alt="img"></p><h3 id="2-检查监听的网络端口"><a href="#2-检查监听的网络端口" class="headerlink" title="2.检查监听的网络端口"></a>2.检查监听的网络端口</h3><p>通过netstat命名能够看到所有已经打开的端口，并且可以看到是哪些程序打开的。如果发现某些是必须要的，建议关掉：</p><pre><code class="hljs plain">[alter@alter~]# netstat -tulpnActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address  Foreign Address  State   PID&#x2F;Program name   tcp        0      0 0.0.0.0:2181   0.0.0.0:*        LISTEN  48983&#x2F;java          tcp        0      0 0.0.0.0:2182   0.0.0.0:*        LISTEN  49051&#x2F;java</code></pre><h3 id="3-优化CRON任务"><a href="#3-优化CRON任务" class="headerlink" title="3.优化CRON任务"></a>3.优化CRON任务</h3><p>linux的cron可以执行一些定时任务。并且还可以通过/etc/cron.allow 和 /etc/cron.deny 控制哪些用户可以运行JOB，哪位用户禁止运行JOB。例如:<br>允许用户alter允许JOB，执行如下命令：</p><pre><code class="hljs plain">echo alter &gt;&gt; &#x2F;etc&#x2F;cron.allow</code></pre><p>禁止所有用户访问JOB，执行如下命令：</p><pre><code class="hljs plain">echo ALL &gt;&gt;&#x2F;etc&#x2F;cron.deny</code></pre><h3 id="4-限制用户使用旧密码"><a href="#4-限制用户使用旧密码" class="headerlink" title="4.限制用户使用旧密码"></a>4.限制用户使用旧密码</h3><p>linux用户的旧密码保存在文件/etc/security/opasswd中：</p><pre><code class="hljs plain">[root@LAPP-V1159 ~]# cat &#x2F;etc&#x2F;security&#x2F;opasswdalter:504:4:$1$MVAi&#x2F;EpJ$iXXkV5r3Hjc8AaK2b5KyQ&#x2F;,$1$AbpFPYaD$ZKj12lK6qaYUqgQnEdocd0,$1$POabjmzY$F4Cp6aTwN6RRk1KjZWm8A&#x2F;,$1$LoHe5GHY$QjkLGqABANpLmlQsRB4WE.</code></pre><p>检查是否有开启限制使用旧密码，在RHEL / CentOS / Fedora系统中，查看文件：/etc/pam.d/system-auth。在Ubuntu/Debian/Linux Mint系统中，查看文件：/etc/pam.d/common-password，需要下面两行关键内容，其中remember=4，表示不能使用最后4次密码，否则会报错：Password has been already used. Choose another.：</p><pre><code class="hljs plain">auth        sufficient    pam_unix.so nullok try_first_passpassword    sufficient    pam_unix.so sha512 shadow nullok try_first_pass use_authtok remember&#x3D;4</code></pre><h3 id="5-检查密码过期"><a href="#5-检查密码过期" class="headerlink" title="5.检查密码过期"></a>5.检查密码过期</h3><p>密码的过期属性可以通过如下命令查看：</p><pre><code class="hljs plain">[root@root ~]# chage -l alterLast password change                    : Sep 14, 2018Password expires                    : Nov 13, 2018Password inactive                    : neverAccount expires                        : neverMinimum number of days between password change        : 0Maximum number of days between password change        : 60Number of days of warning before password expires    : 7</code></pre><p>修改密码的过期属性可以执行如下命令：</p><pre><code class="hljs plain">chage -M 60 -W 7  alter说明：-M 60表示密码最大有效期是60天。-W 7 表示密码还有7天过期时给出告警提醒。</code></pre><h3 id="6-检查密码为空的用户"><a href="#6-检查密码为空的用户" class="headerlink" title="6.检查密码为空的用户"></a>6.检查密码为空的用户</h3><p>密码为空意味着只要知道用户名就能访问，这非常危险。因为用户与密码信息保存在文件/etc/shadow中，且格式如下：</p><pre><code class="hljs plain">admin:$6$YTSkre3DLd4SAZ$Jy9piv&#x2F;gPezhLrLzMMeUleV8F5DNjP:17765:0:99:5:::alter:$6$.vMcyE9ss96$YNk2Q5qiS&#x2F;SAeGCcyEFsmspkC5dr3OXfnN:17788:0:60:7:::</code></pre><blockquote><p>后面的几个数字是密码过期等属性信息，上面已经提及。</p></blockquote><p>所以，检查密码为空的用户，只需要执行如下命令即可，如果发现有这样的用户，通过root用户执行<code>passwd username</code>强行修改它的密码：</p><pre><code class="hljs plain">cat &#x2F;etc&#x2F;shadow | awk -F: &#39;($2&#x3D;&#x3D;&quot;&quot;)&#123;print $1&#125;&#39;</code></pre><h3 id="7-锁定-amp-解锁用户"><a href="#7-锁定-amp-解锁用户" class="headerlink" title="7.锁定&amp;解锁用户"></a>7.锁定&amp;解锁用户</h3><p>和删除用户账户不一样，这个只是限制用户登录。只需要执行如下密码即可锁定&amp;解锁用户：</p><pre><code class="hljs plain">[root@root ~]# passwd -l alterLocking password for user alter.passwd: Success[root@root ~]# passwd -u alterUnlocking password for user alter.passwd: Success</code></pre><p>说明：</p><ul><li>参数l表示lock，即锁定用户密码；</li><li>参数u表示unlock，即解锁用户密码；</li></ul><h3 id="8-关闭IPv6"><a href="#8-关闭IPv6" class="headerlink" title="8.关闭IPv6"></a>8.关闭IPv6</h3><p>现在IPv6基本上没有实际使用，所以我们可以关掉它，在文件/etc/sysconfig/network中增加如下两行内容即可：</p><pre><code class="hljs plain">NETWORKING_IPV6&#x3D;noIPV6INIT&#x3D;no</code></pre><h3 id="9-复查日志"><a href="#9-复查日志" class="headerlink" title="9.复查日志"></a>9.复查日志</h3><p>Linux服务器上很多的行为都会有记录相应的日志，简单列举一些如下，如果有一些非法操作，就能从这些日志中造成蛛丝马迹，例如非法登陆，非法定时任务等：</p><ul><li>/var/log/message – Where whole system logs or current activity logs are available.</li><li>/var/log/auth.log – Authentication logs.</li><li>/var/log/kern.log – Kernel logs.</li><li>/var/log/cron.log – Crond logs (cron job).</li><li>/var/log/maillog – Mail server logs.</li><li>/var/log/boot.log – System boot log.</li><li>/var/log/mysqld.log – MySQL database server log file.</li><li>/var/log/secure – Authentication log.</li><li>/var/log/utmp or /var/log/wtmp : Login records file.</li><li>/var/log/yum.log: Yum log files.</li></ul><h3 id="10-保持系统更新"><a href="#10-保持系统更新" class="headerlink" title="10.保持系统更新"></a>10.保持系统更新</h3><p>总是让系统更新最新发行的补丁包，因为这些补丁包会修复一些BUG：</p><pre><code class="hljs plain">sudo apt-get upgradeyum check-updateyum upgrade</code></pre><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud的版本</title>
    <link href="/2018/09/14/SpringCloud%E7%9A%84%E7%89%88%E6%9C%AC/"/>
    <url>/2018/09/14/SpringCloud%E7%9A%84%E7%89%88%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>Spring Cloud 项目目前仍然是快速迭代期，版本变化很快。这里整理一下版本相关的东西，备忘一下。</p><h2 id="大版本"><a href="#大版本" class="headerlink" title="大版本"></a>大版本</h2><h3 id="版本号规则"><a href="#版本号规则" class="headerlink" title="版本号规则"></a>版本号规则</h3><p>Spring Cloud并没有熟悉的数字版本号，而是对应一个开发代号。</p><a id="more"></a><table><thead><tr><th>Cloud代号</th><th>Boot版本(train)</th><th>Boot版本(tested)</th><th>lifecycle</th></tr></thead><tbody><tr><td>Angle</td><td>1.2.x</td><td>incompatible with 1.3</td><td>EOL in July 2017</td></tr><tr><td>Brixton</td><td>1.3.x</td><td>1.4.x</td><td>2017-07卒</td></tr><tr><td>Camden</td><td>1.4.x</td><td>1.5.x</td><td>-</td></tr><tr><td>Dalston</td><td>1.5.x</td><td>not expected 2.x</td><td>-</td></tr><tr><td>Edgware</td><td>1.5.x</td><td>not expected 2.x</td><td>-</td></tr><tr><td>Finchley</td><td>2.x</td><td>not expected 1.5.x</td><td>-</td></tr></tbody></table><p>开发代号看似没有什么规律，但实际上首字母是有顺序的，比如：Dalston版本，我们可以简称 D 版本，对应的 Edgware 版本我们可以简称 E 版本。</p><h3 id="D版本和E版本的区别"><a href="#D版本和E版本的区别" class="headerlink" title="D版本和E版本的区别"></a>D版本和E版本的区别</h3><p>二者均基于SpringBoot的1.5.x版本。但支持其他组件的版本不同，如以 Dalston.SR4 和 Edgware.RELEASE 来对比：</p><p>spring-cloud-config 分别对应 1.3.3和 1.4.0;<br>spring-cloud-netflix 分别对应 1.3.5和 1.4.0;<br>spring-cloud-consul 分别对应 1.2.1和 1.3.0;<br>spring-cloud-gateway 前者不支持，后者 1.0.0。</p><p>每个小版本的不同，会有细微差别。</p><h3 id="F版本"><a href="#F版本" class="headerlink" title="F版本"></a>F版本</h3><p>F版本是个绝对的大版本，几乎所有组件，全部同步变更版本号为2.x。</p><h2 id="小版本"><a href="#小版本" class="headerlink" title="小版本"></a>小版本</h2><p>Spring Cloud 小版本分为:</p><p>SNAPSHOT： 快照版本，随时可能修改</p><p>M： MileStone，M1表示第1个里程碑版本，一般同时标注PRE，表示预览版版。</p><p>SR： Service Release，SR1表示第1个正式版本，一般同时标注GA：(GenerallyAvailable),表示稳定版本。</p><h2 id="选择版本"><a href="#选择版本" class="headerlink" title="选择版本"></a>选择版本</h2><h3 id="大版本-1"><a href="#大版本-1" class="headerlink" title="大版本"></a>大版本</h3><ul><li>首先说明，各个版本之间组件变化不大，但细节略有不同，比如配置项名称、或者新版本增加新的配置方式。</li></ul><p>从这一点来看，选择哪个版本都不是大问题，但提醒一下，遇到坑时，最好根据版本进行查询，否则你会发现你找到的办法不行。实际上是版本不匹配。</p><ul><li>如果你项目需要和其他老项目交叉，以兼容为第一要务。</li><li>如果全新项目，可以考虑较新版本，如E版。如果你爱好踩坑，F拿去。</li></ul><h3 id="小版本-1"><a href="#小版本-1" class="headerlink" title="小版本"></a>小版本</h3><p>小版本没啥可说的，尝鲜：SNAPSHOT，生产：GA。</p><p>Release train contents:</p><table><thead><tr><th>Component</th><th>Edgware.SR4</th><th>Finchley.SR1</th><th>Finchley.BUILD-SNAPSHOT</th></tr></thead><tbody><tr><td>spring-cloud-aws</td><td>1.2.3.RELEASE</td><td>2.0.0.RELEASE</td><td>2.0.1.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-bus</td><td>1.3.3.RELEASE</td><td>2.0.0.RELEASE</td><td>2.0.1.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-cli</td><td>1.4.1.RELEASE</td><td>2.0.0.RELEASE</td><td>2.0.1.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-commons</td><td>1.3.4.RELEASE</td><td>2.0.1.RELEASE</td><td>2.0.2.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-contract</td><td>1.2.5.RELEASE</td><td>2.0.1.RELEASE</td><td>2.0.2.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-config</td><td>1.4.4.RELEASE</td><td>2.0.1.RELEASE</td><td>2.0.2.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-netflix</td><td>1.4.5.RELEASE</td><td>2.0.1.RELEASE</td><td>2.0.2.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-security</td><td>1.2.3.RELEASE</td><td>2.0.0.RELEASE</td><td>2.0.1.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-cloudfoundry</td><td>1.1.2.RELEASE</td><td>2.0.0.RELEASE</td><td>2.0.1.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-consul</td><td>1.3.4.RELEASE</td><td>2.0.1.RELEASE</td><td>2.0.2.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-sleuth</td><td>1.3.4.RELEASE</td><td>2.0.1.RELEASE</td><td>2.0.2.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-stream</td><td>Ditmars.SR4</td><td>Elmhurst.SR1</td><td>Elmhurst.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-zookeeper</td><td>1.2.2.RELEASE</td><td>2.0.0.RELEASE</td><td>2.0.1.BUILD-SNAPSHOT</td></tr><tr><td>spring-boot</td><td>1.5.14.RELEASE</td><td>2.0.4.RELEASE</td><td>2.0.4.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-task</td><td>1.2.3.RELEASE</td><td>2.0.0.RELEASE</td><td>2.0.1.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-vault</td><td>1.1.1.RELEASE</td><td>2.0.1.RELEASE</td><td>2.0.2.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-gateway</td><td>1.0.2.RELEASE</td><td>2.0.1.RELEASE</td><td>2.0.2.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-openfeign</td><td></td><td>2.0.1.RELEASE</td><td>2.0.2.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-function</td><td>1.0.0.RELEASE</td><td>1.0.0.RELEASE</td><td>1.0.1.BUILD-SNAPSHOT</td></tr></tbody></table><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA中通过Hibernate-Validation进行参数验证</title>
    <link href="/2018/09/13/JAVA%E4%B8%AD%E9%80%9A%E8%BF%87Hibernate-Validation%E8%BF%9B%E8%A1%8C%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81/"/>
    <url>/2018/09/13/JAVA%E4%B8%AD%E9%80%9A%E8%BF%87Hibernate-Validation%E8%BF%9B%E8%A1%8C%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<p>在开发JAVA服务器端代码时，我们会遇到对外部传来的参数合法性进行验证，而hibernate-validator提供了一些常用的参数校验注解，我们可以拿来使用。<br><strong>1.maven中引入hibernate-validator对应的jar：</strong></p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-validator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.1.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><a id="more"></a><p>2.在Model中定义要校验的字段（即该字段不能为空，并且最大长度为14）：**</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.validation.constraints.Pattern;<span class="hljs-keyword">import</span> javax.validation.constraints.Size;<span class="hljs-keyword">import</span> org.hibernate.validator.constraints.NotEmpty; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PayRequestDto</span> </span>&#123;         <span class="hljs-comment">/**</span><span class="hljs-comment">     * 支付完成时间</span><span class="hljs-comment">     **/</span>    <span class="hljs-meta">@NotEmpty</span>(message=<span class="hljs-string">"支付完成时间不能空"</span>)    <span class="hljs-meta">@Size</span>(max=<span class="hljs-number">14</span>,message=<span class="hljs-string">"支付完成时间长度不能超过&#123;max&#125;位"</span>)    <span class="hljs-keyword">private</span> String payTime;         <span class="hljs-comment">/**</span><span class="hljs-comment">     * 状态</span><span class="hljs-comment">     **/</span>    <span class="hljs-meta">@Pattern</span>(regexp = <span class="hljs-string">"0[0123]"</span>, message = <span class="hljs-string">"状态只能为00或01或02或03"</span>)    <span class="hljs-keyword">private</span> String status;     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPayTime</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> payTime;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPayTime</span><span class="hljs-params">(String payTime)</span> </span>&#123;        <span class="hljs-keyword">this</span>.payTime = payTime;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getStatus</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> status;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(String status)</span> </span>&#123;        <span class="hljs-keyword">this</span>.status = status;    &#125;&#125;</code></pre><p><strong>3.定义Validation工具类：</strong></p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Set;<span class="hljs-keyword">import</span> javax.validation.ConstraintViolation;<span class="hljs-keyword">import</span> javax.validation.Validation;<span class="hljs-keyword">import</span> javax.validation.Validator;<span class="hljs-keyword">import</span> org.hibernate.validator.HibernateValidator;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ValidationUtils</span> </span>&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">     * 使用hibernate的注解来进行验证</span><span class="hljs-comment">     * </span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Validator validator = Validation            .byProvider(HibernateValidator<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">configure</span>().<span class="hljs-title">failFast</span>(<span class="hljs-title">true</span>).<span class="hljs-title">buildValidatorFactory</span>().<span class="hljs-title">getValidator</span>()</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 功能描述: &lt;br&gt;</span><span class="hljs-comment">     * 〈注解验证参数〉</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> obj</span><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> [相关类/方法](可选)</span><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> [产品/模块版本](可选)</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">validate</span><span class="hljs-params">(T obj)</span> </span>&#123;        Set&lt;ConstraintViolation&lt;T&gt;&gt; constraintViolations = validator.validate(obj);        <span class="hljs-comment">// 抛出检验异常</span>        <span class="hljs-keyword">if</span> (constraintViolations.size() &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(String.format(<span class="hljs-string">"参数校验失败:%s"</span>, constraintViolations.iterator().next().getMessage()));        &#125;    &#125;&#125;</code></pre><p><strong>4.在代码中调用工具类进行参数校验：</strong></p><pre><code class="hljs java">ValidationUtils.validate(requestDto);</code></pre><p><strong>以下是对hibernate-validator中部分注解进行描述：</strong></p><table><thead><tr><th>注解</th><th>描述</th></tr></thead><tbody><tr><td>@AssertTrue</td><td>用于boolean字段，该字段只能为true</td></tr><tr><td>@AssertFalse</td><td>该字段的值只能为false</td></tr><tr><td>@CreditCardNumber</td><td>对信用卡号进行一个大致的验证</td></tr><tr><td>@DecimalMax</td><td>只能小于或等于该值</td></tr><tr><td>@DecimalMin</td><td>只能大于或等于该值</td></tr><tr><td>@Digits(integer=,fraction=)</td><td>检查是否是一种数字的整数、分数,小数位数的数字</td></tr><tr><td>@Email</td><td>检查是否是一个有效的email地址</td></tr><tr><td>@Future</td><td>检查该字段的日期是否是属于将来的日期</td></tr><tr><td>@Length(min=,max=)</td><td>检查所属的字段的长度是否在min和max之间,只能用于字符串</td></tr><tr><td>@Max</td><td>该字段的值只能小于或等于该值</td></tr><tr><td>@Min</td><td>该字段的值只能大于或等于该值</td></tr><tr><td>@NotNull</td><td>不能为null</td></tr><tr><td>@NotBlank</td><td>不能为空，检查时会将空格忽略</td></tr><tr><td>@NotEmpty</td><td>不能为空，这里的空是指空字符串</td></tr><tr><td>@Null</td><td>检查该字段为空</td></tr><tr><td>@Past</td><td>检查该字段的日期是在过去</td></tr><tr><td>@Pattern(regex=,flag=)</td><td>被注释的元素必须符合指定的正则表达式</td></tr><tr><td>@Range(min=,max=,message=)</td><td>被注释的元素必须在合适的范围内</td></tr><tr><td>@Size(min=, max=)</td><td>检查该字段的size是否在min和max之间，可以是字符串、数组、集合、Map等</td></tr><tr><td>@URL(protocol=,host,port)</td><td>检查是否是一个有效的URL，如果提供了protocol，host等，则该URL还需满足提供的条件</td></tr><tr><td>@Valid</td><td>该注解主要用于字段为一个包含其他对象的集合或map或数组的字段，或该字段直接为一个其他对象的引用，这样在检查当前对象的同时也会检查该字段所引用的对象</td></tr></tbody></table><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Hibernate</tag>
      
      <tag>validation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用JAVA写一个简易图片防篡改</title>
    <link href="/2018/09/11/%E7%94%A8JAVA%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E5%9B%BE%E7%89%87%E9%98%B2%E7%AF%A1%E6%94%B9/"/>
    <url>/2018/09/11/%E7%94%A8JAVA%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E5%9B%BE%E7%89%87%E9%98%B2%E7%AF%A1%E6%94%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="图片防止篡改部分"><a href="#图片防止篡改部分" class="headerlink" title="图片防止篡改部分"></a>图片防止篡改部分</h2><p>第一步，获取图片的md5字符串，并转为字节数组</p><a id="more"></a><pre><code class="hljs java"><span class="hljs-comment">//将图片使用md5加密</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] img2Md5Bytes(File file,String salt) <span class="hljs-keyword">throws</span> Exception&#123;       FileInputStream inputStream=<span class="hljs-keyword">new</span> FileInputStream(file);       StringBuilder builder=<span class="hljs-keyword">new</span> StringBuilder();       <span class="hljs-keyword">byte</span>[] bytes=<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];       <span class="hljs-keyword">int</span> bytesRead;       <span class="hljs-keyword">while</span> ((bytesRead=inputStream.read(bytes))!=-<span class="hljs-number">1</span>)&#123;           builder.append(<span class="hljs-keyword">new</span> String(bytes,<span class="hljs-number">0</span>,bytesRead));       &#125;       inputStream.close();       builder.append(salt);       String md5=md5(builder.toString());       <span class="hljs-keyword">return</span> hexStringToBytes(md5);   &#125;   <span class="hljs-comment">//16进制转字节数组</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span>   <span class="hljs-keyword">byte</span>[] hexStringToBytes(String hexString) &#123;       <span class="hljs-keyword">if</span> (hexString == <span class="hljs-keyword">null</span> || hexString.equals(<span class="hljs-string">""</span>)) &#123;           <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;       &#125;       hexString = hexString.toUpperCase();       <span class="hljs-keyword">int</span> length = hexString.length() / <span class="hljs-number">2</span>;       <span class="hljs-keyword">char</span>[] hexChars = hexString.toCharArray();       <span class="hljs-keyword">byte</span>[] d = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[length];       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;           <span class="hljs-keyword">int</span> pos = i * <span class="hljs-number">2</span>;           d[i] = (<span class="hljs-keyword">byte</span>) (charToByte(hexChars[pos]) &lt;&lt; <span class="hljs-number">6</span> | charToByte(hexChars[pos + <span class="hljs-number">1</span>]));       &#125;       <span class="hljs-keyword">return</span> d;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span> <span class="hljs-title">charToByte</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;       <span class="hljs-keyword">return</span> (<span class="hljs-keyword">byte</span>) <span class="hljs-string">"0123456789ABCDEF"</span>.indexOf(c);   &#125;   <span class="hljs-comment">//md5加密字符串</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">md5</span><span class="hljs-params">(String str)</span> </span>&#123;       <span class="hljs-keyword">try</span> &#123;           MessageDigest md = MessageDigest.getInstance(<span class="hljs-string">"MD5"</span>);           md.update(str.getBytes());           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BigInteger(<span class="hljs-number">1</span>, md.digest()).toString(<span class="hljs-number">16</span>);       &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;           <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;       &#125;   &#125;</code></pre><p>第二步，图片末尾加md5字节数组</p><pre><code class="hljs java"><span class="hljs-comment">//图片末尾加md5字节数组</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">imgAppendMd5Bytes</span><span class="hljs-params">(File file,<span class="hljs-keyword">byte</span>[] md5Bytes)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;       RandomAccessFile accessFile=<span class="hljs-keyword">new</span> RandomAccessFile(file,<span class="hljs-string">"rw"</span>);       <span class="hljs-keyword">long</span> length=accessFile.length();       accessFile.seek(length);       accessFile.write(md5Bytes);       accessFile.close();   &#125;</code></pre><p>第三步，封装一下</p><pre><code class="hljs java"><span class="hljs-comment">//防止图片被篡改</span>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preventTamper</span><span class="hljs-params">(File file,String salt)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;      <span class="hljs-keyword">byte</span>[] md5bytes=img2Md5Bytes(file,salt);      imgAppendMd5Bytes(file,md5bytes);  &#125;</code></pre><h2 id="图片验证部分"><a href="#图片验证部分" class="headerlink" title="图片验证部分"></a>图片验证部分</h2><p>第一步，获取图片的末尾存储的md5字节数组</p><pre><code class="hljs java"><span class="hljs-comment">//获取存储在图片末尾的16个md5字节</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] popMd5Bytes(File file) <span class="hljs-keyword">throws</span> Exception&#123;       RandomAccessFile accessFile=<span class="hljs-keyword">new</span> RandomAccessFile(file,<span class="hljs-string">"rw"</span>);       <span class="hljs-keyword">byte</span>[] bytes=<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">16</span>];       <span class="hljs-keyword">long</span> length=accessFile.length();       accessFile.seek(length-<span class="hljs-number">16</span>);       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">16</span>;i++)&#123;           bytes[i]=accessFile.readByte();       &#125;       accessFile.close();       <span class="hljs-keyword">return</span> bytes;   &#125;</code></pre><p>第二步，去除图片末尾的16个md5字节后，重新计算图片的md5值</p><pre><code class="hljs java"><span class="hljs-comment">//去除图片末尾的16个md5字节</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">imgDelEndMd5Bytes</span><span class="hljs-params">(File file)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;       RandomAccessFile accessFile=<span class="hljs-keyword">new</span> RandomAccessFile(file,<span class="hljs-string">"rw"</span>);       FileChannel fc = accessFile.getChannel();       fc.truncate(accessFile.length()-<span class="hljs-number">16</span>);       fc.close();       accessFile.close();   &#125;<span class="hljs-keyword">byte</span>[] imgMd5=img2Md5Bytes(file,salt);</code></pre><p>第三步，封装为方法</p><pre><code class="hljs java"><span class="hljs-comment">//验证图片是否被篡改</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">notTamper</span><span class="hljs-params">(File file,String salt)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;       <span class="hljs-keyword">byte</span>[] storageMd5=popMd5Bytes(file);<span class="hljs-comment">//获取存储在图片末尾的16个md5字节</span>       imgDelEndMd5Bytes(file);<span class="hljs-comment">//删除末尾md5字节数组</span>       <span class="hljs-keyword">byte</span>[] imgMd5=img2Md5Bytes(file,salt);       <span class="hljs-keyword">return</span> Arrays.equals(storageMd5,imgMd5);   &#125;</code></pre><p>简单实现，没有进行调优</p><h3 id="欢迎关注微信公众号"><a href="#欢迎关注微信公众号" class="headerlink" title="欢迎关注微信公众号"></a>欢迎关注微信公众号</h3><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS下安装环境文档</title>
    <link href="/2018/09/11/CentOS%E4%B8%8B%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83%E6%96%87%E6%A1%A3/"/>
    <url>/2018/09/11/CentOS%E4%B8%8B%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<hr><p>【JDK1.7安装】</p><hr><p>1)登录Sun的JDK官方下载网 址:<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html</a></p><p>2)下载jdk-7u67-linux-x64.rpm文件</p><p>》删除系统自带OpenJDK</p><p>CentOs6.5 默认会安装OpenOffice之类，需要JAVA支持，系统默认安装了一个openjdk1.7版本</p><a id="more"></a><pre><code class="hljs plain"># java -versionjava version &quot;1.7.0&quot;OpenJDK  Runtime Environment (build 1.7.0-b09)OpenJDK Client VM (build 1.7.0-b09, mixed mode)</code></pre><blockquote><p>备注：</p><p>无须删除原有的openjdk;否则，与之相关的openoffice等软件，也会自动随之删除；</p></blockquote><p>如果直接”应用程序-添加/删除软件–基本系统–java“删除其他相关软件也会自动删除，所以删除前，最好安装配置好新的JDK环境</p><p> 1) 删除原有的JDK：</p><pre><code class="hljs plain"># rpm -qa|grep jdk</code></pre><p>查看安装的JDK，会显示多个java-1.7.0-openjdk-1.7.0相关的程序，在以下一一卸载。直到删完为止，如下：</p><pre><code class="hljs plain"># rpm -e --nodeps java-1.7.0-openjdk-1.7.0.65-2.5.1.2.el6_5.x86_64# rpm -e --nodeps java-1.7.0-openjdk-devel-1.7.0.65-2.5.1.2.el6_5.x86_64# rpm -e --nodeps java-1.7.0-openjdk-demo-1.7.0.65-2.5.1.2.el6_5.x86_64</code></pre><p>……</p><pre><code class="hljs plain"># rpm -qa|grep java</code></pre><p>查看安装的JAVA关联程序，在以下一一卸载。直到删完为止，如下：</p><pre><code class="hljs plain"># rpm -e --nodeps tzdata-java-2014h-1.el6.noarch</code></pre><p>……</p><p>》配置新的JDK环境</p><p>1）把安装文件文件保存在/usr/java/tools下 ,并切换到root用户</p><pre><code class="hljs plain"># mkdir &#x2F;usr&#x2F;java  &#x2F;&#x2F;创建&#x2F;urs&#x2F;java目录# cd &#x2F;usr&#x2F;java&#x2F;# rpm -ivh .&#x2F;tools&#x2F;jdk-7u67-linux-x64.rpm</code></pre><p>》配置jdk1.6.0_22环境变量</p> <pre><code class="hljs plain"># vi &#x2F;etc&#x2F;profileJAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.7.0_79JRE_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.7.0_79&#x2F;jrePATH&#x3D;PATH:JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;binCLASSPATH&#x3D;:JAVA_HOME&#x2F;lib&#x2F;dt.jar:JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JRE_HOME&#x2F;libexport JAVA_HOME JRE_HOME PATH CLASSPATH</code></pre><p>》使环境变量生效：</p><pre><code class="hljs plain">#source &#x2F;etc&#x2F;profile</code></pre><p>》测试安装</p><p>   1)查看版本号</p><pre><code class="hljs plain"># java -versionjava version &quot;1.7.0_67&quot;Java(TM) SE Runtime Environment (build 1.7.0_67-b01)Java HotSpot(TM) 64-Bit Server VM (build 24.65-b04, mixed mode)Java HotSpot(TM) Client VM (build 17.1-b03, mixed mode, sharing)</code></pre><p>说明成功了。</p><hr><p>【MYSQL5.5的安装】</p><hr><p>安装方式分为rpm和源码编译安装两种，本文是采用mysql源码编译方式，编译器使用Cmake。软件需要mysql-5.5.40.tar.gz和cmake-2.8.10.2.tar.gz，请自行下载。</p><p>》下载地址：</p><p><a href="http://dev.mysql.com/get/Downloads/MySQL-5.5/mysql-5.5.40.tar.gz" target="_blank" rel="noopener">http://dev.mysql.com/get/Downloads/MySQL-5.5/mysql-5.5.40.tar.gz</a></p><p><a href="http://www.cmake.org/files/v2.8/cmake-2.8.10.2.tar.gz" target="_blank" rel="noopener">http://www.cmake.org/files/v2.8/cmake-2.8.10.2.tar.gz</a></p><p>其中mysql使用最新的稳定版本，即最新试用版的上一个版本，且非rc或者alpha的版本，Cmake直接用的最新版。</p><p> 》上传mysql-5.5.40.tar.gz和cmake-2.8.10.2.tar.gz到/usr/java/tools文件夹下。</p><p> 》CentOS安装g++和ncurses-devel</p> <pre><code class="hljs plain"># yum install gcc-c++# yum install ncurses-devel</code></pre><p>》cmake的安装</p><pre><code class="hljs plain"># mkdir -p &#x2F;usr&#x2F;java&#x2F;make# cd &#x2F;usr&#x2F;java&#x2F;make# mv ..&#x2F;tools&#x2F;cmake-2.8.10.2.tar.gz .&#x2F;# tar -zxv -f cmake-2.8.10.2.tar.gz# cd cmake-2.8.10.2# .&#x2F;configure# make# make install</code></pre><p>》将cmake永久加入系统环境变量</p><p>》用vi在文件/etc/profile文件中增加变量，使其永久有效，</p><pre><code class="hljs plain"># vi &#x2F;etc&#x2F;profile</code></pre><p>》在文件PATH中加入MAKE_PATH环境变量：</p><pre><code class="hljs plain">JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.7.0_67JRE_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.7.0_67&#x2F;jreMAKE_PATH&#x3D;&#x2F;usr&#x2F;java&#x2F;cmake&#x2F;cmake-2.8.10.2&#x2F;binPATH&#x3D;MAKE_PATH:PATH:JAVA_HOME&#x2F;bin:JRE_HOME&#x2F;binCLASSPATH&#x3D;:JAVA_HOME&#x2F;lib&#x2F;dt.jar:JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JRE_HOME&#x2F;libexport JAVA_HOME JRE_HOME PATH CLASSPATH</code></pre><p>》执行以下代码使刚才的修改生效：</p><pre><code class="hljs plain"># source &#x2F;etc&#x2F;profile</code></pre><p>》用 export 命令查看PATH值</p><pre><code class="hljs plain"># echo $PATH</code></pre><p>》创建mysql的安装目录及数据库存放目录</p> <pre><code class="hljs plain"># mkdir -p &#x2F;usr&#x2F;java&#x2F;mysql &#x2F;&#x2F;安装mysql# mkdir -p &#x2F;usr&#x2F;java&#x2F;mysql&#x2F;data &#x2F;&#x2F;存放数据库</code></pre><p>》创建mysql用户及用户组</p><pre><code class="hljs plain"># groupadd mysql# useradd -r -g mysql mysql</code></pre><p>》编译安装mysql</p><pre><code class="hljs plain"># cd &#x2F;usr&#x2F;java&#x2F;mysql# tar zxvf ..&#x2F;tools&#x2F;mysql-5.5.40.tar.gz# cd mysql-5.5.40&#x2F;# cmake -DCMAKE_INSTALL_PREFIX&#x3D;&#x2F;usr&#x2F;java&#x2F;mysql \-DMYSQL_UNIX_ADDR&#x3D;&#x2F;usr&#x2F;java&#x2F;mysql&#x2F;mysql.sock \-DDEFAULT_CHARSET&#x3D;utf8 \-DDEFAULT_COLLATION&#x3D;utf8_general_ci \-DWITH_MYISAM_STORAGE_ENGINE&#x3D;1 \-DWITH_INNOBASE_STORAGE_ENGINE&#x3D;1 \-DWITH_MEMORY_STORAGE_ENGINE&#x3D;1 \-DWITH_READLINE&#x3D;1 \-DENABLED_LOCAL_INFILE&#x3D;1 \-DMYSQL_DATADIR&#x3D;&#x2F;usr&#x2F;java&#x2F;mysql&#x2F;data \-DMYSQL_USER&#x3D;mysql \-DMYSQL_TCP_PORT&#x3D;6666# make# make install</code></pre><p>》检验是否安装成功</p> <pre><code class="hljs plain"># cd  &#x2F;usr&#x2F;java&#x2F;mysql[root@fiona mysql]# lsbin      data  include         lib  mysql-5.5.40  mysql-test  scripts  sql-benchCOPYING  docs  INSTALL-BINARY  man  mysql.sock    README      share    support-files</code></pre><p> 有bin等以上文件的话，恭喜你已经成功安装了mysql。</p><p> 》配置mysql</p><p> 》设置mysql目录权限</p><pre><code class="hljs plain"># cd &#x2F;usr&#x2F;java&#x2F;mysql &#x2F;&#x2F;把当前目录中所有文件的所有者设为root，所属组为mysql# chown -R root:mysql .# chown -R mysql:mysql data</code></pre><p>》将mysql的启动服务添加到系统服务中</p><pre><code class="hljs plain"># cp support-files&#x2F;my-medium.cnf &#x2F;etc&#x2F;my.cnfcp：是否覆盖&quot;&#x2F;etc&#x2F;my.cnf&quot;？ y</code></pre><p>》创建系统数据库的表</p><pre><code class="hljs plain"># cd &#x2F;usr&#x2F;java&#x2F;mysql# scripts&#x2F;mysql_install_db --user&#x3D;mysql</code></pre><p>》设置环境变量</p><pre><code class="hljs plain"># vi &#x2F;root&#x2F;.bash_profile</code></pre><p>在修改PATH=$PATH:$HOME/bin为：</p><pre><code class="hljs plain">PATH&#x3D;PATH:HOME&#x2F;bin:&#x2F;usr&#x2F;java&#x2F;mysql&#x2F;bin:&#x2F;usr&#x2F;java&#x2F;mysql&#x2F;lib# source &#x2F;root&#x2F;.bash_profile &#x2F;&#x2F;使刚才的修改生效</code></pre><p>》手动启动mysql</p><pre><code class="hljs plain"># .&#x2F;bin&#x2F;mysqld_safe --user&#x3D;mysql &amp; &#x2F;&#x2F;启动MySQL，但不能停止mysqladmin -u root -p shutdown &#x2F;&#x2F;此时root还没密码，所以为空值，提示输入密码时，直接回车即可。</code></pre><p>》将mysql的启动服务添加到系统服务中</p><pre><code class="hljs plain"># cp support-files&#x2F;mysql.server &#x2F;etc&#x2F;init.d&#x2F;mysql</code></pre><p>》启动mysql</p><pre><code class="hljs plain"># service mysql startStarting MySQL... ERROR! The server quit without updating PID file (&#x2F;usr&#x2F;java&#x2F;mysql&#x2F;data&#x2F;localhost.localdomain.pid).</code></pre><p>》启动失败：</p><p>》我这里是权限问题，先改变权限</p><pre><code class="hljs plain"># chown -R mysql:mysql &#x2F;usr&#x2F;java&#x2F;mysql</code></pre><p>》接着启动服务器</p><pre><code class="hljs plain"># &#x2F;etc&#x2F;init.d&#x2F;mysql start</code></pre><p>》修改MySQL的root用户的密码以及打开远程连接</p><pre><code class="hljs plain"># mysql -u root mysqlmysql&gt; use mysql;mysql&gt; desc user;mysql&gt; GRANT ALL PRIVILEGES ON . TO root@&quot;%&quot; IDENTIFIED BY &quot;root&quot;; &#x2F;&#x2F;为root添加远程连接的能力mysql&gt; update user set Password &#x3D; password(&#39;x123456.&#39;) where User&#x3D;&#39;root&#39;; &#x2F;&#x2F;设置root用户密码mysql&gt; select Host,User,Password from user where User&#x3D;&#39;root&#39;;mysql&gt; flush privileges;mysql&gt; exit</code></pre><p>》重新登录</p><pre><code class="hljs plain"># mysql -u root -penter password:x123456.000</code></pre><p>》若还不能进行远程连接，关闭防火墙</p><pre><code class="hljs plain">[root@localhost]# &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;iptables stop</code></pre><p>用远程工具连接上了表示成功了。</p><hr><p>【TOMCAT7.0的安装】</p><hr><p>》先下载apache-tomcat-7.0.56.tar.gz</p><p>》下载地下：<a href="http://mirrors.hust.edu.cn/apache/tomcat/tomcat-7/v7.0.56/bin/apache-tomcat-7.0.56.tar.gz" target="_blank" rel="noopener">http://mirrors.hust.edu.cn/apache/tomcat/tomcat-7/v7.0.56/bin/apache-tomcat-7.0.56.tar.gz</a></p><pre><code class="hljs plain"># cd &#x2F;usr&#x2F;java# tar -zxvf .&#x2F;tools&#x2F;apache-tomcat-7.0.56.tar.gz# cd &#x2F;etc&#x2F;rc.d&#x2F;init.d# vi tomcat#----------输入以下信息---------------------## chkconfig: 345 80 15# description: Tomcat is a Servlet+JSP Engine.# Enter the jdk installation directoryjdk_File&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.7.0_67# Enter the tomcat installation directorytomcat_File&#x3D;&#x2F;usr&#x2F;java&#x2F;apache-tomcat-7.0.56export JAVA_HOME&#x3D;$jdk_File# Source function library.. &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;functionsstart()&#123;if [ -z $(&#x2F;sbin&#x2F;pidof java) ]; thenecho &quot;Starting tomcat&quot;$tomcat_File&#x2F;bin&#x2F;startup.shtouch &#x2F;var&#x2F;lock&#x2F;subsys&#x2F;tomcatelseecho &quot;tomcat allready running&quot;fi&#125;stop()&#123;if [ ! -z $(&#x2F;sbin&#x2F;pidof java) ]; thenecho &quot;Shutting down tomcat&quot;$tomcat_File&#x2F;bin&#x2F;shutdown.shuntil [ -z $(&#x2F;sbin&#x2F;pidof java) ]; do :; donerm -f &#x2F;var&#x2F;lock&#x2F;subsys&#x2F;tomcatelseecho &quot;tomcat not running&quot;fi&#125;case &quot;$1&quot; instart)start;;stop)stop;;restart)stopstart;;status)$tomcat_File&#x2F;bin&#x2F;catalina.sh version;;*)echo &quot;Usage: $0 &#123;start|stop|restart|status&#125;&quot;esacexit 0#----------输入以下信息---------------------:wq! #保存退出 # chmod 755 &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;tomcat #添加执行权限# chkconfig --add tomcat #添加服务# chkconfig tomcat on #设置开机启动# service tomcat stop #停止# service tomcat start #启动# service tomcat restart #重启# service tomcat status #查看状态信息</code></pre><hr><p>【nginx-1.7.6.tar.gz的安装】</p><hr><p>》先下载nginx-1.7.6.tar.gz</p><p>》下载URL:<a href="http://nginx.org/download/nginx-1.7.6.tar.gz" target="_blank" rel="noopener">http://nginx.org/download/nginx-1.7.6.tar.gz</a></p><p>》把nginx-1.7.6.tar.gz放到/usr/java/tools目录下</p><pre><code class="hljs plain"># cd &#x2F;usr&#x2F;local&#x2F;# tar -zxvf &#x2F;usr&#x2F;java&#x2F;tools&#x2F;nginx-1.7.5.tar.gz# cd nginx-1.7.6&#x2F;# yum -y install pcre-devel# yum install -y zlib-devel# .&#x2F;configure# make &amp;&amp; make install# cd &#x2F;usr&#x2F;local&#x2F;nginx# cd sbin# .&#x2F;nginx# &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;iptables stop</code></pre><p>》配置服务器启动方式</p><pre><code class="hljs plain"># vi &#x2F;etc&#x2F;init.d&#x2F;nginx#---------输入以下信息------------------# nginx Startup script for the Nginx HTTP Server# it is v.0.0.2 version.# chkconfig: - 85 15# description: Nginx is a high-performance web and proxy server.# It has a lot of features, but it&#39;s not for everyone.# processname: nginx# pidfile: &#x2F;software&#x2F;nginx&#x2F;logs&#x2F;nginx.pid# config: &#x2F;software&#x2F;nginx&#x2F;conf&#x2F;nginx.confnginxd&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginxnginx_config&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.confnginx_pid&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pidRETVAL&#x3D;0prog&#x3D;&quot;nginx&quot;# Source function library.. &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;functions# Source networking configuration.. &#x2F;etc&#x2F;sysconfig&#x2F;network# Check that networking is up.[ $&#123;NETWORKING&#125; &#x3D; &quot;no&quot; ] &amp;&amp; exit 0[ -x $nginxd ] || exit 0# Start nginx daemons functions.start() &#123;if [ -e $nginx_pid ];thenecho &quot;nginx already running....&quot;exit 1fiecho -n &quot;Starting prog: &quot;daemon nginxd -c &#123;nginx_config&#125;RETVAL&#x3D;$?echo[ $RETVAL &#x3D; 0 ] &amp;&amp; touch &#x2F;var&#x2F;lock&#x2F;subsys&#x2F;nginxreturn $RETVAL&#125;# Stop nginx daemons functions.stop() &#123;echo -n &quot;Stopping prog: &quot;killproc $nginxdRETVAL&#x3D;$?echo[ $RETVAL &#x3D; 0 ] &amp;&amp; rm -f &#x2F;var&#x2F;lock&#x2F;subsys&#x2F;nginx &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid&#125;reload() &#123;echo -n &quot;Reloading prog: &quot;#kill -HUP cat $&#123;nginx_pid&#125;killproc $nginxd -HUPRETVAL&#x3D;$?echo&#125;# See how we were called.case &quot;$1&quot; instart)start;;stop)stop;;reload)reload;;restart)stopstart;;status)status $progRETVAL&#x3D;$?;;*)echo &quot;Usage: prog &#123;start|stop|restart|reload|status|help&#125;&quot;exit 1esacexit $RETVAL#---------输入以下信息------------------# chmod 755 &#x2F;etc&#x2F;init.d&#x2F;nginx &amp;&amp; chkconfig nginx on# service nginx start# service nginx stop# service nginx restart# ps -ef | grep nginx# netstat -pant | grep 80</code></pre><p>》测试在浏览器中输入广域网IP看看能不能看到欢迎界面，如果能就表示成功了。</p><hr><p>【配置规则】</p><hr><pre><code class="hljs plain"># vi &#x2F;etc&#x2F;sysconfig&#x2F;iptables</code></pre><p>增加如下配置:</p><blockquote><p>-A INPUT -m state –state NEW -m tcp -p tcp –dport 80 -j ACCEPT</p><p>-A INPUT -m state –state NEW -m tcp -p tcp –dport 8888 -j ACCEPT</p><p>-A INPUT -m state –state NEW -m tcp -p tcp –dport 6666 -j ACCEPT</p></blockquote><pre><code class="hljs plain"># service iptables restart</code></pre><p>》系统启动的方式为自启动</p><pre><code class="hljs plain"># chkconfig mysql on# chkconfig nginx on# chkconfig tomcat on</code></pre><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Server</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CentOS</tag>
      
      <tag>MySQL</tag>
      
      <tag>JDK</tag>
      
      <tag>Tomcat</tag>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS 7 安装 Apache, MySQL, PHP 指南</title>
    <link href="/2018/09/11/CentOS-7-%E5%AE%89%E8%A3%85-Apache-MySQL-PHP-%E6%8C%87%E5%8D%97/"/>
    <url>/2018/09/11/CentOS-7-%E5%AE%89%E8%A3%85-Apache-MySQL-PHP-%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>一个 LAMP 软件栈通常由多个开源软件组合而成，它们合力驱动一个服务器去运行 web 站点和应用。LAMP 这个术语实际上是一个由 Linux 操作系统，Apache web 服务器，MySQL 数据库服务器，以及 PHP 编程环境组合缩略而成的。</p><p>在这篇指南中，我们将为一个搭载 CentOS 7 操作系统的服务器安装 LAMP 软件栈。CentOS 已经满足了 LAMP 软件栈的第一个需求：一个 Linux 操作系统。</p> <a id="more"></a><p>预备条件</p><p>在继续阅读这篇指南之前，请确认你使用具有 root 权限的用户登录了 CentOS。如果对于当前用户如何取得 root 权限存在疑问，请咨询服务器的管理人员。</p><p>第一步 —— 安装 Apache</p><p>Apache 是目前世界上最广泛使用的 web 服务器，这使得它成为运行网站的绝佳选择。</p><p>利用 CentOS 的软件安装包管理系统 yum，我们可以轻易地安装 Apache。它为我们提供了无痛式地从 CentOS 维护的仓库获取并安装绝大多数软件的方式。你可以前往这里 (<a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-and-use-yum-repositories-on-a-centos-6-vps" target="_blank" rel="noopener">https://www.digitalocean.com/community/tutorials/how-to-set-up-and-use-yum-repositories-on-a-centos-6-vps</a>) 获取更多如何使用 yum 安装包管理系统的指导。</p><p>对于我们的目的而言，安装 Apache 只需要在 CentOS 命令终端敲入这条命令就行了：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo yum install httpd</span></code></pre><p>由于使用了 sudo 命令，这些操作将以 root 权限执行。如果当前用户的身份不是 root，CentOS 将会要求你输入当前用户的密码，以验证你的意图。</p><p>不用一会儿，你的 web 服务器就安装好了。</p><p>一旦安装成功，你就可以设置服务器启动时就开启 Apache 服务：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo systemctl <span class="hljs-built_in">enable</span> httpd.service</span></code></pre><p>你可以通过重新启动服务器，然后在命令行终端中敲入这条命令来验证 Apache 服务是否在服务器启动时自动开启了：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo systemctl is-enabled httpd.service</span></code></pre><p>如果你看到了这样的响应：</p><pre><code class="hljs shell">enabled</code></pre><p>则说明 Apache 服务已经配置为在服务器启动时自动开启了。</p><p>在服务器上启动 Apache 服务的命令为：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash">sudo systemctl start httpd.service</span></code></pre><p>重新启动 Apache：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash">sudo systemctl restart httpd.service</span></code></pre><p>停止 Apache：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash">sudo systemctl stop httpd.service</span></code></pre><p>以及</p><p>如果你的服务器正在运行防火墙，请运行下列命令以允许它进行 HTTP 和 HTTPS 通信：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash">sudo firewall-cmd --permanent --zone=public --add-service=http</span><span class="hljs-meta">$</span><span class="bash">sudo firewall-cmd --permanent --zone=public --add-service=https</span><span class="hljs-meta">$</span><span class="bash">sudo firewall-cmd --reload</span></code></pre><p>在 Apache 启动的情况下，你可以在浏览器里访问服务器的公网 IP 地址以验证一切如计划那样顺利地进行（如果你现在还不知道如何获取服务器的公网 IP 地址，请参考下一标题中的内容）：</p><p>http://&lt;服务器的公网 IP 地址&gt;/</p><p>你将会看到一个出于通知和测试目的而存在的默认 CentOS 7 Apache 网页。它应该长这样子：</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymrtia7nj30jv05zaaj.jpg" srcset="/img/loading.gif" alt="img"></p><p>如果你看到了这个页面，那么你的 web 服务器现在已经正确地安装了。</p><p>如何找到服务器的公网 IP 地址</p><p>如果你不知道服务器的公网 IP 地址是什么，你可以使用多种方式找到它。通常情况下，它就是你通过 SSH 用以连接服务器的地址。</p><p>在命令行终端中，你有多种方式找到它。首先，你可以通过下面这条命令，让 iproute2 工具帮你找出服务器的 IP 地址：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ip addr show eth1 | grep inet | awk <span class="hljs-string">'&#123; print $2; &#125;'</span> | sed <span class="hljs-string">'s/\/.*$//'</span></span></code></pre><p>这将会返回一到两行结果。它们都是正确的 IP 地址，但是你的计算机可能只能使用其中的一条，所以随意试试其中的每一条。</p><p>另一种方法是让一个外部组织告诉你它是怎样找到你的服务器的，你可以通过询问特定的服务器来获知自己的 IP 地址：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> curl http://icanhazip.com</span></code></pre><p>第二步 —— 安装 MySQL</p><p>MySQL 是一个 web 服务器上流行的数据库管理系统。然而，从 CentOS 7 的软件仓库不再提供 MySQL 的安装包，转而提供 MariaDB 作为默认的数据库管理系统。MariaDB 作为 MySQL 的简易替代品，足以胜任通常意义上你对的数据库系统的需求 (<a href="https://mariadb.com/kb/en/mariadb/mariadb-vs-mysql-compatibility/)。你可以前往这里" target="_blank" rel="noopener">https://mariadb.com/kb/en/mariadb/mariadb-vs-mysql-compatibility/)。你可以前往这里</a> (<a href="https://www.linode.com/docs/databases/mariadb/how-to-install-mariadb-on-centos-7" target="_blank" rel="noopener">https://www.linode.com/docs/databases/mariadb/how-to-install-mariadb-on-centos-7</a>) 获取在 CentOS 7 上安装 MariaDB 的指导。</p><p>如果你不论如何都更需要 MySQL 作为 web 服务器上的数据管理系统，那么请继续阅读下面这部分指南，它将指引你如何在运行 CentOS 7 的服务器上安装并配置 MySQL 数据库。</p><p>开始安装 MySQL 之前，请更新系统上的软件到最新版：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo yum update</span></code></pre><p>由于 CentOS 7 的软件仓库不再提供 MySQL 的安装包，我们必须从 MySQL 社区仓库 (<a href="https://dev.mysql.com/downloads/repo/yum/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/repo/yum/</a>) 获取 MySQL 安装包。</p><p>首先，获取 MySQL 社区仓库：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> wget http://repo.mysql.com/mysql57-community-release-el7-8.noarch.rpm</span></code></pre><p>载入 MySQL 社区仓库：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo yum install mysql57-community-release-el7-8.noarch.rpm</span></code></pre><p>更新系统上的软件到最新版：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo yum update</span></code></pre><p>在更新过程中，你会被询问是否想接受这个 .rpm 文件 GPG 校验得出的结果，如果没有错误或者不匹配出现，请输入 y 以完成更新。</p><p>接着，我们就能一如往常一样安装 MySQL 了：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo yum install mysql-server</span></code></pre><p>接下来，请按照这里的指南，重置 MySQL root 账户的密码为你能够记住的密码:</p><p><a href="http://stackoverflow.com/questions/33510184/change-mysql-root-password-on-centos7" target="_blank" rel="noopener">http://stackoverflow.com/questions/33510184/change-mysql-root-password-on-centos7</a></p><p>然后，启动 MySQL 服务：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo systemctl start mysqld</span></code></pre><p>现在 MySQL 数据库已经开始运行了。我们希望运行一个安全防御脚本，将一些危险的默认配置移除掉，并为我们的数据库系统加上一点安全机制。请在命令行终端里运行下面这一条命令：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo mysql_secure_installation</span></code></pre><p>命令行终端将会提示你输入 MySQL 内 root 用户的密码。键入上面重置 MySQL root 密码后的新密码。然后，命令行终端将会要求你更新 root 用户的密码。</p><pre><code class="hljs shell">Enter current password for root:The existing password for the user account root has expired. Please set a new password.New password:Re-enter new password:The 'validate_password' plugin is installed on the server.The subsequent steps will run with the existing configurationof the plugin.Using existing password for root.</code></pre><p>对于命令行终端接下来给出的选择，你应该敲击 ENTER 键选择忽略修改 root 密码，接着键入 y 同意移除掉出于示例目的而存在的用户，而后键入 y 同意禁用远程登录 root 用户，再次键入 y 同意移除测试数据库，最后键入 y 载入这些新的规则使得 MySQL 立即响应我们做的变更。</p><p>最后，如果希望 MySQL 服务在服务器启动时自动开启，那么你应该使用这一条的命令：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo systemctl <span class="hljs-built_in">enable</span> mysqld.service</span></code></pre><p>你可以通过重新启动服务器，然后在命令行终端中敲入这条命令来验证MySQL 服务是否在服务器启动时自动开启了：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo systemctl is-enabled mysqld.service</span></code></pre><p>如果你看到了这样的响应：</p><pre><code class="hljs shell">enabled</code></pre><p>则说明 MySQL 服务已经配置为在服务器启动时自动开启了。</p><p>现在，你的数据库系统已经安装妥当，我们可以继续后面的内容了。</p><p>第三步 —— 安装 PHP</p><p>在我们的 web 软件栈中，PHP 是一个能够处理业务逻辑和数据，并动态生成内容展现给用户的软件。它可以运行脚本，连接到 MySQL 数据库以存取数据，以及将处理过的内容递交给 web 服务器来显示。</p><p>我们可以再次利用 yum 安装包管理系统来安装我们的组件。现在，我们打算将 php-mysql 也加入到我们将要安装的软件序列中：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo yum install php php-mysql</span></code></pre><p>这里安装 PHP 应该不会有任何问题。我们需要重新启动 Apache web 服务器以便它能够与 PHP 协作。你可以通过这条命令达到目的：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo systemctl restart httpd.service</span></code></pre><p>安装 PHP 模块</p><p>为了增强 PHP 的功能，我们可以选择性地安装一些额外的模块。</p><p>在命令行终端敲入这条命令，你就可以找到所有可以获取到的 PHP 模块选项和库：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yum search php</span></code></pre><p>响应的结果就是所有你能够选择安装的组件。其中包含了每个可选组件的描述：</p><pre><code class="hljs shell">php-bcmath.x86_64 : A module for PHP applications for using the bcmath libraryphp-cli.x86_64 : Command-line interface for PHPphp-common.x86_64 : Commonfiles for PHPphp-dba.x86_64 : Adatabase abstraction layer module for PHP applicationsphp-devel.x86_64 : Filesneeded for building PHP extensionsphp-embedded.x86_64 : PHPlibrary for embedding in applicationsphp-enchant.x86_64 : Enchantspelling extension for PHP applicationsphp-fpm.x86_64 : PHPFastCGI Process Managerphp-gd.x86_64 : Amodule for PHP applications for using the gd graphics library. . .</code></pre><p>如果需要获取每个模块更多的信息，你可以通过互联网搜索，或者直接在命令行终端中敲入这条命令查看：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yum info package_name</span></code></pre><p>响应中将会包含许多的信息，其中一个名为 Description 的域包含了这个模块提供的功能更为详尽的描述。</p><p>举个例子，如果要获知 php-fpm 模块的功能，我们只要在命令行终端中敲入下列指令就可以了：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> yum info php-fpm</span></code></pre><p>顺着众多其他信息往下看，你将会找到形如这样的信息：</p><pre><code class="hljs shell">. . .Summary    : PHPFastCGI Process ManagerURL            : http://www.php.net/License       : PHPand Zend and BSDDescription : PHP-FPM (FastCGI Process Manager) is an alternative PHP FastCGI​                   : implementation with some additional features useful for sites of​                   : any size, especially busier sites.</code></pre><p>在考究之后，如果你决定要安装一个模块包，你可以像我们之前安装其他软件时的做法一样，使用 yum install 命令达到目的。</p><p>如果我们决定了 php-fpm 就是我们需要的，那么我们可以在命令行终端键入：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo yum install php-fpm</span></code></pre><p>如果你想安装多于 1 个的模块包，你可以在命令行终端中键入 yum install 后，列出你想安装的每个模块包，并使用空格区分，就像下面这样子：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo yum install package1 package2…</span></code></pre><p>现在，你的 LAMP 软件栈已经安装并配置妥当了。但我们仍需要测试一下 PHP。</p><p>第四步 —— 测试你 Web 服务器上的 PHP 处理程序</p><p>为了测试系统已经配置得适合 PHP 运行，我们可以创建一个非常简易的 PHP 脚本。</p><p>我们将这个脚本命名为 info.php。为了让 Apache 能够正确地找到并为之服务，它必须保存在一个称为『web 目录』特殊的目录中。</p><p>在 CentOS 7 中，这个目录位于 /var/www/html/。我们可以通过下面这条命令在此创建一个文件：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo vi /var/www/html/info.php</span></code></pre><p>这将会打开一个空白文件，敲击小写字母 I 即可进行编辑。我们想在文件中输入下列 PHP 代码组成的文本：</p><?php phpinfo(); ?><p>然后，敲击 ESC 键并键入 :wq! 即可保存并关闭这个文件。</p><p>现在我们可以测试 web 服务器是否能够正确地显示由 PHP 脚本生成的内容了。我们可以尝试通过 web 浏览器访问这个页面。你需要再次获取服务器的公网 IP 地址。</p><p>你希望访问的地址就是：</p><p>http://&lt;服务器的公网 IP 地址&gt;/info.php</p><p>你看到的页面应该像下面这样子：</p><p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006tNbRwgy1g9ymru1oojj30jv05zaaj.jpg" srcset="/img/loading.gif" alt="img"></p><p>如果你的浏览器成功地显示了这个页面，那么你的 PHP 就像预期中的那样正常工作了。</p><p>你很可能想要在测试之后移除掉这个文件，因为它事实上可以将服务器的信息展现给未授权的用户。为此，我们需要在命令行终端中键入下面这条命令：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo rm /var/www/html/info.php</span></code></pre><p>以后若需要，你总能重新创建这个页面来获取这些信息。</p><p>结论</p><p>现在我们已经安装了 LAMP 软件栈，对于下一步需要做什么，你有许多的选择。大体上，你已经安装了一个允许你在服务器上部署各种各样网站和 web 软件的平台。</p><p>参考链接</p><p><a href="https://www.digitalocean.com/community/tutorials/how-to-install-linux-apache-mysql-php-lamp-stack-on-centos-7" target="_blank" rel="noopener">https://www.digitalocean.com/community/tutorials/how-to-install-linux-apache-mysql-php-lamp-stack-on-centos-7</a></p><p><a href="https://www.linode.com/docs/databases/mysql/how-to-install-mysql-on-centos-7" target="_blank" rel="noopener">https://www.linode.com/docs/databases/mysql/how-to-install-mysql-on-centos-7</a></p><p><a href="http://dev.mysql.com/doc/refman/5.7/en/linux-installation-yum-repo.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.7/en/linux-installation-yum-repo.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Server</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CentOS</tag>
      
      <tag>Apache</tag>
      
      <tag>MySQL</tag>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Postgresql 9.4.0-1 x64 win7 解压版安装步骤</title>
    <link href="/2018/09/11/Postgresql-9-4-0-1-x64-win7-%E8%A7%A3%E5%8E%8B%E7%89%88%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/"/>
    <url>/2018/09/11/Postgresql-9-4-0-1-x64-win7-%E8%A7%A3%E5%8E%8B%E7%89%88%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/</url>
    
    <content type="html"><![CDATA[<p>1、下载</p><blockquote><p>32位：<a href="https://get.enterprisedb.com/postgresql/postgresql-10.2-1-windows-binaries.zip" target="_blank" rel="noopener">https://get.enterprisedb.com/postgresql/postgresql-10.2-1-windows-binaries.zip</a></p><p>64位：<a href="https://get.enterprisedb.com/postgresql/postgresql-10.2-1-windows-x64-binaries.zip" target="_blank" rel="noopener">https://get.enterprisedb.com/postgresql/postgresql-10.2-1-windows-x64-binaries.zip</a></p></blockquote><p>2、解压到：c:\pgsql\</p><a id="more"></a><p>3、设置环境变量(cmd)：</p><pre><code class="hljs bash">setx PGHOME c:\pgsqlsetx PGHOST localhostsetx PGLIB %PGHOME%\libsetx PGDATA %PGHOME%\datasetx Path %Path%;%PGHOME%\bin</code></pre><p>重新登录</p><p>4、初始化数据库</p><pre><code class="hljs bash">initdb.exe -D c:\pgsql\data -E UTF-8 --locale=chs -U postgres -W</code></pre><p>5、注册为系统服务（以管理员权限打开cmd） </p><pre><code class="hljs bash">pg_ctl register -N PostgreSQL -D c:\pgsql\data</code></pre><p>6、修改配置以支持远程连接</p><p>  6.1  notepad c:\pgsql\data\postgresql.conf</p><blockquote><p>listen_addresses = ‘*’ </p></blockquote><p>​    6.2  设置ipv4段  notepad c:\pgsql\data\pg_hba.conf </p><blockquote><p>host    all    all    0.0.0.0/0    md5 </p></blockquote><p>7、启动服务 </p><pre><code class="hljs bash">net start PostgreSQL</code></pre><p>8、关闭防火墙（视情况而定） </p><pre><code class="hljs bash">netsh firewall <span class="hljs-built_in">set</span> opmode <span class="hljs-built_in">disable</span></code></pre><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Sql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PostgreSQL</tag>
      
      <tag>windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux服务器初始化设置用户和ssh公私钥登陆</title>
    <link href="/2018/09/11/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7%E5%92%8Cssh%E5%85%AC%E7%A7%81%E9%92%A5%E7%99%BB%E9%99%86/"/>
    <url>/2018/09/11/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7%E5%92%8Cssh%E5%85%AC%E7%A7%81%E9%92%A5%E7%99%BB%E9%99%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>当我们开始使用一个新的服务器的时候，首先一定要对服务器的登陆等做一些修改工作，笔者曾经就因为对服务器登陆安全没有重视，导致服务器数据全部丢失。接下来我们按照步骤，罗列出应该做的一些事情。 </p></blockquote><h3 id="修改ssh端口号"><a href="#修改ssh端口号" class="headerlink" title="修改ssh端口号"></a>修改ssh端口号</h3><p>第一件事情：</p><p>修改ssh端口号： 之后加上一个端口比如说50000</p><p><code>vi /etc/ssh/sshd_config</code>之后在port字段加上一个端口比如说50000，原来的端口号字段可能是被注释掉的，要先解除注释。</p><p>然后执行：</p><a id="more"></a><pre><code class="hljs plain">service sshd restart</code></pre><p>这个时候可能还要重新配置一下防火墙，开放50000端口，具体如何配置也可以参考<a href="https://blog.csdn.net/ul646691993/article/details/52104082" target="_blank" rel="noopener">这里</a>的后半部分。但是目前，阿里云的服务器实测是不需要再配置防火墙的，但是需要去登陆到网页后台修改安全组。</p><p>之后就可以通过这样的方式登录了：(注意登录方式一定要写对)</p><pre><code class="hljs plain">ssh root@115.29.102.81 -p 50000</code></pre><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>这个时候我们还是用root进行操作，所以我们接下来要给自己创建一个账户，比如创建一个如下的用户：</p><pre><code class="hljs plain">useradd xiaotaopasswd xiaotao</code></pre><p>可以用`ls -al /home/``查看一下账户</p><p>对创建的这个用户增加sudo权限： 相关配置文件/etc/sudoers中，但是这个文件是只读的，所以要更改一下权限</p><pre><code class="hljs plain">chmod u+w sudoers</code></pre><p>然后进入这个文件在这里进行更改：</p><pre><code class="hljs plain">root    ALL&#x3D;(ALL)       ALLxiaotao  ALL&#x3D;(ALL)       ALL</code></pre><p>然后再改回权限：</p><pre><code class="hljs plain">chmod u-w sudoers</code></pre><p>注意一点，CentOS 7预设容许任何帐号透过ssh登入（也就是说自己根本不用改改，直接新建帐号登录即可），包括根和一般帐号，为了不受根帐号被黑客暴力入侵，我们必须禁止 root帐号的ssh功能，事实上root也没有必要ssh登入伺服器，因为只要使用su或sudo（当然需要输入root的密码）普通帐号便可以拥有root的权限。使用vim（或任何文本编辑器）开启的/ etc/ SSH/ sshd_config中，寻找：</p><pre><code class="hljs plain">＃PermitRootLogin yes</code></pre><p>修改：</p><pre><code class="hljs plain">PermitRootLogin no</code></pre><h3 id="配置公私钥加密登录"><a href="#配置公私钥加密登录" class="headerlink" title="配置公私钥加密登录"></a>配置公私钥加密登录</h3><p><strong>这一步骤要切换到自己新建的用户，不能再用 root 用户了，否则可能无法正常登陆。</strong></p><p>很多时候以上所说的还是不够安全，为了更加安全方便，我们采用公私钥对称加密登录，简单的讲做法就是再客户端生成一把私钥一把公钥，私钥是在客户端的，公钥上传到服务端，对称加密进行登录。</p><p>在客户端先进到这个目录：</p><pre><code class="hljs plain">cd ~&#x2F;.ssh</code></pre><p>生成公钥和私钥（实际上如果之前有的话就不用重新生成了）</p><pre><code class="hljs plain">ssh-keygen -t rsa</code></pre><p>接下来把公钥上传到服务端</p><pre><code class="hljs plain">scp ~&#x2F;.ssh&#x2F;id_rsa.pub xiaotao@&lt;ssh_server_ip&gt;:~</code></pre><p>在服务端执行以下命令(如果没有相关的文件和文件夹要先进行创建，注意不要使用 sudo )</p><pre><code class="hljs plain">cat  id_rsa.pub &gt;&gt; ～&#x2F;.ssh&#x2F;authorized_keys</code></pre><p>配置服务器的/etc/ssh/sshd_config，下面是一些建议的配置：</p><pre><code class="hljs plain">vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config# 禁用root账户登录，非必要，但为了安全性，请配置PermitRootLogin no# 是否让 sshd 去检查用户家目录或相关档案的权限数据，# 这是为了担心使用者将某些重要档案的权限设错，可能会导致一些问题所致。# 例如使用者的 ~.ssh&#x2F; 权限设错时，某些特殊情况下会不许用户登入StrictModes no# 是否允许用户自行使用成对的密钥系统进行登入行为，仅针对 version 2。# 至于自制的公钥数据就放置于用户家目录下的 .ssh&#x2F;authorized_keys 内RSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile      %h&#x2F;.ssh&#x2F;authorized_keys#有了证书登录了，就禁用密码登录吧，安全要紧PasswordAuthentication no</code></pre><p>然后不要忘记 <code>sudo service sshd restart</code></p><p>一般来讲，这样就算是成功了，我们可以在客户端尝试：</p><pre><code class="hljs plain">ssh -i ~&#x2F;.ssh&#x2F;id_rsa remote_username@remote_ip</code></pre><p>如果不行，可能是服务端或客户端相关 <code>.ssh</code> 文件权限不对，可以进行如下尝试：</p><pre><code class="hljs plain">服务端chown -R 0700  ~&#x2F;.sshchown -R 0644  ~&#x2F;.ssh&#x2F;authorized_keys客户端改一下chmod 600 id_rsa</code></pre><p><strong>欢迎关注微信公众号​：</strong></p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>SSH</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS7下安装和配置redis</title>
    <link href="/2018/09/11/CentOS7%E4%B8%8B%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AEredis/"/>
    <url>/2018/09/11/CentOS7%E4%B8%8B%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AEredis/</url>
    
    <content type="html"><![CDATA[<p>Redis是一个高性能的，开源key-value型数据库。是构建高性能，可扩展的Web应用的完美解决方案，可以内存存储亦可持久化存储。因为要使用跨进程，跨服务级别的数据缓存，在对比多个方案后，决定使用Redis。顺便整理下Redis的安装过程，以便查阅。</p><p>1 . 下载Redis<br>目前，最新的Redist版本为3.0，使用wget下载，命令如下：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> wget http://download.redis.io/releases/redis-3.0.4.tar.gz</span></code></pre><a id="more"></a><p>2 . 解压Redis<br>下载完成后，使用tar命令解压下载文件：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> tar -xzvf redis-3.0.4.tar.gz</span></code></pre><p>3 . 编译安装Redis<br>切换至程序目录，并执行make命令编译：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">cd</span> redis-3.0.4</span><span class="hljs-meta">#</span><span class="bash"> make</span></code></pre><p>执行安装命令</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> make install</span></code></pre><p>make install安装完成后，会在/usr/local/bin目录下生成下面几个可执行文件，它们的作用分别是：</p><ul><li>redis-server：Redis服务器端启动程序</li><li>redis-cli：Redis客户端操作工具。也可以用telnet根据其纯文本协议来操作</li><li>redis-benchmark：Redis性能测试工具</li><li>redis-check-aof：数据修复工具</li><li>redis-check-dump：检查导出工具</li></ul><p>备注</p><p>有的机器会出现类似以下错误：</p><pre><code class="hljs shell">make[1]: Entering directory `/root/redis/src'You need tcl 8.5 or newer in order to run the Redis test……</code></pre><p>这是因为没有安装tcl导致，yum安装即可：</p><pre><code class="hljs shell">yum install tcl</code></pre><p>4 . 配置Redis<br>复制配置文件到/etc/目录：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> cp redis.conf /etc/</span></code></pre><p>为了让Redis后台运行，一般还需要修改redis.conf文件：</p><pre><code class="hljs shell">vi /etc/redis.conf</code></pre><p>修改daemonize配置项为yes，使Redis进程在后台运行：</p><pre><code class="hljs shell">daemonize yes</code></pre><p>5 . 启动Redis<br>配置完成后，启动Redis：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/bin</span><span class="hljs-meta">#</span><span class="bash"> ./redis-server /etc/redis.conf</span></code></pre><p>检查启动情况：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> ps -ef | grep redis</span></code></pre><p>看到类似下面的一行，表示启动成功：</p><pre><code class="hljs shell">root     18443     1  0 13:05 ?        00:00:00 ./redis-server *:6379</code></pre><p>6 . 添加开机启动项<br>让Redis开机运行可以将其添加到rc.local文件，也可将添加为系统服务service。本文使用rc.local的方式，添加service请参考：Redis 配置为 Service 系统服务 。</p><p>为了能让Redis在服务器重启后自动启动，需要将启动命令写入开机启动项：</p><pre><code class="hljs shell">echo "/usr/local/bin/redis-server /etc/redis.conf" &gt;&gt;/etc/rc.local</code></pre><p>7 . Redis配置参数<br>在 前面的操作中，我们用到了使Redis进程在后台运行的参数，下面介绍其它一些常用的Redis启动参数：</p><blockquote><p>daemonize：是否以后台daemon方式运行<br>pidfile：pid文件位置<br>port：监听的端口号<br>timeout：请求超时时间<br>loglevel：log信息级别<br>logfile：log文件位置<br>databases：开启数据库的数量<br>save * <em>：保存快照的频率，第一个</em>表示多长时间，第三个*表示执行多少次写操作。在一定时间内执行一定数量的写操作时，自动保存快照。可设置多个条件。<br>rdbcompression：是否使用压缩<br>dbfilename：数据快照文件名（只是文件名）<br>dir：数据快照的保存目录（仅目录）<br>appendonly：是否开启appendonlylog，开启的话每次写操作会记一条log，这会提高数据抗风险能力，但影响效率。<br>appendfsync：appendonlylog如何同步到磁盘。三个选项，分别是每次写都强制调用fsync、每秒启用一次fsync、不调用fsync等待系统自己同步</p></blockquote><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Server</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>CentOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS安装node8.x版本</title>
    <link href="/2018/09/11/CentOS%E5%AE%89%E8%A3%85node8-x%E7%89%88%E6%9C%AC/"/>
    <url>/2018/09/11/CentOS%E5%AE%89%E8%A3%85node8-x%E7%89%88%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>由于一些原因需要给CentOS服务器安装8.0以上版本的node, 本来直接通过yum管理安装管理，但是没找到好办法，在此记录一下自己最后使用的简单过程：</p><p>安装之前删除原来的node和npm (我原来是用yum安装的，如果是第一次安装可以省略这一步):</p><pre><code class="hljs bash">yum remove nodejs npm -y</code></pre><a id="more"></a><p>首先我们随便进入服务器的一个目录，然后从淘宝的源拉取内容: </p><pre><code class="hljs bash">wget https://npm.taobao.org/mirrors/node/v8.0.0/node-v8.0.0-linux-x64.tar.xz</code></pre><p>解压缩: </p><pre><code class="hljs bash">sudo tar -xvf node-v8.0.0-linux-x64.tar.xz</code></pre><p>进入解压目录下的 bin 目录，执行 ls 命令 </p><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> node-v8.0.0-linux-x64/bin &amp;&amp; ls</code></pre><p>我们发现有node 和 npm</p><p>这个时候我们测试:</p><pre><code class="hljs bash">./node -v</code></pre><p>这个时候我们发现实际上已经安装好了，接下来就是要建立链接文件。</p><p>这里还是，如果我们之前已经安装过了，那么我们要先删除之前建立的链接文件：</p><pre><code class="hljs bash">sudo rm -rf /usr/bin/nodesudo rm -rf /usr/bin/npm</code></pre><p>然后建立链接文件: </p><pre><code class="hljs bash">sudo ln -s /usr/share/node-v8.0.0-linux-x64/bin/node /usr/bin/nodesudo ln -s /usr/share/node-v8.0.0-linux-x64/bin/npm /usr/bin/npm</code></pre><p>注意这里的第一个路径不要直接复制粘贴，要写当前文件的真正的路径，这个可以通过pwd获取。</p><p>然后我们可以通过<code>node -v</code>等测试已经安装成功。</p><img src="https://gitee.com/alterem/picFB/raw/master/pics/2020/04/07/006y8mN6gy1g7d3llw1nkj30b40b4wee.jpg" srcset="/img/loading.gif" alt="欢迎关注公众号" style="width: 100px" />]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Server</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CentOS</tag>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Eclipse中常用的操作单词</title>
    <link href="/2018/09/11/Eclipse%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E5%8D%95%E8%AF%8D/"/>
    <url>/2018/09/11/Eclipse%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C%E5%8D%95%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th>Existing Project   into Workspace</th><th>现有的工程引入工作空间(加载工程)</th></tr></thead><tbody><tr><td>File</td><td>文件</td></tr><tr><td>New</td><td>新建</td></tr><tr><td>Project</td><td>工程</td></tr><tr><td>Folder</td><td>文件夹</td></tr><tr><td>Import</td><td>引入(加载&amp;导入)</td></tr><tr><td>Run As</td><td>运行</td></tr><tr><td>Application</td><td>应用程序</td></tr><tr><td>copy</td><td>复制</td></tr><tr><td>paste</td><td>粘贴</td></tr><tr><td>Delete</td><td>删除</td></tr><tr><td>properties</td><td>属性</td></tr><tr><td>Java Build Path</td><td>建立java路径</td></tr><tr><td>Libraries</td><td>库</td></tr><tr><td>Add Library</td><td>添加库</td></tr><tr><td>User Library</td><td>用户库</td></tr><tr><td>Next</td><td>下一步</td></tr><tr><td>User Libraries</td><td>用户库</td></tr><tr><td>New</td><td>新建</td></tr><tr><td>JDBC-ODBC</td><td>桥</td></tr></tbody></table><a id="more"></a><table><thead><tr><th>需掌握的单词</th><th></th></tr></thead><tbody><tr><td>overload</td><td>重载</td></tr><tr><td>override</td><td>重写(覆盖)</td></tr></tbody></table><table><thead><tr><th>程序编写时常用的单词</th><th></th></tr></thead><tbody><tr><td>package</td><td>指定文件夹</td></tr><tr><td>class</td><td>类</td></tr><tr><td>static</td><td>静态类型</td></tr><tr><td>TRUE</td><td>真</td></tr><tr><td>FALSE</td><td>假</td></tr><tr><td>String</td><td>字符串对象(也是一种数据类型)</td></tr><tr><td>extends</td><td>继承</td></tr><tr><td>this</td><td>当前对象引用</td></tr><tr><td>super</td><td>父类对象引用</td></tr><tr><td>Math.random()</td><td>随机数</td></tr><tr><td>interface</td><td>接口</td></tr><tr><td>implements</td><td>继承接口</td></tr><tr><td>throw</td><td>抛出</td></tr><tr><td>throws</td><td>抛出</td></tr><tr><td>try</td><td>尝试</td></tr><tr><td>catch</td><td>捕获</td></tr><tr><td>Exception</td><td>异常</td></tr><tr><td>Separator</td><td>分割线</td></tr></tbody></table><p>基本数据类型(返回值类型中的一部分) </p><table><thead><tr><th>英文</th><th>类型</th><th>默认值</th><th align="center">封装类</th></tr></thead><tbody><tr><td>byte</td><td>字节型</td><td>0b</td><td align="center">Byte</td></tr><tr><td>char</td><td>字符型</td><td>‘\u0000’</td><td align="center">Character</td></tr><tr><td>short</td><td>短整型</td><td>0</td><td align="center">Short</td></tr><tr><td>int</td><td>整型</td><td>0</td><td align="center">Integer</td></tr><tr><td>long</td><td>长整型</td><td>0</td><td align="center">Long</td></tr><tr><td>float</td><td>单精度浮点型</td><td>0.0f</td><td align="center">Float</td></tr><tr><td>double</td><td>双精度浮点型</td><td>0</td><td align="center">Double</td></tr><tr><td>boolean</td><td>布尔型</td><td>flase</td><td align="center">Boolean</td></tr><tr><td>String</td><td>字符串</td><td>null</td><td align="center">String</td></tr></tbody></table><table><thead><tr><th>访问控制修饰符</th><th></th></tr></thead><tbody><tr><td>public</td><td>公有的</td></tr><tr><td>protected</td><td>公共的(保护的)</td></tr><tr><td>private</td><td>私有的</td></tr></tbody></table><table><thead><tr><th>类修饰符</th><th></th></tr></thead><tbody><tr><td>final</td><td>最终</td></tr><tr><td>new</td><td>新的</td></tr><tr><td>abstract</td><td>抽象</td></tr><tr><td>finally</td><td>最终的</td></tr></tbody></table><table><thead><tr><th>逻辑关键字</th><th></th></tr></thead><tbody><tr><td>if</td><td>如果</td></tr><tr><td>else</td><td>否则</td></tr><tr><td>switch</td><td>开关</td></tr><tr><td>case</td><td>事件</td></tr><tr><td>default</td><td>默认</td></tr><tr><td>for</td><td>(循环)</td></tr><tr><td>while</td><td>(循环)</td></tr><tr><td>do-while</td><td>(循环)</td></tr><tr><td>continue</td><td>继续</td></tr><tr><td>break</td><td>打破</td></tr></tbody></table><table><thead><tr><th>类</th><th></th></tr></thead><tbody><tr><td>ArrayList</td><td>数组集合</td></tr><tr><td>add(Object);</td><td>添加数据</td></tr><tr><td>get(int);</td><td>获得数据</td></tr><tr><td>Thread</td><td>线程</td></tr><tr><td>Runnable</td><td>可捕获的</td></tr></tbody></table><table><thead><tr><th>控制数据库常用</th><th></th></tr></thead><tbody><tr><td>Class.forName</td><td>加载数据库驱动程序</td></tr><tr><td>Connection</td><td>数据库连接对象</td></tr><tr><td>Statement</td><td>数据库操纵对象</td></tr><tr><td>ResultSet</td><td>数据库结果集对象</td></tr><tr><td>close</td><td>关闭</td></tr><tr><td>DriverManager</td><td>驱动管理器</td></tr><tr><td>localhost</td><td>本地主机</td></tr><tr><td>executeQuery</td><td>执行命令</td></tr><tr><td>executeUpdate</td><td>执行更新</td></tr><tr><td>SQLException</td><td>SQL数据库异常</td></tr><tr><td>ClassNotFoundException</td><td>类没有被找到异常</td></tr><tr><td>view</td><td>视图</td></tr><tr><td>trigger</td><td>触发器</td></tr><tr><td>proc</td><td>存储过程</td></tr><tr><td>removeAll</td><td>移除所有</td></tr><tr><td>rs.first()</td><td>游标移动到第一条记录</td></tr><tr><td>rs.last()</td><td>游标移动到最后一条记录</td></tr><tr><td>rs.getRow()</td><td>获得当前的行号</td></tr><tr><td>rs.absolute(i)</td><td>定位游标</td></tr><tr><td>top</td><td>最前</td></tr><tr><td>JavaBean</td><td>存放数据</td></tr></tbody></table><table><thead><tr><th>窗体</th><th></th><th></th></tr></thead><tbody><tr><td>show</td><td>展示</td><td></td></tr><tr><td>this.setTitle</td><td>设置标题</td><td></td></tr><tr><td>this.setSize(500,400);</td><td>窗体大小</td><td></td></tr><tr><td>this.setLocation(260,150);</td><td>窗体初始位置</td><td></td></tr><tr><td>this.show();</td><td>显示窗体</td><td></td></tr><tr><td>this.setLocationRelativeTo(null);</td><td>居中</td><td></td></tr><tr><td>this.setDefaultCloseOperation(3);</td><td>关闭按扭起作用</td><td></td></tr><tr><td>this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</td><td>关闭按扭起作用</td><td></td></tr><tr><td>JLabel lbl = new JLabel(new   ImageIcon(“1.gif”));</td><td>图片标签</td><td></td></tr><tr><td>getContentPane</td><td>获得窗体的内部窗格</td><td></td></tr><tr><td>setBackground(Color.BLUE)</td><td>设置背景颜色</td><td></td></tr><tr><td>setResizable()</td><td>设置是否能最大化()内</td><td>填true或false</td></tr><tr><td>setAlwaysOnTop()</td><td>窗口在最顶端()内</td><td>填true或false</td></tr><tr><td>Font</td><td>字体</td><td></td></tr><tr><td>showMessageDialog</td><td>弹出对话框</td><td></td></tr><tr><td>append</td><td>追加</td><td></td></tr><tr><td>valueChanged</td><td>改变数值</td><td></td></tr><tr><td>requestFocus</td><td>获得焦点</td><td></td></tr><tr><td>selectAll</td><td>全选</td><td></td></tr><tr><td>setText</td><td>设置文本域内容</td><td></td></tr><tr><td>getText</td><td>获得文本域内容</td><td></td></tr><tr><td>setEnabled()</td><td>设置控件是否可用()内</td><td>填true或false</td></tr><tr><td>setAccelerator</td><td>设置加速器</td><td></td></tr><tr><td>KeyStroke</td><td>敲击键盘</td><td></td></tr><tr><td>getKeyStroke</td><td>获得所敲击的键盘</td><td></td></tr><tr><td>InputEvent</td><td>输入事件</td><td></td></tr><tr><td>getDocument</td><td>获得文件</td><td></td></tr><tr><td>addUndoableEditListener</td><td>添加撤销监听器</td><td></td></tr><tr><td>SimpleDateFormat</td><td>简易日期格式</td><td></td></tr><tr><td>setLineWrap</td><td>设置行距</td><td></td></tr><tr><td>addEdit</td><td>添加编辑</td><td></td></tr><tr><td>getEdit</td><td>获得编辑</td><td></td></tr><tr><td>setBorder</td><td>设置边框</td><td></td></tr><tr><td>Factory</td><td>工厂</td><td></td></tr><tr><td>createTitledBorder</td><td>创建标题边框</td><td></td></tr><tr><td>setVisible()</td><td>设置视窗是否隐藏()内</td><td>填true或false</td></tr><tr><td>setCursor</td><td>设置指针</td><td></td></tr><tr><td>isPopupTrigger</td><td>确定点鼠标击右键</td><td></td></tr><tr><td>getSelectedValue</td><td>获得选中的值</td><td></td></tr><tr><td>toString</td><td>返回字符串</td><td></td></tr><tr><td>insertIcon</td><td>插入图标</td><td></td></tr><tr><td>getActionCommand</td><td>获得动作命令</td><td></td></tr><tr><td>getKeyCode</td><td>获得键盘码</td><td></td></tr><tr><td>KeyEvent.VK_RIGHT</td><td>键盘事件.右箭头</td><td></td></tr><tr><td>getIcon</td><td>获得标签</td><td></td></tr><tr><td>setIcon</td><td>设置标签</td><td></td></tr><tr><td>getSource</td><td>获得所选</td><td></td></tr><tr><td>charAt()</td><td>查找指定下标所对应的字符</td><td></td></tr><tr><td>indexOf()</td><td>查找某一字符串，首次出现的位置(从前向后)</td><td></td></tr><tr><td>lastIndexOf()</td><td>查找某一字符串，首次出现的位置(从后向前)</td><td></td></tr><tr><td>length()</td><td>返回字符串长度</td><td></td></tr><tr><td>equals()</td><td>比较两个字符串</td><td></td></tr><tr><td>toUpperCase()</td><td>转为大写</td><td></td></tr><tr><td>toLowerCase()</td><td>转为小写</td><td></td></tr><tr><td>split()</td><td>分割字符串</td><td></td></tr><tr><td>replace()</td><td>替换</td><td></td></tr><tr><td>.addRow(Object[])</td><td>添加一条记录</td><td></td></tr><tr><td>setRowCount(0)</td><td>清空表模型</td><td></td></tr><tr><td>repaint</td><td>重绘</td><td></td></tr><tr><td>ComboBox.getSelectedItem</td><td>获得下拉框所选择的内容</td><td></td></tr><tr><td>ComboBox.addItem(rs.getString(1))</td><td>重新添加下拉框内容</td><td></td></tr><tr><td>g.setColor(Color.RED)</td><td>设置画笔颜色</td><td></td></tr><tr><td>g.setFont(new   Font(“隶书”,Font.BOLD,30))</td><td>设置画笔字体</td><td></td></tr><tr><td>g.drawString(“早晨好”,100,200)</td><td>画字符串</td><td></td></tr><tr><td>g.drawLine(100,100,500,500)</td><td>画线</td><td></td></tr><tr><td>g.drawOval(200,200,300,150)</td><td>画椭圆</td><td></td></tr><tr><td>g.fillOval(200,200,300,150)</td><td>填充椭圆</td><td></td></tr><tr><td>g.drawRect(200,200,300,150)</td><td>画矩形</td><td></td></tr><tr><td>this.setUndecorated(true)</td><td>去除窗体边框</td><td></td></tr><tr><td>Thread.currentThread()</td><td>获得当前正在运行的线程</td><td></td></tr><tr><td>Graphics</td><td>画笔</td><td></td></tr><tr><td>t.suspend()</td><td>线程挂起</td><td></td></tr><tr><td>t.resume()</td><td>恢复线程</td><td></td></tr></tbody></table><table><thead><tr><th>布局</th><th></th></tr></thead><tbody><tr><td>FlowLayout</td><td>流式布局</td></tr><tr><td>LEFT</td><td>左</td></tr><tr><td>RIGHT</td><td>右</td></tr><tr><td>BorderLayout</td><td>边界布局</td></tr><tr><td>EAST</td><td>东</td></tr><tr><td>SOUTH</td><td>南</td></tr><tr><td>WEST</td><td>西</td></tr><tr><td>NORTH</td><td>北</td></tr><tr><td>CENTER</td><td>中</td></tr><tr><td>GridLayout</td><td>网格部局</td></tr></tbody></table><table><thead><tr><th>(选择记忆)</th><th></th></tr></thead><tbody><tr><td>Container</td><td>容器</td></tr><tr><td>JPanel</td><td>面板</td></tr><tr><td>JFrame</td><td>窗体</td></tr><tr><td>JButton</td><td>按扭</td></tr><tr><td>JLabel</td><td>标签</td></tr><tr><td>JTextField</td><td>文本域(单行的文本框)</td></tr><tr><td>JTextArea</td><td>文本区</td></tr><tr><td>JPasswordField</td><td>密码域</td></tr><tr><td>ButtonGroup</td><td>按扭组(单选)</td></tr><tr><td>JRadioButton</td><td>单选按扭</td></tr><tr><td>JCheckBox</td><td>多选按扭</td></tr><tr><td>JComboBox</td><td>下拉框</td></tr><tr><td>JList</td><td>下拉列表</td></tr><tr><td>ImageIcon</td><td>图片</td></tr><tr><td>JMenuBar</td><td>菜单工具栏</td></tr><tr><td>JMenu</td><td>菜单项</td></tr><tr><td>JMenuItem</td><td>子菜单项</td></tr><tr><td>JCheckBoxMenuItem</td><td>多选按钮菜单工具栏</td></tr><tr><td>JRadioButtonMenuItem</td><td>单选按钮菜单工具栏</td></tr><tr><td>JScrollPane</td><td>滚动面板</td></tr><tr><td>JTextPane</td><td>文本面板</td></tr><tr><td>JPopupMenu</td><td>弹出菜单</td></tr><tr><td>JProgressBar</td><td>进度条</td></tr><tr><td>DefaultTableModel</td><td>默认的表模型</td></tr><tr><td>JTable</td><td>表格</td></tr><tr><td>ActionListener</td><td>监听器</td></tr><tr><td>ActionEvent</td><td>动作事件</td></tr><tr><td>actionPerformed</td><td>动作演示</td></tr><tr><td>KeyListener</td><td>键盘监听器</td></tr><tr><td>KeyEvent</td><td>键盘事件</td></tr><tr><td>keyPressed</td><td>按下键盘</td></tr><tr><td>keyReleased</td><td>释放键盘</td></tr><tr><td>keyTyped</td><td>点击键盘</td></tr><tr><td>MouseListener</td><td>鼠标监听器</td></tr><tr><td>MouseEvent</td><td>鼠标事件</td></tr><tr><td>mouseClicked</td><td>鼠标单击事件</td></tr><tr><td>mouseEntered</td><td>鼠标移入事件</td></tr><tr><td>mouseExited</td><td>鼠标离开事件</td></tr><tr><td>mousePressed</td><td>按下鼠标事件</td></tr><tr><td>mouseReleased</td><td>释放鼠标事件</td></tr><tr><td>MouseMotionListener</td><td>鼠标监听器</td></tr><tr><td>mouseDragged</td><td>拖拽鼠标</td></tr><tr><td>mouseMoved</td><td>移动鼠标</td></tr><tr><td>ListSelectionListener</td><td>下拉列表监听器</td></tr><tr><td>ListSelectionEvent</td><td>下拉列表选择事件</td></tr><tr><td>JOptionPane</td><td>有选项的面板</td></tr><tr><td>UndoableEditListener</td><td>撤消监听器</td></tr><tr><td>UndoableEditEvent</td><td>撤消事件</td></tr><tr><td>undoableEditHappened</td><td>撤消</td></tr></tbody></table><table><thead><tr><th>包</th></tr></thead><tbody><tr><td>java.awt.*;</td></tr><tr><td>java.lang.*;</td></tr><tr><td>java.util.*;</td></tr><tr><td>java.text.*;</td></tr><tr><td>javax.swing.*;</td></tr><tr><td>java.awt.event.*;</td></tr><tr><td>import java.sql.*;</td></tr><tr><td>javax.swing.undo.*;</td></tr><tr><td>java.swing.table.*;</td></tr><tr><td>javax.swing.event.*;</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Eclipse</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Eclipse</tag>
      
      <tag>单词</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
