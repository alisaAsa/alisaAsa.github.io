{"meta":{"title":"Alterem","subtitle":null,"description":null,"author":"Alterem","url":"http://blog.alterem.top"},"pages":[{"title":"404 Page Not Found","date":"2018-09-10T10:23:22.000Z","updated":"2019-09-26T11:02:45.973Z","comments":true,"path":"404.html","permalink":"http://blog.alterem.top/404.html","excerpt":"","text":"Page Not Found, Please contact the site administrator!您要寻找的页面找不到了，请联系站点管理员！欢迎关注微信公众号​："},{"title":"Alterem","date":"2018-09-10T10:23:22.000Z","updated":"2019-09-26T10:54:11.433Z","comments":false,"path":"about/index.html","permalink":"http://blog.alterem.top/about/index.html","excerpt":"","text":"130-2799-1217 | 13027991217@163.com | 广州微信:404221903 | https://blog.alterem.top 天下难事，必作于易；天下大事，必做于细。 欢迎关注微信公众号​："},{"title":"categories","date":"2019-03-15T04:01:30.000Z","updated":"2019-03-15T04:27:56.000Z","comments":false,"path":"categories/index.html","permalink":"http://blog.alterem.top/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-03-14T07:56:01.000Z","updated":"2019-03-14T08:41:42.000Z","comments":false,"path":"tags/index.html","permalink":"http://blog.alterem.top/tags/index.html","excerpt":"","text":""},{"title":"gallery","date":"2019-03-15T05:01:38.000Z","updated":"2019-09-27T08:50:24.065Z","comments":true,"path":"gallery/index.html","permalink":"http://blog.alterem.top/gallery/index.html","excerpt":"","text":"123123"}],"posts":[{"title":"Python自动更换壁纸爬虫与tkinter结合","slug":"Python自动更换壁纸爬虫与tkinter结合","date":"2019-10-13T16:04:00.000Z","updated":"2019-10-13T16:06:06.446Z","comments":true,"path":"2019/10/14/Python自动更换壁纸爬虫与tkinter结合/","link":"","permalink":"http://blog.alterem.top/2019/10/14/Python自动更换壁纸爬虫与tkinter结合/","excerpt":"","text":"直接上代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import ctypesimport timeimport requestsimport osfrom threading import Threadfrom tkinter import Tk, Label, Button,Entry,StringVar,messagebox# '放到AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup下把本文件后缀设为pyw 就会开机自启'class Bz(object): def __init__(self): self.curent_url = 'https://tenapi.cn/img/acg.php' self.root = Tk() self.root.attributes(\"-alpha\", 0.8) self.root.title('壁纸切---by Alterem---&gt;吾爱17788210295') self.root.geometry('218x55+1300+20') self.b1 = Button(self.root, text=' 换一类 ', command=self.change_type, fg='#00f235',width=8).place(x=0, y=0) self.b2 = Button(self.root, text='下一张&gt;&gt; 频率(分)', command=self.change_next, fg='blue',width=22).place(x=63, y=0) self.b3 = Button(self.root, text='停止切换', command=self.stop, fg='red', width=8).place(x=0, y=30) self.label = Label(self.root, text='二次元',fg='#9e3dff') self.label.place(x=85, y=30) e = StringVar() self.input=Entry(self.root,textvariable=e,fg='#ffaf0a') e.set(0.1) #默认0.1分钟 6s self.input.place(x=153, y=30) self.url_list = &#123;1: ['影视', 'http://pic.tsmp4.net/api/yingshi/img.php'], 2: ['随机', 'http://lorempixel.com/1920/1080/'], 3: ['女神', 'http://pic.tsmp4.net/api/nvsheng/img.php'], 4: ['风景', 'http://pic.tsmp4.net/api/fengjing/img.php'], 5: ['二次元', 'https://tenapi.cn/img/acg.php']&#125; self.path = 'D:\\壁纸' self.filepath = self.path + '/img.jpg' if not os.path.exists(self.path): os.makedirs(self.path) self.flag = True self.start = 1 def stop(self): self.flag = False def change_type(self): if self.start &gt; 5: self.start = 1 list = self.url_list.get(self.start) curent_type = list[0] self.curent_url = list[1] self.label['text'] = curent_type self.start += 1 def change_next(self): data = requests.get(url=self.curent_url).content with open(self.filepath, 'wb') as f: f.write(data) self.config() def get_img(self): try: self.num = eval(self.input.get()) * 60 #捕获结束界面后的异常 except Exception: pass try: data = requests.get(url=self.curent_url).content with open(self.filepath, 'wb') as f: f.write(data) time.sleep(self.num) # 睡眠单位秒 self.config() except Exception: pass def config(self): ctypes.windll.user32.SystemParametersInfoW(20, 0, self.filepath, 0) # 设置桌面壁纸. def img(self): while self.flag: self.get_img() def run(self): t1 = Thread(target=self.img) # t1.setDaemon(True) #设置守护线程 ---&gt;是否完全关闭 t1.start() self.root.mainloop() if self.flag: root = Tk() root.withdraw() messagebox.showinfo(\"by Alterem\", \"只关闭了界面! 图片还在切换! 请进入任务管理器结束进程\")if __name__ == '__main__': b = Bz() b.run() 欢迎关注微信公众号​：","categories":[{"name":"Python","slug":"Python","permalink":"http://blog.alterem.top/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://blog.alterem.top/tags/Python/"},{"name":"Tkinter","slug":"Tkinter","permalink":"http://blog.alterem.top/tags/Tkinter/"}]},{"title":"MySQL的5种时间类型的比较","slug":"MySQL的5种时间类型的比较","date":"2019-10-13T15:45:22.000Z","updated":"2019-10-13T15:50:58.177Z","comments":true,"path":"2019/10/13/MySQL的5种时间类型的比较/","link":"","permalink":"http://blog.alterem.top/2019/10/13/MySQL的5种时间类型的比较/","excerpt":"","text":"日期时间类型 占用空间 日期格式 最小值 最大值 零值表示 DATETIME 8 bytes YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00 9999-12-31 23:59:59 0000-00-00 00:00:00 TIMESTAMP 4 bytes YYYY-MM-DD HH:MM:SS 19700101080001 2038 年的某个时刻 00000000000000 DATE 4 bytes YYYY-MM-DD 1000-01-01 9999-12-31 0000-00-00 TIME 3 bytes HH:MM:SS -838:59:59 838:59:59 00:00:00 YEAR 1 bytes YYYY 1901 2155 0000 DATETIME DATETIME 用于表示 年月日 时分秒，是 DATE 和 TIME 的组合，并且记录的年份（见上表）比较长久。如果实际应用中有这样的需求，就可以使用 DATETIME 类型。 1、DATETIME列可以设置为多个，默认可为null，可以手动设置其值。 2、DATETIME列不可设定默认值。 3、DATETIME列可以变相的设定默认值，比如通过触发器、或者在插入数据时候，将DATETIME字段值设置为now()，这样可以做到了，尤其是后者，在程序开发中常常用到。 TIMESTAMP TIMESTAMP 用于表示 年月日 时分秒，但是记录的年份（见上表）比较短暂，TIMESTAMP列必须有默认值，默认值可以为“0000-00-00 00:00:00”，但不能为null。 TIMESTAMP 和时区相关，更能反映当前时间。当插入日期时，会先转换为本地时区后再存放；当查询日期时，会将日期转换为本地时区后再显示。所以不同时区的人看到的同一时间是 不一样的。 表中的第一个 TIMESTAMP 列自动设置为系统时间（CURRENT_TIMESTAMP）。当插入或更新一行，但没有明确给 TIMESTAMP 列赋值，也会自动设置为当前系统时间。如果表中有第二个 TIMESTAMP 列，则默认值设置为0000-00-00 00:00:00。 TIMESTAMP 的属性受 Mysql 版本和服务器 SQLMode 的影响较大。 如果记录的日期需要让不同时区的人使用，最好使用 TIMESTAMP。 注：一般建表时候，创建时间用datetime，更新时间用timestamp。 DATE DATE 用于表示 年月日，如果实际应用值需要保存 年月日 就可以使用 DATE。 TIME TIME 用于表示 时分秒，如果实际应用值需要保存 时分秒 就可以使用 TIME。 YEAR YEAR 用于表示 年份，YEAR 有 2 位（最好使用4位）和 4 位格式的年。 默认是4位。如果实际应用只保存年份，那么用 1 bytes 保存 YEAR 类型完全可以。不但能够节约存储空间，还能提高表的操作效率。 欢迎关注微信公众号​：","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.alterem.top/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.alterem.top/tags/MySQL/"}]},{"title":"MySql在CentOS上执行自动备份","slug":"MySQL在CentOS上执行自动备份","date":"2019-10-13T15:19:07.000Z","updated":"2019-10-13T15:44:32.533Z","comments":true,"path":"2019/10/13/MySQL在CentOS上执行自动备份/","link":"","permalink":"http://blog.alterem.top/2019/10/13/MySQL在CentOS上执行自动备份/","excerpt":"","text":"​ 开发中我们常常有使用Svn或者Git来管理我们的代码或者是项目相关的文件，然而他们都有一个共同点就是：版本控制 ​ 很多人会问为什么要使用Svn或者是Git，那么我会问：我相信你写的代码很好，但是有一天你修改了很多很多的Bug，但是突然想到以前的代码中有一个比较重要的算法你不小心覆盖掉了，这时候你应该怎么办？ ​ 或许你会告诉我你可以在修改这些代码之前备份一次当前修改的文件，或者是当前项目。 ​ 但是时间久了你的机器上会有多少备份文件呢？ ​ 如果有一天你的同事需要回滚到之前的代码看一下那时候Bug的原因，你会从你的机器上找到指定时间的文件发给他嘛？ ​ 当然不是，我们有Svn或者是Git之后我们可以方便的看到文件之前的版本，还可以方便的对比。那么现在清楚了版本控制的重要性了。 ​ 同样数据库也是这样，我们的系统99%都离不开数据库，因为我们总要把数据存储起来。 ​ 那如果我们数据库被误删、被黑客入侵、被恶意修改怎么办？ ​ 那么我们可以试着让我们的服务器自动来帮我们备份数据库的数据到指定位置，万一有一天我们的数据库不小心手抖了，我们还可以用备份下来的数据库脚本直接恢复。 ​ 上脚本： 123456789101112131415161718# db usernamedb_user=\"test\" # db passworddb_passwd=\"test\"# db hostdb_host=\"121.201.5.216\"# backup db namedb_name=\"Alterem\" # the directory for story your backup file. backup_dir=\"backup\" cd # date format for backup file (dd-mm-yyyy) time=\"$(date +\"%Y-%m-%d-%H-%M-%S\")\" # mysql, mysqldump and some other bin's path MYSQL=\"/usr/local/mysql/bin/mysql\" MYSQLDUMP=\"/usr/local/mysql/bin/mysqldump\" GZIP=\"/bin/gzip\" $MYSQLDUMP -u $db_user -h $db_host -p$db_passwd $db_name | $GZIP -9 &gt; \"/data/backup/$backup_dir/$db_name\"_\"$time.gz\" 创建定时器1crontab -e 添加定时器 12# 每天凌晨 1 点 30 分 进行数据备份30 1 * * * /root/mysql-backup.sh 重启定时器 1/etc/rc.d/init.d/crond restart cron解析12345678910# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed 在线Cron表达式生成器：http://cron.qqe2.com/ 欢迎关注微信公众号​：","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.alterem.top/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.alterem.top/tags/MySQL/"}]},{"title":"python拆分excel","slug":"python拆分excel","date":"2019-10-11T03:40:49.000Z","updated":"2019-10-11T03:45:30.027Z","comments":true,"path":"2019/10/11/python拆分excel/","link":"","permalink":"http://blog.alterem.top/2019/10/11/python拆分excel/","excerpt":"","text":"根据某一列，拆分成几个不同的EXCEL文件操作方法：将EXCEL文件拖至EXE文件上，根据提示操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306import openpyxlfrom openpyxl.utils import get_column_letterimport xlrdimport sys, os, collectionsfrom pprint import pprintfrom copy import copy class splitExcel(object): def __init__(self, sourceFile, titleLine=None, splitColumn=None): self.sourceFile = sourceFile self.sourceWorkbook = openpyxl.load_workbook(sourceFile) self.targetWorkbook = openpyxl.Workbook() self.targetWorkbook.remove(self.targetWorkbook.active) # 源工作表（object对象） self.sourceWorksheet = None # 最大行数 self.sourceWorkbookMaxRow = None # 最大列数 self.sourceWorkbookMaxColumn = None # 源工作表索引号 self.sourceWorksheetIndex = None # 标题所在行号，用户输入时索引从1开始，内部处理时请留意索引数 # if titleLine == None: # titleLine = int(input('请输入标题所在行[2]: ').strip()) self.titleLine = titleLine # 根据哪个列进行拆分，用户输入时索引从1开始，内部处理时请留意索引数 self.splitColumn = splitColumn # 源工作薄当前行号 self.sbCurrectLine = None # 目标工作薄各表当前数据行号 self.tbCurrectLines = &#123;&#125; # 表头文字 self.header = [] # 各表数据 self.data = collections.OrderedDict() # 保存列宽 self.columnsWidth = collections.OrderedDict() # 格式 self.formats = &#123;&#125; def readData(self): wb = xlrd.open_workbook(self.sourceFile) ws = wb.sheet_by_index(self.sourceWorksheetIndex) for x in range(ws.nrows): if x &lt; self.titleLine: # 表头 self.header.append(ws.row_values(x)) else: v = ws.cell(x, self.splitColumn - 1).value sheetName = self.clearSheetName(v) # 将表名加入data字典 if sheetName not in self.data.keys(): self.data[sheetName] = [] # 添加数据 self.data[sheetName].append(ws.row_values(x)) def selectSplitSheet(self): if len(self.sourceWorkbook.sheetnames) == 1: self.sourceWorksheet = self.sourceWorkbook.active self.sourceWorksheetIndex = 0 else: _n_ = 0 print('在工作薄中找到以下工作表：') for SheetName in self.sourceWorkbook.sheetnames: print(_n_, SheetName) _n_ += 1 n = 0 _input = input('请输入要拆分表的序号[0]: ').strip() if _input != '': n = int(_input) self.sourceWorksheet = self.sourceWorkbook.worksheets[n] self.sourceWorksheetIndex = n def selectSplitColumn(self): wb = xlrd.open_workbook(self.sourceFile) ws = wb.sheet_by_index(self.sourceWorksheetIndex) # 保存一下最大行数、列数，以供其它（属性）地方使用 self.sourceWorkbookMaxRow = ws.nrows self.sourceWorkbookMaxColumn = ws.ncols print('\\n在工作表的标题行（第 %s 行）找到以下列: ' % self.titleLine) for y in range(1, ws.ncols + 1): print(y, ws.cell(self.titleLine - 1, y - 1).value) columnNum = input('请输入拆分列号[2]: ').strip() if columnNum == '': columnNum = 2 else: columnNum = int(columnNum) self.splitColumn = columnNum def readCellsStyle(self): ws = self.sourceWorksheet maxColumn = self.sourceWorkbookMaxColumn styles = [[None] * (maxColumn + 11) for i in range(self.titleLine + 11)] fonts = [[None] * (maxColumn + 11) for i in range(self.titleLine + 11)] borders = [[None] * (maxColumn + 11) for i in range(self.titleLine + 11)] fills = [[None] * (maxColumn + 11) for i in range(self.titleLine + 11)] alignments = [[None] * (maxColumn + 11) for i in range(self.titleLine + 11)] number_formats = [[None] * (maxColumn + 11) for i in range(self.titleLine + 11)] protections = [[None] * (maxColumn + 11) for i in range(self.titleLine + 11)] heights = [None] * (self.titleLine + 11) widths = [None] * (maxColumn + 11) # isDates = [None] * (maxColumn + 11) for x in range(1, self.titleLine + 2): heights[x] = ws.row_dimensions[x].height # print(x,'height',heights[x]) # for y in range(1, ws.max_column + 1): for y in range(1, maxColumn + 1): styles[x][y] = copy(ws.cell(x, y).style.replace('常规', 'Normal')) fonts[x][y] = copy(ws.cell(x, y).font) borders[x][y] = copy(ws.cell(x, y).border) fills[x][y] = copy(ws.cell(x, y).fill) alignments[x][y] = copy(ws.cell(x, y).alignment) number_formats[x][y] = copy(ws.cell(x, y).number_format) protections[x][y] = copy(ws.cell(x, y).protection) if y not in widths: widths[y] = ws.column_dimensions[get_column_letter(y)].width # print(y, get_column_letter(y), ws.column_dimensions[get_column_letter(y)].width) # if y not in isDates: # isDates[y] = ws.cell(x, y).is_date self.formats['heights'] = heights self.formats['styles'] = styles self.formats['fonts'] = fonts self.formats['borders'] = borders self.formats['fills'] = fills self.formats['alignments'] = alignments self.formats['number_formats'] = number_formats self.formats['protections'] = protections self.formats['widths'] = widths # self.formats['isDates'] = isDates def writeFormatToNewWorkbook(self): for sheetName in self.data.keys(): ws = self.targetWorkbook[sheetName] # for x in range(1,self.titleLine+2): for x in range(1, ws.max_row + 1): # 表头 if x &lt;= self.titleLine: xx = x # ws.row_dimensions[x].height = self.formats['heights'][x] else: # 表数据 xx = self.titleLine + 1 height = self.formats['heights'][xx] if not height == None and height &gt; 0: ws.row_dimensions[x].height = self.formats['heights'][xx] for y in range(1, ws.max_column + 1): # 表头 if x &lt;= self.titleLine: # 路过空白单元格 # if ws.cell(x, y).value == '': # continue width = self.formats['widths'][y] if not width == None and width &gt; 0: ws.column_dimensions[get_column_letter(y)].width = self.formats['widths'][y] xx = x else: # 表数据 xx = self.titleLine + 1 ws.cell(x, y).style = self.formats['styles'][xx][y] ws.cell(x, y).font = self.formats['fonts'][xx][y] ws.cell(x, y).border = self.formats['borders'][xx][y] ws.cell(x, y).fill = self.formats['fills'][xx][y] ws.cell(x, y).alignment = self.formats['alignments'][xx][y] ws.cell(x, y).number_format = self.formats['number_formats'][xx][y] ws.cell(x, y).protection = self.formats['protections'][xx][y] # if x&gt;self.titleLine and self.formats['isDates'][y]: # ws.cell(x, y).number_format = 'yyyy/mm/dd' def writeDataToNewWorkbook(self): for sheetName in self.data.keys(): ws = self.targetWorkbook.create_sheet(sheetName) # 写入头文字 x = 0 # 行号 for row in self.header: x += 1 y = 0 # 列号 for cellValue in row: y += 1 if not cellValue == '': ws.cell(x, y).value = cellValue # 写入数据 for row in self.data[sheetName]: ws.append(row) def clearSheetName(self, name, replaceAs='-'): invalidChars = r':\\/?*[]：' for c in invalidChars: name = name.replace(c, replaceAs).strip() return name def selectTitleLine(self): wb = xlrd.open_workbook(self.sourceFile) ws = wb.sheet_by_index(self.sourceWorksheetIndex) # 保存一下最大行数、列数，以供其它（属性）地方使用 self.sourceWorkbookMaxRow = ws.nrows self.sourceWorkbookMaxColumn = ws.ncols print('打印所拆分工作表前10行，前5列数据：') maxY = ws.ncols if ws.ncols &gt; 5: maxY = 5 for x in range(10): tempList = [] for y in range(maxY): tempList.append(ws.cell(x, y).value) print('第%s行：' % (x + 1), tempList) titleLine = 2 n = input('\\n请输入标题行所在行号[2]：').strip() if not n == '': titleLine = int(n) self.titleLine = titleLine def make(self): self.selectSplitSheet() self.selectTitleLine() self.selectSplitColumn() print('开始读取数据...') self.readData() print('开始读取格式...') self.readCellsStyle() print('开始写入数据至分表...') self.writeDataToNewWorkbook() print('开始写入格式至分表...') self.writeFormatToNewWorkbook() def save(self, filename=None): if filename == None: splitPath = os.path.split(self.sourceFile) filename = splitPath[0] + '/拆分_' + splitPath[1] self.targetWorkbook.save(filename) self.sourceWorkbook.close() self.targetWorkbook.close() return filename class saveWorksheetToWorkbook(object): def __init__(self, excelFile): self.excelFile = excelFile def saveTo(self, savePath=None, addNumToFilename=True): if savePath == None: splitPath = os.path.splitext(self.excelFile) savePath = splitPath[0] if not os.path.exists(savePath): os.makedirs(savePath, exist_ok=True) wb = openpyxl.load_workbook(self.excelFile) sheetNames = wb.sheetnames wb.close() # # _input=input('正在保存各表至独立工作薄，文件名前是否加序号？[Y] Y/N：').strip().lower() # if _input=='n': # addNumToFilename=False n=0 for sheetName in sheetNames: n+=1 print('保存', n, sheetName) wb = openpyxl.load_workbook(self.excelFile) for ws in wb.worksheets: if not sheetName == ws.title: wb.remove(ws) xh='' if addNumToFilename: xh=str(n) filename='%s/%s%s.xlsx' % (savePath, xh,sheetName) wb.save(filename) wb.close() return savePath if __name__ == '__main__': file = r'C:\\Users\\Alterem\\Desktop\\汇总.xlsx' file = sys.argv[1] se = splitExcel(file) # file = r'C:\\Users\\Alterem\\Desktop\\2019年积分排名－2019-07-09.xlsx' # se = splitExcel(file, 1, 3) se.make() f = se.save() print('拆分汇总文件：', f) # f=r'C:\\Users\\Alterem\\Desktop\\汇总.拆分.xlsx' saveTo = saveWorksheetToWorkbook(f) p = saveTo.saveTo() print('拆分表保存文件夹：', p) input('\\n完成，按回车键退出。') 欢迎提出问题 欢迎关注微信公众号​：","categories":[{"name":"python","slug":"python","permalink":"http://blog.alterem.top/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://blog.alterem.top/tags/python/"},{"name":"excel","slug":"excel","permalink":"http://blog.alterem.top/tags/excel/"}]},{"title":"Lombok介绍、使用方法和总结","slug":"Lombok介绍、使用方法和总结","date":"2019-09-30T02:17:26.000Z","updated":"2019-09-30T02:26:23.672Z","comments":true,"path":"2019/09/30/Lombok介绍、使用方法和总结/","link":"","permalink":"http://blog.alterem.top/2019/09/30/Lombok介绍、使用方法和总结/","excerpt":"","text":"文章来源公众号：猿人谷 1 Lombok背景介绍官方介绍如下： 1Project Lombok makes java a spicier language by adding 'handlers' that know how to build and compile simple, boilerplate-free, not-quite-java code. 大致意思是Lombok通过增加一些“处理程序”，可以让java变得简洁、快速。 2 Lombok使用方法Lombok能以简单的注解形式来简化java代码，提高开发人员的开发效率。例如开发中经常需要写的javabean，都需要花时间去添加相应的getter/setter，也许还要去写构造器、equals等方法，而且需要维护，当属性多时会出现大量的getter/setter方法，这些显得很冗长也没有太多技术含量，一旦修改属性，就容易出现忘记修改对应方法的失误。 Lombok能通过注解的方式，在编译时自动为属性生成构造器、getter/setter、equals、hashcode、toString方法。出现的神奇就是在源码中没有getter和setter方法，但是在编译生成的字节码文件中有getter和setter方法。这样就省去了手动重建这些代码的麻烦，使代码看起来更简洁些。 Lombok的使用跟引用jar包一样，可以在官网（https://projectlombok.org/download）下载jar包，也可以使用maven添加依赖： 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.20&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 接下来我们来分析Lombok中注解的具体用法。 2.1 @Data@Data注解在类上，会为类的所有属性自动生成setter/getter、equals、canEqual、hashCode、toString方法，如为final属性，则不会为该属性生成setter方法。 官方实例如下： 123456789101112131415161718import lombok.AccessLevel;import lombok.Setter;import lombok.Data;import lombok.ToString;@Data public class DataExample &#123; private final String name; @Setter(AccessLevel.PACKAGE) private int age; private double score; private String[] tags; @ToString(includeFieldNames=true) @Data(staticConstructor=\"of\") public static class Exercise&lt;T&gt; &#123; private final String name; private final T value; &#125;&#125; 如不使用Lombok，则实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119import java.util.Arrays;public class DataExample &#123; private final String name; private int age; private double score; private String[] tags; public DataExample(String name) &#123; this.name = name; &#125; public String getName() &#123; return this.name; &#125; void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return this.age; &#125; public void setScore(double score) &#123; this.score = score; &#125; public double getScore() &#123; return this.score; &#125; public String[] getTags() &#123; return this.tags; &#125; public void setTags(String[] tags) &#123; this.tags = tags; &#125; @Override public String toString() &#123; return \"DataExample(\" + this.getName() + \", \" + this.getAge() + \", \" + this.getScore() + \", \" + Arrays.deepToString(this.getTags()) + \")\"; &#125; protected boolean canEqual(Object other) &#123; return other instanceof DataExample; &#125; @Override public boolean equals(Object o) &#123; if (o == this) return true; if (!(o instanceof DataExample)) return false; DataExample other = (DataExample) o; if (!other.canEqual((Object)this)) return false; if (this.getName() == null ? other.getName() != null : !this.getName().equals(other.getName())) return false; if (this.getAge() != other.getAge()) return false; if (Double.compare(this.getScore(), other.getScore()) != 0) return false; if (!Arrays.deepEquals(this.getTags(), other.getTags())) return false; return true; &#125; @Override public int hashCode() &#123; final int PRIME = 59; int result = 1; final long temp1 = Double.doubleToLongBits(this.getScore()); result = (result*PRIME) + (this.getName() == null ? 43 : this.getName().hashCode()); result = (result*PRIME) + this.getAge(); result = (result*PRIME) + (int)(temp1 ^ (temp1 &gt;&gt;&gt; 32)); result = (result*PRIME) + Arrays.deepHashCode(this.getTags()); return result; &#125; public static class Exercise&lt;T&gt; &#123; private final String name; private final T value; private Exercise(String name, T value) &#123; this.name = name; this.value = value; &#125; public static &lt;T&gt; Exercise&lt;T&gt; of(String name, T value) &#123; return new Exercise&lt;T&gt;(name, value); &#125; public String getName() &#123; return this.name; &#125; public T getValue() &#123; return this.value; &#125; @Override public String toString() &#123; return \"Exercise(name=\" + this.getName() + \", value=\" + this.getValue() + \")\"; &#125; protected boolean canEqual(Object other) &#123; return other instanceof Exercise; &#125; @Override public boolean equals(Object o) &#123; if (o == this) return true; if (!(o instanceof Exercise)) return false; Exercise&lt;?&gt; other = (Exercise&lt;?&gt;) o; if (!other.canEqual((Object)this)) return false; if (this.getName() == null ? other.getValue() != null : !this.getName().equals(other.getName())) return false; if (this.getValue() == null ? other.getValue() != null : !this.getValue().equals(other.getValue())) return false; return true; &#125; @Override public int hashCode() &#123; final int PRIME = 59; int result = 1; result = (result*PRIME) + (this.getName() == null ? 43 : this.getName().hashCode()); result = (result*PRIME) + (this.getValue() == null ? 43 : this.getValue().hashCode()); return result; &#125; &#125;&#125; 2.2 @Getter/@Setter如果觉得@Data太过残暴（因为@Data集合了@ToString、@EqualsAndHashCode、@Getter/@Setter、@RequiredArgsConstructor的所有特性）不够精细，可以使用@Getter/@Setter注解，此注解在属性上，可以为相应的属性自动生成Getter/Setter方法，示例如下： 1234567891011121314import lombok.AccessLevel;import lombok.Getter;import lombok.Setter;public class GetterSetterExample &#123; @Getter @Setter private int age = 10; @Setter(AccessLevel.PROTECTED) private String name; @Override public String toString() &#123; return String.format(\"%s (age: %d)\", name, age); &#125;&#125; 如果不使用Lombok： 12345678910111213141516171819202122public class GetterSetterExample &#123; private int age = 10; private String name; @Override public String toString() &#123; return String.format(\"%s (age: %d)\", name, age); &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; protected void setName(String name) &#123; this.name = name; &#125;&#125; 2.3 @NonNull该注解用在属性或构造器上，Lombok会生成一个非空的声明，可用于校验参数，能帮助避免空指针。 示例如下： 12345678910import lombok.NonNull;public class NonNullExample extends Something &#123; private String name; public NonNullExample(@NonNull Person person) &#123; super(\"Hello\"); this.name = person.getName(); &#125;&#125; 不使用Lombok： 12345678910111213import lombok.NonNull;public class NonNullExample extends Something &#123; private String name; public NonNullExample(@NonNull Person person) &#123; super(\"Hello\"); if (person == null) &#123; throw new NullPointerException(\"person\"); &#125; this.name = person.getName(); &#125;&#125; 2.4 @Cleanup该注解能帮助我们自动调用close()方法，很大的简化了代码。 示例如下： 123456789101112131415import lombok.Cleanup;import java.io.*;public class CleanupExample &#123; public static void main(String[] args) throws IOException &#123; @Cleanup InputStream in = new FileInputStream(args[0]); @Cleanup OutputStream out = new FileOutputStream(args[1]); byte[] b = new byte[10000]; while (true) &#123; int r = in.read(b); if (r == -1) break; out.write(b, 0, r); &#125; &#125;&#125; 如不使用Lombok，则需如下： 1234567891011121314151617181920212223242526import java.io.*;public class CleanupExample &#123; public static void main(String[] args) throws IOException &#123; InputStream in = new FileInputStream(args[0]); try &#123; OutputStream out = new FileOutputStream(args[1]); try &#123; byte[] b = new byte[10000]; while (true) &#123; int r = in.read(b); if (r == -1) break; out.write(b, 0, r); &#125; &#125; finally &#123; if (out != null) &#123; out.close(); &#125; &#125; &#125; finally &#123; if (in != null) &#123; in.close(); &#125; &#125; &#125;&#125; 2.5 @EqualsAndHashCode默认情况下，会使用所有非静态（non-static）和非瞬态（non-transient）属性来生成equals和hasCode，也能通过exclude注解来排除一些属性。 示例如下： 12345678910111213141516171819202122232425import lombok.EqualsAndHashCode;@EqualsAndHashCode(exclude=&#123;\"id\", \"shape\"&#125;)public class EqualsAndHashCodeExample &#123; private transient int transientVar = 10; private String name; private double score; private Shape shape = new Square(5, 10); private String[] tags; private int id; public String getName() &#123; return this.name; &#125; @EqualsAndHashCode(callSuper=true) public static class Square extends Shape &#123; private final int width, height; public Square(int width, int height) &#123; this.width = width; this.height = height; &#125; &#125;&#125; 2.6 @ToString类使用@ToString注解，Lombok会生成一个toString()方法，默认情况下，会输出类名、所有属性（会按照属性定义顺序），用逗号来分割。 通过将includeFieldNames参数设为true，就能明确的输出toString()属性。这一点是不是有点绕口，通过代码来看会更清晰些。 使用Lombok的示例： 123456789101112131415161718192021222324import lombok.ToString;@ToString(exclude=\"id\")public class ToStringExample &#123; private static final int STATIC_VAR = 10; private String name; private Shape shape = new Square(5, 10); private String[] tags; private int id; public String getName() &#123; return this.getName(); &#125; @ToString(callSuper=true, includeFieldNames=true) public static class Square extends Shape &#123; private final int width, height; public Square(int width, int height) &#123; this.width = width; this.height = height; &#125; &#125;&#125; 不使用Lombok的示例如下： 123456789101112131415161718192021222324252627282930import java.util.Arrays;public class ToStringExample &#123; private static final int STATIC_VAR = 10; private String name; private Shape shape = new Square(5, 10); private String[] tags; private int id; public String getName() &#123; return this.getName(); &#125; public static class Square extends Shape &#123; private final int width, height; public Square(int width, int height) &#123; this.width = width; this.height = height; &#125; @Override public String toString() &#123; return \"Square(super=\" + super.toString() + \", width=\" + this.width + \", height=\" + this.height + \")\"; &#125; &#125; @Override public String toString() &#123; return \"ToStringExample(\" + this.getName() + \", \" + this.shape + \", \" + Arrays.deepToString(this.tags) + \")\"; &#125;&#125; 2.7 @NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor无参构造器、部分参数构造器、全参构造器。Lombok没法实现多种参数构造器的重载。 Lombok示例代码如下： 12345678910111213141516import lombok.AccessLevel;import lombok.RequiredArgsConstructor;import lombok.AllArgsConstructor;import lombok.NonNull;@RequiredArgsConstructor(staticName = \"of\")@AllArgsConstructor(access = AccessLevel.PROTECTED)public class ConstructorExample&lt;T&gt; &#123; private int x, y; @NonNull private T description; @NoArgsConstructor public static class NoArgsExample &#123; @NonNull private String field; &#125;&#125; 不使用Lombok的示例如下： 12345678910111213141516171819202122232425262728public class ConstructorExample&lt;T&gt; &#123; private int x, y; @NonNull private T description; private ConstructorExample(T description) &#123; if (description == null) throw new NullPointerException(\"description\"); this.description = description; &#125; public static &lt;T&gt; ConstructorExample&lt;T&gt; of(T description) &#123; return new ConstructorExample&lt;T&gt;(description); &#125; @java.beans.ConstructorProperties(&#123;\"x\", \"y\", \"description\"&#125;) protected ConstructorExample(int x, int y, T description) &#123; if (description == null) throw new NullPointerException(\"description\"); this.x = x; this.y = y; this.description = description; &#125; public static class NoArgsExample &#123; @NonNull private String field; public NoArgsExample() &#123; &#125; &#125;&#125; 3 Lombok工作原理分析会发现在Lombok使用的过程中，只需要添加相应的注解，无需再为此写任何代码。自动生成的代码到底是如何产生的呢？ 核心之处就是对于注解的解析上。JDK5引入了注解的同时，也提供了两种解析方式。 运行时解析 运行时能够解析的注解，必须将@Retention设置为RUNTIME，这样就可以通过反射拿到该注解。java.lang,reflect反射包中提供了一个接口AnnotatedElement，该接口定义了获取注解信息的几个方法，Class、Constructor、Field、Method、Package等都实现了该接口，对反射熟悉的朋友应该都会很熟悉这种解析方式。 编译时解析 编译时解析有两种机制，分别简单描述下： 1）Annotation Processing Tool apt自JDK5产生，JDK7已标记为过期，不推荐使用，JDK8中已彻底删除，自JDK6开始，可以使用Pluggable Annotation Processing API来替换它，apt被替换主要有2点原因： api都在com.sun.mirror非标准包下 没有集成到javac中，需要额外运行 2）Pluggable Annotation Processing API JSR 269自JDK6加入，作为apt的替代方案，它解决了apt的两个问题，javac在执行的时候会调用实现了该API的程序，这样我们就可以对编译器做一些增强，这时javac执行的过程如下： Lombok本质上就是一个实现了“JSR 269 API”的程序。在使用javac的过程中，它产生作用的具体流程如下： javac对源代码进行分析，生成了一棵抽象语法树（AST） 运行过程中调用实现了“JSR 269 API”的Lombok程序 此时Lombok就对第一步骤得到的AST进行处理，找到@Data注解所在类对应的语法树（AST），然后修改该语法树（AST），增加getter和setter方法定义的相应树节点 javac使用修改后的抽象语法树（AST）生成字节码文件，即给class增加新的节点（代码块） 拜读了Lombok源码，对应注解的实现都在HandleXXX中，比如@Getter注解的实现时HandleGetter.handle()。还有一些其它类库使用这种方式实现，比如Google Auto、Dagger等等。 4. Lombok的优缺点优点： 能通过注解的形式自动生成构造器、getter/setter、equals、hashcode、toString等方法，提高了一定的开发效率 让代码变得简洁，不用过多的去关注相应的方法 属性做修改时，也简化了维护为这些属性所生成的getter/setter方法等 缺点： 不支持多种参数构造器的重载 虽然省去了手动创建getter/setter方法的麻烦，但大大降低了源代码的可读性和完整性，降低了阅读源代码的舒适度 5. 总结Lombok虽然有很多优点，但Lombok更类似于一种IDE插件，项目也需要依赖相应的jar包。Lombok依赖jar包是因为编译时要用它的注解，为什么说它又类似插件？因为在使用时，eclipse或IntelliJ IDEA都需要安装相应的插件，在编译器编译时通过操作AST（抽象语法树）改变字节码生成，变向的就是说它在改变java语法。它不像spring的依赖注入或者mybatis的ORM一样是运行时的特性，而是编译时的特性。这里我个人最感觉不爽的地方就是对插件的依赖！因为Lombok只是省去了一些人工生成代码的麻烦，但IDE都有快捷键来协助生成getter/setter等方法，也非常方便。 知乎上有位大神发表过对Lombok的一些看法： 123这是一种低级趣味的插件，不建议使用。JAVA发展到今天，各种插件层出不穷，如何甄别各种插件的优劣？能从架构上优化你的设计的，能提高应用程序性能的 ，实现高度封装可扩展的...， 像lombok这种，像这种插件，已经不仅仅是插件了，改变了你如何编写源码，事实上，少去了代码你写上去又如何？ 如果JAVA家族到处充斥这样的东西，那只不过是一坨披着金属颜色的屎，迟早会被其它的语言取代。 虽然话糙但理确实不糙，试想一个项目有非常多类似Lombok这样的插件，个人觉得真的会极大的降低阅读源代码的舒适度。 虽然非常不建议在属性的getter/setter写一些业务代码，但在多年项目的实战中，有时通过给getter/setter加一点点业务代码，能极大的简化某些业务场景的代码。所谓取舍，也许就是这时的舍弃一定的规范，取得极大的方便。 我现在非常坚信一条理念，任何编程语言或插件，都仅仅只是工具而已，即使工具再强大也在于用的人，就如同小米加步枪照样能赢飞机大炮的道理一样。结合具体业务场景和项目实际情况，无需一味追求高大上的技术，适合的才是王道。 Lombok有它的得天独厚的优点，也有它避之不及的缺点，熟知其优缺点，在实战中灵活运用才是王道。 参考： https://projectlombok.org/features/ https://github.com/rzwitserloot/lombok?spm=a2c4e.11153940.blogcont59972.5.2aeb6d32hayLHv https://www.zhihu.com/question/42348457 https://blog.csdn.net/ghsau/article/details/52334762 欢迎关注微信公众号​：","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.alterem.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.alterem.top/tags/Java/"}]},{"title":"高可用的一些思考和理解","slug":"高可用的一些思考和理解","date":"2019-09-29T02:30:40.000Z","updated":"2019-09-29T03:12:12.729Z","comments":true,"path":"2019/09/29/高可用的一些思考和理解/","link":"","permalink":"http://blog.alterem.top/2019/09/29/高可用的一些思考和理解/","excerpt":"","text":"本文来源公众号：匠心零度 在目前的互联网大时代，在高并发等冲击下，还必须保证服务高可用，如果服务不高可用那么意味着： 系统不是7*24小时提供服务，那么用户体验就特别差了，可能用户下次不用了，留不住用户。 当系统不可用的时候，对公司的形象是有所影响的，BAT类似这种技术都是象征的。 最重要的一点，当系统不可用的时候，直接损失就是金钱！！！基本都是秒算损失的，依稀记得2015年5月28日携程网瘫痪事件，按照携程一季度财报公布的数据，携程宕机的损失为平均每小时106.48万美元。 高可用是非常复杂的，自己水平有限，并不能涵盖那么多，只能说是自己对高可用的一些思考和理解。 那么怎么使系统高可用呢？ 我们不能让服务器不挂，让服务不挂，那么怎么样让这种必败的局面不会有问题呢，就是可以挂，服务可以坏，那么怎么让系统还可以提供服务呢？ 首先如果机器有很多，服务有很多，就算坏了一部分也没有问题啊，必败的局面得到的解决。下面进行一步一步剖析，如果机器里面存储了特定值，那么就不能扩展，必须是用挂的那台机器，那么这个是不行的，机器问题好解决，相同的配置替代是容易的，那么应用服务也是类似，应用服务可以不存储状态有关的值在任何机器而自己内部不会有存储一些特定的特征数据，如果有就没办法很容易的扩展，只有当每个主件都是一样的时候，无任何差异，我们才好替换，容易扩展，那么这个就叫着服务的无状态化。 假如目前服务已经是无状态化了，那么如何让系统动态的感知到服务挂了呢？不然请求还是回去到挂的那台机器，怎么转移到新的机器呢？那么可能就需要服务发现与注册了。 如果达到了上面的情况，应对一般的情况基本已经够了，但是互联网是复杂的，刚刚说的机器坏，服务坏了的问题，那么如果网络出现短暂不通因为怎么办呢？ 所以服务之间应该有心跳的检测，来定期看看是否可通（机器坏了，服务挂了，网络不通了）反正就是不可达了。这种情况通过服务注册与发现即可解决，但是有时候网络是闪断下那么在那种特定的情况呢？比如刚刚a服务已经把请求发送给了b服务，b服务已经接收到请求了，那么这个时候忽然网络断了，但是b服务进行把逻辑处理做完成了，但是a服务反应的就是没有响应，前台超时了，那么再一次触发下，那么如果b服务把之前的逻辑再做一遍是否存在问题呢？ 比如支付，已经付款200元，难道再付款200元吗？这里需要提到一个幂等性的设计概念，什么是幂等呢，就是多次执行结果都一样，如果有幂等性设计那么就不怕这种情况了，在没有得到反馈情况重试即可，也不会出现问题。 达到上面说的这些就是应对机器坏了，服务挂了，网络不通或者闪断等情况已经基本没有什么大问题了，那么目前互联网都是高并发，那么在高并发的情况，如何来提高系统的能力的？ 就和搬东西一样，一个人慢，可以多来点人一起帮东西，由于上面的架构是可以添加机器，服务的，那么很容易想到的就是多来点机器和服务。那么这样一定比机器少要快的，比如有5台机器，那么很多请求过来了，用什么策略让他们分摊到不同的机器呢？通过设备，通过一些软件层面，但是其中一定有服务发现注册，不然没办法动态知道节点变化，还有就是对一些信息的控制，黑白名单，访问频率等。很多时候，加机器可能看起来比较low，但是有时候的确比较有效，但是也不能一味的加机器，有些情况加机器是解决不了的了。 机器多了的确快了，如果在服务里面有一个阻塞方法，那么就算服务在多也没用，所以必须注意关于服务超时的问题，由于服务是幂等的，就算再次执行也没有任何关系，有了超时就不会卡很久影响到后面的服务了（下游服务宕机了，线程死锁了，下游服务忙等等）。 关于同步，异步的一些设计模式，在有些必须顺序执行的业务场景就必须要使用同步了，在非必须的这种场景那么用异步一定比同步处理的并发量要大（由于中间件经历很多步骤，所以从单个请求的总时间来看并不一定有同步的快，但是从一个宏观的角度来看提高并发的请求会大很多了）。简单聊聊异步，在一个服务内部，异步那么就需要提到多线程了，多线程很多有点提高cpu利用率，提高系统性能，但是实现成本要高很多了，那么不同服务直接的如何异步呢，消息中间件了，（消息中间件很难，第一要保证真异步，第二需要保证不重不漏，就这2点真的很难，特别是在大数据情况下），特别是网络I/O需要重点考虑异步模型，不过Netty封装的挺好了。 由于每个机器，或者服务都是有上限的，如果量一下泄洪式的过来并且不是他的能力可以处理的，那么该如果解决呢？ 该问题在生活中到处可见，刚刚好国庆回家、出去玩，随处可见该事项体现，比如过安检的时候，有一个保安专门拿一个牌看人差不多了，让后面的人等，等处理的查不多了，在让后面的人进行，之后类似在等。，但是如果有级别高的，或者车快发车了，一般让他们先过，在软件架构里面应该叫限流、服务降级，一般有两种控制策略（1，拒绝部分请求，2，关闭部分服务）可能之前的时候都提到了关闭部分服务，不过现在不推荐了（毕竟也是公司技术实力的体现），目前重点说的是关于拒绝部分请求，关于这块的控制在那里添加？就是那块需要控制，应该每层都需要加下该控制。 依稀记得行业里面有句话，高并发、高可用三大法宝：限流、降级、缓存，关于缓存，大家应该接触的最多，互联网业务特点就是读多写少，那么就非常适合使用缓存了。 由于所以请求在一个服务，扩展还是不好扩展，而且统一服务里面有些调用特别多，有些调用就比较少，因为继续划分，继续拆，这样还是可以再次提高并发。 微服务了，微服务概念很多，首先提到的就是搞垂直拆分，很容易理解，之后垂直业务可能也很多，还需要继续水平拆分，（这里一切的拆分依据都是根据自己公司的业务，理解越深才的越好）。 通过上面的这些，服务可以挂，机器可以坏，网络不通或者闪断的问题都解决了，并且可以提高并发，尽最大努力来让服务高可用。那么由于这么做带来了很多问题，所以需要把这些修改带来的问题解决： 以前在一个服务里面，对于事务的控制很容易，那么微服务之后，事务的控制就显的特别重要了，很多时候我们不能强一致性，但是我们可以做到最终一致性就是可以的。 调用链监控也就显得特别重要了，一起的还有预警也特别重要了。 分布式日志也显得特别重要了。 高级的jstack、Btrace在真实环境就是特别重要的。 结束语 本人水平有限，难免会有一些理解偏差的地方，如果发现，欢迎各位积极指出，感谢！！！ 欢迎关注微信公众号​：","categories":[{"name":"高可用","slug":"高可用","permalink":"http://blog.alterem.top/categories/高可用/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.alterem.top/tags/Java/"}]},{"title":"【Python】哄女朋友的那些奇技淫巧","slug":"【Python】哄女朋友的那些奇技淫巧","date":"2019-09-27T02:00:20.000Z","updated":"2019-09-27T02:52:54.181Z","comments":true,"path":"2019/09/27/【Python】哄女朋友的那些奇技淫巧/","link":"","permalink":"http://blog.alterem.top/2019/09/27/【Python】哄女朋友的那些奇技淫巧/","excerpt":"","text":"本文来源公众号： Python乱炖 Python里面的奇技淫巧 声明 “以下所有模块均可 使用pip直接安装” 说python是 所有编程语言里面 最奇葩的语言 这肯定是没错了 它可以做 自动化，爬虫，数据，AI，机器学习 这些我们暂且不说 可是它竟然还可以 撩妹 撩到妹 定位女朋友 和女朋友聊天 天天和女朋友早晚安 给女朋友打电话 讨女朋友开心 让女朋友崇拜你 ……… 怎么样？ 够厉害吧 赶紧跟着狗哥 来看看python里面的奇技淫巧吧！ pinyin第一个就是我们的pinyin模块了，这个模块骚就骚在可以直接把中文汉字转化成中文的汉语拼音，甚至连第几声发音都可以给你搞出来，具体使用很简单，导入后直接使用get方法即可： 123import pinyintransf = pinyin.get(\"狗哥\")trans2 = pinyin.get(\"狗哥\", format=\"strip\") qrcode下面这个是我们的二维码生成器，可以将文字，号码，网址存放在二维码中，只需要只用make方法去生成二维码，如何使用save方法保存二维码图片即可。很简单的两部搞定！下面我们来看一个栗子： 12345import qrcodewords='https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzU1NDcwNTE2OA==&amp;scene=126#wechat_redirect'img = qrcode.make(words)img.save('test.png')img.show() myqr如果说刚刚的qrcode已经足够神奇了的话，那这个将会更加神奇，因为它可以以图片为背景来生成二维码，背景图片可以是动态gif也可以是静态jpg，png，整个生成二维码的步骤也要比上面简单许多，你甚至都不需要敲代码就可以享受到动态二维码的美好，可以直接在终端（cmd）敲一句口令即可生成二维码！（需要安装好myqr） 1myqr \"https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzU1NDcwNTE2OA==&amp;scene=126#wechat_redirect\" -v 1 -l Q -n \"s_qr.gif\" -p s.gif -con 1.2 -bri 1.2 -c 整个口令你需要修改的就是： url网址修改成你需要的 s.gif修改成你自己图片的地址 其他的参数你不知道什么意思均可以不动 如果想了解具体参数是什么意思，可参考狗哥公众号内python生成二维码那片文章。 效果如下： jiebajieba，真的就是结巴的意思，主要是用来进行分词的。 jieba 可以**把一句话拆分成多个词。** 从一句话（一段话）中提取最重要的几个关键词。 最常用的功能应该就是这些吧，分词之后结合 TF-IDF，就可以做搜索工具和相关推荐了。 狗哥推荐：结合本次推荐的这些模块，使用结巴工具来和女朋友聊天，是个不错的主意！ 下面看看切割示范： 12345678import jiebastring = \"大家都说狗哥好，狗哥帅气人又好\"sl = jieba.cut(string, cut_all=True)print('全的模式:', list(sl))sl = jieba.cut(string, cut_all=False)print(\"精确模式:\", list(sl))sl = jieba.cut(string)print('搜索模式:', list(sl)) 结巴还有很多高级的方法，希望大家多多发掘，如果实在懒，在狗哥的公众号里面搜一下也就找到了。 itchat/wxpy itchat和wxpy这两个模块功能都差不多，都是用于微信聊天的，可以用来获取朋友圈好友的数据，也可以用来和好友聊天自动回复等等。（接上图灵机器人也是无敌了） 使用itchat很简单，导入模块后调用login方法便可以直接扫码登陆了： 12import itchatitchat.login() 登陆了之后可以通过get_friends方法获取到所有的微信好友 1friends = itchat.get_friends(update=True)[0:] 至于获取微信好友要干啥，那就随你了，狗哥直接教你发送消息吧，直接使用send方法指明发送对象即可： 1users = itchat.search_friends(\"亲爱的\")userName = users[0]['UserName']print(userName)itchat.send('亲爱的，送你一个杨树林要不要？', toUserName=userName) 这边狗哥直接选择了一个用户直接发送消息 当然，我们除了发送消息，还可以设置自动回复： 定义几个方法，调用itchat自带的装饰器即可： 12345678910111213141516171819202122from itchat.content import *def reply(msg): itchat.send(('23333'), msg['FromUserName'])@itchat.msg_register([PICTURE])def pic_replay(msg): itchat.send(('最近又漂亮了'), msg['FromUserName'])@itchat.msg_register([RECORDING])def rec_replay(msg): itchat.send(('连声音都是这么迷人'), msg['FromUserName'])@itchat.msg_register([VIDEO,])def video_replay(msg): itchat.send(('我没流量了，视频打不开啊'), msg['FromUserName'])@itchat.msg_register([SHARING])def share_replay(msg): itchat.send(('这链接我这么怎么点不进去啊'), msg['FromUserName']) 没错定义好回复的对象，只要登陆上了，这些回复就会生效了！ 狗哥测试的一个例子： wordcloud下面这个看起来比较鬼畜，但是其实在数据可视化里面它的用处还是比较强大的。 词云这个东西一般与numpy，matplotlib，jieba，pillow连用，用起来也是挺麻烦的 狗哥这里整理了一个简单的版本供大家参考： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import numpy as npfrom PIL import Imageimport reimport jiebafrom wordcloud import WordCloud,\\ ImageColorGenerator,\\ STOPWORDSimport matplotlib.pyplot as pltwith open('content.txt', 'r', encoding='utf-8') as f: word = (f.read()) f.close()# 图片模板和字体image = np.array(Image.open('ditu.jpg'))font = r'C:\\\\Windows\\\\fonts\\\\msyh.ttf'# 去掉英文，保留中文resultword = re.sub(\"[A-Za-z0-9\\[\\`\\~\\!\\@\\#\\$\\^\\&amp;\\*\\(\\)\\=\\|\\&#123;\\&#125;\" \"\\'\\:\\;\\'\\,\\[\\]\\.\\&lt;\\&gt;\\/\\?\\~\\。\\@\\#\\\\\\&amp;\\*\\%]\", \"\", word)wordlist_after_jieba = jieba.cut(resultword)wl_space_split = \" \".join(wordlist_after_jieba)# 设置停用词sw = set(STOPWORDS)# 关键一步my_wordcloud = WordCloud(scale=4, font_path=font, mask=image, stopwords=sw, background_color='white', max_words=100, max_font_size=60, random_state=20).\\ generate(wl_space_split)# 显示生成的词云plt.imshow(my_wordcloud)plt.axis(\"off\")plt.show()# 保存生成的图片my_wordcloud.to_file('result.jpg') 欢迎关注微信公众号​：","categories":[{"name":"python","slug":"python","permalink":"http://blog.alterem.top/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://blog.alterem.top/tags/python/"}]},{"title":"SonarQube的使用-在idea&eclipse中安装与使用sonarlint","slug":"SonarQube的使用-在idea&eclipse中安装与使用sonarlint","date":"2019-09-26T03:24:31.000Z","updated":"2019-09-26T04:48:25.246Z","comments":true,"path":"2019/09/26/SonarQube的使用-在idea&eclipse中安装与使用sonarlint/","link":"","permalink":"http://blog.alterem.top/2019/09/26/SonarQube的使用-在idea&eclipse中安装与使用sonarlint/","excerpt":"","text":"介绍​ 代码质量管理的开源平台，用于管理源代码的质量 通过插件形式，可以支持包括java,C#,C/C++,PL/SQL,Cobol,JavaScrip,Groovy等等二十几种编程语言的代码质量管理与检测。集成了CheckStyle，PMD，Findbugs等工具校验规则，具有重复代码发现，代码测试覆盖率，代码注释率，及所有的检测率变化追踪的功能特性。 特点​ SonarQube:开源的代码质量管控平台，我们使用的http://localhost:9000即为SonarQube。 ​ SonarLint:一个扩展插件，可以安装在idea与eclipse等开发工具中 Eclipse中的使用1、 安装​ help -&gt; eclipse marketplace…，搜索sonarlint, Install。 2、 使用打开java文件，soanrlint会自动进行检测，对于不规范或有问题的代码会在下方划蓝色波浪线，如图： 鼠标放在蓝色部分会有弹框显示错误信息或建议修改信息 点击“open description of rule”可以查看具体的错误描述，错误示例及修改示例。 在项目或单个java文件上右键 -&gt; sonarlint -&gt; Analyze 进行手动操作分析。这样SonarLint Report面板中查看所有的异常信息 3、Server连接SonarQube的主要目的是同步分析规则、质量规则与自定义设置。操作如下： 从Window -&gt; show view 中找到SonarLint Bindings打开； 在该面板空白处 右键创建 server连接，选择SonarQube url为：http://localhost:9000 使用UserName+Password或者token登陆 没有token可以点击右侧按钮创建，或者寻找管理员创建 配置名称 完成服务配置 绑定工程，点击add 输入sonarQube中创建的工程的名称 完成 4、 结果同步SonarQube显示在maven的settings.xml中配置如下： 配置完成后，使用soanr:sonar命令运行项目，此部分要求JDK为1.8。clean install sonar:sonar 可以打开http://localhost:9000/dashboard?id=com.xxx查看对应的错误信息，也可以在SonarQube点击Issues进行查看 IDEA中使用1、 安装​ File -&gt; settings -&gt; plugins 搜索sonarLint，Install。 2、 使用在左下角点击隐藏面板，可以看到sonarLint，打开 打开java文件，soanrlint会自动进行检测，对于不规范或有问题的代码会添加暗金色的背景色，鼠标放上去会有如图提示： 也可以通过点击上图的绿色倒三角手动执行分析。 3、 Server连接SonarQube的主要目的是同步分析规则、质量规则与自定义设置。操作如下： 从File -&gt; settings -&gt; OtherSettings中找到“SonarLint General Settings”打开； 点击加号，输入一个name，如localhost;选择SonarQube，Url为http://localhost9000； 选择Login/Password或者token，输入账号与密码或者token； finish 勾选“Enable binding to remote SonarQube Server”,选择添加的server,搜索到你需要绑定的项目，然后选择确认。 4、结果同步SonarQube显示同Eclipse部分，此部分要求JDK为1.8。","categories":[{"name":"SonarQube","slug":"SonarQube","permalink":"http://blog.alterem.top/categories/SonarQube/"},{"name":"SonarLint","slug":"SonarQube/SonarLint","permalink":"http://blog.alterem.top/categories/SonarQube/SonarLint/"}],"tags":[{"name":"SonarQube","slug":"SonarQube","permalink":"http://blog.alterem.top/tags/SonarQube/"},{"name":"SonarLint","slug":"SonarLint","permalink":"http://blog.alterem.top/tags/SonarLint/"}]},{"title":"[SonarQube的使用] SonarQube安装","slug":"SonarQube的使用-SonarQube安装","date":"2019-09-26T03:15:44.000Z","updated":"2019-09-26T03:17:51.335Z","comments":true,"path":"2019/09/26/SonarQube的使用-SonarQube安装/","link":"","permalink":"http://blog.alterem.top/2019/09/26/SonarQube的使用-SonarQube安装/","excerpt":"","text":"工欲善其事必先利其器一 . SonarQube代码质量检查工具简介 Sonar (SonarQube)是一个开源平台，用于管理源代码的质量 Sonar 不只是一个质量数据报告工具，更是代码质量管理平台 支持Java, C#, C/C++, PL/SQL, Cobol, JavaScrip, Groovy 等等二十几种编程语言的代码质量管理与检测。 Sonar可以从以下七个维度检测代码质量，而作为开发人员至少需要处理前5种代码质量问题。 不遵循代码标准 sonar可以通过PMD,CheckStyle,Findbugs等等代码规则检测工具规范代码编写。 潜在的缺陷 sonar可以通过PMD,CheckStyle,Findbugs等等代码规则检测工具检 测出潜在的缺陷。 糟糕的复杂度分布 文件、类、方法等，如果复杂度过高将难以改变，这会使得开发人员 难以理解它们, 且如果没有自动化的单元测试，对于程 序中的任何组件的改变都将可能导致需要全面的回归测试。 重复 显然程序中包含大量复制粘贴的代码是质量低下的，sonar可以展示 源码中重复严重的地方。 注释不足或者过多 没有注释将使代码可读性变差，特别是当不可避免地出现人员变动 时，程序的可读性将大幅下降 而过多的注释又会使得开发人员将精力过多地花费在阅读注释上，亦违背初衷。 缺乏单元测试 sonar可以很方便地统计并展示单元测试覆盖率。 糟糕的设计 通过sonar可以找出循环，展示包与包、类与类之间的相互依赖关系，可以检测自定义的架构规则 通过sonar可以管理第三方 的jar包，可以利用LCOM4检测单个任务规则的应用情况， 检测藕合。 为什么要选择sonarQube?个人使用之后认为 : sonarQube的优势如下(相比于阿里编码规约这种市面上常见类似软件): 更加优秀的图形化界面 基本上通过界面就可以对自己项目的代码状况一目了然 可以查询出其它软件难以定位到的问题 比如 : 可能导致空指针异常的问题 (对象在进行使用前没有加空的判断) 可能导致内存泄漏的问题, 在try catch 块里面,直接使用e.printStackTrace()将堆栈信息打印到内存的 可能导致的漏洞 : 成员变量使用public定义的 还有诸如 : 流等未关闭或者是非正常关闭都能够检测出来! 功能非常强大!! 二. 安装：2.1 安装SonarQube web server 首先确保安装了jdk1.8 + 到此链接 https://www.sonarqube.org/downloads/ 下载sonalqube(下载社区版,是开源的), 我下载的是sonarqube-7.2.1，因为最新版7.9.1需要jdk11支持 并解压,解压完之后的目录如下 : 到解压目录的bin\\macosx-universal-64(对应系统)目录下: linux、Mac sh sonar.sh start启动 windows 双击StartSonar.bat 启动 到浏览器界面,输入 : http://localhost:9000 如果能访问表明安装成功 2.2 安装数据库 版本要求: 在conf目录下的sonar.properties文件下: 有这样一行配置 : 1#----- MySQL &gt;=5.6 &amp;&amp; &lt; 8.0 为sonarqube 创建一个数据库 12create database sonar;-- 创建数据库 创建sonarqube用户并进行授权 1234567CREATE USER 'username'@'host' IDENTIFIED BY 'password'; -- 创建用户并设置密码-- username 为创建的用户名-- host 为对应的主机地址,本地就是localhost-- password 为设置的密码GRANT ALL ON *.* TO 'username'@'localhost';-- 对用户进行授权操作 修改SonarQube配置文件,添加Mysql相关配置 1234567891011sonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance&amp;useSSL=false# 刚刚创建的sonarQube用户sonar.jdbc.username=sonar# 创建用户对应的密码sonar.jdbc.password=sonar# 设置编码格式为UTF-8sonar.sorceEncoding=UTF-8# sonar登陆用户名sonar.login=admin# sonar登陆密码sonar.password=admin 2.3 重新启动服务端 退出 SonarQube 服务端 在之前弹出的cmd窗口执行ctrl + c, 弹出来的提示选择Y,退出SonarQube服务 双击StartSonar.bat文件, 重新启动SonarQube 这次因为要进行数据库的初始化操作,所以需要的时间可能稍微久一点 启动成功后,浏览器输入 : http://localhost:9000 进入界面 登录 点击界面右上角的登录按钮, 进行登录 : 初始的账户名 : admin 初始的密码 : admin 附 : 一些关键配置的修改,如 主机地址,context,端口号等: 通常情况下使用默认的配置即可! 文件 /conf/sonar.properties 123#sonar.web.host=0.0.0.0 #sonar.web.context=#sonar.web.port=9000 三. 使用3.1. 安装必要的插件 (汉化包举例)点击 导航栏的 Administration, 选择Marketplace 搜索 Chinese pack, 点击install进行安装 安装成功后, 重启 SonarQube ! 3.2. 开始分析项目代码源代码使用maven的方式进行分析 3.2.1 编辑maven 的settings.xml文件12345678910111213141516&lt;settings&gt; &lt;pluginGroups&gt; &lt;pluginGroup&gt;org.sonarsource.scanner.maven&lt;/pluginGroup&gt; &lt;/pluginGroups&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;sonar&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;sonar.host.url&gt;http://loaclhost:9000&lt;/sonar.host.url&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt;&lt;/settings&gt; 其中sonar.host.url 值就是 上文启动的sonar 服务器地址。 3.2.2 对maven项目进行分析到项目所在的文件路径下: 使用命令提示符或者是power shell执行 如下命令: 1mvn org.sonarsource.scanner.maven:sonar-maven-plugin:3.6.0.1398:sonar 出现: BUILD SUCCESS 标识之后 刷新界面查看 : 3.3 配置分析参数强制参数： Serversonar.host.url http://localhost:9000 Project Configurationsonar.projectKey Maven :sonar.sources Maven 默认的源码路径 可以配置的参数： Project identitysonar.projectName 项目名称sonar.projectversion 项目版本 Authenticationsonar.login 分析该项目的用户名称sonar.password 分析该项目的用户密码 3.4. 程序员用户使用说明SonarQube Web管理者通过配置和设置以下参数值对项目源代码进行： 复杂度、覆盖率、文档、重复、问题、可维护性、可靠性、安全性、大小等约束和规范。 sonar中的质量阈管理以下内容。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108复杂度 复杂度 复杂度/类 复杂度/文件 复杂度/方法覆盖率 分支覆盖 集成测试的新分支覆盖 新代码的分支覆盖率 覆盖率 新集成测试覆盖 新覆盖率 集成测试分支覆盖 集成测试覆盖 集成测试覆盖行 集成测试未覆盖分支 集成测试未覆盖行 代码覆盖率 集成测试的新行覆盖 新代码覆盖率 代码行 集成测试的新行覆盖 覆盖的新代码 总体分支覆盖率 总体新分支覆盖率 总体覆盖率 总体新覆盖率 总体代码覆盖率 总体新代码覆盖率 总体覆盖的新行数 总体未覆盖分支 总体未覆盖的新分支 总体未覆盖代码 总体未覆盖新行数 单元测试忽略数 未覆盖分支 集成测试未覆盖的新分支 未覆盖新分支 未覆盖的代码 集成测试未覆盖的行 未覆盖的新代码 单元测试持续时间 单元测试错误数 单元测试失败数 单元测试成功 (%) 单元测试数文档 注释行 注释 (%) 公共API 公共注释的API (%) 公共未注释的API重复 重复块 重复文件 重复行 重复行(%)问题 阻断违规 确认问题 严重违规 误判问题 提示违规 违规 主要违规 次要违规 新阻断违规 新严重违规 新提示违规 新违规 新主要违规 新次要违规 开启问题 重开问题 不修复的问题可维护性 新代码的技术债务 坏味道 达到可维护性A级所需的工作 新增坏味道 技术债务 技术债务比率 新代码技术债务比率 Management Burned budget Business value Team size可靠性 Bugs 新增Bugs 可靠性修复工作 新代码的可靠性修复工作安全性 新增漏洞 安全修复工作 新代码的安全修复工作 漏洞大小 类 目录 文件 方法 生成的行数 生成的代码行数 行数 代码行数 项目 语句","categories":[{"name":"Sonar","slug":"Sonar","permalink":"http://blog.alterem.top/categories/Sonar/"},{"name":"SonarQube","slug":"Sonar/SonarQube","permalink":"http://blog.alterem.top/categories/Sonar/SonarQube/"}],"tags":[{"name":"SonarQube","slug":"SonarQube","permalink":"http://blog.alterem.top/tags/SonarQube/"},{"name":"Sonar","slug":"Sonar","permalink":"http://blog.alterem.top/tags/Sonar/"}]},{"title":"教程|教你如何给你的头像添加一个好看的国旗","slug":"教程-教你如何给你的头像添加一个好看的国旗","date":"2019-09-24T10:10:31.000Z","updated":"2019-09-24T10:36:29.800Z","comments":true,"path":"2019/09/24/教程-教你如何给你的头像添加一个好看的国旗/","link":"","permalink":"http://blog.alterem.top/2019/09/24/教程-教你如何给你的头像添加一个好看的国旗/","excerpt":"今天朋友圈又火了，听说原因是 @腾讯官网 就能得到一顶绿色的帽子，啊呸，是一个好看的国庆节头像，可是听说没一会就502了，那么我们自己动手实现一个吧 由于代码比较简单就不一一介绍了。","text":"今天朋友圈又火了，听说原因是 @腾讯官网 就能得到一顶绿色的帽子，啊呸，是一个好看的国庆节头像，可是听说没一会就502了，那么我们自己动手实现一个吧 由于代码比较简单就不一一介绍了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687var cvs = document.getElementById(\"cvs\");var ctx = cvs.getContext(\"2d\");var exportImage = document.getElementById(\"export\");var img = document.getElementById(\"img\");var hat = \"hat6\";var canvasFabric;var hatInstance;var screenWidth = window.screen.width &lt; 500 ? window.screen.width : 300;function viewer() &#123; var file = document.getElementById(\"upload\").files[0]; console.log(file); var reader = new FileReader; if (file) &#123; reader.readAsDataURL(file); reader.onload = function(e) &#123; img.src = reader.result; img.onload = function() &#123; img2Cvs(img) &#125; &#125; &#125; else &#123; img.src = \"\" &#125;&#125;function img2Cvs(img) &#123; cvs.width = img.width; cvs.height = img.height; cvs.style.display = \"block\"; canvasFabric = new fabric.Canvas(\"cvs\", &#123; width: screenWidth, height: screenWidth, backgroundImage: new fabric.Image(img, &#123; scaleX: screenWidth / img.width, scaleY: screenWidth / img.height &#125;) &#125;); changeHat(); document.getElementById(\"uploadContainer\").style.display = \"none\"; document.getElementById(\"uploadText\").style.display = \"none\"; document.getElementById(\"upload\").style.display = \"none\"; document.getElementById(\"change\").style.display = \"block\"; document.getElementById(\"exportBtn\").style.display = \"block\"; document.getElementById(\"tip\").style.opacity = 1&#125;function changeHat() &#123; document.getElementById(hat).style.display = \"none\"; var hats = document.getElementsByClassName(\"hide\"); hat = \"hat\" + (+hat.replace(\"hat\", \"\") + 1) % hats.length; var hatImage = document.getElementById(hat); hatImage.style.display = \"block\"; if (hatInstance) &#123; canvasFabric.remove(hatInstance) &#125; hatInstance = new fabric.Image(hatImage, &#123; top: 40, left: screenWidth / 3, scaleX: 100 / hatImage.width, scaleY: 100 / hatImage.height, cornerColor: \"#0b3a42\", cornerStrokeColor: \"#fff\", cornerStyle: \"circle\", transparentCorners: false, rotatingPointOffset: 30 &#125;); hatInstance.setControlVisible(\"bl\", false); hatInstance.setControlVisible(\"tr\", false); hatInstance.setControlVisible(\"tl\", false); hatInstance.setControlVisible(\"mr\", false); hatInstance.setControlVisible(\"mt\", false); canvasFabric.add(hatInstance)&#125;function exportFunc() &#123; document.getElementsByClassName(\"canvas-container\")[0].style.display = \"none\"; document.getElementById(\"exportBtn\").style.display = \"none\"; document.getElementById(\"tip\").innerHTML = \"长按图片保存或分享\"; document.getElementById(\"change\").style.display = \"none\"; cvs.style.display = \"none\"; exportImage.style.display = \"block\"; exportImage.src = canvasFabric.toDataURL(&#123; width: screenWidth, height: screenWidth &#125;)&#125; 最后效果 拖动图片可见已经拼合成一张完整图片了 右键查看源代码 源码地址：https://gitee.com/alterem/avatar.git 演示地址：http://alterem.gitee.io/avatar/","categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://blog.alterem.top/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://blog.alterem.top/tags/Javascript/"}]},{"title":"在SpringMVC项目中使用HIkariCP","slug":"在SpringMVC项目中使用HIkariCP","date":"2019-06-24T09:42:16.000Z","updated":"2019-06-24T09:45:20.999Z","comments":true,"path":"2019/06/24/在SpringMVC项目中使用HIkariCP/","link":"","permalink":"http://blog.alterem.top/2019/06/24/在SpringMVC项目中使用HIkariCP/","excerpt":"什么是HIkariCP https://www.jianshu.com/p/15b846107a7c 使用HikariCP数据源pom.xml12345&lt;dependency&gt; &lt;groupId&gt;com.zaxxer&lt;/groupId&gt; &lt;artifactId&gt;HikariCP&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt;&lt;/dependency&gt;","text":"什么是HIkariCP https://www.jianshu.com/p/15b846107a7c 使用HikariCP数据源pom.xml12345&lt;dependency&gt; &lt;groupId&gt;com.zaxxer&lt;/groupId&gt; &lt;artifactId&gt;HikariCP&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt;&lt;/dependency&gt; Spring-mvc.xml1234567891011121314151617181920&lt;bean id=\"dataSource\" class=\"com.zaxxer.hikari.HikariDataSource\" destroy-method=\"shutdown\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\" /&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt; &lt;property name=\"connectionTestQuery\" value=\"SELECT 1\" /&gt; &lt;!-- 生效超时 --&gt; &lt;property name=\"validationTimeout\" value=\"3000\" /&gt; &lt;!-- 连接只读数据库时配置为true， 保证安全 --&gt; &lt;property name=\"readOnly\" value=\"false\" /&gt; &lt;!-- 等待连接池分配连接的最大时长（毫秒），超过这个时长还没可用的连接则发生SQLException， 缺省:30秒 --&gt; &lt;property name=\"connectionTimeout\" value=\"60000\" /&gt; &lt;!-- 一个连接idle状态的最大时长（毫秒），超时则被释放（retired），缺省:10分钟 --&gt; &lt;property name=\"idleTimeout\" value=\"60000\" /&gt; &lt;!-- 一个连接的生命时长（毫秒），超时而且没被使用则被释放（retired），缺省:30分钟，建议设置比数据库超时时长少30秒，参考MySQL wait_timeout参数（show variables like '%timeout%';） --&gt; &lt;property name=\"maxLifetime\" value=\"60000\" /&gt; &lt;!-- 连接池中允许的最大连接数。缺省值：10；推荐的公式：((core_count * 2) + effective_spindle_count) --&gt; &lt;property name=\"maximumPoolSize\" value=\"10\" /&gt; &lt;/bean&gt; 启动成功日志123456789101112131415161718192021222324252627282930313233343536373817:36:50.838 [main] WARN com.zaxxer.hikari.HikariConfig - HikariPool-1 - idleTimeout has been set but has no effect because the pool is operating as a fixed size pool.17:36:50.838 [main] DEBUG com.zaxxer.hikari.HikariConfig - HikariPool-1 - configuration:17:36:50.841 [main] DEBUG com.zaxxer.hikari.HikariConfig - allowPoolSuspension.............false17:36:50.841 [main] DEBUG com.zaxxer.hikari.HikariConfig - autoCommit......................true17:36:50.841 [main] DEBUG com.zaxxer.hikari.HikariConfig - catalog.........................none17:36:50.841 [main] DEBUG com.zaxxer.hikari.HikariConfig - connectionInitSql...............none17:36:50.841 [main] DEBUG com.zaxxer.hikari.HikariConfig - connectionTestQuery.............\"SELECT 1\"17:36:50.841 [main] DEBUG com.zaxxer.hikari.HikariConfig - connectionTimeout...............6000017:36:50.841 [main] DEBUG com.zaxxer.hikari.HikariConfig - dataSource......................none17:36:50.841 [main] DEBUG com.zaxxer.hikari.HikariConfig - dataSourceClassName.............none17:36:50.841 [main] DEBUG com.zaxxer.hikari.HikariConfig - dataSourceJNDI..................none17:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - dataSourceProperties............&#123;password=&lt;masked&gt;&#125;17:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - driverClassName.................\"com.mysql.jdbc.Driver\"17:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - healthCheckProperties...........&#123;&#125;17:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - healthCheckRegistry.............none17:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - idleTimeout.....................6000017:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - initializationFailTimeout.......117:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - isolateInternalQueries..........false17:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - jdbcUrl.........................jdbc:mysql://ykx.uerp.net:3306/ykx?useUnicode=true&amp;characterEncoding=utf817:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - leakDetectionThreshold..........017:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - maxLifetime.....................6000017:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - maximumPoolSize.................1017:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - metricRegistry..................none17:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - metricsTrackerFactory...........none17:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - minimumIdle.....................1017:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - password........................&lt;masked&gt;17:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - poolName........................\"HikariPool-1\"17:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - readOnly........................false17:36:50.843 [main] DEBUG com.zaxxer.hikari.HikariConfig - registerMbeans..................false17:36:50.844 [main] DEBUG com.zaxxer.hikari.HikariConfig - scheduledExecutor...............none17:36:50.844 [main] DEBUG com.zaxxer.hikari.HikariConfig - schema..........................none17:36:50.844 [main] DEBUG com.zaxxer.hikari.HikariConfig - threadFactory...................internal17:36:50.844 [main] DEBUG com.zaxxer.hikari.HikariConfig - transactionIsolation............default17:36:50.844 [main] DEBUG com.zaxxer.hikari.HikariConfig - username........................\"ykx\"17:36:50.844 [main] DEBUG com.zaxxer.hikari.HikariConfig - validationTimeout...............300017:36:50.844 [main] INFO com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Starting...17:36:51.257 [main] DEBUG com.zaxxer.hikari.pool.HikariPool - HikariPool-1 - Added connection com.mysql.jdbc.JDBC4Connection@1d77a31d17:36:51.260 [main] INFO com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Start completed.","categories":[{"name":"HIkariCP","slug":"HIkariCP","permalink":"http://blog.alterem.top/categories/HIkariCP/"},{"name":"dataSource","slug":"HIkariCP/dataSource","permalink":"http://blog.alterem.top/categories/HIkariCP/dataSource/"}],"tags":[{"name":"HIkariCP","slug":"HIkariCP","permalink":"http://blog.alterem.top/tags/HIkariCP/"},{"name":"dataSource","slug":"dataSource","permalink":"http://blog.alterem.top/tags/dataSource/"}]},{"title":"MyBatis在Spring环境下的事务管理","slug":"MyBatis在Spring环境下的事务管理","date":"2019-06-13T05:23:05.000Z","updated":"2019-06-13T05:31:12.821Z","comments":true,"path":"2019/06/13/MyBatis在Spring环境下的事务管理/","link":"","permalink":"http://blog.alterem.top/2019/06/13/MyBatis在Spring环境下的事务管理/","excerpt":"MyBatis的设计思想很简单，可以看做是对JDBC的一次封装，并提供强大的动态SQL映射功能。但是由于它本身也有一些缓存、事务管理等功能，所以实际使用中还是会碰到一些问题——另外，最近接触了JFinal，其思想和Hibernate类似，但要更简洁，和MyBatis的设计思想不同，但有一点相同：都是想通过简洁的设计最大限度地简化开发和提升性能——说到性能，前段时间碰到两个问题： 在一个上层方法（DAO方法的上层）内删除一条记录，然后再插入一条相同主键的记录时，会报主键冲突的错误。 某些项目中的DAO方法平均执行时间会是其他一些项目中的 2倍 。 第一个问题是偶尔会出现，在实验环境无论如何也重现不了，经过分析MyBatis的逻辑，估计是两个DAO分别拿到了两个不同的Connection，第二个语句比第一个更早的被提交，导致了主键冲突，有待进一步的分析和验证。对于第二个问题，本文将尝试通过分析源代码和实验找到它的root cause，主要涉及到以下内容： 问题描述与分析 MyBatis在Spring环境下的载入过程 MyBatis在Spring环境下事务的管理 实验验证","text":"MyBatis的设计思想很简单，可以看做是对JDBC的一次封装，并提供强大的动态SQL映射功能。但是由于它本身也有一些缓存、事务管理等功能，所以实际使用中还是会碰到一些问题——另外，最近接触了JFinal，其思想和Hibernate类似，但要更简洁，和MyBatis的设计思想不同，但有一点相同：都是想通过简洁的设计最大限度地简化开发和提升性能——说到性能，前段时间碰到两个问题： 在一个上层方法（DAO方法的上层）内删除一条记录，然后再插入一条相同主键的记录时，会报主键冲突的错误。 某些项目中的DAO方法平均执行时间会是其他一些项目中的 2倍 。 第一个问题是偶尔会出现，在实验环境无论如何也重现不了，经过分析MyBatis的逻辑，估计是两个DAO分别拿到了两个不同的Connection，第二个语句比第一个更早的被提交，导致了主键冲突，有待进一步的分析和验证。对于第二个问题，本文将尝试通过分析源代码和实验找到它的root cause，主要涉及到以下内容： 问题描述与分析 MyBatis在Spring环境下的载入过程 MyBatis在Spring环境下事务的管理 实验验证 项目环境整个系统是微服务架构，这里讨论的「项目」是指一个单独的服务。单个项目的框架基本是Spring+MyBatis，具体版本如下： 1Spring 3.2.9/4.3.5 + Mybatis 3.2.6 + mybatis-spring 1.2.2 + mysql connector 5.1.20 + commons-dbcp 1.4 与MyBatis和事务相关的配置如下： 1234567891011121314151617181920212223242526//代码1&lt;!-- bean#1--&gt; &lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\"&gt; &lt;!-- 一些数据库信息配置--&gt; &lt;!-- 一些DBCP连接池配置 --&gt; //在这里设置是否自动提交 &lt;property name=\"defaultAutoCommit\" value=\"$&#123;dbcp.defaultAutoCommit&#125;\" /&gt; &lt;/bean&gt;&lt;!-- bean#2--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;property name=\"mapperLocations\" value=\"classpath*:path/to/mapper/**/*.xml\" /&gt; &lt;/bean&gt;&lt;!-- bean#3 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt;&lt;!-- bean#4--&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\".path.to.mapper\" /&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/&gt; &lt;/bean&gt; &lt;!-- bean5 --&gt; &lt;tx:annotation-driven transaction-manager=\"transactionManager\" /&gt; 问题描述与分析一倍的时间差挺严重的，平均到每次调用，正常的大约在6到10几 ms，慢的要近20 ms，由于调用次数很多，导致整体性能会有很大的差别。经过仔细比对这几个项目，发现DAO执行慢的项目的数据源配置（bean#1）中defaultAutoCommit的配置都是false。而且将此配置改为 true之后就恢复了正常。 由此推断是在MyBatis在执行「非自动提交」语句时，进行等待，或者多提交了一次，导致实际调用数据库API次数增多。但是这个推断也有个问题，由于整个项目是在Spring环境中运行的，而且也开启了Spring的事务管理，所以还是需要详细的看一下MyBatis到底是如何装配DAO方法与管理事务的，才能彻底解开谜团。 问题重现首先写一个Service，其中调用了同一个mapper类的两个方法分别2次，insertModelList()会在数据库中插入两条记录，delModels()方法会删除这两条记录，代码如下： 12345678910111213141516//代码2//@Transactionalpublic void testIS()&#123; List&lt;Model&gt; models= new ArrayList&lt;&gt;(); //省略一些数据工作。。。 modelMapper.insertModelList(50001l, models); modelMapper.delModels(50001); if (CollectionUtils.isNotEmpty(models)) modelMapper.insertModelList(50001, models); modelMapper.delModels(50001);&#125;public void testOther()&#123; System.out.println(\"加载类：\"); System.out.println(modelMapper.getClass().getClassLoader()); modelMapper.delModels(50001);&#125; 实际项目中使用cat来进行执行时间的统计，这里也仿照cat，使用一个单独的AOP类实现时间的计算： 123456789101112131415161718192021//代码3public class DaoTimeAdvice &#123; private long time = 0; private long num = 0; public Object calcTime(ProceedingJoinPoint joinPoint) throws Throwable &#123; long then = System.nanoTime(); Object object = joinPoint.proceed(); long now = System.nanoTime(); setTime(getTime() + (now-then)); setNum(getNum() + 1); return object; &#125; //省略getter &amp; setter。。。 public void printInfo() &#123; System.out.println(\"总共次数：\" + num); System.out.println(\"总共时间：\" + time); System.out.println(\"平均时间：\" + time / num); &#125;&#125; 测试代码： 1234567891011121314151617//代码4public static void test()&#123; System.out.println(new SimpleDateFormat(\"[yyyy-MM-dd HH:mm:ss]\").format(new Date()) + \" 开始测试!\"); for (int i = 0; i &lt; TEST_NUM; i++) &#123; ItemStrategyServiceTest ist = (ItemStrategyServiceTest) context.getBean(\"isTS\"); ist.testIS(); if (i % 1000 == 0) &#123; System.out.println(\"1000次\"); &#125; &#125; DaoTimeAdvice ad = (DaoTimeAdvice) context.getBean(\"daoTimeAdvice\"); ad.printInfo(); ItemStrategyServiceTest ist = (ItemStrategyServiceTest) context.getBean(\"isTS\"); ist.testOther(); System.exit(1);&#125; 测试结果： defaultAutoCommit 循环次数 共消耗时间(ns) 平均时间(ns) true 40000 17831088316 445777 true 40000 17881589992 447039 false 40000 27280458229 682011 false 40000 27237413893 680935 defaultAutoCommit为false时的执行时间是true的近1.5倍，并没有重现2倍的时间消耗，估计是在cat统计或者其他AOP方法的执行时还有其他消耗，从而扩大了false和true之间的区别。 MyBatis在Spring环境下的载入过程按照第一节中的配置文件，整个MyBatis中DAO的bean的装配应该是这样的： 先使用BasicDataSource装配一个数据源的bean（bean#1），名字叫做dataSource。 这个bean很简单，就是实例化并注册到Spring的上下文中。 使用dataSource来创建sqlSessionFactory（bean#2)，这个bean创建时会扫描MyBatis的语句映射文件并解析。 在MyBatis中，真正的数据库读写操作是通过SqlSession的实例来实现的，而SqlSession要通过SQLSessionFactory来管理。这里的 org.mybatis.spring.SqlSessionFactoryBean实现了FactoryBean类（这个类比较特殊，与主题无关，这里不再赘述），Spring会从这个bean中会获取真正的SQLSessionFactory的实例，源代码中显示，实际返回的对象是DefaultSqlSessionFactory的实例。 使用sqlSessionFactory这个工厂类来创建mapper扫描器（bean#4），并创建含有DAO方法的实例。 为了让上层方法可以通过普通的方法调用来使用DAO方法，需要往Spring上下文里注册相应的bean，而在MyBatis的普通使用场景中是没有mapper的实现类的（具体的SQL语句映射通过注解或者XML文件来实现），只有接口，在MyBatis中这些接口是通过动态代理实现的。这里使用的类是 org.mybatis.spring.mapper.MapperScannerConfigurer，它实现了org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor接口，所以会在Spring中「所有的bean定义全部注册完成，但还没有实例化」之前，调用方法向Spring上下文注册mapper实现类（动态代理的对象）。具体代码如下： 123456789101112131415161718192021222324252627282930 //代码5 @Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123; if (this.processPropertyPlaceHolders) &#123; processPropertyPlaceHolders(); &#125; ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry); //设置一些属性 scanner.scan(StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS)); &#125; /*** Perform a scan within the specified base packages.* @param basePackages the packages to check for annotated classes* @return number of beans registered*/ public int scan(String... basePackages) &#123; int beanCountAtScanStart = this.registry.getBeanDefinitionCount(); doScan(basePackages); // Register annotation config processors, if necessary. if (this.includeAnnotationConfig) &#123; AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry); &#125; return (this.registry.getBeanDefinitionCount() - beanCountAtScanStart); &#125; 在源代码里可以看到，真正的mapper实现类是org.mybatis.spring.mapper.MapperFactoryBean&lt;Object&gt;，具体的逻辑在方法org.mybatis.spring.mapper.ClassPathMapperScanner.processBeanDefinitions(Set&lt;BeanDefinitionHolder&gt;)里。最后，每一个方法的执行，最终落入了 org.mybatis.spring.SqlSessionTemplate的某个方法中，并被如下这个拦截器拦截： 1234567891011121314151617181920212223242526272829303132//代码6 /** * Proxy needed to route MyBatis method calls to the proper SqlSession got * from Spring's Transaction Manager * It also unwraps exceptions thrown by &#123;@code Method#invoke(Object, Object...)&#125; to * pass a &#123;@code PersistenceException&#125; to the &#123;@code PersistenceExceptionTranslator&#125;. */private class SqlSessionInterceptor implements InvocationHandler &#123;@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; SqlSession sqlSession = getSqlSession( SqlSessionTemplate.this.sqlSessionFactory, SqlSessionTemplate.this.executorType, SqlSessionTemplate.this.exceptionTranslator); try &#123; Object result = method.invoke(sqlSession, args); if (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.this.sqlSessionFactory)) &#123; // force commit even on non-dirty sessions because some databases require // a commit/rollback before calling close() sqlSession.commit(true); &#125; return result; &#125; catch (Throwable t) &#123; //省略一些错误处理 throw unwrapped; &#125; finally &#123; if (sqlSession != null) &#123; closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory); &#125; &#125;&#125;&#125; MyBatis在Spring环境下事务的管理 从源代码中知道真正的SqlSessionFactory使用的是org.apache.ibatis.session.defaults.DefaultSqlSessionFactory的实例，同时，事务管理使用 org.mybatis.spring.transaction.SpringManagedTransactionFactory。但是在代码1的配置中，还添加了Spring事务管理的配置，就是在某个Service方法（或某个其他可被扫描到的方法）上加上@Transactional注解，那么Spring的事务管理会自动创建事务，那么它和MyBatis的事务之间是怎么协作的呢？ 可以看到在代码6中的方法isSqlSessionTransactional()，它会返回上层代码中是否有Spring的事务，如果有，将不会执行下边的commit()。在我的项目中的实际情况是没有Spring事务，所以肯定是走到了下面的commit()，这个方法最终落到了SpringManagedTransactionFactory中的commit()，看代码： 123456789101112131415//代码7private void openConnection() throws SQLException &#123; this.connection = DataSourceUtils.getConnection(this.dataSource); this.autoCommit = this.connection.getAutoCommit(); this.isConnectionTransactional = DataSourceUtils.isConnectionTransactional(this.connection, this.dataSource); &#125;public void commit() throws SQLException &#123; if (this.connection != null &amp;&amp; !this.isConnectionTransactional &amp;&amp; !this.autoCommit) &#123; if (LOGGER.isDebugEnabled()) &#123; LOGGER.debug(\"Committing JDBC Connection [\" + this.connection + \"]\"); &#125; this.connection.commit(); &#125;&#125; 可以看到，此处是否要执行commit()操作是由3个变量决定的，如果DataSource的 autoCommit是 false，则其结果一定为 true，控制台也会看到一行日志：Committing JDBC Connection [xxxxxx]，刚好与项目中遇到的情况相同。这个提交动作是需要和数据库交互的，比较耗时。 实验验证由上一节分析得出，造成DAO方法执行时间变长的原因是会多执行一次提交，那么如果上层方法被Spring事务管理器托管（或者数据源的 defaultAutoCommit为 true，这个条件已经在刚开始的问题重现被验证），则不会执行MyBatis的提交动作，DAO方法应该相应的执行时间会变短。于是将Service方法加上 @transactional注解，分别测试 true和 false的情况。结果： defaultCommit 循环次数 共消耗时间 平均时间 true 40000 7017113852 175427 false 40000 7283591630 182089 可以看到执行的时间已经基本接近，由此基本可以确定是这个原因造成的。这里仍然有几个疑点，尤其是问题重现时没有出现2倍的时间消耗，如果你有别的想法，也欢迎提出来讨论。","categories":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://blog.alterem.top/categories/MyBatis/"},{"name":"Spring","slug":"MyBatis/Spring","permalink":"http://blog.alterem.top/categories/MyBatis/Spring/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://blog.alterem.top/tags/MyBatis/"},{"name":"Spring","slug":"Spring","permalink":"http://blog.alterem.top/tags/Spring/"}]},{"title":"CAS4.0分布式部署以及使用Redis缓存共享ticket","slug":"CAS4-0分布式部署以及使用Redis缓存共享ticket","date":"2019-06-12T14:14:30.000Z","updated":"2019-07-04T11:57:39.759Z","comments":true,"path":"2019/06/12/CAS4-0分布式部署以及使用Redis缓存共享ticket/","link":"","permalink":"http://blog.alterem.top/2019/06/12/CAS4-0分布式部署以及使用Redis缓存共享ticket/","excerpt":"CAS4.0分布式部署以及使用Redis缓存共享ticket 当业务不断拓展，系统用户在不断增加时，我们的平台统一登录认证服务无法承受当前压力。此时，我们需要分布式部署我们的统一登录认证服务。 CAS的分布式部署，除了注意session共享，通过nginx或者apache反向代理外，还需要注意票据ticket的存储共享。 在ticketRegistry.xml文件中，配置ticket相关的信息。","text":"CAS4.0分布式部署以及使用Redis缓存共享ticket 当业务不断拓展，系统用户在不断增加时，我们的平台统一登录认证服务无法承受当前压力。此时，我们需要分布式部署我们的统一登录认证服务。 CAS的分布式部署，除了注意session共享，通过nginx或者apache反向代理外，还需要注意票据ticket的存储共享。 在ticketRegistry.xml文件中，配置ticket相关的信息。 主要配置：1.注册ticket存储，2.定时清除过期ticket。 由于我们使用的Redis缓存Key设置了过期时间，因此可以注释掉清除过期ticket的定时器及相关类。 编写新的ticket存储类需要继承类AbstractDistributedTicketRegistry。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209package cas.ticket; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Collection; import org.jasig.cas.ticket.Ticket; import org.jasig.cas.ticket.TicketGrantingTicket; import org.jasig.cas.ticket.registry.AbstractDistributedTicketRegistry; import cn.net.xinyi.util.SysPropertiesUtil; import redis.clients.jedis.Jedis; import redis.clients.jedis.JedisPool; import redis.clients.jedis.JedisPoolConfig; /** * 使用Redis存储Ticket * @author XIVA */ public class RedisTicketRegistry extends AbstractDistributedTicketRegistry &#123; private static int redisDatabaseNum; private static String hosts; private static int port; private static int connTimeout; private static String redisPassword; /** * ST最大空闲时间 */ private static int st_time; /** * TGT最大空闲时间 */ private static int tgt_time; private static JedisPool cachePool; static &#123; redisDatabaseNum = SysPropertiesUtil.getPropertyInt(\"redis_database_num\"); hosts = SysPropertiesUtil.getProperty(\"redis_hosts\"); port = SysPropertiesUtil.getPropertyInt(\"redis_port\"); connTimeout = SysPropertiesUtil.getPropertyInt(\"redis_conn_timeout\"); redisPassword = SysPropertiesUtil.getProperty(\"redis_password\"); st_time = SysPropertiesUtil.getPropertyInt(\"st_time\"); tgt_time = SysPropertiesUtil.getPropertyInt(\"tgt_time\"); cachePool = new JedisPool(new JedisPoolConfig(), hosts, port, connTimeout, redisPassword); &#125; @Override public void addTicket(Ticket ticket) &#123; Jedis jedis = cachePool.getResource(); jedis.select(redisDatabaseNum); int seconds = 0; String key = ticket.getId(); if (ticket instanceof TicketGrantingTicket) &#123; seconds = tgt_time / 1000; &#125; else &#123; seconds = st_time / 1000; &#125; ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = null; try &#123; oos = new ObjectOutputStream(bos); oos.writeObject(ticket); &#125; catch (Exception e) &#123; logger.error(\"adding ticket to redis error.\"); &#125; finally &#123; try &#123; if (null != oos) oos.close(); &#125; catch (Exception e) &#123; logger.error(\"oos closing error when adding ticket to redis.\"); &#125; &#125; jedis.set(key.getBytes(), bos.toByteArray()); jedis.expire(key.getBytes(), seconds); jedis.close(); &#125; @Override public boolean deleteTicket(String ticketId) &#123; if (ticketId == null) &#123; return false; &#125; Jedis jedis = cachePool.getResource(); jedis.select(redisDatabaseNum); jedis.del(ticketId.getBytes()); jedis.close(); return true; &#125; @Override public Ticket getTicket(String ticketId) &#123; return getProxiedTicketInstance(getRawTicket(ticketId)); &#125; private Ticket getRawTicket(final String ticketId) &#123; if (null == ticketId) &#123; return null; &#125; Jedis jedis = cachePool.getResource(); jedis.select(redisDatabaseNum); Ticket ticket = null; byte[] bytes = jedis.get(ticketId.getBytes()); if (bytes == null || bytes.length &lt; 1) &#123; return null; &#125; ByteArrayInputStream bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = null; try &#123; ois = new ObjectInputStream(bais); ticket = (Ticket) ois.readObject(); &#125; catch (Exception e) &#123; e.printStackTrace(); logger.error(\"getting ticket to redis error.\"); &#125; finally &#123; try &#123; if (null != ois) &#123; ois.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); logger.error(\"ois closing error when getting ticket to redis.\"); &#125; &#125; jedis.close(); return ticket; &#125; @Override public Collection&lt;Ticket&gt; getTickets() &#123; throw new UnsupportedOperationException(\"GetTickets not supported.\"); &#125; @Override protected boolean needsCallback() &#123; return false; &#125; @Override protected void updateTicket(Ticket ticket) &#123; this.addTicket(ticket); &#125; &#125; 变更后的ticketRegistry.xml代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!-- Licensed to Jasig under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. Jasig licenses this file to you under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at the following location: http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. --&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;description&gt; Configuration for the default TicketRegistry which stores the tickets in-memory and cleans them out as specified intervals. &lt;/description&gt; &lt;!-- Ticket Registry &lt;bean id=\"ticketRegistry\" class=\"org.jasig.cas.ticket.registry.DefaultTicketRegistry\" /&gt; --&gt; &lt;!-- ticket store on redis db --&gt; &lt;bean id=\"ticketRegistry\" class=\"cas.ticket.RedisTicketRegistry\" /&gt; &lt;!--Quartz --&gt; &lt;!-- TICKET REGISTRY CLEANER &lt;bean id=\"ticketRegistryCleaner\" class=\"org.jasig.cas.ticket.registry.support.DefaultTicketRegistryCleaner\" p:ticketRegistry-ref=\"ticketRegistry\" p:logoutManager-ref=\"logoutManager\" /&gt; &lt;bean id=\"jobDetailTicketRegistryCleaner\" class=\"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean\" p:targetObject-ref=\"ticketRegistryCleaner\" p:targetMethod=\"clean\" /&gt; &lt;bean id=\"triggerJobDetailTicketRegistryCleaner\" class=\"org.springframework.scheduling.quartz.SimpleTriggerBean\" p:jobDetail-ref=\"jobDetailTicketRegistryCleaner\" p:startDelay=\"20000\" p:repeatInterval=\"5000000\" /&gt; --&gt; &lt;/beans&gt;","categories":[{"name":"Cas","slug":"Cas","permalink":"http://blog.alterem.top/categories/Cas/"},{"name":"Redis","slug":"Cas/Redis","permalink":"http://blog.alterem.top/categories/Cas/Redis/"},{"name":"Ticket","slug":"Cas/Redis/Ticket","permalink":"http://blog.alterem.top/categories/Cas/Redis/Ticket/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://blog.alterem.top/tags/Redis/"},{"name":"Cas","slug":"Cas","permalink":"http://blog.alterem.top/tags/Cas/"},{"name":"Ticket","slug":"Ticket","permalink":"http://blog.alterem.top/tags/Ticket/"}]},{"title":"Spring极速集成注解Redis实践","slug":"Spring极速集成注解Redis实践","date":"2019-06-12T14:09:37.000Z","updated":"2019-06-12T14:17:54.730Z","comments":true,"path":"2019/06/12/Spring极速集成注解Redis实践/","link":"","permalink":"http://blog.alterem.top/2019/06/12/Spring极速集成注解Redis实践/","excerpt":"Redis 做为基于内存的 Key-Value 数据库，用来做缓存服务器性价比相当高。 官方推出的面向 Java 的 Client Jedis，提供了很多接口和方法，可以让 Java 操作使用 Redis。 Spring 团队对 Jedis 进行了封装，独立为 spring-data-redis 项目，配合 spring 特性并集成 Jedis 的一些命令和方法。 本文重点描述集成过程，能让你迅速的通过 spring-data-redis 将 redis 集成到 spring 项目中,毕竟大家都忙的。","text":"Redis 做为基于内存的 Key-Value 数据库，用来做缓存服务器性价比相当高。 官方推出的面向 Java 的 Client Jedis，提供了很多接口和方法，可以让 Java 操作使用 Redis。 Spring 团队对 Jedis 进行了封装，独立为 spring-data-redis 项目，配合 spring 特性并集成 Jedis 的一些命令和方法。 本文重点描述集成过程，能让你迅速的通过 spring-data-redis 将 redis 集成到 spring 项目中,毕竟大家都忙的。 1. 添加项目依赖1234567891011&lt;!--redis 缓存--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.8.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; 2. 添加 spring-redis-context 配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;description&gt;redis 相关类 Spring 托管&lt;/description&gt; &lt;!--载入 redis 配置文件--&gt; &lt;context:property-placeholder location=\"classpath:redis.properties\" ignore-unresolvable=\"true\"/&gt; &lt;!-- 配置 JedisPoolConfig 实例 --&gt; &lt;bean id=\"poolConfig\" class=\"redis.clients.jedis.JedisPoolConfig\"&gt; &lt;property name=\"maxIdle\" value=\"$&#123;redis.maxIdle&#125;\"/&gt; &lt;property name=\"maxTotal\" value=\"$&#123;redis.maxActive&#125;\"/&gt; &lt;property name=\"maxWaitMillis\" value=\"$&#123;redis.maxWait&#125;\"/&gt; &lt;property name=\"testOnBorrow\" value=\"$&#123;redis.testOnBorrow&#125;\"/&gt; &lt;/bean&gt; &lt;!-- 配置JedisConnectionFactory --&gt; &lt;bean id=\"jedisConnectionFactory\" class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\"&gt; &lt;property name=\"hostName\" value=\"$&#123;redis.host&#125;\"/&gt; &lt;property name=\"port\" value=\"$&#123;redis.port&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;redis.pass&#125;\"/&gt; &lt;property name=\"database\" value=\"$&#123;redis.dbIndex&#125;\"/&gt; &lt;property name=\"poolConfig\" ref=\"poolConfig\"/&gt; &lt;/bean&gt; &lt;!-- 配置RedisTemplate --&gt; &lt;bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.RedisTemplate\"&gt; &lt;property name=\"connectionFactory\" ref=\"jedisConnectionFactory\"/&gt; &lt;/bean&gt; &lt;!-- 配置RedisCacheManager --&gt; &lt;bean id=\"redisCacheManager\" class=\"org.springframework.data.redis.cache.RedisCacheManager\"&gt; &lt;constructor-arg name=\"redisOperations\" ref=\"redisTemplate\"/&gt; &lt;property name=\"defaultExpiration\" value=\"$&#123;redis.expiration&#125;\"/&gt; &lt;/bean&gt; &lt;!-- 配置RedisCacheConfig --&gt; &lt;bean id=\"redisCacheConfig\" class=\"com.rambo.sdh.common.util.RedisCacheConfig\"&gt; &lt;constructor-arg ref=\"jedisConnectionFactory\"/&gt; &lt;constructor-arg ref=\"redisTemplate\"/&gt; &lt;constructor-arg ref=\"redisCacheManager\"/&gt; &lt;/bean&gt;&lt;/beans&gt; JedisConnectionFactory 为 Jedis 连接工厂，配置由单独抽象的 JedisPoolConfig 提供。 如果你熟悉 Spring 的 JdbcTemplate 对象的话，这里大概能猜出来 RedisTemplate 的作用，RedisTemplate 对 RedisConnection 进行了封装。 提供连接管理，序列化等功能，它对 Redis 的交互进行了更高层次的抽象，极大的方便和简化了 Redis 的操作。 RedisCacheManager 做为 redis 统一的调度和管理者，有兴趣可以反编译源码看看。 继承自 org.springframework.cache.transaction.AbstractTransactionSupportingCacheManager 并实现 org.springframework.cache.CacheManager。 3. 添加 redis.properties1234567891011121314151617181920212223242526272829#============================##==== Redis settings ====##============================##redis 服务器 IPredis.host=127.0.0.1#redis 服务器端口redis.port=6379#redis 密码redis.pass=redis#2017#redis 支持16个数据库（相当于不同用户）可以使不同的应用程序数据彼此分开同时又存储在相同的实例上redis.dbIndex=0#redis 缓存数据过期时间单位秒redis.expiration=3000#控制一个 pool 最多有多少个状态为 idle 的jedis实例redis.maxIdle=300#控制一个 pool 可分配多少个jedis实例redis.maxActive=600#当borrow一个jedis实例时，最大的等待时间，如果超过等待时间，则直接抛出JedisConnectionException；redis.maxWait=1000#在borrow一个jedis实例时，是否提前进行alidate操作；如果为true，则得到的jedis实例均是可用的；redis.testOnBorrow=true 当然配置文件你也可以硬编码到程序中，只是在参数发生改变的时候比较痛苦一点而已。 其中大部分配置项都是围绕着 jedisPool ，如果你对数据库连接池比较熟，你会发现它俩的配置项有点相似。 当系统 redis 遇到问题出现故障时，理解这里的选项是个不错的选择。 更多配置项详解: http://www.2cto.com/database/201311/254449.html 4. 编写自定义 redis 配置类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Configuration@EnableCachingpublic class RedisCacheConfig extends CachingConfigurerSupport &#123; protected final static Logger log = LoggerFactory.getLogger(RedisCacheConfig.class); private volatile JedisConnectionFactory mJedisConnectionFactory; private volatile RedisTemplate&lt;String, String&gt; mRedisTemplate; private volatile RedisCacheManager mRedisCacheManager; public RedisCacheConfig() &#123; super(); &#125; public RedisCacheConfig(JedisConnectionFactory mJedisConnectionFactory, RedisTemplate&lt;String, String&gt; mRedisTemplate, RedisCacheManager mRedisCacheManager) &#123; super(); this.mJedisConnectionFactory = mJedisConnectionFactory; this.mRedisTemplate = mRedisTemplate; this.mRedisCacheManager = mRedisCacheManager; &#125; public JedisConnectionFactory redisConnectionFactory() &#123; return mJedisConnectionFactory; &#125; public RedisTemplate&lt;String, String&gt; redisTemplate(RedisConnectionFactory cf) &#123; return mRedisTemplate; &#125; public CacheManager cacheManager(RedisTemplate&lt;?, ?&gt; redisTemplate) &#123; return mRedisCacheManager; &#125; @Bean public KeyGenerator keyGenerator() &#123; return new KeyGenerator() &#123; @Override public Object generate(Object o, Method method, Object... objects) &#123; StringBuilder sb = new StringBuilder(); sb.append(o.getClass().getName()); sb.append(method.getName()); for (Object obj : objects) &#123; sb.append(obj.toString()); &#125; return sb.toString(); &#125; &#125;; &#125;&#125; 该配置类继承自 org.springframework.cache.annotation.CachingConfigurerSupport 并实现 org.springframework.cache.annotation.CachingConfigurer 的方法。 通俗一点，该类告诉 spring 当前使用的缓存服务为 redis 并自定义了缓存 key 生成的规则。 5. 在你喜欢的地方进行注解缓存 spring缓存一般使用在服务层，在你想缓存的方法上面添加相应的注解即可，下面三个缓存的注解你得掌握。 @Cacheable spring 会在其被调用后将返回值缓存起来，以保证下次利用同样的参数来执行该方法时可以直接从缓存中获取结果，而不需要再次执行该方法。 @CachePut 标注的方法在执行前不会去检查缓存中是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入指定的缓存中。 @CacheEvict 用来标注在需要清除缓存元素的方法或类上的。 当然这些注解里面还有很多其他的属性配置，配合 spring-el 表达式能做的事情还有很多，大概只有你想不到，没有做不到。 在业务规则比较复杂的情况下，缓存 key 的设计相当重要，设计出色可以使你的应用飞起来。 整个集成工作就结束了，是不是很简单，上述算是 redis 的冰山一角，还有很多像 redis 路由/分布式/集群….，有机会实践慢慢体会。","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.alterem.top/categories/Java/"},{"name":"Spring","slug":"Java/Spring","permalink":"http://blog.alterem.top/categories/Java/Spring/"},{"name":"Redis","slug":"Java/Spring/Redis","permalink":"http://blog.alterem.top/categories/Java/Spring/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://blog.alterem.top/tags/Redis/"},{"name":"Java","slug":"Java","permalink":"http://blog.alterem.top/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://blog.alterem.top/tags/Spring/"}]},{"title":"运算符优先级","slug":"运算符优先级","date":"2019-06-12T10:43:48.000Z","updated":"2019-06-18T05:01:12.878Z","comments":true,"path":"2019/06/12/运算符优先级/","link":"","permalink":"http://blog.alterem.top/2019/06/12/运算符优先级/","excerpt":"","text":"Java 运算符优先级 运算符 优先级 postfix expr++ expr– unary ++expr –expr +expr -expr ~ ! multiplicative * / % additive + - shift &lt;&lt; &gt;&gt; &gt;&gt;&gt; relational &lt; &gt; &lt;= &gt;= instanceof equality == != bitwise AND &amp; bitwise exclusive OR ^ bitwise inclusive OR &#124; logical AND &amp;&amp; logical OR &#124;&#124; ternary ? : assignment = += -= *= /= %= &amp;= ^= C++运算符优先级 Precedence Operator Description Associativity 1 :: Scope resolution Left-to-right 2 ++ – Suffix/postfix increment and decrement () Function call [] Array subscripting . Element selection by reference −&gt; Element selection through pointer 3 ++ – Prefix increment and decrement Right-to-left + − Unary plus and minus ! ~ Logical NOT and bitwise NOT (type) Type cast * Indirection (dereference) &amp; Address-of sizeof Size-of new, new[] Dynamic memory allocation delete, delete[] Dynamic memory deallocation 4 . -&gt; Pointer to member Left-to-right 5 * / % Multiplication, division, and remainder 6 + − Addition and subtraction 7 &lt;&lt; &gt;&gt; Bitwise left shift and right shift 8 &lt; &lt;= For relational operators &lt; and ≤ respectively &gt; &gt;= For relational operators &gt; and ≥ respectively 9 == != For relational = and ≠ respectively 10 &amp; Bitwise AND 11 ^ Bitwise XOR (exclusive or) 12 &#124; Bitwise OR (inclusive or) 13 &amp;&amp; Logical AND 14 &#124;&#124; Logical OR 15 ?: Ternary conditional Right-to-Left 16 = Direct assignment (provided by default for C++ classes) += −= Assignment by sum and difference *= /= %= Assignment by product, quotient, and remainder &lt;&lt;= &gt;&gt;= Assignment by bitwise left shift and right shift &amp;= ^= &#124;= Assignment by bitwise AND, XOR, and OR 17 throw Throw operator (for exceptions) 18 , Comma Left-to-right C语言运算符优先级 Precedence Operator Description Associativity 1 ++ – Suffix/postfix increment and decrement Left-to-right () Function call [] Array subscripting . Structure and union member access −&gt; Structure and union member access through pointer (type){list} Compound literal(C99) 2 ++ – Prefix increment and decrement Right-to-left + − Unary plus and minus ! ~ Logical NOT and bitwise NOT (type) Type cast * Indirection (dereference) &amp; Address-of sizeof Size-of _Alignof Alignment requirement(C11) 3 * / % Multiplication, division, and remainder Left-to-right 4 + − Addition and subtraction 5 &lt;&lt; &gt;&gt; Bitwise left shift and right shift 6 &lt; &lt;= For relational operators &lt; and ≤ respectively &gt; &gt;= For relational operators &gt; and ≥ respectively 7 == != For relational = and ≠ respectively 8 &amp; Bitwise AND 9 ^ Bitwise XOR (exclusive or) 10 &#124; Bitwise OR (inclusive or) 11 &amp;&amp; Logical AND 12 &#124;&#124; Logical OR 13 ?: Ternary conditional Right-to-Left 14 = Simple assignment += −= Assignment by sum and difference *= /= %= Assignment by product, quotient, and remainder &lt;&lt;= &gt;&gt;= Assignment by bitwise left shift and right shift &amp;= ^= = Assignment by bitwise AND, XOR, and OR 15 , Comma Left-to-right PHP运算符优先级 结合方向 运算符 附加信息 非结合 clone new clone 和 new 左 [ array() 非结合 ++ – 递增／递减运算符 非结合 ~ - (int) (float) (string) (array) (object) (bool) @ 类型 非结合 instanceof 类型 右结合 ! 逻辑操作符 左 * / % 算术运算符 左 + - . 算术运算符 和 字符串运算符 左 &lt;&lt; &gt;&gt; 位运算符 非结合 &lt; &lt;= &gt; &gt;= &lt;&gt; 比较运算符 非结合 == != === !== 比较运算符 左 &amp; 位运算符 和 引用 左 ^ 位运算符 左 &#124; 位运算符 左 &amp;&amp; 逻辑运算符 左 &#124;&#124; 逻辑运算符 左 ? : 三元运算符 右 = += -= *= /= .= %= &amp;= &#124;= ^= &lt;&lt;= &gt;&gt;= 赋值运算符 左 and 逻辑运算符 左 xor 逻辑运算符 左 or 逻辑运算符 左 , 多处用到 Python 运算符优先级| 运算符 | 描述 | 序号 || :——————- | :————— | —- || lambda | Lambda表达式 | 1 || or | 布尔“或” | 2 || and | 布尔“与” | 3 || not x | 布尔“非” | 4 || in，not in | 成员测试 | 5 || is，is not | 同一性测试 | 6 || &lt;，&lt;=，&gt;，&gt;=，!=，== | 比较 | 7 || &#124; | 按位或 | 8 || ^ | 按位异或 | 9 || &amp; | 按位与 | 10 || &lt;&lt;，&gt;&gt; | 移位 | 11 || +，- | 加法与减法 | 12 || *，/，% | 乘法、除法与取余 | 13 || +x，-x | 正负号 | 14 || ~x | 按位翻转 | 15 || ** | 指数 | 16 || x.attribute | 属性参考 | 17 || x[index] | 下标 | 18 || x[index:index] | 寻址段 | 19 || f(arguments…) | 函数调用 | 20 || (experession,…) | 绑定或元组显示 | 21 || [expression,…] | 列表显示 | 22 || {key:datum,…} | 字典显示 | 23 || ‘expression,…’ | 字符串转换 | 24 |","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.alterem.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.alterem.top/tags/Java/"}]},{"title":"EurekaClient注册到EurekaServer的秘密","slug":"EurekaClient注册到EurekaServer的秘密","date":"2019-06-12T10:10:20.000Z","updated":"2019-06-12T10:14:31.077Z","comments":true,"path":"2019/06/12/EurekaClient注册到EurekaServer的秘密/","link":"","permalink":"http://blog.alterem.top/2019/06/12/EurekaClient注册到EurekaServer的秘密/","excerpt":"前言我们知道Eureka分为两部分，Eureka Server和Eureka Client。Eureka Server充当注册中心的角色，Eureka Client相对于Eureka Server来说是客户端，需要将自身信息注册到注册中心。本文主要介绍的就是在Eureka Client注册到Eureka Server时 RetryableClientQuarantineRefreshPercentage参数的使用技巧。","text":"前言我们知道Eureka分为两部分，Eureka Server和Eureka Client。Eureka Server充当注册中心的角色，Eureka Client相对于Eureka Server来说是客户端，需要将自身信息注册到注册中心。本文主要介绍的就是在Eureka Client注册到Eureka Server时 RetryableClientQuarantineRefreshPercentage参数的使用技巧。 Eureka Client注册过程分析Eureka Client注册到Eureka Server时，首先遇到第一个问题就是Eureka Client端要知道Server的地址，这个参数对应的是 eureka.client.service-url.defaultZone举个例子，在Eureka Client的properties文件中配置如下： 12eureka.client.service-url.defaultZone=http://localhost:8761/eureka,http://localhost:8762/eureka,http://localhost:8763/eureka,http://localhost:8764/eureka 如上图所示，Eureka Client配置对应的Eureka Server地址分别是8761、8762、8763、8764。这里存在两个问题： Eureka Client会将自身信息分别注册到这四个地址吗？ Eureka Clinent注册机制是怎样的？ 源码面前一目了然，带着这两个问题我们通过源码来解答这两个问题。Eureka Client在启动的时候注册源码如下：RetryableEurekaHttpClient中的execut方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Overrideprotected &lt;R&gt; EurekaHttpResponse&lt;R&gt; execute(RequestExecutor&lt;R&gt; requestExecutor) &#123; List&lt;EurekaEndpoint&gt; candidateHosts = null; int endpointIdx = 0; for (int retry = 0; retry &lt; numberOfRetries; retry++) &#123; EurekaHttpClient currentHttpClient = delegate.get(); EurekaEndpoint currentEndpoint = null; if (currentHttpClient == null) &#123; if (candidateHosts == null) &#123; candidateHosts = getHostCandidates(); if (candidateHosts.isEmpty()) &#123; throw new TransportException(\"There is no known eureka server; cluster server list is empty\"); &#125; &#125; if (endpointIdx &gt;= candidateHosts.size()) &#123; throw new TransportException(\"Cannot execute request on any known server\"); &#125; currentEndpoint = candidateHosts.get(endpointIdx++); currentHttpClient = clientFactory.newClient(currentEndpoint); &#125; try &#123; EurekaHttpResponse&lt;R&gt; response = requestExecutor.execute(currentHttpClient); if (serverStatusEvaluator.accept(response.getStatusCode(), requestExecutor.getRequestType())) &#123; delegate.set(currentHttpClient); if (retry &gt; 0) &#123; logger.info(\"Request execution succeeded on retry #&#123;&#125;\", retry); &#125; return response; &#125; logger.warn(\"Request execution failure with status code &#123;&#125;; retrying on another server if available\", response.getStatusCode()); &#125; catch (Exception e) &#123; logger.warn(\"Request execution failed with message: &#123;&#125;\", e.getMessage()); // just log message as the underlying client should log the stacktrace &#125; // Connection error or 5xx from the server that must be retried on another server delegate.compareAndSet(currentHttpClient, null); if (currentEndpoint != null) &#123; quarantineSet.add(currentEndpoint); &#125; &#125; throw new TransportException(\"Retry limit reached; giving up on completing the request\");&#125; 按照我的理解，代码精简后内容如下： 12345678910111213141516171819202122232425262728293031323334int endpointIdx = 0;//用来保存所有Eureka Server信息(8761、8762、8763、8764)List&lt;EurekaEndpoint&gt; candidateHosts = null;//numberOfRetries的值代码写死默认为3次for (int retry = 0; retry &lt; numberOfRetries; retry++) &#123; /** *首次进入循环时，获取全量的Eureka Server信息(8761、8762、8763、8764) */ if (candidateHosts == null) &#123; candidateHosts = getHostCandidates(); &#125; /** *通过endpointIdx自增，依次获取Eureka Server信息，然后发送 *注册的Post请求. */ currentEndpoint = candidateHosts.get(endpointIdx++); currentHttpClient = clientFactory.newClient(currentEndpoint); try &#123; /** *发送注册的Post请求动作，注意如果成功，则跳出循环，如果失败则 *根据endpointIdx依次获取下一个Eureka Server. */ response = requestExecutor.execute(currentHttpClient); return respones; &#125; catch (Exception e) &#123; //向注册中心(Eureka Server)发起注册的post出现异常时，打印日志... &#125; //如果此次注册动作失败，将当前的信息保存到quarantineSet中(一个Set集合) if (currentEndpoint != null) &#123; quarantineSet.add(currentEndpoint); &#125;&#125;//如果都失败,则以异常形式抛出...throw new TransportException(\"Retry limit reached; giving up on completing the request\"); 上面代码中还有一个方法很重要就是 List&lt;EurekaEndpoint&gt; candidateHosts = getHostCandidates();接下来看下 getHostCandidates()方法源码 12345678910111213141516171819202122private List&lt;EurekaEndpoint&gt; getHostCandidates() &#123; List&lt;EurekaEndpoint&gt; candidateHosts = clusterResolver.getClusterEndpoints(); quarantineSet.retainAll(candidateHosts); // If enough hosts are bad, we have no choice but start over again int threshold = (int) (candidateHosts.size() * transportConfig.getRetryableClientQuarantineRefreshPercentage()); if (quarantineSet.isEmpty()) &#123; // no-op &#125; else if (quarantineSet.size() &gt;= threshold) &#123; logger.debug(\"Clearing quarantined list of size &#123;&#125;\", quarantineSet.size()); quarantineSet.clear(); &#125; else &#123; List&lt;EurekaEndpoint&gt; remainingHosts = new ArrayList&lt;&gt;(candidateHosts.size()); for (EurekaEndpoint endpoint : candidateHosts) &#123; if (!quarantineSet.contains(endpoint)) &#123; remainingHosts.add(endpoint); &#125; &#125; candidateHosts = remainingHosts; &#125; return candidateHosts;&#125; 按照我的理解，将代码精简下，只包括关键逻辑，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051private List&lt;EurekaEndpoint&gt; getHostCandidates() &#123; /** * 获取所有defaultZone配置的注册中心信息(Eureka Server)， * 在本文例子中代表4个(8761、8762、8763、8764)Eureka Server */ List candidateHosts = clusterResolver.getClusterEndpoints(); /** * quarantineSet这个Set集合中保存的是不可用的Eureka Server * 此处是拿不可用的Eureka Server与全量的Eureka Server取交集 */ quarantineSet.retainAll(candidateHosts); /** * 根据RetryableClientQuarantineRefreshPercentage参数计算阈值 * 该阈值后续会和quarantineSet中保存的不可用的Eureka Server个数 * 作比较，从而判断是否返回全量的Eureka Server还是过滤掉不可用的 * Eureka Server。 */ int threshold = (int) ( candidateHosts.size() * transportConfig.getRetryableClientQuarantineRefreshPercentage() ); if (quarantineSet.isEmpty()) &#123; /** * 首次进入的时候，此时quarantineSet为空，直接返回全量的 * Eureka Server列表 */ &#125; else if (quarantineSet.size() &gt;= threshold) &#123; /** * 将不可用的Eureka Server与threshold值相比较，如果不可 * 用的Eureka Server个数大于阈值，则将之间保存的Eureka * Server内容直接清空，并返回全量的Eureka Server列表。 */ quarantineSet.clear(); &#125; else &#123; /** * 通过quarantineSet集合保存不可用的Eureka Server来过滤 * 全量的EurekaServer，从而获取此次Eureka Client要注册要 * 注册的Eureka Server实例地址。 */ List&lt;EurekaEndpoint&gt; remainingHosts = new ArrayList&lt;&gt;(candidateHosts.size()); for (EurekaEndpoint endpoint : candidateHosts) &#123; if (!quarantineSet.contains(endpoint)) &#123; remainingHosts.add(endpoint); &#125; &#125; candidateHosts = remainingHosts; &#125; return candidateHosts;&#125; 通过源码分析，我们现在初步知道，当Eureka Client向Eureka Server发起注册请求的时候(根据defaultZone寻找Eureka Server列表)，如果有一次请求注册成功，那么后续就不会在向其他Eureka Server发起注册请求。以本文为例，注册中心有四个(8761、8762、8763、8764)。如果8761对应的Eureka Server服务的状态是UP，那么Eureka Client向该注册中心注册成功后，不会再向(8762、8763、8764)对应的Eureka Server发起注册请求(对应程序是在for循环中直接return respones)。 说到这里又引出来另外一个问题，如果8761这个Eureka Server是down掉的呢？ 根据源码我们可知Eureka Client首次会向8761这个Server发起注册请求，如果该Server的状态是down，那么它会将该Server保存到quarantineSet这个Set集合中，然后再次访问8762这个Eureka Server，如果8762这个Server的状态依旧是down，它也会把这个Server保存到quarantineSet这个Set集合中，然后继续访问8763这个Server，如果8763这个Server的状态依旧是down，此时除了会将其保存到quarantineSet这个Set集合中之外，还会跳出本次循环。从而结束此次注册过程。 说道这里有人要问接下来会不会向8764这个Server发起注册，答案是否定的，因为循环的次数默认是3次。所以即使8764这个Server的状态是UP，它也不会接收到来自Eureka Client发起的注册信息。 Eureka Client向Eureka Server发起注册信息的过程除了在Eureka Client启动的时候触发，还有另外一种方式，就是后台定时任务。假设我们上面描述的场景是在Eureka Client启动的时候，因为在启动的时候注册这个过程全部失败了，当后台定时任务执行时，还会进入该注册流程。注意此时quarantineSet的值为3(8761、8762、8763之前注册失败的Eureka Server)。所以当程序再次进入 getHostCandidates()方法时， if (quarantineSet.isEmpty())这个方法是不满足的，接下来会走 else if (quarantineSet.size() &gt;= threshold)这个判断，如果这个判断成立，那么会将quarantineSet集合清空，同时返回全量的Eureka Server列表，如果这个判断不成立，会拿quarantineSet集合中保存的内容去过滤Eureka Server的全量列表。以本文为例： quarantineSet中保存的是(8761、8762、8763)三个Eureka Server Eureka Server全量列表的内容是(8761、8762、8763、8764)四个Eureka Server，过滤后返回的结果为8764这个Eureka Server。 在本文的例子中8761、8762、8763这三个Eureka Server的状态是down而8764这个Eureka Server的状态是UP，我们其实是想走到最后的else分支，从而完成过滤操作，并最终得到8764这个Server，遗憾的是它并不会走到这个分支，而是被上面的 else if (quarantineSet.size() &gt;= threshold)这个分支所拦截，返回的依旧是全量的Eureka Server列表。这样造成的后果就是Eureka Client依旧会依次向(8761、8762、8763)这三个down的Eureka Server发起注册请求。那么问题的关键在哪里呢？问题的关键就是threshold这个值的由来，因为此时quarantineSet.size()的值为3，而3这个值大于threshold，从而导致，会将quarantineSet集合清空，返回全量的Server列表。我们知道threshold这个值是根据全量的Eureka Server列表乘以一个可配置的参数计算出来的，在本文的例子当中，我的properties文件中除了defaultZone之外并没有配置这个参数，那么也就是说这个参数是有默认值的，通过源码我们了解到，这个默认值是0.66。具体源码如下： 1234567891011121314151617181920final class PropertyBasedTransportConfigConstants &#123; /** *省略部分源码 */ static class Values &#123; static final int SESSION_RECONNECT_INTERVAL = 20*60; //默认值为0.66 static final double QUARANTINE_REFRESH_PERCENTAGE = 0.66; static final int DATA_STALENESS_TRHESHOLD = 5*60; static final int ASYNC_RESOLVER_REFRESH_INTERVAL = 5*60*1000; static final int ASYNC_RESOLVER_WARMUP_TIMEOUT = 5000; static final int ASYNC_EXECUTOR_THREADPOOL_SIZE = 5; &#125;&#125; /** *@return the percentage of the full endpoints set above which the *quarantine set is cleared in the range [0, 1.0] */double getRetryableClientQuarantineRefreshPercentage(); 看到这里就不难理解了，因为这个值是0.66而此时全量的Eureka Server值为4。计算之后的值为2，而由于注册的for循环为3次，所以当第二次发起注册流程的时候quarantineSet的值始终大于threshold。这样就会导致一个问题，就是如果8761、8762、8763一直是down即使8764一直是好的，那么Eureka Client也不会注册成功。而且这个参数值的区间为0到1. 既然通过源码分析我们找到了问题根源，其实对应的我们也找到了解决这个问题的办法，就是对应把这个参数值调大些。这个值在properties中对应的写法如下： 1eureka.client.transport.retryableClientQuarantineRefreshPercentage = xxx 接下来我们修改下properties文件，修改后的内容如下： 123eureka.client.service-url.defaultZone=http://localhost:8761/eureka,http://localhost:8762/eureka,http://localhost:8763/eureka,http://localhost:8764/eurekaeureka.client.transport.retryableClientQuarantineRefreshPercentage=1 接下来按照这个配置再次回顾下上面的流程： Eureka Client启动时进行注册(8761、8762、8763的状态是down)，所以此时quarantineSet的值为3. 接下来在定时任务中又触发注册事件，此时因为参数的值从0.66调整为1。所以计算出的threshold的值为4。而此时quarantineSet的值为3。所以不会进入到 else if (quarantineSet.size() &gt;= threshold)分支，而是会进入最后的esle分支。 在else分支中会完成过滤功能，最终返回的list中的结果只有一个就是8764这个Eureka Server。 Eureka Client向8764这个Eureka Server发起注册请求，得到成功相应，并返回。 遗留问题说道这里我们感觉好像是解决了这个问题，那么问一个问题，这个参数值可以设置的无限大吗？ 比如我将这个参数值设置为10，虽然javaDoc中说明这个参数值的范围在0-1之间，但是并没有说明如果将这个参数调整大于1会出现什么情况。接下来按照上面的流程我们分析下：之前我们分析的流程中的前提是8761、8762、8763这三台Server的状态是down而8764这个server的状态是up，现在我们修改下这个前提。假设一开始8761、8762、8763、8764这四台Eureka Server的状态都是down。 Eureka Client启动时进行注册(8761、8762、8763的状态是down)，所以此时quarantineSet的值为3. 接下来在定时任务中又触发注册事件，此时因为参数的值从0.66调整为10。所以计算出的threshold的值为40。而此时quarantineSet的值为3。所以不会进入到 else if (quarantineSet.size() &gt;= threshold)分支，而是会进入最后的esle分支。 在else分支中会完成过滤功能，最终返回的list中的结果只有一个就是8764这个Eureka Server。 Eureka Client向8764这个Eureka Server发起注册请求，因为此时8764的状态也是down导致注册失败，此时quarantineSet中的内容是(8761、8762、8763、8764) 当定时任务再次触发时 if (quarantineSet.isEmpty())这个分支不会进入，因为此时quarantineSet的值为4 else if (quarantineSet.size() &gt;= threshold)这分支也不会进入因为threshold的值为40 最终会进入else分支，这个分支原本的含义是想通过quarantineSet来充当过滤器，从全量的Eureka Server中过滤掉之前状态为down的Eureka Server，但是由于quarantineSet的值现在已经是全量，导致过滤后的结果返回的是一个空的list。即使此时Eureka Server列表(8761、8762、8763、8764)任何一个Server的状态变为UP，该Eureka Client也不可能完成注册事件。 解决办法上面出现的那个问题，根本原因个人认为是由于 eureka.client.transport.retryableClientQuarantineRefreshPercentage参数过大而源码中没有校验，从而导致没有进入 else if (quarantineSet.size() &gt;= threshold)的逻辑分支，因为此时如果quarantineSet中的值已经达到了所有Eureka Server列表，那么此时我们希望的是将这个Set集合清空，从而再次返回全量的Eureka Server列表，也就是说再重新来一次注册流程。所以基于上面的分析，个人认为在源码的 getHostCandidates增加下校验，具体代码如下： 123456789101112131415161718192021222324252627282930313233private List&lt;EurekaEndpoint&gt; getHostCandidates() &#123; List&lt;EurekaEndpoint&gt; candidateHosts = clusterResolver.getClusterEndpoints(); quarantineSet.retainAll(candidateHosts); // If enough hosts are bad, we have no choice but start over again int threshold = (int) (candidateHosts.size() * transportConfig.getRetryableClientQuarantineRefreshPercentage()); /** * 增加判断如果threshold的值过大，即超过Eureka Server * 列表的数量，那么将其再次赋值，赋值的内容为Eureka Server * 列表的数量。 */ if (threshold &gt; candidateHosts.size()) &#123; threshold = candidateHosts.size(); &#125; if (quarantineSet.isEmpty()) &#123; // no-op &#125; else if (quarantineSet.size() &gt;= threshold) &#123; logger.debug(\"Clearing quarantined list of size &#123;&#125;\", quarantineSet.size()); quarantineSet.clear(); &#125; else &#123; List&lt;EurekaEndpoint&gt; remainingHosts = new ArrayList&lt;&gt;(candidateHosts.size()); for (EurekaEndpoint endpoint : candidateHosts) &#123; if (!quarantineSet.contains(endpoint)) &#123; remainingHosts.add(endpoint); &#125; &#125; candidateHosts = remainingHosts; &#125; return candidateHosts;&#125; 以上内容就是个人对 eureka.client.transport.retryableClientQuarantineRefreshPercentage的理解，由于本人知识水平有限，对此问题也可能理解不正确，还请大家多多留言讨论。 最后感谢spring4all社区提供这个平台，能让大家交流学习Spring相关知识。","categories":[{"name":"Eureka","slug":"Eureka","permalink":"http://blog.alterem.top/categories/Eureka/"}],"tags":[{"name":"Eureka","slug":"Eureka","permalink":"http://blog.alterem.top/tags/Eureka/"}]},{"title":"使用hexo搭建个人博客","slug":"使用hexo搭建个人博客","date":"2019-06-12T09:34:09.000Z","updated":"2019-06-12T16:00:08.993Z","comments":true,"path":"2019/06/12/使用hexo搭建个人博客/","link":"","permalink":"http://blog.alterem.top/2019/06/12/使用hexo搭建个人博客/","excerpt":"最近开始研究blog，找到了很多开源的系统，java、asp、nodejs、php，下面介绍一种基于nodejs的开源blog，网上有很多关于hexo的文档但是个人感觉还是欠缺不能一次达到目的，因为本人现在手上只有mint发行版的linux，所以直接用mint直接搭建，因为hexo是基于nodejs的应用，所以要先安装nodejs 1.Nodejs安装使用apt-get 安装的nodejs版本过老，会导致安装hexo的时候出问题。官方推荐的安装方法： 12curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -sudo apt-get install -y nodejs centos 上： 12wget https://nodejs.org/dist/v7.7.4/node-v7.7.4-linux-x64.tar.gztar zxvf node-v7.7.4-linux-x64.tar.gz","text":"最近开始研究blog，找到了很多开源的系统，java、asp、nodejs、php，下面介绍一种基于nodejs的开源blog，网上有很多关于hexo的文档但是个人感觉还是欠缺不能一次达到目的，因为本人现在手上只有mint发行版的linux，所以直接用mint直接搭建，因为hexo是基于nodejs的应用，所以要先安装nodejs 1.Nodejs安装使用apt-get 安装的nodejs版本过老，会导致安装hexo的时候出问题。官方推荐的安装方法： 12curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -sudo apt-get install -y nodejs centos 上： 12wget https://nodejs.org/dist/v7.7.4/node-v7.7.4-linux-x64.tar.gztar zxvf node-v7.7.4-linux-x64.tar.gz sudo vi /etc/profile 1234# node （注释作用）export NODE_HOME=/home/user/software/node-v7.7.4-linux-x64export PATH=$PATH:$NODE_HOME/bin export NODE_PATH=$NODE_HOME/lib/node_modules :wq （保存并退出）source /etc/profile （使配置文件生效） 2.Hexo安装Hexo 是一个功能强大的静态网站生成系统，快速、简洁、高效。Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。可以一键部署到github，还有丰富的插件和主题,还支持热部署哦。执行如下命令进行安装 1sudo npm install hexo-cli -g 安装Hexo安成后，使用如下命令快速新建一个博客系统，然后运行它： hexo init blog cd blog npm install hexo server 如果npm安装失败，请使用sudo安装。运行成功后，访问 http://127.0.0.1:4000/ Hexo 生成博客的目录结构： 123456789.├── _config.yml├── db.json├── node_modules├── package.json├── public├── scaffolds├── source└── themes 其中_config.yml是配置站点的文件，public是hexo生成的静态站点文件夹，scaffolds是模板文件夹，source是存在用户资源的文件夹，themes是主题文件夹。 3.站点配置找到title，subtitle，author参数配置，分别配置站点的标题、副标题和作者 12345title: Alter的博客subtitle: 专注于Javadescription: 我就是我不一样的水果author: Alterlanguage: zh-CN 然后配置站点的url和permalink，这两个分别是你的站点的url host地址以及文章的永久连接 1234url: http://www.alterempty.cnroot:/permalink::year/:month/:day/:title.htmlpermalink_defaults: permalink 我配置的是年月日以及title，后缀是html，便于搜索收录。permalink详情参见： http://hexo.io/zh-cn/docs/permalinks.html 4.新增一篇文章使用如下命令即可新增一篇md格式的文章： 1hexo new'github-page-with-hexo' 然后就会在sources/_posts生成一篇文件名为github-page-with-hexo.md的markdown文件。编辑该文件就可以写博客了 Front-matter 是文件最上方以 —- 分隔的区域，用于指定个别文件的变量，举例来说： 12345678title:\"使用Hexo在Github上搭建自己的博客\"date:2017-03-22 00:00:04tags:-Hexo-Githubcategories:-Hexo--- 目前的categories只能有一个一级分类，如果填写多个，第二个会被解析为二级分类，以及类推。tags可以允许有多个。更多关于Front-matter请参考 http://hexo.io/zh-cn/docs/front-matter.html 。 5.安装git1sudo apt install git 通过 git –version 查看是否安装成功 6.申请GitHub7.发布博客 发布更新博客 1$ hexo d -g 然后等个几分钟，访问你的域名就可以看到你的网站了 注：从github上获取数据的办法有很多，就不一一阐述","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.alterem.top/categories/Hexo/"},{"name":"Blog","slug":"Hexo/Blog","permalink":"http://blog.alterem.top/categories/Hexo/Blog/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.alterem.top/tags/Hexo/"},{"name":"Blog","slug":"Blog","permalink":"http://blog.alterem.top/tags/Blog/"}]},{"title":"js生成一个不重复的ID的函数的进化之路","slug":"js生成一个不重复的ID的函数的进化之路","date":"2019-06-12T09:27:14.000Z","updated":"2019-06-12T15:43:26.383Z","comments":true,"path":"2019/06/12/js生成一个不重复的ID的函数的进化之路/","link":"","permalink":"http://blog.alterem.top/2019/06/12/js生成一个不重复的ID的函数的进化之路/","excerpt":"在MongoDB中的ObjectID，可以理解为是一个不会重复的ID，这里有个链接http://blog.csdn.net/xiamizy/article/details/41521025 感兴趣可以去研究一下。 我今天要做的就是做一个不重复ID的生成器123456/** * 生成一个用不重复的ID */function GenNonDuplicateID():String&#123; &#125;","text":"在MongoDB中的ObjectID，可以理解为是一个不会重复的ID，这里有个链接http://blog.csdn.net/xiamizy/article/details/41521025 感兴趣可以去研究一下。 我今天要做的就是做一个不重复ID的生成器123456/** * 生成一个用不重复的ID */function GenNonDuplicateID():String&#123; &#125; 先看看下面的几个方法1.生成[0,1)的随机数的Math.random,例如12//我这次运行生成的是：0.5834165740043102Math.random() 2.获取当前时间戳Date.now12//现在时间戳是1482645606622Date.now() = 1521009303858 3.将10进制转换为其他进制的字符串 Number.toString123456//将1482645606622转换成二进制：10101100100110100100100001001000011011110(1482645606622).toString(2)//转换成16进制：159349090de MongDB中的ObjectID就是24位16进制数(1482645606622).toString(16)；//最大进制支持转为36进制，使用字符是0-9a-z ：ix48wvry(1482645606622).toString(36) GenNonDuplicateID的自我进化1.随机数版本 v0.0.1123456789/** * 生成一个用不重复的ID */function GenNonDuplicateID()&#123; return Math.random().toString()&#125;//生成一个类似 0.1283460319177394的IDGenNonDuplicateID() 2.随机数版本16进制版本 v0.0.2123456789/** * 生成一个用不重复的ID */function GenNonDuplicateID()&#123; return Math.random().toString(16)&#125;//函数将生成类似 0.c1615913fa915 的IDGenNonDuplicateID() 3.随机数版本36进制版本 v0.0.3123456789/** * 生成一个用不重复的ID */function GenNonDuplicateID()&#123; return Math.random().toString(36)&#125;//函数将生成类似 0.hefy7uw6ddzwidkwcmxkzkt9 的IDGenNonDuplicateID() 4.随机数版本36进制版本 去掉”0.” v0.0.4123456789/** * 生成一个用不重复的ID */function GenNonDuplicateID()&#123; return Math.random().toString(36).substr(3)&#125;//函数将生成类似 8dlv9vabygks2cbg1spds4i 的IDGenNonDuplicateID() 然而用一个随机数作为ID，随着使用次数的累积，必然会出现相同的两个ID 5.引入时间戳 的36微进制版本 v0.1.11234567891011/** * 生成一个用不重复的ID */function GenNonDuplicateID()&#123; let idStr = Date.now().toString(36) idStr += Math.random().toString(36).substr(3) return idStr&#125;//函数将生成类似 ix49sfsnt7514k5wpflyb5l2vtok9y66r 的IDGenNonDuplicateID() 6.引入时间戳 的36微进制版本 加入随机数长度控制 v0.1.21234567891011/** * 生成一个用不重复的ID */function GenNonDuplicateID(randomLength)&#123; let idStr = Date.now().toString(36) idStr += Math.random().toString(36).substr(3,randomLength) return idStr&#125;// GenNonDuplicateID(3) 将生成类似 ix49wl2978w 的IDGenNonDuplicateID(3) 这样生成的ID前面几位总是相同，看着不爽，于是再改改 7. 引入时间戳 随机数前置 36进制 加入随机数长度控制 v0.1.312345678/** * 生成一个用不重复的ID */function GenNonDuplicateID(randomLength)&#123; return Number(Math.random().toString().substr(3,randomLength) + Date.now()).toString(36)&#125;//GenNonDuplicateID()将生成 rfmipbs8ag0kgkcogc 类似的IDGenNonDuplicateID()","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.alterem.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.alterem.top/tags/JavaScript/"}]},{"title":"常见的安全算法","slug":"常见的安全算法","date":"2019-06-12T08:54:19.000Z","updated":"2019-06-12T08:58:59.647Z","comments":true,"path":"2019/06/12/常见的安全算法/","link":"","permalink":"http://blog.alterem.top/2019/06/12/常见的安全算法/","excerpt":"本文整理了常见的安全算法，包括MD5、SHA、DES、AES、RSA等，并写了完整的工具类（Java 版），工具类包含测试。 一、数字摘要算法 数字摘要也称为消息摘要，它是一个唯一对应一个消息或文本的固定长度的值，它由一个单向Hash函数对消息进行计算而产生。如果消息在传递的途中改变了，接收者通过对收到消息采用相同的Hash重新计算，新产生的摘要与原摘要进行比较，就可知道消息是否被篡改了，因此消息摘要能够验证消息的完整性。消息摘要采用单向Hash函数将需要计算的内容”摘要”成固定长度的串，这个串亦称为数字指纹。这个串有固定的长度，且不同的明文摘要成密文，其结果总是不同的(相对的)，而同样的明文其摘要必定一致。这样这串摘要便可成为验证明文是否是”真身”的”指纹”了。 1. Md5MD5即Message Digest Algorithm 5(信息摘要算法5)，是数字摘要算法一种实现，用于确保信息传输完整性和一致性，摘要长度为128位。 MD5由MD4、 MD3、 MD2改进而来，主要增强算法复杂度和不可逆性，该算法因其普遍、稳定、快速的特点，在产业界得到了极为广泛的使用，目前主流的编程语言普遍都已有MD5算法实现。","text":"本文整理了常见的安全算法，包括MD5、SHA、DES、AES、RSA等，并写了完整的工具类（Java 版），工具类包含测试。 一、数字摘要算法 数字摘要也称为消息摘要，它是一个唯一对应一个消息或文本的固定长度的值，它由一个单向Hash函数对消息进行计算而产生。如果消息在传递的途中改变了，接收者通过对收到消息采用相同的Hash重新计算，新产生的摘要与原摘要进行比较，就可知道消息是否被篡改了，因此消息摘要能够验证消息的完整性。消息摘要采用单向Hash函数将需要计算的内容”摘要”成固定长度的串，这个串亦称为数字指纹。这个串有固定的长度，且不同的明文摘要成密文，其结果总是不同的(相对的)，而同样的明文其摘要必定一致。这样这串摘要便可成为验证明文是否是”真身”的”指纹”了。 1. Md5MD5即Message Digest Algorithm 5(信息摘要算法5)，是数字摘要算法一种实现，用于确保信息传输完整性和一致性，摘要长度为128位。 MD5由MD4、 MD3、 MD2改进而来，主要增强算法复杂度和不可逆性，该算法因其普遍、稳定、快速的特点，在产业界得到了极为广泛的使用，目前主流的编程语言普遍都已有MD5算法实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;/** * Message Digest Algorithm 5(信息摘要算法5) */public class MD5Util &#123; /** * Constructs the MD5Util object and sets the string whose MD5Util is to be * computed. * * @param inStr * the &lt;code&gt;String&lt;/code&gt; whose MD5Util is to be computed */ public final static String COMMON_KEY=\"zhongzhuoxin#@!321\"; public MD5Util() &#123; &#125; public final static String str2MD5(String inStr) &#123; char hexDigits[] = &#123; '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' &#125;; try &#123; byte[] strTemp = inStr.getBytes(\"UTF-8\"); MessageDigest mdTemp = MessageDigest.getInstance(\"MD5\"); mdTemp.update(strTemp); byte[] md = mdTemp.digest(); int j = md.length; char str[] = new char[j * 2]; int k = 0; for (int i = 0; i &lt; j; i++) &#123; byte byte0 = md[i]; str[k++] = hexDigits[byte0 &gt;&gt;&gt; 4 &amp; 0xf]; str[k++] = hexDigits[byte0 &amp; 0xf]; &#125; return new String(str); &#125; catch (Exception e) &#123; return null; &#125; &#125; //--MD5Util private static final char HEX_DIGITS[] = &#123; '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' &#125;; public static String toHexString(byte[] b) &#123; // String to byte StringBuilder sb = new StringBuilder(b.length * 2); for (int i = 0; i &lt; b.length; i++) &#123; sb.append(HEX_DIGITS[(b[i] &amp; 0xf0) &gt;&gt;&gt; 4]); sb.append(HEX_DIGITS[b[i] &amp; 0x0f]); &#125; return sb.toString(); &#125; public static String AndroidMd5(String s) &#123; try &#123; // Create MD5Util Hash MessageDigest digest = MessageDigest .getInstance(\"MD5\"); digest.update(s.getBytes()); byte messageDigest[] = digest.digest(); return toHexString(messageDigest); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; return \"\"; &#125; public static void main(String[] args) &#123; String m = MD5Util.str2MD5(\"swwwwwwwwwwdkinner\"); System.out.print(m.length() + \" \"); System.out.println(m); &#125;&#125; 2.SHASHA的全称是Secure Hash Algorithm，即安全散列算法。 1993年，安全散列算法(SHA)由美国国家标准和技术协会（NIST)提出，并作为联邦信息处理标准(FIPS PUB 180)公布， 1995年又发布了一个修订版FIPS PUB 180-1，通常称之为SHA-1。 SHA-1是基于MD4算法的，现在已成为公认的最安全的散列算法之一，并被广泛使用。SHA-1算法生成的摘要信息的长度为160位，由于生成的摘要信息更长，运算的过程更加复杂，在相同的硬件上， SHA-1的运行速度比MD5更慢，但是也更为安全。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import com.google.common.base.Strings;import java.security.MessageDigest;/** * SHA的全称是Secure Hash Algorithm，即安全散列算法 * Created by fangzhipeng on 2017/3/21. */public class SHAUtil &#123; /** * 定义加密方式 */ private final static String KEY_SHA = \"SHA\"; private final static String KEY_SHA1 = \"SHA-1\"; /** * 全局数组 */ private final static String[] hexDigits = &#123; \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" &#125;; /** * 构造函数 */ public SHAUtil() &#123; &#125; /** * SHA 加密 * @param data 需要加密的字节数组 * @return 加密之后的字节数组 * @throws Exception */ public static byte[] encryptSHA(byte[] data) throws Exception &#123; // 创建具有指定算法名称的信息摘要// MessageDigest sha = MessageDigest.getInstance(KEY_SHA); MessageDigest sha = MessageDigest.getInstance(KEY_SHA1); // 使用指定的字节数组对摘要进行最后更新 sha.update(data); // 完成摘要计算并返回 return sha.digest(); &#125; /** * SHA 加密 * @param data 需要加密的字符串 * @return 加密之后的字符串 * @throws Exception */ public static String encryptSHA(String data) throws Exception &#123; // 验证传入的字符串 if (Strings.isNullOrEmpty(data)) &#123; return \"\"; &#125; // 创建具有指定算法名称的信息摘要 MessageDigest sha = MessageDigest.getInstance(KEY_SHA); // 使用指定的字节数组对摘要进行最后更新 sha.update(data.getBytes()); // 完成摘要计算 byte[] bytes = sha.digest(); // 将得到的字节数组变成字符串返回 return byteArrayToHexString(bytes); &#125; /** * 将一个字节转化成十六进制形式的字符串 * @param b 字节数组 * @return 字符串 */ private static String byteToHexString(byte b) &#123; int ret = b; //System.out.println(\"ret = \" + ret); if (ret &lt; 0) &#123; ret += 256; &#125; int m = ret / 16; int n = ret % 16; return hexDigits[m] + hexDigits[n]; &#125; /** * 转换字节数组为十六进制字符串 * @param bytes 字节数组 * @return 十六进制字符串 */ private static String byteArrayToHexString(byte[] bytes) &#123; StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; bytes.length; i++) &#123; sb.append(byteToHexString(bytes[i])); &#125; return sb.toString(); &#125; /** * 测试方法 * @param args */ public static void main(String[] args) throws Exception &#123; String key = \"123\"; System.out.println(encryptSHA(key)); &#125;&#125; 二、对称加密 对称加密算法是应用较早的加密算法，技术成熟。在对称加密算法中，数据发送方将明文(原始数据)和加密密钥一起经过特殊加密算法处理后，生成复杂的加密密文进行发送，数据接收方收到密文后，若想读取原文，则需要使用加密使用的密钥及相同算法的逆算法对加密的密文进行解密，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发送和接收双方都使用这个密钥对数据进行加密和解密，这就要求加密和解密方事先都必须知道加密的密钥。 1. DES算法1973 年，美国国家标准局(NBS)在认识到建立数据保护标准既明显又急迫的情况下，开始征集联邦数据加密标准的方案。 1975 年3月17日， NBS公布了IBM公司提供的密码算法，以标准建议的形式在全国范围内征求意见。经过两年多的公开讨论之后， 1977 年7月15日， NBS宣布接受这建议，作为联邦信息处理标准46 号数据加密标准(Data Encryptin Standard)，即DES正式颁布，供商业界和非国防性政府部门使用。DES算法属于对称加密算法，明文按64位进行分组，密钥长64位，但事实上只有56位参与DES运算(第8、 16、 24、 32、 40、 48、 56、 64位是校验位，使得每个密钥都有奇数个1),分组后的明文和56位的密钥按位替代或交换的方法形成密文。由于计算机运算能力的增强，原版DES密码的密钥长度变得容易被暴力破解，因此演变出了3DES算法。 3DES是DES向AES过渡的加密算法，它使用3条56位的密钥对数据进行三次加密，是DES的一个更安全的变形 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118import java.io.IOException;import java.security.SecureRandom;import javax.crypto.Cipher;import javax.crypto.SecretKey;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.DESKeySpec;import sun.misc.BASE64Decoder;import sun.misc.BASE64Encoder;/** * Data Encryptin Standard * 数据加密标准 */public class DESUtil &#123; private final static String DES = \"DES\"; /** * Description 根据键值进行加密 * * @param data * @param key 加密键byte数组 * @return * @throws Exception */ public static String encrypt(String data, String key) throws Exception &#123; byte[] bt = encrypt(data.getBytes(), key.getBytes()); String strs = new BASE64Encoder().encode(bt); return strs; &#125; /** * Description 根据键值进行解密 * * @param data * @param key 加密键byte数组 * @return * @throws IOException * @throws Exception */ public static String decrypt(String data, String key) throws Exception, Exception &#123; if (data == null) return null; BASE64Decoder decoder = new BASE64Decoder(); byte[] buf = decoder.decodeBuffer(data); byte[] bt = decrypt(buf, key.getBytes()); return new String(bt); &#125; /** * Description 根据键值进行加密 * * @param data * @param key 加密键byte数组 * @return * @throws Exception */ private static byte[] encrypt(byte[] data, byte[] key) throws Exception &#123; // 生成一个可信任的随机数源 SecureRandom sr = new SecureRandom(); // 从原始密钥数据创建DESKeySpec对象 DESKeySpec dks = new DESKeySpec(key); // 创建一个密钥工厂，然后用它把DESKeySpec转换成SecretKey对象 SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(DES); SecretKey securekey = keyFactory.generateSecret(dks); // Cipher对象实际完成加密操作 Cipher cipher = Cipher.getInstance(DES); // 用密钥初始化Cipher对象 cipher.init(Cipher.ENCRYPT_MODE, securekey, sr); return cipher.doFinal(data); &#125; /** * Description 根据键值进行解密 * * @param data * @param key 加密键byte数组 * @return * @throws Exception */ private static byte[] decrypt(byte[] data, byte[] key) throws Exception &#123; // 生成一个可信任的随机数源 SecureRandom sr = new SecureRandom(); // 从原始密钥数据创建DESKeySpec对象 DESKeySpec dks = new DESKeySpec(key); // 创建一个密钥工厂，然后用它把DESKeySpec转换成SecretKey对象 SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(DES); SecretKey securekey = keyFactory.generateSecret(dks); // Cipher对象实际完成解密操作 Cipher cipher = Cipher.getInstance(DES); // 用密钥初始化Cipher对象 cipher.init(Cipher.DECRYPT_MODE, securekey, sr); return cipher.doFinal(data); &#125; public static void main(String[]args)throws Exception&#123; String sStr=encrypt(\"122222112222:12343232323:jajwwwwslwskwkkwksk\",\"wew2323w233321ws233w\"); System.out.println(sStr); String mStr=decrypt(sStr,\"wew2323w233321ws233w\"); System.out.println(mStr); &#125;&#125; 2. AESAES的全称是Advanced Encryption Standard，即高级加密标准，该算法由比利时密码学家Joan Daemen和Vincent Rijmen所设计，结合两位作者的名字，又称Rijndael加密算法，是美国联邦政府采用的一种对称加密标准，这个标准用来替代原先的DES算法，已经广为全世界所使用，已然成为对称加密算法中最流行的算法之一。AES算法作为新一代的数据加密标准汇聚了强安全性、高性能、高效率、易用和灵活等优点，设计有三个密钥长度:128,192,256位，比DES算法的加密强度更高，更为安全。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import java.io.IOException;import java.io.UnsupportedEncodingException;import java.security.InvalidKeyException;import java.security.NoSuchAlgorithmException;import java.security.SecureRandom;import java.util.Base64;import java.util.Scanner;import javax.crypto.BadPaddingException;import javax.crypto.Cipher;import javax.crypto.IllegalBlockSizeException;import javax.crypto.KeyGenerator;import javax.crypto.NoSuchPaddingException;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import sun.misc.BASE64Decoder;import sun.misc.BASE64Encoder;/** * Created by fangzhipeng on 2017/3/21. */public class AESUtil &#123; static byte[] key = \"w@#$4@#$s^&amp;3*&amp;^4\".getBytes(); final static String algorithm=\"AES\"; public static String encrypt(String data)&#123; byte[] dataToSend = data.getBytes(); Cipher c = null; try &#123; c = Cipher.getInstance(algorithm); &#125; catch (NoSuchAlgorithmException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (NoSuchPaddingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; SecretKeySpec k = new SecretKeySpec(key, algorithm); try &#123; c.init(Cipher.ENCRYPT_MODE, k); &#125; catch (InvalidKeyException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; byte[] encryptedData = \"\".getBytes(); try &#123; encryptedData = c.doFinal(dataToSend); &#125; catch (IllegalBlockSizeException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (BadPaddingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; byte[] encryptedByteValue = Base64.getEncoder().encode(encryptedData); return new String(encryptedByteValue);//.toString(); &#125; public static String decrypt(String data)&#123; byte[] encryptedData = Base64.getDecoder().decode(data); Cipher c = null; try &#123; c = Cipher.getInstance(algorithm); &#125; catch (NoSuchAlgorithmException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (NoSuchPaddingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; SecretKeySpec k = new SecretKeySpec(key, algorithm); try &#123; c.init(Cipher.DECRYPT_MODE, k); &#125; catch (InvalidKeyException e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; byte[] decrypted = null; try &#123; decrypted = c.doFinal(encryptedData); &#125; catch (IllegalBlockSizeException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (BadPaddingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return new String(decrypted); &#125; public static void main(String[] args)&#123; String password=encrypt(\"12233440988:1239874389888:dd333\"); System.out.println(password); System.out.println(decrypt(password)); &#125;&#125; 三、非对称加密 非对称加密算法又称为公开密钥加密算法，它需要两个密钥，一个称为公开密钥(public key)，即公钥，另一个称为私有密钥(private key)，即私钥。公钥与私钥需要配对使用，如果用公钥对数据进行加密，只有用对应的私钥才能进行解密，而如果使用私钥对数据进行加密，那么只有用对应的公钥才能进行解密。因为加密和解密使用的是两个不同的密钥，所以这种算法称为非对称加密算法。非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公钥向其它人公开，得到该公钥的乙方使用该密钥对机密信息进行加密后再发送给甲方，甲方再使用自己保存的另一把专用密钥，即私钥，对加密后的信息进行解密。 RSARSA非对称加密算法是1977年由Ron Rivest、 Adi Shamirh和LenAdleman开发的， RSA取名来自开发他们三者的名字。 RSA是目前最有影响力的非对称加密算法，它能够抵抗到目前为止已知的所有密码攻击，已被ISO推荐为公钥数据加密标准。 RSA算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但反过来想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374/** * Created by fangzhipeng on 2017/3/21. * RSA ：RSA非对称加密算法是1977年由Ron Rivest、 Adi Shamirh和LenAdleman开发 * 的， RSA取名来 * 自开发他们三者的名字。 * 参考：http://blog.csdn.net/wangqiuyun/article/details/42143957 */import java.io.*;import java.security.InvalidKeyException;import java.security.KeyFactory;import java.security.KeyPair;import java.security.KeyPairGenerator;import java.security.NoSuchAlgorithmException;import java.security.SecureRandom;import java.security.interfaces.RSAPrivateKey;import java.security.interfaces.RSAPublicKey;import java.security.spec.InvalidKeySpecException;import java.security.spec.PKCS8EncodedKeySpec;import java.security.spec.X509EncodedKeySpec;import java.util.Base64;import javax.crypto.BadPaddingException;import javax.crypto.Cipher;import javax.crypto.IllegalBlockSizeException;import javax.crypto.NoSuchPaddingException;public class RSAUtil &#123; /** * 字节数据转字符串专用集合 */ private static final char[] HEX_CHAR = &#123; '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' &#125;; /** * 随机生成密钥对 */ public static void genKeyPair(String filePath) &#123; // KeyPairGenerator类用于生成公钥和私钥对，基于RSA算法生成对象 KeyPairGenerator keyPairGen = null; try &#123; keyPairGen = KeyPairGenerator.getInstance(\"RSA\"); &#125; catch (NoSuchAlgorithmException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; // 初始化密钥对生成器，密钥大小为96-1024位 keyPairGen.initialize(1024,new SecureRandom()); // 生成一个密钥对，保存在keyPair中 KeyPair keyPair = keyPairGen.generateKeyPair(); // 得到私钥 RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate(); // 得到公钥 RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic(); try &#123; // 得到公钥字符串 // 得到私钥字符串 String privateKeyString =new String( Base64.getEncoder().encode(privateKey.getEncoded())); String publicKeyString =new String( Base64.getEncoder().encode(publicKey.getEncoded())); // 将密钥对写入到文件 File file1=new File(filePath + \"publicKey.keystore\"); File file2=new File(filePath + \"privateKey.keystore\"); if(!file1.exists()) &#123; file1.createNewFile(); &#125; if(!file2.exists()) &#123; file2.createNewFile(); &#125; FileWriter pubfw = new FileWriter(filePath + \"/publicKey.keystore\"); FileWriter prifw = new FileWriter(filePath + \"/privateKey.keystore\"); BufferedWriter pubbw = new BufferedWriter(pubfw); BufferedWriter pribw = new BufferedWriter(prifw); pubbw.write(publicKeyString); pribw.write(privateKeyString); pubbw.flush(); pubbw.close(); pubfw.close(); pribw.flush(); pribw.close(); prifw.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 从文件中输入流中加载公钥 * * @param * * @throws Exception * 加载公钥时产生的异常 */ public static String loadPublicKeyByFile(String path) throws Exception &#123; try &#123; BufferedReader br = new BufferedReader(new FileReader(path + \"/publicKey.keystore\")); String readLine = null; StringBuilder sb = new StringBuilder(); while ((readLine = br.readLine()) != null) &#123; sb.append(readLine); &#125; br.close(); return sb.toString(); &#125; catch (IOException e) &#123; throw new Exception(\"公钥数据流读取错误\"); &#125; catch (NullPointerException e) &#123; throw new Exception(\"公钥输入流为空\"); &#125; &#125; /** * 从字符串中加载公钥 * * @param publicKeyStr * 公钥数据字符串 * @throws Exception * 加载公钥时产生的异常 */ public static RSAPublicKey loadPublicKeyByStr(String publicKeyStr) throws Exception &#123; try &#123; byte[] buffer = Base64.getDecoder().decode(publicKeyStr); KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\"); X509EncodedKeySpec keySpec = new X509EncodedKeySpec(buffer); return (RSAPublicKey) keyFactory.generatePublic(keySpec); &#125; catch (NoSuchAlgorithmException e) &#123; throw new Exception(\"无此算法\"); &#125; catch (InvalidKeySpecException e) &#123; throw new Exception(\"公钥非法\"); &#125; catch (NullPointerException e) &#123; throw new Exception(\"公钥数据为空\"); &#125; &#125; /** * 从文件中加载私钥 * * @param * * @return 是否成功 * @throws Exception */ public static String loadPrivateKeyByFile(String path) throws Exception &#123; try &#123; BufferedReader br = new BufferedReader(new FileReader(path + \"/privateKey.keystore\")); String readLine = null; StringBuilder sb = new StringBuilder(); while ((readLine = br.readLine()) != null) &#123; sb.append(readLine); &#125; br.close(); return sb.toString(); &#125; catch (IOException e) &#123; throw new Exception(\"私钥数据读取错误\"); &#125; catch (NullPointerException e) &#123; throw new Exception(\"私钥输入流为空\"); &#125; &#125; public static RSAPrivateKey loadPrivateKeyByStr(String privateKeyStr) throws Exception &#123; try &#123; byte[] buffer = Base64.getDecoder().decode(privateKeyStr); PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(buffer); KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\"); return (RSAPrivateKey) keyFactory.generatePrivate(keySpec); &#125; catch (NoSuchAlgorithmException e) &#123; throw new Exception(\"无此算法\"); &#125; catch (InvalidKeySpecException e) &#123; throw new Exception(\"私钥非法\"); &#125; catch (NullPointerException e) &#123; throw new Exception(\"私钥数据为空\"); &#125; &#125; /** * 公钥加密过程 * * @param publicKey * 公钥 * @param plainTextData * 明文数据 * @return * @throws Exception * 加密过程中的异常信息 */ public static byte[] encrypt(RSAPublicKey publicKey, byte[] plainTextData) throws Exception &#123; if (publicKey == null) &#123; throw new Exception(\"加密公钥为空, 请设置\"); &#125; Cipher cipher = null; try &#123; // 使用默认RSA cipher = Cipher.getInstance(\"RSA\"); // cipher= Cipher.getInstance(\"RSA\", new BouncyCastleProvider()); cipher.init(Cipher.ENCRYPT_MODE, publicKey); byte[] output = cipher.doFinal(plainTextData); return output; &#125; catch (NoSuchAlgorithmException e) &#123; throw new Exception(\"无此加密算法\"); &#125; catch (NoSuchPaddingException e) &#123; e.printStackTrace(); return null; &#125; catch (InvalidKeyException e) &#123; throw new Exception(\"加密公钥非法,请检查\"); &#125; catch (IllegalBlockSizeException e) &#123; throw new Exception(\"明文长度非法\"); &#125; catch (BadPaddingException e) &#123; throw new Exception(\"明文数据已损坏\"); &#125; &#125; /** * 私钥加密过程 * * @param privateKey * 私钥 * @param plainTextData * 明文数据 * @return * @throws Exception * 加密过程中的异常信息 */ public static byte[] encrypt(RSAPrivateKey privateKey, byte[] plainTextData) throws Exception &#123; if (privateKey == null) &#123; throw new Exception(\"加密私钥为空, 请设置\"); &#125; Cipher cipher = null; try &#123; // 使用默认RSA cipher = Cipher.getInstance(\"RSA\"); cipher.init(Cipher.ENCRYPT_MODE, privateKey); byte[] output = cipher.doFinal(plainTextData); return output; &#125; catch (NoSuchAlgorithmException e) &#123; throw new Exception(\"无此加密算法\"); &#125; catch (NoSuchPaddingException e) &#123; e.printStackTrace(); return null; &#125; catch (InvalidKeyException e) &#123; throw new Exception(\"加密私钥非法,请检查\"); &#125; catch (IllegalBlockSizeException e) &#123; throw new Exception(\"明文长度非法\"); &#125; catch (BadPaddingException e) &#123; throw new Exception(\"明文数据已损坏\"); &#125; &#125; /** * 私钥解密过程 * * @param privateKey * 私钥 * @param cipherData * 密文数据 * @return 明文 * @throws Exception * 解密过程中的异常信息 */ public static byte[] decrypt(RSAPrivateKey privateKey, byte[] cipherData) throws Exception &#123; if (privateKey == null) &#123; throw new Exception(\"解密私钥为空, 请设置\"); &#125; Cipher cipher = null; try &#123; // 使用默认RSA cipher = Cipher.getInstance(\"RSA\"); // cipher= Cipher.getInstance(\"RSA\", new BouncyCastleProvider()); cipher.init(Cipher.DECRYPT_MODE, privateKey); byte[] output = cipher.doFinal(cipherData); return output; &#125; catch (NoSuchAlgorithmException e) &#123; throw new Exception(\"无此解密算法\"); &#125; catch (NoSuchPaddingException e) &#123; e.printStackTrace(); return null; &#125; catch (InvalidKeyException e) &#123; throw new Exception(\"解密私钥非法,请检查\"); &#125; catch (IllegalBlockSizeException e) &#123; throw new Exception(\"密文长度非法\"); &#125; catch (BadPaddingException e) &#123; throw new Exception(\"密文数据已损坏\"); &#125; &#125; /** * 公钥解密过程 * * @param publicKey * 公钥 * @param cipherData * 密文数据 * @return 明文 * @throws Exception * 解密过程中的异常信息 */ public static byte[] decrypt(RSAPublicKey publicKey, byte[] cipherData) throws Exception &#123; if (publicKey == null) &#123; throw new Exception(\"解密公钥为空, 请设置\"); &#125; Cipher cipher = null; try &#123; // 使用默认RSA cipher = Cipher.getInstance(\"RSA\"); // cipher= Cipher.getInstance(\"RSA\", new BouncyCastleProvider()); cipher.init(Cipher.DECRYPT_MODE, publicKey); byte[] output = cipher.doFinal(cipherData); return output; &#125; catch (NoSuchAlgorithmException e) &#123; throw new Exception(\"无此解密算法\"); &#125; catch (NoSuchPaddingException e) &#123; e.printStackTrace(); return null; &#125; catch (InvalidKeyException e) &#123; throw new Exception(\"解密公钥非法,请检查\"); &#125; catch (IllegalBlockSizeException e) &#123; throw new Exception(\"密文长度非法\"); &#125; catch (BadPaddingException e) &#123; throw new Exception(\"密文数据已损坏\"); &#125; &#125; /** * 字节数据转十六进制字符串 * * @param data * 输入数据 * @return 十六进制内容 */ public static String byteArrayToString(byte[] data) &#123; StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; data.length; i++) &#123; // 取出字节的高四位 作为索引得到相应的十六进制标识符 注意无符号右移 stringBuilder.append(HEX_CHAR[(data[i] &amp; 0xf0) &gt;&gt;&gt; 4]); // 取出字节的低四位 作为索引得到相应的十六进制标识符 stringBuilder.append(HEX_CHAR[(data[i] &amp; 0x0f)]); if (i &lt; data.length - 1) &#123; stringBuilder.append(' '); &#125; &#125; return stringBuilder.toString(); &#125; public static void main(String[] args) throws Exception &#123; String filepath=\"F:/temp/\"; File file=new File(filepath); if(!file.exists())&#123; file.mkdir(); &#125; genKeyPair(filepath); System.out.println(\"--------------公钥加密私钥解密过程-------------------\"); String plainText=\"1223333323:8783737321232:dewejj28i33e92hhsxxxx\"; //公钥加密过程 byte[] cipherData=encrypt(loadPublicKeyByStr(loadPublicKeyByFile(filepath)),plainText.getBytes()); String cipher=new String(Base64.getEncoder().encode(cipherData)); //私钥解密过程 byte[] res=decrypt(loadPrivateKeyByStr(loadPrivateKeyByFile(filepath)), Base64.getDecoder().decode(cipher)); String restr=new String(res); System.out.println(\"原文：\"+plainText); System.out.println(\"加密密文：\"+cipher); System.out.println(\"解密：\"+restr); System.out.println(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.alterem.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.alterem.top/tags/Java/"}]},{"title":"ID生成器-Twitter的雪花算法","slug":"ID生成器-Twitter的雪花算法","date":"2019-06-12T05:38:55.000Z","updated":"2019-07-04T12:10:01.499Z","comments":true,"path":"2019/06/12/ID生成器-Twitter的雪花算法/","link":"","permalink":"http://blog.alterem.top/2019/06/12/ID生成器-Twitter的雪花算法/","excerpt":"","text":"上代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146/** * Twitter_Snowflake&lt;br&gt; * SnowFlake的结构如下(每部分用-分开):&lt;br&gt; * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt; * 1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0&lt;br&gt; * 41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截) * 得到的值），这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下下面程序IdWorker类的startTime属性）。41位的时间截，可以使用69年，年T = (1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69&lt;br&gt; * 10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId&lt;br&gt; * 12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号&lt;br&gt; * 加起来刚好64位，为一个Long型。&lt;br&gt; * SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右。 */public class SnowflakeIdWorker &#123; // ==============================Fields=========================================== /** 开始时间截 (2015-01-01) */ private final long twepoch = 1489111610226L; /** 机器id所占的位数 */ private final long workerIdBits = 5L; /** 数据标识id所占的位数 */ private final long dataCenterIdBits = 5L; /** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */ private final long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits); /** 支持的最大数据标识id，结果是31 */ private final long maxDataCenterId = -1L ^ (-1L &lt;&lt; dataCenterIdBits); /** 序列在id中占的位数 */ private final long sequenceBits = 12L; /** 机器ID向左移12位 */ private final long workerIdShift = sequenceBits; /** 数据标识id向左移17位(12+5) */ private final long dataCenterIdShift = sequenceBits + workerIdBits; /** 时间截向左移22位(5+5+12) */ private final long timestampLeftShift = sequenceBits + workerIdBits + dataCenterIdBits; /** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */ private final long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits); /** 工作机器ID(0~31) */ private long workerId; /** 数据中心ID(0~31) */ private long dataCenterId; /** 毫秒内序列(0~4095) */ private long sequence = 0L; /** 上次生成ID的时间截 */ private long lastTimestamp = -1L; //==============================Constructors===================================== /** * 构造函数 * @param workerId 工作ID (0~31) * @param dataCenterId 数据中心ID (0~31) */ public SnowflakeIdWorker(long workerId, long dataCenterId) &#123; if (workerId &gt; maxWorkerId || workerId &lt; 0) &#123; throw new IllegalArgumentException(String.format(\"workerId can't be greater than %d or less than 0\", maxWorkerId)); &#125; if (dataCenterId &gt; maxDataCenterId || dataCenterId &lt; 0) &#123; throw new IllegalArgumentException(String.format(\"dataCenterId can't be greater than %d or less than 0\", maxDataCenterId)); &#125; this.workerId = workerId; this.dataCenterId = dataCenterId; &#125; // ==============================Methods========================================== /** * 获得下一个ID (该方法是线程安全的) * @return SnowflakeId */ public synchronized long nextId() &#123; long timestamp = timeGen(); //如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常 if (timestamp &lt; lastTimestamp) &#123; throw new RuntimeException( String.format(\"Clock moved backwards. Refusing to generate id for %d milliseconds\", lastTimestamp - timestamp)); &#125; //如果是同一时间生成的，则进行毫秒内序列 if (lastTimestamp == timestamp) &#123; sequence = (sequence + 1) &amp; sequenceMask; //毫秒内序列溢出 if (sequence == 0) &#123; //阻塞到下一个毫秒,获得新的时间戳 timestamp = tilNextMillis(lastTimestamp); &#125; &#125; //时间戳改变，毫秒内序列重置 else &#123; sequence = 0L; &#125; //上次生成ID的时间截 lastTimestamp = timestamp; //移位并通过或运算拼到一起组成64位的ID return ((timestamp - twepoch) &lt;&lt; timestampLeftShift) // | (dataCenterId &lt;&lt; dataCenterIdShift) // | (workerId &lt;&lt; workerIdShift) // | sequence; &#125; /** * 阻塞到下一个毫秒，直到获得新的时间戳 * @param lastTimestamp 上次生成ID的时间截 * @return 当前时间戳 */ protected long tilNextMillis(long lastTimestamp) &#123; long timestamp = timeGen(); while (timestamp &lt;= lastTimestamp) &#123; timestamp = timeGen(); &#125; return timestamp; &#125; /** * 返回以毫秒为单位的当前时间 * @return 当前时间(毫秒) */ protected long timeGen() &#123; return System.currentTimeMillis(); &#125; //==============================Test============================================= /** 测试 */ public static void main(String[] args) &#123; System.out.println(System.currentTimeMillis()); SnowflakeIdWorker idWorker = new SnowflakeIdWorker(1, 1); long startTime = System.nanoTime(); for (int i = 0; i &lt; 50000; i++) &#123; long id = idWorker.nextId(); System.out.println(id); &#125; System.out.println((System.nanoTime()-startTime)/1000000+\"ms\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.alterem.top/categories/Java/"},{"name":"Id","slug":"Java/Id","permalink":"http://blog.alterem.top/categories/Java/Id/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.alterem.top/tags/Java/"},{"name":"Id","slug":"Id","permalink":"http://blog.alterem.top/tags/Id/"}]},{"title":"Java高效读取大文件","slug":"Java高效读取大文件","date":"2019-06-12T05:36:00.000Z","updated":"2019-06-12T05:37:13.007Z","comments":true,"path":"2019/06/12/Java高效读取大文件/","link":"","permalink":"http://blog.alterem.top/2019/06/12/Java高效读取大文件/","excerpt":"1、概述本教程将演示如何用Java高效地读取大文件。 2、在内存中读取读取文件行的标准方式是在内存中读取，Guava 和Apache Commons IO都提供了如下所示快速读取文件行的方法： 123Files.readLines(new File(path), Charsets.UTF_8); FileUtils.readLines(new File(path)); 这种方法带来的问题是文件的所有行都被存放在内存中，当文件足够大时很快就会导致程序抛出OutOfMemoryError 异常。","text":"1、概述本教程将演示如何用Java高效地读取大文件。 2、在内存中读取读取文件行的标准方式是在内存中读取，Guava 和Apache Commons IO都提供了如下所示快速读取文件行的方法： 123Files.readLines(new File(path), Charsets.UTF_8); FileUtils.readLines(new File(path)); 这种方法带来的问题是文件的所有行都被存放在内存中，当文件足够大时很快就会导致程序抛出OutOfMemoryError 异常。 例如：读取一个大约1G的文件： 12345@Testpublic void givenUsingGuava_whenIteratingAFile_thenWorks() throws IOException &#123; String path = ... Files.readLines(new File(path), Charsets.UTF_8);&#125; 这种方式开始时只占用很少的内存：（大约消耗了0Mb内存） 12[main] INFO org.baeldung.java.CoreJavaIoUnitTest - Total Memory: 128 Mb[main] INFO org.baeldung.java.CoreJavaIoUnitTest - Free Memory: 116 Mb 然而，当文件全部读到内存中后，我们最后可以看到（大约消耗了2GB内存）： 12[main] INFO org.baeldung.java.CoreJavaIoUnitTest - Total Memory: 2666 Mb[main] INFO org.baeldung.java.CoreJavaIoUnitTest - Free Memory: 490 Mb 这意味这一过程大约耗费了2.1GB的内存——原因很简单：现在文件的所有行都被存储在内存中。 把文件所有的内容都放在内存中很快会耗尽可用内存——不论实际可用内存有多大，这点是显而易见的。 此外，我们通常不需要把文件的所有行一次性地放入内存中——相反，我们只需要遍历文件的每一行，然后做相应的处理，处理完之后把它扔掉。所以，这正是我们将要做的——通过行迭代，而不是把所有行都放在内存中。 3、文件流现在让我们看下这种解决方案——我们将使用java.util.Scanner类扫描文件的内容，一行一行连续地读取： 123456789101112131415161718192021FileInputStream inputStream = null;Scanner sc = null;try &#123; inputStream = new FileInputStream(path); sc = new Scanner(inputStream, \"UTF-8\"); while (sc.hasNextLine()) &#123; String line = sc.nextLine(); // System.out.println(line); &#125; // note that Scanner suppresses exceptions if (sc.ioException() != null) &#123; throw sc.ioException(); &#125;&#125; finally &#123; if (inputStream != null) &#123; inputStream.close(); &#125; if (sc != null) &#123; sc.close(); &#125;&#125; 这种方案将会遍历文件中的所有行——允许对每一行进行处理，而不保持对它的引用。总之没有把它们存放在内存中：（大约消耗了150MB内存） 12[main] INFO org.baeldung.java.CoreJavaIoUnitTest - Total Memory: 763 Mb[main] INFO org.baeldung.java.CoreJavaIoUnitTest - Free Memory: 605 Mb 4、Apache Commons IO流同样也可以使用Commons IO库实现，利用该库提供的自定义LineIterator: 123456789LineIterator it = FileUtils.lineIterator(theFile, \"UTF-8\");try &#123; while (it.hasNext()) &#123; String line = it.nextLine(); // do something with line &#125;&#125; finally &#123; LineIterator.closeQuietly(it);&#125; 由于整个文件不是全部存放在内存中，这也就导致相当保守的内存消耗：（大约消耗了150MB内存） 12[main] INFO o.b.java.CoreJavaIoIntegrationTest - Total Memory: 752 Mb[main] INFO o.b.java.CoreJavaIoIntegrationTest - Free Memory: 564 Mb 5、结论这篇短文介绍了如何在不重复读取与不耗尽内存的情况下处理大文件——这为大文件的处理提供了一个有用的解决办法。 所有这些例子的实现和代码片段都可以在我的github项目上获取到——这是一个基于Eclipse的项目，所以它应该很容易被导入和运行。","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.alterem.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.alterem.top/tags/Java/"}]},{"title":"restful接口设计规范总结","slug":"restful接口设计规范总结","date":"2019-06-12T05:30:54.000Z","updated":"2019-06-12T05:32:58.081Z","comments":true,"path":"2019/06/12/restful接口设计规范总结/","link":"","permalink":"http://blog.alterem.top/2019/06/12/restful接口设计规范总结/","excerpt":"这篇 文章主要是借鉴他人，但是自己很想总结出一套规范，以供向我这样的新手使用，用来规范代码，如果有什么好的提议，请不吝赐教，本篇文章长期更新！ 一、重要概念： REST,即Representational State Transfer的缩写。我对这个词组的翻译是”表现层状态转化”。 Resource（资源） ：对象的单个实例。 例如，一只动物。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。 集合：对象的集合。 例如，动物。 第三方：使用我们接口的开发者 表现层（Representation） “资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。 状态转化（State Transfer） 访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。 客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。 比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。 URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。 综合上面的解释，我们总结一下什么是RESTful架构： （1）每一个URI代表一种资源； （2）客户端和服务器之间，传递这种资源的某种表现层； （3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。","text":"这篇 文章主要是借鉴他人，但是自己很想总结出一套规范，以供向我这样的新手使用，用来规范代码，如果有什么好的提议，请不吝赐教，本篇文章长期更新！ 一、重要概念： REST,即Representational State Transfer的缩写。我对这个词组的翻译是”表现层状态转化”。 Resource（资源） ：对象的单个实例。 例如，一只动物。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。 集合：对象的集合。 例如，动物。 第三方：使用我们接口的开发者 表现层（Representation） “资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。 状态转化（State Transfer） 访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。 客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。 比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。 URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。 综合上面的解释，我们总结一下什么是RESTful架构： （1）每一个URI代表一种资源； （2）客户端和服务器之间，传递这种资源的某种表现层； （3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。 二、REST接口规范1、动作GET （SELECT）：从服务器检索特定资源，或资源列表。POST （CREATE）：在服务器上创建一个新的资源。PUT （UPDATE）：更新服务器上的资源，提供整个资源。PATCH （UPDATE）：更新服务器上的资源，仅提供更改的属性。DELETE （DELETE）：从服务器删除资源。 首先是四个半种动作：post、delete、put/patch、get因为put/patch只能算作一类，所以将patch归为半个。 另外还有有两个较少知名的HTTP动词：HEAD - 检索有关资源的元数据，例如数据的哈希或上次更新时间。OPTIONS - 检索关于客户端被允许对资源做什么的信息。 2、路径（接口命名）路径又称”终点”（endpoint），表示API的具体网址。 在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。 举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。 接口尽量使用名词，禁止使用动词，下面是一些例子。 12345678GET /zoos：列出所有动物园POST /zoos：新建一个动物园GET /zoos/ID：获取某个指定动物园的信息PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）DELETE /zoos/ID：删除某个动物园GET /zoos/ID/animals：列出某个指定动物园的所有动物DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物 反例： 123/getAllCars/createNewCar/deleteAllRedCars 再比如，某个URI是/posts/show/1，其中show是动词，这个URI就设计错了，正确的写法应该是/posts/1，然后用GET方法表示show。 如果某些动作是HTTP动词表示不了的，你就应该把动作做成一种资源。比如网上汇款，从账户1向账户2汇款500元，错误的URI是： POST /accounts/1/transfer/500/to/2 正确的写法是把动词transfer改成名词transaction，资源不能是动词，但是可以是一种服务： POST /transaction HTTP/1.1 Host: 127.0.0.1 from=1&amp;to=2&amp;amount=500.00 理清资源的层次结构，比如业务针对的范围是学校，那么学校会是一级资源(/school)，老师(/school/teachers)，学生(/school/students)就是二级资源。 3、版本（Versioning）应该将API的版本号放入URL。如： 1https://api.example.com/v1/ 另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。 4、过滤信息（Filtering）如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。下面是一些常见的参数。 1234567?limit=10：指定返回记录的数量?offset=10：指定返回记录的开始位置。?page_number=2&amp;page_size=100：指定第几页，以及每页的记录数。?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。?animal_type_id=1：指定筛选条件参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。 5、状态码（Status Codes）状态码范围 12345671xx 信息，请求收到，继续处理。范围保留用于底层HTTP的东西，你很可能永远也用不到。2xx 成功，行为被成功地接受、理解和采纳3xx 重定向，为了完成请求，必须进一步执行的动作4xx 客户端错误，请求包含语法错误或者请求无法实现。范围保留用于响应客户端做出的错误，例如。他们提供不良数据或要求不存在的东西。这些请求应该是幂等的，而不是更改服务器的状态。5xx 范围的状态码是保留给服务器端错误用的。这些错误常常是从底层的函数抛出来的，甚至开发人员也通常没法处理，发送这类状态码的目的以确保客户端获得某种响应。当收到5xx响应时，客户端不可能知道服务器的状态，所以这类状态码是要尽可能的避免。 服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。 123456789101112131415200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）204 NO CONTENT - [DELETE]：用户删除数据成功。400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。502 网关错误503 Service Unavailable504 网关超时 参考资料： RESTful API 设计指南–阮一峰：http://www.ruanyifeng.com/blog/2014/05/restful_api.html","categories":[{"name":"Restful","slug":"Restful","permalink":"http://blog.alterem.top/categories/Restful/"},{"name":"Java","slug":"Restful/Java","permalink":"http://blog.alterem.top/categories/Restful/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.alterem.top/tags/Java/"},{"name":"Restful","slug":"Restful","permalink":"http://blog.alterem.top/tags/Restful/"}]},{"title":"String拼接操作”+”的优化","slug":"String拼接操作”-”的优化","date":"2019-06-12T05:19:47.000Z","updated":"2019-06-12T05:26:18.201Z","comments":true,"path":"2019/06/12/String拼接操作”-”的优化/","link":"","permalink":"http://blog.alterem.top/2019/06/12/String拼接操作”-”的优化/","excerpt":"很多讲Java优化的文章都会强调对String拼接的优化。倒不用特意记，本质上在于对不可变类优势和劣势的理解上。 需要关注的是编译器对String拼接做出的优化，在简单场景下的性能能够与StringBuilder相当，复杂场景下仍然有较大的性能问题。网上关于这一问题讲的非常乱；如果我讲的有什么纰漏，也欢迎指正。 本文用到了反编译工具jad。在查阅网上关于String拼接操作的优化时发现了这个工具，能同时反编译出来源码和字节码，亲测好用，点我下载。","text":"很多讲Java优化的文章都会强调对String拼接的优化。倒不用特意记，本质上在于对不可变类优势和劣势的理解上。 需要关注的是编译器对String拼接做出的优化，在简单场景下的性能能够与StringBuilder相当，复杂场景下仍然有较大的性能问题。网上关于这一问题讲的非常乱；如果我讲的有什么纰漏，也欢迎指正。 本文用到了反编译工具jad。在查阅网上关于String拼接操作的优化时发现了这个工具，能同时反编译出来源码和字节码，亲测好用，点我下载。 String拼接的性能问题优化之前，每次用”+”拼接，都会生成一个新的String。特别在循环拼接字符串的场景下，性能损失是极其严重的： 空间浪费：每次拼接的结果都需要创建新的不可变类 时间浪费：创建的新不可变类需要初始化；产生大量“短命”垃圾，影响 young gc甚至full gc 所谓简单场景 简单场景和复杂场景是我乱起的名字，帮助理解编译器的优化方案。 简单场景可理解为在一句中完成拼接： 123int i = 0;String sentence = “Hello” + “world” + String.valueOf(i) + “\\n”;System.out.println(sentence); 利用jad可看到优化结果： 123int i = 0;String sentence = (new StringBuilder()).append(“Hello”).append(“world”).append(String.valueOf(i)).append(“\\n”).toString();System.out.println(sentence); 是不是很神奇，竟然把String的拼接操作优化成了StringBuilder#append()！ 此时，可以认为已经将简单场景的空间性能、时间性能优化到最优（仅针对String拼接操作而言），看起来编译器已经完成了必要的优化。你可以测试一下，简单场景下的性能能够与StringBuilder相当。但是——“但是”以前的都是废话——编译器的优化对于复杂场景的帮助却很有限了。 所谓复杂场景所谓复杂场景，可理解为“编译器不确定（或很难确定，于是不做分析）要进行多少次字符串拼接后才需要转换回String”。可能表述不准确，理解个大概就好。 我们分析一个最简单的复杂场景： 12345String sentence = “”;for (int i = 0; i &lt; 10000000; i++) &#123; sentence += “Hello” + “world” + String.valueOf(i) + “\\n”;&#125;System.out.println(sentence); 理想的优化方案当然，无论什么场景，程序猿都可以手动优化： 在性能敏感的场景使用StringBuilder完成拼接。 在性能不敏感的场景使用更方便的String。 PS：别吐槽，这样的API设计是合理的，在合适的地方做合适的事。 理想目标是把这件事交给javac和JIT： 设定一个拼接次数的阈值，超过阈值就启动优化（对于javac有一个编译期的阈值，JIT有一个运行期的阈值，以分阶段优化）。 优化时，在拼接前生成StringBuilder对象，将拼接操作换成StringBuilder#append()，继续使用该对象，直至“需要”String对象时，使用StringBuilder#toString()“懒加载”新的String对象。 该优化方案的难度在于代码分析：机器很难知道到底何时“需要”String对象，所以也很难在合适的位置注入代码完成“懒加载”。 虽然很难实现，但还是给出理想的优化结果，以供实际方案对比： 1234567String sentence = “”;StringBuilder sentenceSB = new StringBuilder(sentence);for (int i = 0; i &lt; 10000000; i++) &#123; sentenceSB.append(“Hello”).append(“world”).append(String.valueOf(i)).append(“\\n”);&#125;sentence = sentenceSB.toString();System.out.println(sentence); 实际的优化方案利用jad查看实际的优化结果： 12345String sentence = “”;for (int i = 0; i &lt; 10000000; i++) &#123; sentence = (new StringBuilder()).append(sentence).append(“Hello”).append(“world”).append(String.valueOf(i)).append(“\\n”).toString();&#125;System.out.println(sentence); 可以看到，实际上编译器的优化只能达到简单场景的最优：仅优化字符串拼接的一句。这种优化程度，对于上述复杂场景的性能提升很有限，循环时还是会生成大量短命垃圾，特别是字符串拼接到很大的时候，空间和时间上都是致命的。 通过对理想方案的分析，我们也能理解编译器优化的无奈之处：编译器无法（或很难）通过代码分析判断何时是最晚进行懒加载的时机。为什么呢？我们将代码换个形式可能更容易理解： 12345String sentence = “”;for (int i = 0; i &lt; 10000000; i++) &#123; sentence = sentence + “Hello” + “world” + String.valueOf(i) + “\\n”;&#125;System.out.println(sentence); 观察第3行的代码，等式右侧引用了sentence。我肉眼知道这句话只完成了字符串拼接，机器呢？最起码，现在的机器还很难通过代码判断。 待以后将人工智能与编译优化结合起来，就算只能以90%的概率完成优化，也是非常cool的。 总结这个问题我没有做性能测试。其实也没必要过于深究，与其让编译器以隐晦的方式完成优化，不如用代码进行主动、清晰的优化，让代码能够“自解释”。 那么，如果需要优化，使用StringBuilder吧。","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.alterem.top/categories/Java/"},{"name":"String","slug":"Java/String","permalink":"http://blog.alterem.top/categories/Java/String/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.alterem.top/tags/Java/"},{"name":"String","slug":"String","permalink":"http://blog.alterem.top/tags/String/"}]},{"title":"使用BigDecimal进行精确运算","slug":"使用BigDecimal进行精确运算","date":"2019-06-12T04:57:10.000Z","updated":"2019-06-12T04:58:38.740Z","comments":true,"path":"2019/06/12/使用BigDecimal进行精确运算/","link":"","permalink":"http://blog.alterem.top/2019/06/12/使用BigDecimal进行精确运算/","excerpt":"首先我们先来看如下代码示例： 123456789public class Test_1 &#123; public static void main(String[] args) &#123; System.out.println(0.06+0.01); System.out.println(1.0-0.42); System.out.println(4.015*100); System.out.println(303.1/1000); &#125; &#125; 运行结果如下。 ​ 0.06999999999999999 ​ 0.5800000000000001 ​ 401.49999999999994 ​ 0.30310000000000004 ​ 你认为你看错了，但结果却是是这样的。问题在哪里呢？原因在于我们的计算机是二进制的。浮点数没有办法是用二进制进行精确表示。我们的CPU表示浮点数由两个部分组成：指数和尾数，这样的表示方法一般都会失去一定的精确度，有些浮点数运算也会产生一定的误差。如：2.4的二进制表示并非就是精确的2.4。反而最为接近的二进制表示是 2.3999999999999999。浮点数的值实际上是由一个特定的数学公式计算得到的。","text":"首先我们先来看如下代码示例： 123456789public class Test_1 &#123; public static void main(String[] args) &#123; System.out.println(0.06+0.01); System.out.println(1.0-0.42); System.out.println(4.015*100); System.out.println(303.1/1000); &#125; &#125; 运行结果如下。 ​ 0.06999999999999999 ​ 0.5800000000000001 ​ 401.49999999999994 ​ 0.30310000000000004 ​ 你认为你看错了，但结果却是是这样的。问题在哪里呢？原因在于我们的计算机是二进制的。浮点数没有办法是用二进制进行精确表示。我们的CPU表示浮点数由两个部分组成：指数和尾数，这样的表示方法一般都会失去一定的精确度，有些浮点数运算也会产生一定的误差。如：2.4的二进制表示并非就是精确的2.4。反而最为接近的二进制表示是 2.3999999999999999。浮点数的值实际上是由一个特定的数学公式计算得到的。 ​ 其实java的float只能用来进行科学计算或工程计算，在大多数的商业计算中，一般采用java.math.BigDecimal类来进行精确计算。 ​ 在使用BigDecimal类来进行计算的时候，主要分为以下步骤： ​ 1、用float或者double变量构建BigDecimal对象。 ​ 2、通过调用BigDecimal的加，减，乘，除等相应的方法进行算术运算。 ​ 3、把BigDecimal对象转换成float，double，int等类型。 ​ 一般来说，可以使用BigDecimal的构造方法或者静态方法的valueOf()方法把基本类型的变量构建成BigDecimal对象。 12BigDecimal b1 = new BigDecimal(Double.toString(0.48));BigDecimal b2 = BigDecimal.valueOf(0.48); 对于常用的加，减，乘，除，BigDecimal类提供了相应的成员方法。 1234public BigDecimal add(BigDecimal value); //加法public BigDecimal subtract(BigDecimal value); //减法 public BigDecimal multiply(BigDecimal value); //乘法public BigDecimal divide(BigDecimal value); //除法 进行相应的计算后，我们可能需要将BigDecimal对象转换成相应的基本数据类型的变量，可以使用floatValue()，doubleValue()等方法。 ​ 下面是一个工具类，该工具类提供加，减，乘，除运算。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Arith &#123; /** * 提供精确加法计算的add方法 * @param value1 被加数 * @param value2 加数 * @return 两个参数的和 */ public static double add(double value1,double value2)&#123; BigDecimal b1 = new BigDecimal(Double.valueOf(value1)); BigDecimal b2 = new BigDecimal(Double.valueOf(value2)); return b1.add(b2).doubleValue(); &#125; /** * 提供精确减法运算的sub方法 * @param value1 被减数 * @param value2 减数 * @return 两个参数的差 */ public static double sub(double value1,double value2)&#123; BigDecimal b1 = new BigDecimal(Double.valueOf(value1)); BigDecimal b2 = new BigDecimal(Double.valueOf(value2)); return b1.subtract(b2).doubleValue(); &#125; /** * 提供精确乘法运算的mul方法 * @param value1 被乘数 * @param value2 乘数 * @return 两个参数的积 */ public static double mul(double value1,double value2)&#123; BigDecimal b1 = new BigDecimal(Double.valueOf(value1)); BigDecimal b2 = new BigDecimal(Double.valueOf(value2)); return b1.multiply(b2).doubleValue(); &#125; /** * 提供精确的除法运算方法div * @param value1 被除数 * @param value2 除数 * @param scale 精确范围 * @return 两个参数的商 * @throws IllegalAccessException */ public static double div(double value1,double value2,int scale) throws IllegalAccessException&#123; //如果精确范围小于0，抛出异常信息 if(scale&lt;0)&#123; throw new IllegalAccessException(\"精确度不能小于0\"); &#125; BigDecimal b1 = new BigDecimal(Double.valueOf(value1)); BigDecimal b2 = new BigDecimal(Double.valueOf(value2)); return b1.divide(b2, scale).doubleValue(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.alterem.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.alterem.top/tags/Java/"}]},{"title":"Java开发人员最常犯的10个错误","slug":"Java开发人员最常犯的10个错误","date":"2019-06-12T04:53:33.000Z","updated":"2019-06-12T05:27:28.175Z","comments":true,"path":"2019/06/12/Java开发人员最常犯的10个错误/","link":"","permalink":"http://blog.alterem.top/2019/06/12/Java开发人员最常犯的10个错误/","excerpt":"一、把数组转成 ArrayList为了将数组转换为ArrayList，开发者经常会这样做： 1List&lt;String&gt; list = Arrays.asList(arr); 使用 Arrays.asList()方法可以得到一个ArrayList，但是得到这个 ArrayList其实是定义在Arrays类中的一个私有的静态内部类。这个类虽然和 java.util.ArrayList同名，但是并不是同一个类。 java.util.Arrays.ArrayList类中实现了 set(), get(), contains()等方法，但是并没有定义向其中增加元素的方法。也就是说通过 Arrays.asList()得到的ArrayList的大小是固定的。 如果在开发过程中，想得到一个真正的ArrayList对象（ java.util.ArrayList的实例），可以通过以下方式： 1ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(Arrays.asList(arr)); ` java.util.ArrayList`中包含一个可以接受集合类型参数的构造函数。因为 ` java.util.Arrays.ArrayList`这个内部类继承了AbstractList类，所以，该类也是Collection的子类。","text":"一、把数组转成 ArrayList为了将数组转换为ArrayList，开发者经常会这样做： 1List&lt;String&gt; list = Arrays.asList(arr); 使用 Arrays.asList()方法可以得到一个ArrayList，但是得到这个 ArrayList其实是定义在Arrays类中的一个私有的静态内部类。这个类虽然和 java.util.ArrayList同名，但是并不是同一个类。 java.util.Arrays.ArrayList类中实现了 set(), get(), contains()等方法，但是并没有定义向其中增加元素的方法。也就是说通过 Arrays.asList()得到的ArrayList的大小是固定的。 如果在开发过程中，想得到一个真正的ArrayList对象（ java.util.ArrayList的实例），可以通过以下方式： 1ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(Arrays.asList(arr)); ` java.util.ArrayList`中包含一个可以接受集合类型参数的构造函数。因为 ` java.util.Arrays.ArrayList`这个内部类继承了AbstractList类，所以，该类也是Collection的子类。 二、判断一个数组是否包含某个值在判断一个数组中是否包含某个值的时候，开发者经常这样做： 12Set&lt;String&gt; set = new HashSet&lt;String&gt;(Arrays.asList(arr));return set.contains(targetValue); 在在Java中如何高效的判断数组中是否包含某个元素一文中，深入分析过，以上方式虽然可以实现功能，但是效率却比较低。因为将数组压入Collection类型中，首先要将数组元素遍历一遍，然后再使用集合类做其他操作。 在判断一个数组是否包含某个值的时候，推荐使用for循环遍历的形式或者使用Apache Commons类库中提供的 ArrayUtils类的 contains方法。 三、在循环中删除列表中的元素在讨论这个问题之前，先考虑以下代码的输出结果： 12345ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(\"a\",\"b\",\"c\",\"d\"));for(int i=0;i&lt;list.size();i++)&#123; list.remove(i);&#125;System.out.println(list); 输出结果： 1[b,d] 以上代码的目的是想遍历删除list中所有元素，但是结果却没有成功。原因是忽略了一个关键的问题：当一个元素被删除时，列表的大小缩小并且下标也会随之变化，所以当你想要在一个循环中用下标删除多个元素的时候，它并不会正常的生效。 也有些人知道以上代码的问题就由于数组下标变换引起的。所以，他们想到使用增强for循环的形式： 123456ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(\"a\",\"b\",\"c\",\"d\"));for(String s:list)&#123; if(s.equals(\"a\"))&#123; list.remove(s); &#125;&#125; 但是，很不幸的是，以上代码会抛出 ConcurrentModificationException，有趣的是，如果在remove操作后增加一个break，代码就不会报错： 1234567ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(\"a\",\"b\",\"c\",\"d\"));for(String s:list)&#123; if(s.equals(\"a\"))&#123; list.remove(s); break; &#125;&#125; 在Java中的fail-fast机制一文中，深入分析了几种在遍历数组的同时删除其中元素的方法以及各种方法存在的问题。其中就介绍了上面的代码出错的原因。 迭代器（Iterator）是工作在一个独立的线程中，并且拥有一个 mutex 锁。 迭代器被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变，所以当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则 迭代器会马上抛出 java.util.ConcurrentModificationException 异常。 所以，正确的在遍历过程中删除元素的方法应该是使用Iterator： 123456789ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(\"a\", \"b\", \"c\", \"d\"));Iterator&lt;String&gt; iter = list.iterator();while (iter.hasNext()) &#123; String s = iter.next(); if (s.equals(\"a\")) &#123; iter.remove(); &#125;&#125; ` next()`方法必须在调用 ` remove()`方法之前调用。如果在循环过程中先调用 ` remove()`，再调用 ` next()`，就会导致异常 ` ConcurrentModificationException`。原因如上。 四、HashTable 和 HashMap 的选择了解算法的人可能对HashTable比较熟悉，因为他是一个数据结构的名字。但在Java里边，用HashMap来表示这样的数据结构。Hashtable和 HashMap的一个关键性的不同是，HashTable是同步的，而HashMap不是。所以通常不需要HashTable，HashMap用的更多。 HashMap完全解读、Java中常见亲属比较等文章中介绍了他们的区别和如何选择。 五、使用原始集合类型在Java里边，原始类型和无界通配符类型很容易混合在一起。以Set为例，Set是一个原始类型，而Set&lt; ? &gt;是一个无界通配符类型。 （可以把原始类型理解为没有使用泛型约束的类型） 考虑下面使用原始类型List作为参数的代码： 12345678public static void add(List list, Object o)&#123; list.add(o);&#125;public static void main(String[] args)&#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); add(list, 10); String s = list.get(0);&#125; 上面的代码将会抛出异常： ` java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String` 使用原始集合类型是很危险的，因为原始集合类型跳过了泛型类型检查，是不安全的。Set、Set&lt; ? &gt;和Set&lt; Object &gt;之间有很大差别。关于泛型，可以参考下列文章：《成神之路-基础篇》Java基础知识——泛型 六、访问级别程序员们经常使用 public作为类中的字段的修饰符，因为这样可以很简单的通过引用得到值，但这并不是好的设计，按照经验，分配给成员变量的访问级别应该尽可能的低。参考Java中的四种访问级别 七、 ArrayList与 LinkedList的选择当程序员们不知道 ArrayList与 LinkedList的区别时，他们经常使用ArrayList，因为它看起来比较熟悉。然而，它们之前有巨大的性能差别。在ArrayList vs LinkedList vs Vector 区别、Java中常见亲属比较等文章中介绍过，简而言之，如果有大量的增加删除操作并且没有很多的随机访问元素的操作，应该首先 LinkedList。（ LinkedList更适合从中间插入或者删除（链表的特性）） 八、可变与不可变在为什么Java要把字符串设计成不可变的一文中介绍过，不可变对象有许多的优点，比如简单，安全等等。同时，也有人提出疑问：既然不可变有这么多好处，为什么不把所有类都搞成不可变的呢？ 通常情况下，可变对象可以用来避免产生过多的中间对象。一个经典的实例就是连接大量的字符串，如果使用不可变的字符串，将会产生大量的需要进行垃圾回收的对象。这会浪费CPU大量的时间，使用可变对象才是正确的方案(比如 StringBuilder)。 1234String result=\"\";for(String s: arr)&#123; result = result + s;&#125; StackOverflow中也有关于这个的讨论。 九、父类和子类的构造函数上图的代码中有两处编译时错误，原因其实很简单，主要和构造函数有关。首先，我们都知道： 如果一个类没有定义构造函数，编译器将会插入一个无参数的默认构造函数。 如果一个类中定义了一个带参数的构造函数，那么编译器就不会再帮我们创建无参的构造函数。 上面的Super类中定义了一个带参数的构造函数。编译器将不会插入默认的无参数构造函数。 我们还应该知道： 子类的所有构造函数（无论是有参还是无参）在执行时，都会调用父类的无参构造函数。 所以，编译器试图调用Super类中的无参构造函数。但是父类默认的构造函数未定义，编译器就会报出这个错误信息。 要解决这个问题，可以简单的通过 1)在父类中添加一个Super()构造方法，就像这样： public Super(){} 2)移除自定义的父类构造函数 3)在子类的构造函数中调用父类的super(value)。 十、””还是构造函数关于这个问题，也是程序员经常出现困惑的地方，在该如何创建字符串，使用” “还是构造函数？中也介绍过. 如果你只需要创建一个字符串，你可以使用双引号的方式，如果你需要在堆中创建一个新的对象，你可以选择构造函数的方式。 在 String d = new String(&quot;abcd&quot;)时，因为字面值“abcd”已经是字符串类型，那么使用构造函数方式只会创建一个额外没有用处的对象。","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.alterem.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.alterem.top/tags/Java/"}]},{"title":"Redis分布式锁的正确实现方式","slug":"Redis分布式锁的正确实现方式","date":"2019-06-11T16:41:14.000Z","updated":"2019-06-11T16:43:18.582Z","comments":true,"path":"2019/06/12/Redis分布式锁的正确实现方式/","link":"","permalink":"http://blog.alterem.top/2019/06/12/Redis分布式锁的正确实现方式/","excerpt":"前言分布式锁一般有三种实现方式：1. 数据库乐观锁；2. 基于Redis的分布式锁；3. 基于ZooKeeper的分布式锁。本篇博客将介绍第二种方式，基于Redis实现分布式锁。虽然网上已经有各种介绍Redis分布式锁实现的博客，然而他们的实现却有着各种各样的问题，为了避免误人子弟，本篇博客将详细介绍如何正确地实现Redis分布式锁。 可靠性","text":"前言分布式锁一般有三种实现方式：1. 数据库乐观锁；2. 基于Redis的分布式锁；3. 基于ZooKeeper的分布式锁。本篇博客将介绍第二种方式，基于Redis实现分布式锁。虽然网上已经有各种介绍Redis分布式锁实现的博客，然而他们的实现却有着各种各样的问题，为了避免误人子弟，本篇博客将详细介绍如何正确地实现Redis分布式锁。 可靠性 首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件： 互斥性。在任意时刻，只有一个客户端能持有锁。 不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。 具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。 解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。 代码实现组件依赖首先我们要通过Maven引入Jedis开源组件，在pom.xml文件加入下面的代码： 12345&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; 加锁代码正确姿势Talk is cheap, show me the code。先展示代码，再带大家慢慢解释为什么这样实现： 123456789101112131415161718192021222324public class RedisTool &#123; private static final String LOCK_SUCCESS = \"OK\"; private static final String SET_IF_NOT_EXIST = \"NX\"; private static final String SET_WITH_EXPIRE_TIME = \"PX\"; /** * 尝试获取分布式锁 * @param jedis Redis客户端 * @param lockKey 锁 * @param requestId 请求标识 * @param expireTime 超期时间 * @return 是否获取成功 */ public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, int expireTime) &#123; String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime); if (LOCK_SUCCESS.equals(result)) &#123; return true; &#125; return false; &#125;&#125; 可以看到，我们加锁就一行代码：jedis.set(String key, String value, String nxxx, String expx, int time)，这个set()方法一共有五个形参： 第一个为key，我们使用key来当锁，因为key是唯一的。 第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。 第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作； 第四个为expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。 第五个为time，与第四个参数相呼应，代表key的过期时间。 总的来说，执行上面的set()方法就只会导致两种结果： 当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。 已有锁存在，不做任何操作。 心细的童鞋就会发现了，我们的加锁代码满足我们可靠性里描述的三个条件。首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。 最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。由于我们只考虑Redis单机部署的场景，所以容错性我们暂不考虑。 错误示例1比较常见的错误示例就是使用jedis.setnx()和jedis.expire()组合实现加锁，代码如下： 12345678public static void wrongGetLock1(Jedis jedis, String lockKey, String requestId, int expireTime) &#123; Long result = jedis.setnx(lockKey, requestId); if (result == 1) &#123; // 若在这里程序突然崩溃，则无法设置过期时间，将发生死锁 jedis.expire(lockKey, expireTime); &#125;&#125; setnx()方法作用就是SET IF NOT EXIST，expire()方法就是给锁加一个过期时间。乍一看好像和前面的set()方法结果一样，然而由于这是两条Redis命令，不具有原子性，如果程序在执行完setnx()之后突然崩溃，导致锁没有设置过期时间。那么将会发生死锁。网上之所以有人这样实现，是因为低版本的jedis并不支持多参数的set()方法。 错误示例2这一种错误示例就比较难以发现问题，而且实现也比较复杂。实现思路：使用jedis.setnx()命令实现加锁，其中key是锁，value是锁的过期时间。 执行过程： 通过setnx()方法尝试加锁，如果当前锁不存在，返回加锁成功。 如果锁已经存在则获取锁的过期时间，和当前时间比较，如果锁已经过期，则设置新的过期时间，返回加锁成功。 代码如下： 12345678910111213141516171819202122232425public static boolean wrongGetLock2(Jedis jedis, String lockKey, int expireTime) &#123; long expires = System.currentTimeMillis() + expireTime; String expiresStr = String.valueOf(expires); // 如果当前锁不存在，返回加锁成功 if (jedis.setnx(lockKey, expiresStr) == 1) &#123; return true; &#125; // 如果锁存在，获取锁的过期时间 String currentValueStr = jedis.get(lockKey); if (currentValueStr != null &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis()) &#123; // 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间 String oldValueStr = jedis.getSet(lockKey, expiresStr); if (oldValueStr != null &amp;&amp; oldValueStr.equals(currentValueStr)) &#123; // 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才有权利加锁 return true; &#125; &#125; // 其他情况，一律返回加锁失败 return false;&#125; 那么这段代码问题在哪里？1. 由于是客户端自己生成过期时间，所以需要强制要求分布式下每个客户端的时间必须同步。 2. 当锁过期的时候，如果多个客户端同时执行jedis.getSet()方法，那么虽然最终只有一个客户端可以加锁，但是这个客户端的锁的过期时间可能被其他客户端覆盖。3. 锁不具备拥有者标识，即任何客户端都可以解锁。 解锁代码正确姿势还是先展示代码，再带大家慢慢解释为什么这样实现： 123456789101112131415161718192021222324public class RedisTool &#123; private static final Long RELEASE_SUCCESS = 1L; /** * 释放分布式锁 * @param jedis Redis客户端 * @param lockKey 锁 * @param requestId 请求标识 * @return 是否释放成功 */ public static boolean releaseDistributedLock(Jedis jedis, String lockKey, String requestId) &#123; String script = \"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end\"; Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId)); if (RELEASE_SUCCESS.equals(result)) &#123; return true; &#125; return false; &#125;&#125; 可以看到，我们解锁只需要两行代码就搞定了！第一行代码，我们写了一个简单的Lua脚本代码，上一次见到这个编程语言还是在《黑客与画家》里，没想到这次居然用上了。第二行代码，我们将Lua代码传到jedis.eval()方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。eval()方法是将Lua代码交给Redis服务端执行。 那么这段Lua代码的功能是什么呢？其实很简单，首先获取锁对应的value值，检查是否与requestId相等，如果相等则删除锁（解锁）。那么为什么要使用Lua语言来实现呢？因为要确保上述操作是原子性的。关于非原子性会带来什么问题，可以阅读【解锁代码-错误示例2】 。那么为什么执行eval()方法可以确保原子性，源于Redis的特性，下面是官网对eval命令的部分解释： 简单来说，就是在eval命令执行Lua代码的时候，Lua代码将被当成一个命令去执行，并且直到eval命令执行完成，Redis才会执行其他命令。 错误示例1最常见的解锁代码就是直接使用jedis.del()方法删除锁，这种不先判断锁的拥有者而直接解锁的方式，会导致任何客户端都可以随时进行解锁，即使这把锁不是它的。 123public static void wrongReleaseLock1(Jedis jedis, String lockKey) &#123; jedis.del(lockKey);&#125; 错误示例2这种解锁代码乍一看也是没问题，甚至我之前也差点这样实现，与正确姿势差不多，唯一区别的是分成两条命令去执行，代码如下： 123456789public static void wrongReleaseLock2(Jedis jedis, String lockKey, String requestId) &#123; // 判断加锁与解锁是不是同一个客户端 if (requestId.equals(jedis.get(lockKey))) &#123; // 若在此时，这把锁突然不是这个客户端的，则会误解锁 jedis.del(lockKey); &#125;&#125; 如代码注释，问题在于如果调用jedis.del()方法的时候，这把锁已经不属于当前客户端的时候会解除他人加的锁。那么是否真的有这种场景？答案是肯定的，比如客户端A加锁，一段时间之后客户端A解锁，在执行jedis.del()之前，锁突然过期了，此时客户端B尝试加锁成功，然后客户端A再执行del()方法，则将客户端B的锁给解除了。 总结本文主要介绍了如何使用Java代码正确实现Redis分布式锁，对于加锁和解锁也分别给出了两个比较经典的错误示例。其实想要通过Redis实现分布式锁并不难，只要保证能满足可靠性里的四个条件。互联网虽然给我们带来了方便，只要有问题就可以google，然而网上的答案一定是对的吗？其实不然，所以我们更应该时刻保持着质疑精神，多想多验证。 如果你的项目中Redis是多机部署的，那么可以尝试使用Redisson实现分布式锁，这是Redis官方提供的Java组件。","categories":[{"name":"Redis","slug":"Redis","permalink":"http://blog.alterem.top/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://blog.alterem.top/tags/Redis/"}]},{"title":"brew安装常用软件","slug":"brew安装常用软件","date":"2019-06-11T16:28:40.000Z","updated":"2019-06-11T16:53:22.843Z","comments":true,"path":"2019/06/12/brew安装常用软件/","link":"","permalink":"http://blog.alterem.top/2019/06/12/brew安装常用软件/","excerpt":"1 安装mysql a) brew install mysql 安装完后会提示： To have launchd start mysql now and restart at login: brew services start mysql Or, if you don’t want/need a background service you can just run: mysql.server start 根据需要选择自己要的 这样就安装完了，执行mysql.server start，服务就起来了，可以用 mysql -uroot 进去看看","text":"1 安装mysql a) brew install mysql 安装完后会提示： To have launchd start mysql now and restart at login: brew services start mysql Or, if you don’t want/need a background service you can just run: mysql.server start 根据需要选择自己要的 这样就安装完了，执行mysql.server start，服务就起来了，可以用 mysql -uroot 进去看看 之前还以为要初始化mysql， 实际上是不用的，那样只是重新在别的地方安装了一个db起来而已 不过密码还是要修改一下 cd /usr/local/opt/mysql/ ./bin/mysql_secure_installation 然后按照提示进行修改密码即可 2 安装redis brew install redis To have launchd start redis now and restart at login: brew services start redis Or, if you don’t want/need a background service you can just run: redis-server /usr/local/etc/redis.conf redis 配置文件的位置/usr/local/etc/redis.conf 3 安装zookeeper brew info zookeeper brew install zookeeper 安装完毕提示： To have launchd start zookeeper now and restart at login: brew services start zookeeper Or, if you don’t want/need a background service you can just run: zkServer start 配置文件地址： /usr/local/etc/zookeeper/zoo.cfg 4 安装activemq brew install activemq To have launchd start activemq now and restart at login: brew services start activemq Or, if you don’t want/need a background service you can just run: activemq start 5 安装nginx brew info nginx brew install nginx 装完以后提示： The default port has been set in /usr/local/etc/nginx/nginx.conf to 8080 so that nginx can run without sudo. nginx will load all files in /usr/local/etc/nginx/servers/. To have launchd start nginx now and restart at login: brew services start nginx Or, if you don’t want/need a background service you can just run: nginx","categories":[{"name":"Mac","slug":"Mac","permalink":"http://blog.alterem.top/categories/Mac/"},{"name":"Homebrew","slug":"Mac/Homebrew","permalink":"http://blog.alterem.top/categories/Mac/Homebrew/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://blog.alterem.top/tags/Mac/"},{"name":"Homebrew","slug":"Homebrew","permalink":"http://blog.alterem.top/tags/Homebrew/"}]},{"title":"Shadowsocks-Go一键安装脚本","slug":"Shadowsocks-Go一键安装脚本","date":"2019-06-11T03:01:44.000Z","updated":"2019-06-11T03:04:29.022Z","comments":true,"path":"2019/06/11/Shadowsocks-Go一键安装脚本/","link":"","permalink":"http://blog.alterem.top/2019/06/11/Shadowsocks-Go一键安装脚本/","excerpt":"本脚本适用环境：系统支持：CentOS，Debian，Ubuntu内存要求：≥128M 关于本脚本：一键安装 Go 版的 shadowsocks 最新版本 1.1.5。据说 go 版本有 buff 。与 Python 版不同的是，其客户端程序能使用多个服务端配置，本脚本安装的是服务端程序。作者默认推荐 aes-128-cfb 加密，基于一致性，脚本使用了 aes-256-cfb 加密方式","text":"本脚本适用环境：系统支持：CentOS，Debian，Ubuntu内存要求：≥128M 关于本脚本：一键安装 Go 版的 shadowsocks 最新版本 1.1.5。据说 go 版本有 buff 。与 Python 版不同的是，其客户端程序能使用多个服务端配置，本脚本安装的是服务端程序。作者默认推荐 aes-128-cfb 加密，基于一致性，脚本使用了 aes-256-cfb 加密方式 默认配置：服务器端口：自己设定（如不设定，默认为 8989）客户端端口：1080密码：自己设定（如不设定，默认为teddysun.com）客户端下载：https://github.com/shadowsocks/shadowsocks-windows/releases使用方法：使用root用户登录，运行以下命令：wget –no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-go.shchmod +x shadowsocks-go.sh./shadowsocks-go.sh 2&gt;&amp;1 | tee shadowsocks-go.log 安装完成后，脚本提示如下：Congratulations, shadowsocks-go install completed!Your Server IP:your_server_ipYour Server Port:your_server_portYour Password:your_passwordYour Local Port:1080Your Encryption Method:aes-256-cfb Welcome to visit:https://teddysun.com/392.htmlEnjoy it! 卸载方法：使用 root 用户登录，运行以下命令：./shadowsocks-go.sh uninstall 其他事项：客户端配置的参考链接：https://teddysun.com/339.html安装完成后即已后台启动 shadowsocks-go ，运行：/etc/init.d/shadowsocks status 可以查看 shadowsocks-go 进程是否已经启动。本脚本安装完成后，已将 shadowsocks-go 加入开机自启动。统一回复：在 Bandwagonhost 的 VPS 上出现 Trace/breakpoint trap 现象的，初步认为是 Bandwagonhost 的系统问题。经过测试发现，和版本升级无关，唯独在 Bandwagonhost 才会出现这个现象。建议换成 libev 版，或者将系统换为 CentOS 7 可以解决该问题。本人不是 Shadowsocks Go 作者，安装程序均来自于这里。使用命令：启动：/etc/init.d/shadowsocks start停止：/etc/init.d/shadowsocks stop重启：/etc/init.d/shadowsocks restart状态：/etc/init.d/shadowsocks status多用户多端口配置文件 sample（2015年01月08日）：配置文件路径：/etc/shadowsocks/config.json{“port_password”:{“8989”:”password0”,“9001”:”password1”,“9002”:”password2”,“9003”:”password3”,“9004”:”password4”},“method”:”aes-256-cfb”,“timeout”:600} 官方版本的 sample ，详见这里。更多版本 Shadowsocks 服务端一键安装脚本：ShadowsocksR 版一键安装脚本（CentOS，Debian，Ubuntu）Shadowsocks Python 版一键安装脚本（CentOS，Debian，Ubuntu）CentOS 下 shadowsocks-libev 一键安装脚本Debian 下 shadowsocks-libev 一键安装脚本 附： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385## go一键安装脚本 ########################################################################!/usr/bin/env bashPATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATH#=================================================================## System Required: CentOS, Debian, Ubuntu ## Description: One click Install Shadowsocks-go server ## Author: Teddysun &lt;i@teddysun.com&gt; ## Thanks: @cyfdecyf &lt;https://twitter.com/cyfdecyf&gt; ## Intro: https://teddysun.com/392.html ##==================================================================clearechoecho \"#############################################################\"echo \"# One click Install Shadowsocks-go server #\"echo \"# Intro: https://teddysun.com/392.html #\"echo \"# Author: Teddysun &lt;i@teddysun.com&gt; #\"echo \"# Github: https://github.com/shadowsocks/shadowsocks-go #\"echo \"#############################################################\"echo#Current foldercur_dir=`pwd`# Make sure only root can run our scriptrootness()&#123; if [[ $EUID -ne 0 ]]; then echo \"Error:This script must be run as root!\" 1&gt;&amp;2 exit 1 fi&#125;#Check systemcheck_sys()&#123; local checkType=$1 local value=$2 local release='' local systemPackage='' if [[ -f /etc/redhat-release ]]; then release=\"centos\" systemPackage=\"yum\" elif cat /etc/issue | grep -q -E -i \"debian\"; then release=\"debian\" systemPackage=\"apt\" elif cat /etc/issue | grep -q -E -i \"ubuntu\"; then release=\"ubuntu\" systemPackage=\"apt\" elif cat /etc/issue | grep -q -E -i \"centos|red hat|redhat\"; then release=\"centos\" systemPackage=\"yum\" elif cat /proc/version | grep -q -E -i \"debian\"; then release=\"debian\" systemPackage=\"apt\" elif cat /proc/version | grep -q -E -i \"ubuntu\"; then release=\"ubuntu\" systemPackage=\"apt\" elif cat /proc/version | grep -q -E -i \"centos|red hat|redhat\"; then release=\"centos\" systemPackage=\"yum\" fi if [[ $&#123;checkType&#125; == \"sysRelease\" ]]; then if [ \"$value\" == \"$release\" ]; then return 0 else return 1 fi elif [[ $&#123;checkType&#125; == \"packageManager\" ]]; then if [ \"$value\" == \"$systemPackage\" ]; then return 0 else return 1 fi fi&#125;# Get versiongetversion()&#123; if [[ -s /etc/redhat-release ]]; then grep -oE \"[0-9.]+\" /etc/redhat-release else grep -oE \"[0-9.]+\" /etc/issue fi&#125;# CentOS versioncentosversion()&#123; if check_sys sysRelease centos; then local code=$1 local version=\"$(getversion)\" local main_ver=$&#123;version%%.*&#125; if [ \"$main_ver\" == \"$code\" ]; then return 0 else return 1 fi else return 1 fi&#125;# is 64bit or notis_64bit()&#123; if [ `getconf WORD_BIT` = '32' ] &amp;&amp; [ `getconf LONG_BIT` = '64' ] ; then return 0 else return 1 fi&#125;# Disable selinuxdisable_selinux()&#123; if [ -s /etc/selinux/config ] &amp;&amp; grep 'SELINUX=enforcing' /etc/selinux/config; then sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/selinux/config setenforce 0 fi&#125;get_ip()&#123; local IP=$( ip addr | egrep -o '[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;' | egrep -v \"^192\\.168|^172\\.1[6-9]\\.|^172\\.2[0-9]\\.|^172\\.3[0-2]\\.|^10\\.|^127\\.|^255\\.|^0\\.\" | head -n 1 ) [ -z $&#123;IP&#125; ] &amp;&amp; IP=$( wget -qO- -t1 -T2 ipv4.icanhazip.com ) [ -z $&#123;IP&#125; ] &amp;&amp; IP=$( wget -qO- -t1 -T2 ipinfo.io/ip ) [ ! -z $&#123;IP&#125; ] &amp;&amp; echo $&#123;IP&#125; || echo&#125;# Pre-installation settingspre_install()&#123; if ! check_sys packageManager yum &amp;&amp; ! check_sys packageManager apt; then echo \"Error: Your OS is not supported. please change OS to CentOS/Debian/Ubuntu and try again.\" exit 1 fi # Set shadowsocks-go config password echo \"Please input password for shadowsocks-go:\" read -p \"(Default password: teddysun.com):\" shadowsockspwd [ -z \"$&#123;shadowsockspwd&#125;\" ] &amp;&amp; shadowsockspwd=\"teddysun.com\" echo echo \"---------------------------\" echo \"password = $&#123;shadowsockspwd&#125;\" echo \"---------------------------\" echo # Set shadowsocks-go config port while true do echo -e \"Please input port for shadowsocks-go [1-65535]:\" read -p \"(Default port: 8989):\" shadowsocksport [ -z \"$&#123;shadowsocksport&#125;\" ] &amp;&amp; shadowsocksport=\"8989\" expr $&#123;shadowsocksport&#125; + 0 &amp;&gt;/dev/null if [ $? -eq 0 ]; then if [ $&#123;shadowsocksport&#125; -ge 1 ] &amp;&amp; [ $&#123;shadowsocksport&#125; -le 65535 ]; then echo echo \"---------------------------\" echo \"port = $&#123;shadowsocksport&#125;\" echo \"---------------------------\" echo break else echo \"Input error, please input correct number\" fi else echo \"Input error, please input correct number\" fi done get_char()&#123; SAVEDSTTY=`stty -g` stty -echo stty cbreak dd if=/dev/tty bs=1 count=1 2&gt; /dev/null stty -raw stty echo stty $SAVEDSTTY &#125; echo echo \"Press any key to start...or Press Ctrl+C to cancel\" char=`get_char` #Install necessary dependencies if check_sys packageManager yum; then yum install -y wget unzip gzip curl elif check_sys packageManager apt; then apt-get -y update apt-get install -y wget unzip gzip curl fi echo&#125;# Download shadowsocks-godownload_files()&#123; cd $&#123;cur_dir&#125; if is_64bit; then if ! wget --no-check-certificate -c https://github.com/shadowsocks/shadowsocks-go/releases/download/1.1.5/shadowsocks-server-linux64-1.1.5.gz; then echo \"Failed to download shadowsocks-server-linux64-1.1.5.gz\" exit 1 fi gzip -d shadowsocks-server-linux64-1.1.5.gz if [ $? -eq 0 ]; then echo \"Decompress shadowsocks-server-linux64-1.1.5.gz success.\" else echo \"Decompress shadowsocks-server-linux64-1.1.5.gz failed! Please check gzip command.\" exit 1 fi mv -f shadowsocks-server-linux64-1.1.5 /usr/bin/shadowsocks-server else if ! wget --no-check-certificate -c https://github.com/shadowsocks/shadowsocks-go/releases/download/1.1.5/shadowsocks-server-linux32-1.1.5.gz; then echo \"Failed to download shadowsocks-server-linux32-1.1.5.gz\" exit 1 fi gzip -d shadowsocks-server-linux32-1.1.5.gz if [ $? -eq 0 ]; then echo \"Decompress shadowsocks-server-linux32-1.1.5.gz success.\" else echo \"Decompress shadowsocks-server-linux32-1.1.5.gz failed! Please check gzip command.\" exit 1 fi mv -f shadowsocks-server-linux32-1.1.5 /usr/bin/shadowsocks-server fi # Download start script if check_sys packageManager yum; then if ! wget --no-check-certificate -O /etc/init.d/shadowsocks https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-go; then echo \"Failed to download shadowsocks-go auto start script!\" exit 1 fi elif check_sys packageManager apt; then if ! wget --no-check-certificate -O /etc/init.d/shadowsocks https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-go-debian; then echo \"Failed to download shadowsocks-go auto start script!\" exit 1 fi fi&#125;# Config shadowsocksconfig_shadowsocks()&#123; if [ ! -d /etc/shadowsocks ]; then mkdir -p /etc/shadowsocks fi cat &gt; /etc/shadowsocks/config.json&lt;&lt;-EOF&#123; \"server\":\"0.0.0.0\", \"server_port\":$&#123;shadowsocksport&#125;, \"local_port\":1080, \"password\":\"$&#123;shadowsockspwd&#125;\", \"method\":\"aes-256-cfb\", \"timeout\":600&#125;EOF&#125;# Firewall setfirewall_set()&#123; echo \"firewall set start...\" if centosversion 6; then /etc/init.d/iptables status &gt; /dev/null 2&gt;&amp;1 if [ $? -eq 0 ]; then iptables -L -n | grep -i $&#123;shadowsocksport&#125; &gt; /dev/null 2&gt;&amp;1 if [ $? -ne 0 ]; then iptables -I INPUT -m state --state NEW -m tcp -p tcp --dport $&#123;shadowsocksport&#125; -j ACCEPT iptables -I INPUT -m state --state NEW -m udp -p udp --dport $&#123;shadowsocksport&#125; -j ACCEPT /etc/init.d/iptables save /etc/init.d/iptables restart else echo \"port $&#123;shadowsocksport&#125; has been set up.\" fi else echo \"WARNING: iptables looks like shutdown or not installed, please manually set it if necessary.\" fi elif centosversion 7; then systemctl status firewalld &gt; /dev/null 2&gt;&amp;1 if [ $? -eq 0 ]; then firewall-cmd --permanent --zone=public --add-port=$&#123;shadowsocksport&#125;/tcp firewall-cmd --permanent --zone=public --add-port=$&#123;shadowsocksport&#125;/udp firewall-cmd --reload else echo \"Firewalld looks like not running, try to start...\" systemctl start firewalld if [ $? -eq 0 ]; then firewall-cmd --permanent --zone=public --add-port=$&#123;shadowsocksport&#125;/tcp firewall-cmd --permanent --zone=public --add-port=$&#123;shadowsocksport&#125;/udp firewall-cmd --reload else echo \"WARNING: Try to start firewalld failed. please enable port $&#123;shadowsocksport&#125; manually if necessary.\" fi fi fi echo \"firewall set completed...\"&#125;# Install Shadowsocks-goinstall()&#123; if [ -s /usr/bin/shadowsocks-server ]; then echo \"shadowsocks-go install success!\" chmod +x /usr/bin/shadowsocks-server chmod +x /etc/init.d/shadowsocks if check_sys packageManager yum; then chkconfig --add shadowsocks chkconfig shadowsocks on elif check_sys packageManager apt; then update-rc.d -f shadowsocks defaults fi /etc/init.d/shadowsocks start if [ $? -eq 0 ]; then echo \"Shadowsocks-go start success!\" else echo \"Shadowsocks-go start failed!\" fi else echo echo \"Shadowsocks-go install failed!\" exit 1 fi clear echo echo \"Congratulations, Shadowsocks-go install completed!\" echo -e \"Your Server IP: \\033[41;37m $(get_ip) \\033[0m\" echo -e \"Your Server Port: \\033[41;37m $&#123;shadowsocksport&#125; \\033[0m\" echo -e \"Your Password: \\033[41;37m $&#123;shadowsockspwd&#125; \\033[0m\" echo -e \"Your Local Port: \\033[41;37m 1080 \\033[0m\" echo -e \"Your Encryption Method: \\033[41;37m aes-256-cfb \\033[0m\" echo echo \"Welcome to visit:https://teddysun.com/392.html\" echo \"Enjoy it!\" echo&#125;# Uninstall Shadowsocks-gouninstall_shadowsocks_go()&#123; printf \"Are you sure uninstall shadowsocks-go? (y/n) \" printf \"\\n\" read -p \"(Default: n):\" answer [ -z $&#123;answer&#125; ] &amp;&amp; answer=\"n\" if [ \"$&#123;answer&#125;\" == \"y\" ] || [ \"$&#123;answer&#125;\" == \"Y\" ]; then ps -ef | grep -v grep | grep -i \"shadowsocks-server\" &gt; /dev/null 2&gt;&amp;1 if [ $? -eq 0 ]; then /etc/init.d/shadowsocks stop fi if check_sys packageManager yum; then chkconfig --del shadowsocks elif check_sys packageManager apt; then update-rc.d -f shadowsocks remove fi # delete config file rm -rf /etc/shadowsocks # delete shadowsocks rm -f /etc/init.d/shadowsocks rm -f /usr/bin/shadowsocks-server echo \"Shadowsocks-go uninstall success!\" else echo echo \"Uninstall cancelled, nothing to do...\" echo fi&#125;# Install Shadowsocks-goinstall_shadowsocks_go()&#123; rootness disable_selinux pre_install download_files config_shadowsocks if check_sys packageManager yum; then firewall_set fi install&#125;# Initialization stepaction=$1[ -z $1 ] &amp;&amp; action=installcase \"$action\" in install|uninstall) $&#123;action&#125;_shadowsocks_go ;; *) echo \"Arguments error! [$&#123;action&#125;]\" echo \"Usage: `basename $0` &#123;install|uninstall&#125;\" ;;esac","categories":[{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"http://blog.alterem.top/categories/Shadowsocks/"}],"tags":[{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"http://blog.alterem.top/tags/Shadowsocks/"}]},{"title":"Java根据URL将网页转存为PDF文件","slug":"Java根据URL将网页转存为PDF文件","date":"2019-06-10T10:58:55.000Z","updated":"2019-06-10T11:03:00.561Z","comments":true,"path":"2019/06/10/Java根据URL将网页转存为PDF文件/","link":"","permalink":"http://blog.alterem.top/2019/06/10/Java根据URL将网页转存为PDF文件/","excerpt":"开始添加以下依赖： 123456&lt;!-- url转pdf --&gt;&lt;dependency&gt; &lt;groupId&gt;org.xhtmlrenderer&lt;/groupId&gt; &lt;artifactId&gt;flying-saucer-pdf-itext5&lt;/artifactId&gt; &lt;version&gt;9.0.3&lt;/version&gt;&lt;/dependency&gt;","text":"开始添加以下依赖： 123456&lt;!-- url转pdf --&gt;&lt;dependency&gt; &lt;groupId&gt;org.xhtmlrenderer&lt;/groupId&gt; &lt;artifactId&gt;flying-saucer-pdf-itext5&lt;/artifactId&gt; &lt;version&gt;9.0.3&lt;/version&gt;&lt;/dependency&gt; UrlToPdfUtil.java： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.FileOutputStream;import java.io.OutputStream; import org.xhtmlrenderer.pdf.ITextFontResolver;import org.xhtmlrenderer.pdf.ITextRenderer; import com.itextpdf.text.pdf.BaseFont; public class UrlToPdfUtil &#123; //private static final String OUT_PUT_PDF_PATH = \"/home/data/pdf/\"; //pdf文件的存放路径（Linux） private static final String OUT_PUT_PDF_PATH = \"C:/Users/Administrator/Desktop/pdf/\"; //pdf文件的存放路径（windows） /** * @Title 网页转存为PDF文件 * @param url 链接地址 * @param outputFileName 转存的PDF文件名 */ public static void urlToPdf(String url, String outputFileName) &#123; try &#123; String folder = outputFileName.substring(0, 6); String outputFile = OUT_PUT_PDF_PATH + folder +\"/\"+ outputFileName; java.io.File targetFile = new java.io.File(outputFile); if (!targetFile.getParentFile().exists()) &#123; targetFile.getParentFile().mkdirs(); // 创建父级文件路径 &#125; OutputStream os = new FileOutputStream(outputFile); ITextRenderer renderer = new ITextRenderer(); renderer.setDocument(url); ITextFontResolver fontResolver = renderer.getFontResolver(); //fontResolver.addFont(\"/usr/share/fonts/chinese/simsun.ttc\", BaseFont.IDENTITY_H, BaseFont.EMBEDDED); //Linux fontResolver.addFont(\"c:/Windows/Fonts/simsun.ttc\", BaseFont.IDENTITY_H, BaseFont.NOT_EMBEDDED); //windows renderer.layout(); renderer.createPDF(os); os.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; urlToPdf(\"http://www.lrfun.com/toPdf.html\", \"201905098888888.pdf\"); &#125;&#125; 注意点：1.字体限制，要使用simsun字体（可点击下载），下载自行安装吧； 2.需要转为PDF的网页，必须遵守W3C标准，也就是说每个标签都必须闭合（如：img等标签的结尾必须要添加“/”），否则就会报错，详细请参考文件：http://www.lrfun.com/toPdf.html","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://blog.alterem.top/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://blog.alterem.top/tags/JAVA/"}]},{"title":"HTTP协议状态码详解","slug":"HTTP协议状态码详解","date":"2019-06-10T09:49:44.000Z","updated":"2019-06-12T10:04:51.280Z","comments":true,"path":"2019/06/10/HTTP协议状态码详解/","link":"","permalink":"http://blog.alterem.top/2019/06/10/HTTP协议状态码详解/","excerpt":"常见 200 – 服务器成功返回网页404 – 请求的网页不存在500 – 服务器内部错误 0（特别说明） 0表示无法访问，或者说与服务器没有连接成功，但不一定是0就表示失败，有些时候访问本地资源成功了也会是0，比如Android的webviewajax访问本地资源时，responseCode就是0。","text":"常见 200 – 服务器成功返回网页404 – 请求的网页不存在500 – 服务器内部错误 0（特别说明） 0表示无法访问，或者说与服务器没有连接成功，但不一定是0就表示失败，有些时候访问本地资源成功了也会是0，比如Android的webviewajax访问本地资源时，responseCode就是0。 1xx（临时响应） 表示临时响应并需要请求者继续执行操作的状态代码。 代码 说明100 （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。101 （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。 2xx （成功） 表示成功处理了请求的状态代码。 代码 说明200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。201 （已创建） 请求成功并且服务器创建了新的资源。202 （已接受） 服务器已接受请求，但尚未处理。203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。204 （无内容） 服务器成功处理了请求，但没有返回任何内容。205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。206 （部分内容） 服务器成功处理了部分 GET 请求。 3xx （重定向） 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 代码 说明300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4xx（请求错误） 这些状态代码表示请求可能出错，妨碍了服务器的处理。 代码 说明400 （错误请求） 服务器不理解请求的语法。401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。403 （禁止） 服务器拒绝请求。404 （未找到） 服务器找不到请求的网页。405 （方法禁用） 禁用请求中指定的方法。406 （不接受） 无法使用请求的内容特性响应请求的网页。407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。408 （请求超时） 服务器等候请求时发生超时。409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。415 （不支持的媒体类型） 请求的格式不受请求页面的支持。416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。 5xx（服务器错误） 这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 代码 说明500 （服务器内部错误） 服务器遇到错误，无法完成请求。501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。","categories":[{"name":"Http","slug":"Http","permalink":"http://blog.alterem.top/categories/Http/"},{"name":"Status","slug":"Http/Status","permalink":"http://blog.alterem.top/categories/Http/Status/"}],"tags":[{"name":"Http","slug":"Http","permalink":"http://blog.alterem.top/tags/Http/"},{"name":"Status","slug":"Status","permalink":"http://blog.alterem.top/tags/Status/"}]},{"title":"MongoDB多数据源配置","slug":"MongoDB多数据源配置","date":"2019-06-10T09:06:23.000Z","updated":"2019-06-10T09:08:13.703Z","comments":true,"path":"2019/06/10/MongoDB多数据源配置/","link":"","permalink":"http://blog.alterem.top/2019/06/10/MongoDB多数据源配置/","excerpt":"SpringBoot对常用的数据库支持外，对NoSQL 数据库也进行了封装自动化。这一篇主要讲springboot与mongo多数据源相关的配置 1、mongo的介绍MongoDB是一个高性能，开源，无模式的文档型数据库，是当前NoSql数据库中比较热门的一种。它在许多场景下可用于替代传统的关系型数据库或键/值存储方式,这里不再多做说明。详细介绍参考mongo入门","text":"SpringBoot对常用的数据库支持外，对NoSQL 数据库也进行了封装自动化。这一篇主要讲springboot与mongo多数据源相关的配置 1、mongo的介绍MongoDB是一个高性能，开源，无模式的文档型数据库，是当前NoSql数据库中比较热门的一种。它在许多场景下可用于替代传统的关系型数据库或键/值存储方式,这里不再多做说明。详细介绍参考mongo入门 2、项目构建添加pom文件 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;&lt;/dependency&gt; 3、在application.properties中添加配置123456789101112131415##start mongodb for basic#----------------------------------------------basic.mongodb.host= 127.0.0.1basic.mongodb.port= 27017basic.mongodb.database= basic#----------------------------------------------##end mongodb for spirit##start mongodb for basic#----------------------------------------------order.mongodb.host= 127.0.0.2order.mongodb.port= 27017order.mongodb.database= order#----------------------------------------------##end mongodb for spirit 4、配置相应的数据源这里我们采用mongoTemplate这种模式去做mongo的相关操作 先写一个基础的抽象类 123456789101112131415161718192021222324252627282930313233343536373839404142public abstract class AbstractMongoConfigure &#123; private String host, database; private int port; /* * Method that creates MongoDbFactory * Common to both of the MongoDb connections */ public MongoDbFactory mongoDbFactory() throws Exception &#123; return new SimpleMongoDbFactory(new MongoClient(host, port), database); &#125; /* * Factory method to create the MongoTemplate */ abstract public MongoTemplate getMongoTemplate() throws Exception; public String getHost() &#123; return host; &#125; public void setHost(String host) &#123; this.host = host; &#125; public String getDatabase() &#123; return database; &#125; public void setDatabase(String database) &#123; this.database = database; &#125; public int getPort() &#123; return port; &#125; public void setPort(int port) &#123; this.port = port; &#125;&#125; 3.1)接下来第一个库的封装12345678910@Configuration@EnableMongoRepositories(basePackages = &#123;\"com.sunliangliang.service.basic\"&#125;, mongoTemplateRef = \"basicMongoTemplate\")@ConfigurationProperties(prefix = \"basic.mongodb\")public class BasicMongoConfigure extends AbstractMongoConfigure &#123; @Override @Bean(name = \"basicMongoTemplate\") public MongoTemplate getMongoTemplate() throws Exception &#123; return new MongoTemplate(mongoDbFactory()); &#125;&#125; 其中 basePackages 的值是该库应用于相应的基础包，prefix即为相应的applications中的配置值 3.2)接下来第两个库的封装1234567891011@Configuration@EnableMongoRepositories(basePackages = &#123;\"com.sunliangliang.service.order\"&#125;, mongoTemplateRef = \"orderMongoTemplate\")@ConfigurationProperties(prefix = \"order.mongodb\")public class OrderMongoConfigure extends AbstractMongoConfigure&#123; @Primary @Override @Bean(name = \"orderMongoTemplate\") public MongoTemplate getMongoTemplate() throws Exception &#123; return new MongoTemplate(mongoDbFactory()); &#125;&#125; 封装完成后接下来进行相应实体的配置 4、创建数据实体1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class UserInfo implements Serializable&#123; private long id; private String username; private String password; private String nickname; private int age; private String name; public long getId() &#123; return id; &#125; public void setId(long id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getNickname() &#123; return nickname; &#125; public void setNickname(String nickname) &#123; this.nickname = nickname; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 4、添加对实体的操作在这里我写了一个公用的接口用于基础的增删改查 12345678910111213public interface BaseService&lt;T&gt; &#123; Boolean save(T entity); Boolean update(T entity); Boolean delete(Long id); T getById(Long id); List&lt;T&gt; listAll(); List&lt;T&gt; listAll(T entity);&#125; 接下来接口的实现 123456789101112131415161718192021222324252627282930313233343536@Servicepublic class UserInfoService implements BaseService&lt;UserInfo&gt;&#123; @Autowired @Qualifier(\"basicMongoTemplate\") private MongoTemplate mongoTemplate; @Override public Boolean save(UserInfo entity) &#123; mongoTemplate.save(entity); return true; &#125; @Override public Boolean update(UserInfo entity) &#123; return null; &#125; @Override public Boolean delete(Long id) &#123; return null; &#125; @Override public UserInfo getById(Long id) &#123; return null; &#125; @Override public List&lt;UserInfo&gt; listAll() &#123; return mongoTemplate.findAll(UserInfo.class); &#125; @Override public List&lt;UserInfo&gt; listAll(UserInfo entity) &#123; return null; &#125;&#125; 注意此处@Qualifier(“basicMongoTemplate”)中即为相应的具体实现类。 这里只写了添加和查询列表的实现，其他的查询相应的api即可 12345678910111213141516171819202122@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTestpublic class UserInfoServiceTest &#123; @Autowired private UserInfoService userInfoService; @Test public void save() throws Exception &#123; UserInfo userInfo = new UserInfo(); userInfo.setAge(23); userInfo.setId(1000l); userInfo.setName(\"管理员\"); userInfo.setNickname(\"hehe\"); userInfo.setPassword(\"123456\"); userInfo.setUsername(\"admin\"); userInfoService.save(userInfo); &#125; @Test public void listAll() throws Exception &#123; userInfoService.listAll(); &#125;&#125; 若库不存在，会自动生成相应的库和文档如图： 另一个order相关库的配置就不再这里写了","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://blog.alterem.top/categories/MongoDB/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://blog.alterem.top/tags/MongoDB/"}]},{"title":"JAVA操作MongoDB工具类分享","slug":"JAVA操作MongoDB工具类分享","date":"2019-06-10T09:01:11.000Z","updated":"2019-06-10T09:05:24.438Z","comments":true,"path":"2019/06/10/JAVA操作MongoDB工具类分享/","link":"","permalink":"http://blog.alterem.top/2019/06/10/JAVA操作MongoDB工具类分享/","excerpt":"最近做了个用MongoDB存储的项目，由于MongoDB对开发人员不开放，由DBA统一管理。因此，自己抽时间写了个MongoDB的查询机。便于查询项目中的数据，方便维护和分析问题。总结了一些java操作MongoDB的方法。本文没有使用spring-data来操作MongoDB。而是直接使用MongoDB for java的原始API。现在介绍一下工具类。 1.准备工作MongoDB的安装，不多做介绍。 MongoDB的java驱动 12345&lt;dependency&gt; &lt;groupId&gt;org.mongodb&lt;/groupId&gt; &lt;artifactId&gt;mongo-java-driver&lt;/artifactId&gt; &lt;version&gt;2.11.3&lt;/version&gt;&lt;/dependency&gt;","text":"最近做了个用MongoDB存储的项目，由于MongoDB对开发人员不开放，由DBA统一管理。因此，自己抽时间写了个MongoDB的查询机。便于查询项目中的数据，方便维护和分析问题。总结了一些java操作MongoDB的方法。本文没有使用spring-data来操作MongoDB。而是直接使用MongoDB for java的原始API。现在介绍一下工具类。 1.准备工作MongoDB的安装，不多做介绍。 MongoDB的java驱动 12345&lt;dependency&gt; &lt;groupId&gt;org.mongodb&lt;/groupId&gt; &lt;artifactId&gt;mongo-java-driver&lt;/artifactId&gt; &lt;version&gt;2.11.3&lt;/version&gt;&lt;/dependency&gt; 2.封装实体介绍 MongoDBCursor——MongoDB条件查询封装实体（支持limit，skip，sort） MongoDBEntity——MongoDB集合封装实体 MongoDBUpdate——MongoDB更新封装实体 ​ MongoDBCursor 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import com.mongodb.BasicDBObject;import com.mongodb.DBObject; import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map; /** * MongoDB条件查询封装实体（支持limit，skip，sort） * * @author: alex * @time: 14-1-21 下午5:00 * @version: 1.0 */public class MongoDBCursor extends MongoDBEntity &#123; /** * skip属性 */ private int skip; /** * limit属性 */ private int limit = 100; /** * 排序属性 */ private Map&lt;String, Object&gt; sort = new LinkedHashMap&lt;String, Object&gt;(); /** * 自定义查询字段属性 */ private Map&lt;String, Object&gt; customFieldMap = new HashMap&lt;String, Object&gt;(); public int getSkip() &#123; return skip; &#125; public void setSkip(int skip) &#123; this.skip = skip; &#125; public int getLimit() &#123; return limit; &#125; public void setLimit(int limit) &#123; this.limit = limit; &#125; public Map&lt;String, Object&gt; getSort() &#123; return sort; &#125; public void setSort(Map&lt;String, Object&gt; sort) &#123; this.sort = sort; &#125; public DBObject getSortObject() &#123; if (this.sort == null) &#123; return null; &#125; DBObject dbo = new BasicDBObject(); for (String k : sort.keySet()) &#123; dbo.put(k, Integer.valueOf(sort.get(k).toString())); &#125; return dbo; &#125; public Map&lt;String, Object&gt; getCustomFieldMap() &#123; return customFieldMap; &#125; public void setCustomFieldMap(Map&lt;String, Object&gt; customFieldMap) &#123; this.customFieldMap = customFieldMap; &#125;&#125; MongoDBEntity 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import com.mongodb.DB; import java.util.Map; /** * MongoDB集合封装实体 * * @author: alex * @time: 14-1-20 下午2:57 * @version: 1.0 */public class MongoDBEntity &#123; /** * mongo数据库 */ private DB db; /** * 集合名字 */ private String collectionName; /** * 字段封装Map */ private Map&lt;String,Object&gt; fieldMap; public DB getDb() &#123; return db; &#125; public void setDb(DB db) &#123; this.db = db; &#125; public String getCollectionName() &#123; return collectionName; &#125; public void setCollectionName(String collectionName) &#123; this.collectionName = collectionName; &#125; public Map&lt;String, Object&gt; getFieldMap() &#123; return fieldMap; &#125; public void setFieldMap(Map&lt;String, Object&gt; fieldMap) &#123; this.fieldMap = fieldMap; &#125;&#125; MongoDBUpdate 12345678910111213141516171819202122232425262728293031323334353637import java.util.Map; /** * MongoDB更新封装实体 * * @author: alex * @time: 14-1-21 下午5:00 * @version: 1.0 */public class MongoDBUpdate extends MongoDBEntity &#123; /** * where查询Map */ private Map&lt;String, Object&gt; whereMap; /** * value查询Map */ private Map&lt;String, Object&gt; valueMap; public Map&lt;String, Object&gt; getWhereMap() &#123; return whereMap; &#125; public void setWhereMap(Map&lt;String, Object&gt; whereMap) &#123; this.whereMap = whereMap; &#125; public Map&lt;String, Object&gt; getValueMap() &#123; return valueMap; &#125; public void setValueMap(Map&lt;String, Object&gt; valueMap) &#123; this.valueMap = valueMap; &#125;&#125; 3.MongoDB操作类 MongoDBCommonUtil——MongoDB集合操作工作类 MongoDBUtil——MongoDBCRUD操作封装工具类 MongoDBCommonUtil 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325import com.mongodb.*;import org.bson.types.BasicBSONList;import org.bson.types.ObjectId; import java.util.*; /** * MongoDBCRUD操作封装工具类 * * @author: alex * @time: 14-1-21 下午3:16 * @version: 1.0 */public class MongoDBUtil &#123; /** * 按主键查询单个实体 * * @param id 主键 * @param mongoDBCursor 查询实体 * @return DBObject */ public static DBObject findById(MongoDBCursor mongoDBCursor, String id) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(\"_id\", new ObjectId(id)); mongoDBCursor.setFieldMap(map); return findOne(mongoDBCursor); &#125; /** * 按条件查询单个 * * @param mongoDBCursor 查询实体 * @return DBObject */ public static DBObject findOne(MongoDBCursor mongoDBCursor) &#123; DBObject dbObject = getMapped(mongoDBCursor.getFieldMap()); return MongoDBCommonUtil.getCollection(mongoDBCursor).findOne(dbObject); &#125; /** * 查询全部 * * @param mongoDBCursor 查询实体 */ public static List&lt;DBObject&gt; findAll(MongoDBCursor mongoDBCursor) &#123; mongoDBCursor.setFieldMap(new HashMap&lt;String, Object&gt;()); return find(mongoDBCursor); &#125; /** * 按条件查询 * 支持skip，limit,sort * * @param mongoDBCursor 查询实体 */ public static List&lt;DBObject&gt; find(MongoDBCursor mongoDBCursor) &#123; DBObject dbObject = getMapped(mongoDBCursor.getFieldMap()); BasicDBObjectBuilder customField = null; //自定义查询字段 if(mongoDBCursor.getCustomFieldMap() != null &amp;&amp; mongoDBCursor.getCustomFieldMap().size() &gt; 0) &#123; customField = new BasicDBObjectBuilder(); for(Map.Entry&lt;String, Object&gt; field : mongoDBCursor.getCustomFieldMap().entrySet()) &#123; customField.add(field.getKey(),field.getValue()); &#125; &#125; return find(mongoDBCursor, dbObject, customField); &#125; /** * 查询（私有方法,检查是否含有skip，limit，sort） * * @param dbObject 查询条件 * @param mongoDBCursor 查询实体 */ private static List&lt;DBObject&gt; find(final MongoDBCursor mongoDBCursor, DBObject dbObject,BasicDBObjectBuilder customField) &#123; MongoDBCursorPreparer cursorPreparer = mongoDBCursor == null ? null : new MongoDBCursorPreparer() &#123; public DBCursor prepare(DBCursor dbCursor) &#123; if (mongoDBCursor == null) &#123; return dbCursor; &#125; if (mongoDBCursor.getLimit() &lt;= 0 &amp;&amp; mongoDBCursor.getSkip() &lt;= 0 &amp;&amp; mongoDBCursor.getSortObject() == null) &#123; return dbCursor; &#125; DBCursor cursorToUse = dbCursor; if (mongoDBCursor.getSkip() &gt; 0) &#123; cursorToUse = cursorToUse.skip(mongoDBCursor.getSkip()); &#125; if (mongoDBCursor.getLimit() &gt; 0) &#123; cursorToUse = cursorToUse.limit(mongoDBCursor.getLimit()); &#125; if (mongoDBCursor.getSortObject() != null) &#123; cursorToUse = cursorToUse.sort(mongoDBCursor.getSortObject()); &#125; return cursorToUse; &#125; &#125;; return find(mongoDBCursor, dbObject, cursorPreparer,customField); &#125; /** * 查询（私有方法，真正的查询操作） * * @param query 查询条件 * @param mongoDBCursor 查询实体 * @param cursorPreparer 查询转换接口 */ private static List&lt;DBObject&gt; find(MongoDBCursor mongoDBCursor, DBObject query, MongoDBCursorPreparer cursorPreparer,BasicDBObjectBuilder customField) &#123; DBCursor dbCursor = null; if(customField == null) &#123; dbCursor = MongoDBCommonUtil.getCollection(mongoDBCursor).find(query); &#125; else &#123; dbCursor = MongoDBCommonUtil.getCollection(mongoDBCursor).find(query,customField.get()); &#125; if (cursorPreparer != null) &#123; dbCursor = cursorPreparer.prepare(dbCursor); &#125; return dbCursor.toArray(); &#125; /** * Count查询 * * @param mongoDBCursor 查询实体 * @return 总数 */ public static long count(MongoDBCursor mongoDBCursor) &#123; DBObject dbObject = getMapped(mongoDBCursor.getFieldMap()); return MongoDBCommonUtil.getCollection(mongoDBCursor).count(dbObject); &#125; /** * 把参数Map转换DBObject * * @param map 查询条件 * @return DBObject */ private static DBObject getMapped(Map&lt;String, Object&gt; map) &#123; DBObject dbObject = new BasicDBObject(); Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; iterable = map.entrySet().iterator(); while (iterable.hasNext()) &#123; Map.Entry&lt;String, Object&gt; entry = iterable.next(); Object value = entry.getValue(); String key = entry.getKey(); if (key.startsWith(\"$\") &amp;&amp; value instanceof Map) &#123; BasicBSONList basicBSONList = new BasicBSONList(); Map&lt;String, Object&gt; conditionsMap = ((Map) value);// Set&lt;String&gt; keys = conditionsMap.keySet(); for (String k : conditionsMap.keySet()) &#123; Object conditionsValue = conditionsMap.get(k); if (conditionsValue instanceof Collection) &#123; conditionsValue = convertArray(conditionsValue); &#125; DBObject dbObject2 = new BasicDBObject(k, conditionsValue); basicBSONList.add(dbObject2); &#125; value = basicBSONList; &#125; else if (value instanceof Collection) &#123; value = convertArray(value); &#125; else if (!key.startsWith(\"$\") &amp;&amp; value instanceof Map) &#123; value = getMapped(((Map) value)); &#125; dbObject.put(key, value); &#125; return dbObject; &#125; /** * 转换成Object[] * * @param value 待转换实体 * @return Object[] */ private static Object[] convertArray(Object value) &#123; Object[] values = ((Collection) value).toArray(); return values; &#125; /** * 添加操作 * * @param mongoDBEntity 实体 */ public static void add(MongoDBEntity mongoDBEntity) &#123; DBObject dbObject = new BasicDBObject(mongoDBEntity.getFieldMap()); MongoDBCommonUtil.getCollection(mongoDBEntity).insert(dbObject); &#125; /** * 批量处理添加操作 * * @param list 批量字段数据 * @param mongoDBEntity 实体 */ public static void add(MongoDBEntity mongoDBEntity, List&lt;Map&lt;String, Object&gt;&gt; list) &#123; for (Map&lt;String, Object&gt; map : list) &#123; mongoDBEntity.setFieldMap(map); add(mongoDBEntity); &#125; &#125; /** * 删除操作 * * @param mongoDBEntity 实体 */ public static void delete(MongoDBEntity mongoDBEntity) &#123; DBObject dbObject = new BasicDBObject(mongoDBEntity.getFieldMap()); MongoDBCommonUtil.getCollection(mongoDBEntity).remove(dbObject); &#125; /** * 删除操作,根据主键 * * @param id 主键 * @param mongoDBEntity 实体 */ public static void delete(MongoDBEntity mongoDBEntity, String id) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(\"_id\", new ObjectId(id)); mongoDBEntity.setFieldMap(map); delete(mongoDBEntity); &#125; /** * 删除全部 * * @param mongoDBEntity 实体 */ public static void deleteAll(MongoDBEntity mongoDBEntity) &#123; MongoDBCommonUtil.getCollection(mongoDBEntity).drop(); &#125; /** * 修改操作 * 会用一个新文档替换现有文档,文档key结构会发生改变 * 比如原文档&#123;\"_id\":\"123\",\"name\":\"zhangsan\",\"age\":12&#125;当根据_id修改age * value为&#123;\"age\":12&#125;新建的文档name值会没有,结构发生了改变 * * @param mongoDBUpdate 更新实体 */ public static void update(MongoDBUpdate mongoDBUpdate) &#123; executeUpdate(mongoDBUpdate, new UpdateCallback() &#123; public DBObject doCallback(DBObject valueDBObject) &#123; return valueDBObject; &#125; &#125;); &#125; /** * 修改操作,使用$set修改器 * 用来指定一个键值,如果键不存在,则自动创建,会更新原来文档, 不会生成新的, 结构不会发生改变 * * @param mongoDBUpdate 更新实体 */ public static void updateSet(MongoDBUpdate mongoDBUpdate) &#123; executeUpdate(mongoDBUpdate, new UpdateCallback() &#123; public DBObject doCallback(DBObject valueDBObject) &#123; return new BasicDBObject(\"$set\", valueDBObject); &#125; &#125;); &#125; /** * 修改操作,使用$inc修改器 * 修改器键的值必须为数字 * 如果键存在增加或减少键的值, 如果不存在创建键 * * @param mongoDBUpdate 更新实体 */ public static void updateInc(MongoDBUpdate mongoDBUpdate) &#123; executeUpdate(mongoDBUpdate, new UpdateCallback() &#123; public DBObject doCallback(DBObject valueDBObject) &#123; return new BasicDBObject(\"$inc\", valueDBObject); &#125; &#125;); &#125; /** * 修改(私有方法) * * @param mongoDBUpdate 更新实体 * @param updateCallback 更新回调 */ private static void executeUpdate(MongoDBUpdate mongoDBUpdate, UpdateCallback updateCallback) &#123; DBObject whereDBObject = new BasicDBObject(mongoDBUpdate.getWhereMap()); DBObject valueDBObject = new BasicDBObject(mongoDBUpdate.getValueMap()); valueDBObject = updateCallback.doCallback(valueDBObject); MongoDBCommonUtil.getCollection(mongoDBUpdate).update(whereDBObject, valueDBObject); &#125; public static void main(String[] args) &#123; try &#123; //获取操作DB DB db = MongoDBCommonUtil.getDB(\"192.168.227.170\", 20011,\"lagd\",\"lagd_rw\",\"lagd_pwd\"); MongoDBCursor mongoDBCursor = new MongoDBCursor(); mongoDBCursor.setDb(db); //赋值DB mongoDBCursor.setCollectionName(\"lagd_data_dictionary\"); //赋值集合名 //封装查询条件 Map&lt;String, Object&gt; fieldMap = new HashMap&lt;String, Object&gt;(); fieldMap.put(\"type\",\"dataSource\"); mongoDBCursor.setFieldMap(fieldMap); //赋值skip mongoDBCursor.setSkip(1); //赋值limit mongoDBCursor.setLimit(1); //封装Sort Map&lt;String, Object&gt; sortMap = new LinkedHashMap&lt;String, Object&gt;(); sortMap.put(\"key\",1); mongoDBCursor.setSort(sortMap); //查询 List&lt;DBObject&gt; result = MongoDBUtil.find(mongoDBCursor); for(DBObject dbObject : result)&#123; for(String key : dbObject.keySet())&#123; System.out.println(\"key=\" + key + \"; value=\" + dbObject.get(key)); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; MongoDBUtil 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331import com.mongodb.*;import org.bson.types.BasicBSONList;import org.bson.types.ObjectId; import java.util.*; /** * MongoDBCRUD操作封装工具类 * * @author: alex * @time: 14-1-21 下午3:16 * @version: 1.0 */public class MongoDBUtil &#123; /** * 按主键查询单个实体 * * @param id 主键 * @param mongoDBCursor 查询实体 * @return DBObject */ public static DBObject findById(MongoDBCursor mongoDBCursor, String id) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(\"_id\", new ObjectId(id)); mongoDBCursor.setFieldMap(map); return findOne(mongoDBCursor); &#125; /** * 按条件查询单个 * * @param mongoDBCursor 查询实体 * @return DBObject */ public static DBObject findOne(MongoDBCursor mongoDBCursor) &#123; DBObject dbObject = getMapped(mongoDBCursor.getFieldMap()); return MongoDBCommonUtil.getCollection(mongoDBCursor).findOne(dbObject); &#125; /** * 查询全部 * * @param mongoDBCursor 查询实体 */ public static List&lt;DBObject&gt; findAll(MongoDBCursor mongoDBCursor) &#123; mongoDBCursor.setFieldMap(new HashMap&lt;String, Object&gt;()); return find(mongoDBCursor); &#125; /** * 按条件查询 * 支持skip，limit,sort * * @param mongoDBCursor 查询实体 */ public static List&lt;DBObject&gt; find(MongoDBCursor mongoDBCursor) &#123; DBObject dbObject = getMapped(mongoDBCursor.getFieldMap()); BasicDBObjectBuilder customField = null; //自定义查询字段 if(mongoDBCursor.getCustomFieldMap() != null &amp;&amp; mongoDBCursor.getCustomFieldMap().size() &gt; 0) &#123; customField = new BasicDBObjectBuilder(); for(Map.Entry&lt;String, Object&gt; field : mongoDBCursor.getCustomFieldMap().entrySet()) &#123; customField.add(field.getKey(),field.getValue()); &#125; &#125; return find(mongoDBCursor, dbObject, customField); &#125; /** * 查询（私有方法,检查是否含有skip，limit，sort） * * @param dbObject 查询条件 * @param mongoDBCursor 查询实体 */ private static List&lt;DBObject&gt; find(final MongoDBCursor mongoDBCursor, DBObject dbObject,BasicDBObjectBuilder customField) &#123; MongoDBCursorPreparer cursorPreparer = mongoDBCursor == null ? null : new MongoDBCursorPreparer() &#123; public DBCursor prepare(DBCursor dbCursor) &#123; if (mongoDBCursor == null) &#123; return dbCursor; &#125; if (mongoDBCursor.getLimit() &lt;= 0 &amp;&amp; mongoDBCursor.getSkip() &lt;= 0 &amp;&amp; mongoDBCursor.getSortObject() == null) &#123; return dbCursor; &#125; DBCursor cursorToUse = dbCursor; if (mongoDBCursor.getSkip() &gt; 0) &#123; cursorToUse = cursorToUse.skip(mongoDBCursor.getSkip()); &#125; if (mongoDBCursor.getLimit() &gt; 0) &#123; cursorToUse = cursorToUse.limit(mongoDBCursor.getLimit()); &#125; if (mongoDBCursor.getSortObject() != null) &#123; cursorToUse = cursorToUse.sort(mongoDBCursor.getSortObject()); &#125; return cursorToUse; &#125; &#125;; return find(mongoDBCursor, dbObject, cursorPreparer,customField); &#125; /** * 查询（私有方法，真正的查询操作） * * @param query 查询条件 * @param mongoDBCursor 查询实体 * @param cursorPreparer 查询转换接口 */ private static List&lt;DBObject&gt; find(MongoDBCursor mongoDBCursor, DBObject query, MongoDBCursorPreparer cursorPreparer,BasicDBObjectBuilder customField) &#123; DBCursor dbCursor = null; if(customField == null) &#123; dbCursor = MongoDBCommonUtil.getCollection(mongoDBCursor).find(query); &#125; else &#123; dbCursor = MongoDBCommonUtil.getCollection(mongoDBCursor).find(query,customField.get()); &#125; if (cursorPreparer != null) &#123; dbCursor = cursorPreparer.prepare(dbCursor); &#125; return dbCursor.toArray(); &#125; /** * Count查询 * * @param mongoDBCursor 查询实体 * @return 总数 */ public static long count(MongoDBCursor mongoDBCursor) &#123; DBObject dbObject = getMapped(mongoDBCursor.getFieldMap()); return MongoDBCommonUtil.getCollection(mongoDBCursor).count(dbObject); &#125; /** * 把参数Map转换DBObject * * @param map 查询条件 * @return DBObject */ private static DBObject getMapped(Map&lt;String, Object&gt; map) &#123; DBObject dbObject = new BasicDBObject(); Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; iterable = map.entrySet().iterator(); while (iterable.hasNext()) &#123; Map.Entry&lt;String, Object&gt; entry = iterable.next(); Object value = entry.getValue(); String key = entry.getKey(); if (key.startsWith(\"$\") &amp;&amp; value instanceof Map) &#123; BasicBSONList basicBSONList = new BasicBSONList(); Map&lt;String, Object&gt; conditionsMap = ((Map) value);// Set&lt;String&gt; keys = conditionsMap.keySet(); for (String k : conditionsMap.keySet()) &#123; Object conditionsValue = conditionsMap.get(k); if (conditionsValue instanceof Collection) &#123; conditionsValue = convertArray(conditionsValue); &#125; DBObject dbObject2 = new BasicDBObject(k, conditionsValue); basicBSONList.add(dbObject2); &#125; value = basicBSONList; &#125; else if (value instanceof Collection) &#123; value = convertArray(value); &#125; else if (!key.startsWith(\"$\") &amp;&amp; value instanceof Map) &#123; value = getMapped(((Map) value)); &#125; dbObject.put(key, value); &#125; return dbObject; &#125; /** * 转换成Object[] * * @param value 待转换实体 * @return Object[] */ private static Object[] convertArray(Object value) &#123; Object[] values = ((Collection) value).toArray(); return values; &#125; /** * 添加操作 * * @param mongoDBEntity 实体 */ public static void add(MongoDBEntity mongoDBEntity) &#123; DBObject dbObject = new BasicDBObject(mongoDBEntity.getFieldMap()); MongoDBCommonUtil.getCollection(mongoDBEntity).insert(dbObject); &#125; /** * 批量处理添加操作 * * @param list 批量字段数据 * @param mongoDBEntity 实体 */ public static void add(MongoDBEntity mongoDBEntity, List&lt;Map&lt;String, Object&gt;&gt; list) &#123; for (Map&lt;String, Object&gt; map : list) &#123; mongoDBEntity.setFieldMap(map); add(mongoDBEntity); &#125; &#125; /** * 删除操作 * * @param mongoDBEntity 实体 */ public static void delete(MongoDBEntity mongoDBEntity) &#123; DBObject dbObject = new BasicDBObject(mongoDBEntity.getFieldMap()); MongoDBCommonUtil.getCollection(mongoDBEntity).remove(dbObject); &#125; /** * 删除操作,根据主键 * * @param id 主键 * @param mongoDBEntity 实体 */ public static void delete(MongoDBEntity mongoDBEntity, String id) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(\"_id\", new ObjectId(id)); mongoDBEntity.setFieldMap(map); delete(mongoDBEntity); &#125; /** * 删除全部 * * @param mongoDBEntity 实体 */ public static void deleteAll(MongoDBEntity mongoDBEntity) &#123; MongoDBCommonUtil.getCollection(mongoDBEntity).drop(); &#125; /** * 修改操作 * 会用一个新文档替换现有文档,文档key结构会发生改变 * 比如原文档&#123;\"_id\":\"123\",\"name\":\"zhangsan\",\"age\":12&#125;当根据_id修改age * value为&#123;\"age\":12&#125;新建的文档name值会没有,结构发生了改变 * * @param mongoDBUpdate 更新实体 */ public static void update(MongoDBUpdate mongoDBUpdate) &#123; executeUpdate(mongoDBUpdate, new UpdateCallback() &#123; public DBObject doCallback(DBObject valueDBObject) &#123; return valueDBObject; &#125; &#125;); &#125; /** * 修改操作,使用$set修改器 * 用来指定一个键值,如果键不存在,则自动创建,会更新原来文档, 不会生成新的, 结构不会发生改变 * * @param mongoDBUpdate 更新实体 */ public static void updateSet(MongoDBUpdate mongoDBUpdate) &#123; executeUpdate(mongoDBUpdate, new UpdateCallback() &#123; public DBObject doCallback(DBObject valueDBObject) &#123; return new BasicDBObject(\"$set\", valueDBObject); &#125; &#125;); &#125; /** * 修改操作,使用$inc修改器 * 修改器键的值必须为数字 * 如果键存在增加或减少键的值, 如果不存在创建键 * * @param mongoDBUpdate 更新实体 */ public static void updateInc(MongoDBUpdate mongoDBUpdate) &#123; executeUpdate(mongoDBUpdate, new UpdateCallback() &#123; public DBObject doCallback(DBObject valueDBObject) &#123; return new BasicDBObject(\"$inc\", valueDBObject); &#125; &#125;); &#125; /** * 修改(私有方法) * * @param mongoDBUpdate 更新实体 * @param updateCallback 更新回调 */ private static void executeUpdate(MongoDBUpdate mongoDBUpdate, UpdateCallback updateCallback) &#123; DBObject whereDBObject = new BasicDBObject(mongoDBUpdate.getWhereMap()); DBObject valueDBObject = new BasicDBObject(mongoDBUpdate.getValueMap()); valueDBObject = updateCallback.doCallback(valueDBObject); MongoDBCommonUtil.getCollection(mongoDBUpdate).update(whereDBObject, valueDBObject); &#125; public static void main(String[] args) &#123; try &#123; //获取操作DB DB db = MongoDBCommonUtil.getDB(\"192.168.227.170\", 20011,\"lagd\",\"lagd_rw\",\"lagd_pwd\"); MongoDBCursor mongoDBCursor = new MongoDBCursor(); mongoDBCursor.setDb(db); //赋值DB mongoDBCursor.setCollectionName(\"lagd_data_dictionary\"); //赋值集合名 //封装查询条件 Map&lt;String, Object&gt; fieldMap = new HashMap&lt;String, Object&gt;(); fieldMap.put(\"type\",\"dataSource\"); mongoDBCursor.setFieldMap(fieldMap); //赋值skip mongoDBCursor.setSkip(1); //赋值limit mongoDBCursor.setLimit(1); //封装Sort Map&lt;String, Object&gt; sortMap = new LinkedHashMap&lt;String, Object&gt;(); sortMap.put(\"key\",1); mongoDBCursor.setSort(sortMap); //自定义查询字段 Map&lt;String, Object&gt; customFieldMap = new LinkedHashMap&lt;String, Object&gt;(); customFieldMap.put(\"type\",\"1\"); customFieldMap.put(\"key\",\"1\"); customFieldMap.put(\"value\",\"1\"); mongoDBCursor.setCustomFieldMap(customFieldMap); //查询 List&lt;DBObject&gt; result = MongoDBUtil.find(mongoDBCursor); for(DBObject dbObject : result)&#123; for(String key : dbObject.keySet())&#123; System.out.println(\"键：\" + key + \"; 值：\" + dbObject.get(key)); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; MongoDBCursorPreparer 12345678910111213import com.mongodb.DBCursor; /** * 查询转换接口定义 * * @author: alex * @time: 14-1-21 下午4:55 * @version: 1.0 */public interface MongoDBCursorPreparer &#123; DBCursor prepare(DBCursor cursor);&#125; UpdateCallback 12345678910111213import com.mongodb.DBObject; /** * MongoDB更新操作接口定义 * * @author: alex * @time: 14-1-21 下午5:25 * @version: 1.0 */interface UpdateCallback &#123; DBObject doCallback(DBObject valueDBObject);&#125;","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://blog.alterem.top/categories/MongoDB/"},{"name":"JAVA","slug":"MongoDB/JAVA","permalink":"http://blog.alterem.top/categories/MongoDB/JAVA/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://blog.alterem.top/tags/MongoDB/"},{"name":"JAVA","slug":"JAVA","permalink":"http://blog.alterem.top/tags/JAVA/"}]},{"title":"CentOS7搭建ngrok服务器","slug":"CentOS7搭建ngrok服务器","date":"2019-06-10T08:38:52.000Z","updated":"2019-06-10T08:41:50.091Z","comments":true,"path":"2019/06/10/CentOS7搭建ngrok服务器/","link":"","permalink":"http://blog.alterem.top/2019/06/10/CentOS7搭建ngrok服务器/","excerpt":"ngrok是一个反向代理，它能够让你本地的web服务或tcp服务通过公共的端口和外部建立一个安全的通道， 使得外网可以访问本地的计算机服务。也就是说，我们提供的服务（比如web站点）无需搭建在外部服务器， 只要通过ngrok把站点映射出去，别人即可直接访问到我们的服务。 有做过微信公众号开发的人，对它应该不陌生。因为用户跟微信公众号产生的交互行为，微信会把用户的相关信息推送到我们自己的服务器， 如果服务在本地，那微信当然无法推送给我们，这使得开发功能的时候调试相当麻烦。我们可以使用ngrok把本地站点映射出去，解决这个问题。 另外如果我们想把本地开发时候的系统临时给外网用户看，无需部署到服务器上面去就可以，非常方便。 ngrok是开源的，官网地址：https://github.com/inconshreveable/ngrok 下面，我们开始搭建ngrok服务。操作系统为CentOS 7.2","text":"ngrok是一个反向代理，它能够让你本地的web服务或tcp服务通过公共的端口和外部建立一个安全的通道， 使得外网可以访问本地的计算机服务。也就是说，我们提供的服务（比如web站点）无需搭建在外部服务器， 只要通过ngrok把站点映射出去，别人即可直接访问到我们的服务。 有做过微信公众号开发的人，对它应该不陌生。因为用户跟微信公众号产生的交互行为，微信会把用户的相关信息推送到我们自己的服务器， 如果服务在本地，那微信当然无法推送给我们，这使得开发功能的时候调试相当麻烦。我们可以使用ngrok把本地站点映射出去，解决这个问题。 另外如果我们想把本地开发时候的系统临时给外网用户看，无需部署到服务器上面去就可以，非常方便。 ngrok是开源的，官网地址：https://github.com/inconshreveable/ngrok 下面，我们开始搭建ngrok服务。操作系统为CentOS 7.2 准备工作搭建ngrok服务需要有一个外网服务器及一个域名解析到外网服务器上，我已经有了一个xncoding.com域名，并且拥有一台腾讯云主机。 在腾讯云主机的域名解析处，配置2个A记录，比如我新建2个ngrok.xncoding.com 和 *.ngrok.xncoding.com 解析到vps服务器上。 搭建ngrok服务安装go语言环境ngrok是基于go语言开发的，所以需要先安装go语言开发环境，CentOS可以使用yum安装： 1yum install golang 安装git默认的git版本太低了，需要升级到git2.5，具体步骤如下： 1234sudo yum remove gitsudo yum install epel-releasesudo yum install https://centos7.iuscommunity.org/ius-release.rpmsudo yum install git2u git --version，返回 git version 2.5.0，安装成功。 下载ngrok源码新建一个目录，并clone一份源码： 1234mkdir ~/go/src/github.com/inconshreveablecd ~/go/src/github.com/inconshreveablegit clone https://github.com/inconshreveable/ngrok.gitexport GOPATH=~/go/src/github.com/inconshreveable/ngrok 生成自签名证书使用ngrok.com官方服务时，我们使用的是官方的SSL证书。自己建立ngrok服务，需要我们生成自己的证书，并提供携带该证书的ngrok客户端。 证书生成过程需要有自己的一个基础域名，比如我的就是ngrok.xncoding.com。 123456$ cd ngrok$ openssl genrsa -out rootCA.key 2048$ openssl req -x509 -new -nodes -key rootCA.key -subj &quot;/CN=ngrok.xncoding.com&quot; -days 5000 -out rootCA.pem$ openssl genrsa -out device.key 2048$ openssl req -new -key device.key -subj &quot;/CN=ngrok.xncoding.com&quot; -out device.csr$ openssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000 执行完成以上命令后，在ngrok目录下，会新生成6个文件： 123456-rw-r--r-- 1 root root 1001 Dec 29 11:53 device.crt-rw-r--r-- 1 root root 903 Dec 29 11:44 device.csr-rw-r--r-- 1 root root 1675 Dec 29 11:44 device.key-rw-r--r-- 1 root root 1679 Dec 29 11:44 rootCA.key-rw-r--r-- 1 root root 1119 Dec 29 11:44 rootCA.pem-rw-r--r-- 1 root root 17 Dec 29 11:53 rootCA.srl 我们在编译可执行文件之前，需要把生成的证书分别替换到 assets/client/tls和assets/server/tls中， 这两个目录分别存放着ngrok和ngrokd的默认证书。 123$ cp rootCA.pem assets/client/tls/ngrokroot.crt$ cp device.crt assets/server/tls/snakeoil.crt$ cp device.key assets/server/tls/snakeoil.key 使用lets encrypt免费证书如果想让浏览器不弹出提示，最好不要使用自签名证书，现在lets encrypt推出泛域名证书了，所以可以先申请个免费域名证书。 客户端用证书 ： 12cd ngrokcp /etc/letsencrypt/live/xncoding.com/chain.pem assets/client/tls/ngrokroot.crt 服务器端用证书： 12cp /etc/letsencrypt/live/xncoding.com/cert.pem assets/server/tls/snakeoil.crtcp /etc/letsencrypt/live/xncoding.com/privkey.pem assets/server/tls/snakeoil.key 编译ngrokd和ngrok首先需要知道，ngrokd 为服务端的执行文件，ngrok为客户端的执行文件。 接下来我们来编译ngrokd，在ngrok目录下，执行如下命令： 1$ make release-server 编译过程需要等待一会，因为需要通过git安装相关依赖包。如果提示没有权限，使用 sudo 命令来安装。 由于客户端的平台版本较多，我们需要交叉编译来选择生成的平台。 以windows、arm、linux版本编译，如下： 123$ GOOS=linux GOARCH=amd64 make release-client$ GOOS=windows GOARCH=amd64 make release-client$ GOOS=linux GOARCH=arm make release-client 不同平台使用不同的 GOOS 和 GOARCH，GOOS为go编译出来的操作系统 (windows,linux,darwin)，GOARCH, 对应的构架 (386,amd64,arm) 通过上面的步骤，将生成所有客户端文件，客户端文件放在对于的文件夹中，如windows 64位的为：windows_amd64，linux客户端在bin目录下的ngrok文件。 完成之后，把相应的客户端文件使用SFTP或其他方式分发到客户端电脑上面，比如我用的windows电脑，就把windows_amd64/ngrok.exe文件复制过去。 启动ngrokd服务器请将 bin/ngrokd 放入PATH环境变量中，启动命令： 1nohup ngrokd -domain=ngrok.xncoding.com -httpAddr=:5442 -httpsAddr=:5443 -tunnelAddr=&quot;:4443&quot; &amp; -domain为你的服务域名，-httpAddr为http服务端口地址，访问形式为xxx.ngrok.xncoding.com:5442，也可设置为80默认端口，-httpsAddr为https服务，同上。 ngrokd还会开一个端口用来跟客户端通讯（可通过-tunnelAddr=&quot;:xxx&quot; 指定），如果你配置了 iptables 规则，需要放行这个通讯端口(4443)上的 TCP 协议。 12firewall-cmd --zone=public --add-port=4443/tcp --permanentfirewall-cmd --reload Nginx配置80端口转发我们在微信开发时候不允许使用端口访问，那么最好使用nginx反向代理转发，首先申请一个demo.ngrok.xncoding.com的免费证书，然后修改nginx配置如下： 123456789101112131415161718192021222324252627server &#123; listen 80; server_name demo.ngrok.xncoding.com; return 301 https://demo.ngrok.xncoding.com$request_uri;&#125;server &#123; listen 443 ssl http2; server_name demo.ngrok.xncoding.com; charset utf-8; ssl_certificate /etc/letsencrypt/live/demo.ngrok.xncoding.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/demo.ngrok.xncoding.com/privkey.pem; ssl_trusted_certificate /etc/letsencrypt/live/demo.ngrok.xncoding.com/chain.pem; access_log /var/log/nginx/ngrok.log main; error_log /var/log/nginx/ngrok_error.log error; location / &#123; proxy_pass http://127.0.0.1:5442; proxy_redirect off; proxy_set_header Host $http_host:5442; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125; 但是！这里就有一个很烦躁的地方了，ngrokd 里面有一层自己的 Host 处理，于是 proxy_set_header Host 必须带上 ngrokd 所监听的端口， 否则就算请求被转发到对应端口上， ngrokd 也不会正确的处理。 启用客户端在刚刚复制过来的ngrok.exe客户端文件夹中，新建一个客户端配置ngrok.cfg： 12server_addr: &quot;ngrok.xncoding.com:4443&quot;trust_host_root_certs: false 本地启动一个SpringBoot的WEB工程，端口8092，然后通过下面命令启动客户端： 1ngrok.exe -subdomain demo -config=ngrok.cfg -log=log.txt 8092 看到下面的画面说明连接成功了： 访问页面，浏览器中输入：https://demo.ngrok.xncoding.com，成功访问本地SpringBoot站点内容。 浏览器输入：127.0.0.1:4040 查看页面请求情况： 烦恼的事情带上端口号又会导致了另一个操蛋的问题：你请求的时候是demo.ngrok.xncoding.com， 你在 web 应用中获取到的 Host 是 demo.ngrok.xncoding.com:5442， 如果你的程序里面有基于 Request Host 的重定向，就会被重定向到 demo.ngrok.xncoding.com:5442 下面去。 要完美的解决这个端口的问题，就需要让 ngrokd 直接监听 80 端口，或者使用Docker容器的端口映射来解决。 使用Docker上面我讲到自己手动搭建的时候出现的端口问题，没办法解决。 一般80端口早就被占用了，不可能就给你ngrok使用，最完美的方式是使用Docker + Nginx的方式。 安装docker参考我的这篇Docker入门来安装docker。 构建镜象这里使用的是hteen/docker-ngrok 123git clone https://github.com/hteen/docker-ngrok.gitcd docker-ngrokdocker build -t hteen/ngrok . 这里需要等待一段时间下载 Docker容器的https关于 https 的支持 由于 ngrok 工作是通过分配 subdomain 的方式，所以我们实际使用到的域名都是 ngrok.xncoding.com的子域名， 如 demo.ngrok.xncoding.com 如果要对这个子域名启用 https 服务，那么至少需要三点支持： ngrok 支持 https， 这个默认就是开启的 demo.ngrok.xncoding.com 也需要有证书或包含在一个泛域名证书中 浏览器（或其他终端）信任 demo.ngrok.xncoding.com 的根证书 好消息是现在lets encrypt支持通配符域名了，所以很简单，具体怎么申请，请参考我博客中的nginx相关文章。 这里请先申请ngrok.xncoding.com的通配符证书。 申请好之后，增加配置/etc/nginx/conf.d/ngrok.conf 添加反向代理配置： 1234567891011121314151617181920212223242526map $scheme $proxy_port &#123; &quot;http&quot; &quot;5442&quot;; &quot;https&quot; &quot;5443&quot;; default &quot;5442&quot;;&#125;server &#123; listen 80; listen 443; server_name ngrok.xncoding.com *.ngrok.xncoding.com; location / &#123; proxy_pass $scheme://127.0.0.1:$proxy_port; &#125; ssl on; ssl_certificate /etc/letsencrypt/live/ngrok.xncoding.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/ngrok.xncoding.com/privkey.pem; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $http_host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; access_log off; log_not_found off;&#125; 运行镜象上一步已经申请ngrok.xncoding.com这个域名的通配符lets encrypt证书，然后修改脚本server.sh 1-tlsKey=/etc/letsencrypt/live/ngrok.xncoding.com/privkey.pem -tlsCrt=/etc/letsencrypt/live/ngrok.xncoding.com/fullchain.pem 也就是将之前的证书变量改成你实际的证书路径即可。 然后运行： 1234docker run -idt --name ngrok-server \\-p 5442:80 -p 5443:443 -p 4443:4443 \\-v /data/ngrok:/myfiles \\-e DOMAIN=&apos;ngrok.xncoding.com&apos; -e HTTP_ADDR=&apos;:80&apos; -e HTTPS_ADDR=&apos;:443&apos; hteen/ngrok /bin/sh /server.sh 如果在腾讯云主机上面，还需要本级防火墙放行4443端口，以及在腾讯云安全组中也要放开4443端口。 1234561.查看已开放的端口(默认不开放任何端口)firewall-cmd --list-ports2.开启4443端口firewall-cmd --zone=public --add-port=4443/tcp --permanent3.重启防火墙systemctl restart firewalld 这里会把主机的5442端口映射到Docker容器中的80端口，讲5443端口映射到443端口，同时将本机的/data/ngrok文件夹映射到docker容器的/myfiles目录。 运行后，会要等一段时间，因为要编译客户端。一直等到/data/ngrok/目录里面有/bin目录就OK了。 注意事项因为ngrok有心跳机制，每次心跳均会产生日志，所以以docker方式运行，会产生很多日志。实测试中，大概每个星期会产生100M的日志文件。 查年docker日志文件位置sudo docker inspect &lt;id&gt; | grep LogPath 查看大小sudo ls -lh /var/lib/docker/containers/&lt;id&gt;/&lt;id&gt;-json.log 运行客户端在/data/ngrok/bin/目录下会生成客户端程序，每个平台的版本都有。以windows64位来说， 在windows_amd64目录下，拷贝到自己的windows电脑上。 新建配置文件ngrok.cfg，跟ngrok.exe同级目录，里面的内容跟之前讲的一样： 12server_addr: &quot;ngrok.xncoding.com:4443&quot;trust_host_root_certs: false 然后打开windows的命令行，cd到ngrok.exe所在的目录中，到这个运行： 1ngrok -config=ngrok.cfg -subdomain=demo -log=log.txt 8092 或者为了方便，在ngrok.exe所在的目录中新建一个run.bat文件，内容如下： 12@echo offngrok.exe -config=ngrok.cfg -subdomain=demo -log=log.txt 8092 上面的subdomain是你想去访问域名前缀，后面的端口是你本机应用启动端口。 看到下面的结果表示成功了： 然后再打开http://demo.ngrok.xncoding.com看看，发现不会像之前那样出现端口了。 国内免费的ngrok如果你自己没VPS，或者你机子上面80端口已经被nginx占用不想搞了，就直接使用免费的ngrok吧， 我推荐你使用https://www.ngrok.cc/。 比如我自己弄了个yidao620.free.ngrok.cc，启动本地客户端后，映射到本地的8092端口了，也还不错。 参考文章 从零教你搭建ngrok服务器 ngrok使用自己的证书通过https访问 搭建并配置优雅的 ngrok 服务实现内网穿透 使用Docker搭建Ngrok服务器实现内网穿透 搭建自己的Ngrok服务器, 并与Nginx并存","categories":[{"name":"CentOS","slug":"CentOS","permalink":"http://blog.alterem.top/categories/CentOS/"},{"name":"Linux","slug":"CentOS/Linux","permalink":"http://blog.alterem.top/categories/CentOS/Linux/"},{"name":"Ngrok","slug":"CentOS/Linux/Ngrok","permalink":"http://blog.alterem.top/categories/CentOS/Linux/Ngrok/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"http://blog.alterem.top/tags/CentOS/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.alterem.top/tags/Linux/"},{"name":"Ngrok","slug":"Ngrok","permalink":"http://blog.alterem.top/tags/Ngrok/"}]},{"title":"创建线程池的两种办法","slug":"创建线程池的两种办法","date":"2019-06-10T08:23:07.000Z","updated":"2019-06-10T08:24:48.457Z","comments":true,"path":"2019/06/10/创建线程池的两种办法/","link":"","permalink":"http://blog.alterem.top/2019/06/10/创建线程池的两种办法/","excerpt":"线程池，其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作， 无需反复创建线程而消耗过多资源。 我们详细的解释一下为什么要使用线程池？ 在java中，如果每个请求到达就创建一个新线程，开销是相当大的。在实际使用中，创建和销毁线程花费的时间和消耗的系统资源都相当大， 甚至可能要比在处理实际的用户请求的时间和资源要多的多。除了创建和销毁线程的开销之外，活动的线程也需要消耗系统资源。 如果在一个jvm里创建太多的线程，可能会使系统由于过度消耗内存或“切换过度”而导致系统资源不足。为了防止资源不足， 需要采取一些办法来限制任何给定时刻处理的请求数目，尽可能减少创建和销毁线程的次数，特别是一些资源耗费比较大的线程的创建和销毁， 尽量利用已有对象来进行服务。 线程池主要用来解决线程生命周期开销问题和资源不足问题。通过对多个任务重复使用线程，线程创建的开销就被分摊到了多个任务上了， 而且由于在请求到达时线程已经存在，所以消除了线程创建所带来的延迟。这样，就可以立即为请求服务，使用应用程序响应更快。另外， 通过适当的调整线程中的线程数目可以防止出现资源不足的情况。","text":"线程池，其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作， 无需反复创建线程而消耗过多资源。 我们详细的解释一下为什么要使用线程池？ 在java中，如果每个请求到达就创建一个新线程，开销是相当大的。在实际使用中，创建和销毁线程花费的时间和消耗的系统资源都相当大， 甚至可能要比在处理实际的用户请求的时间和资源要多的多。除了创建和销毁线程的开销之外，活动的线程也需要消耗系统资源。 如果在一个jvm里创建太多的线程，可能会使系统由于过度消耗内存或“切换过度”而导致系统资源不足。为了防止资源不足， 需要采取一些办法来限制任何给定时刻处理的请求数目，尽可能减少创建和销毁线程的次数，特别是一些资源耗费比较大的线程的创建和销毁， 尽量利用已有对象来进行服务。 线程池主要用来解决线程生命周期开销问题和资源不足问题。通过对多个任务重复使用线程，线程创建的开销就被分摊到了多个任务上了， 而且由于在请求到达时线程已经存在，所以消除了线程创建所带来的延迟。这样，就可以立即为请求服务，使用应用程序响应更快。另外， 通过适当的调整线程中的线程数目可以防止出现资源不足的情况。 使用线程池方式–Runnable接口 通常，线程池都是通过线程池工厂创建，再调用线程池中的方法获取线程，再通过线程去执行任务方法。 1234567891011121314151617181920212223public class ThreadPoolDemo &#123; public static void main(String[] args) &#123; //创建线程池对象 ExecutorService service = Executors.newFixedThreadPool(2);//包含2个线程对象 //创建Runnable实例对象 MyRunnable r = new MyRunnable(); //自己创建线程对象的方式 //Thread t = new Thread(r); //t.start(); ---&gt; 调用MyRunnable中的run() //从线程池中获取线程对象,然后调用MyRunnable中的run() service.submit(r); //再获取个线程对象，调用MyRunnable中的run() service.submit(r); service.submit(r); service.submit(r); //注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。将使用完的线程又归还到了线程池中 //关闭线程池 service.shutdown(); &#125;&#125; Runnable接口实现类 1234567891011121314public class MyRunnable implements Runnable &#123; @Override public void run() &#123; System.out.println(\"我要一个教练\"); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"教练来了： \" + Thread.currentThread().getName()); System.out.println(\"教我游泳,教完后，教练回到了游泳池\"); &#125;&#125; 使用线程池方式—Callable接口 与Runnable接口功能相似，用来指定线程的任务。其中的call()方法，用来返回线程任务执行完毕后的结果，call方法可抛出异常。 1234567891011121314151617181920import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ThreadPoolDemo &#123; public static void main(String[] args) &#123; //创建线程池对象 ExecutorService service = Executors.newFixedThreadPool(2);//包含2个线程对象 //创建Callable对象 MyCallable c = new MyCallable(); //从线程池中获取线程对象,然后调用MyRunnable中的run() service.submit(c); //再获取个教练 service.submit(c); service.submit(c); //注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。将使用完的线程又归还到了线程池中 //关闭线程池 //service.shutdown(); &#125;&#125; Callable接口实现类,call方法可抛出异常、返回线程任务执行完毕后的结果 12345678910public class MyCallable implements Callable &#123; @Override public Object call() throws Exception &#123; System.out.println(\"我要一个教练:call\"); Thread.sleep(2000); System.out.println(\"教练来了： \" + Thread.currentThread().getName()); System.out.println(\"教我游泳,教完后,教练回到了游泳池\"); return null; &#125;&#125;","categories":[{"name":"线程","slug":"线程","permalink":"http://blog.alterem.top/categories/线程/"},{"name":"JAVA","slug":"线程/JAVA","permalink":"http://blog.alterem.top/categories/线程/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://blog.alterem.top/tags/JAVA/"},{"name":"线程","slug":"线程","permalink":"http://blog.alterem.top/tags/线程/"}]},{"title":"实现多线程的两种方式","slug":"实现多线程的两种方式","date":"2019-06-10T06:58:56.000Z","updated":"2019-06-10T07:09:29.504Z","comments":true,"path":"2019/06/10/实现多线程的两种方式/","link":"","permalink":"http://blog.alterem.top/2019/06/10/实现多线程的两种方式/","excerpt":"Thread类： Thread是程序中的执行线程。java虚拟机允许应用程序并发地的运行多个执行线程。 1.进程与线程的关系进程：进程指正在运行的程序。确切的来说，当一个程序进入内存运行，即变成一个进程，进程是处于运行过程中的程序，并且具有一定独立功能。 线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的， 这个应用程序也可以称之为多线程程序。 简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程。 ​","text":"Thread类： Thread是程序中的执行线程。java虚拟机允许应用程序并发地的运行多个执行线程。 1.进程与线程的关系进程：进程指正在运行的程序。确切的来说，当一个程序进入内存运行，即变成一个进程，进程是处于运行过程中的程序，并且具有一定独立功能。 线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的， 这个应用程序也可以称之为多线程程序。 简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程。 ​ 2.多线程两种实现方式创建线程有两种方法 一种方法是将类声明为 Thread 的子类。该子类应重写 Thread 类的 run 方法。创建对象，开启线程。 run方法相当于其他线程的main方法。 另一种方法是声明一个实现 Runnable 接口的类。该类然后实现 run 方法。 然后创建Runnable的子类对象，传入到某个线程的构造方法中，开启线程。 2.1.创建线程方式一继承Thread类创建线程的步骤： 1 定义一个类继承Thread。 2 重写run方法。 3 创建子类对象，就是创建线程对象。 4 调用start方法，开启线程并让线程执行，同时还会告诉jvm去调用run方法。 123456789101112public class Demo01 &#123; public static void main(String[] args) &#123; //创建自定义线程对象 MyThread mt = new MyThread(\"新的线程！\"); //开启新线程 mt.start(); //在主方法中执行for循环 for (int i = 0; i &lt; 10; i++) &#123; System.out.println(\"for==main线程！\" + i); &#125; &#125;&#125; 自定义线程类 1234567891011121314151617public class MyThread extends Thread &#123; //定义指定线程名称的构造方法 public MyThread(String name) &#123; //调用父类的String参数的构造方法，指定线程的名称 super(name); &#125; /** * 重写run方法，完成该线程执行的逻辑 */ @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(getName() + \"：正在执行！\" + i); &#125; &#125;&#125; 2.2.创建线程方式—实现Runnable接口创建线程的另一种方法是声明实现 Runnable 接口的类。 该类然后实现 run 方法。然后创建Runnable的子类对象，传入到某个线程的构造方法中，开启线程。 1、定义类实现Runnable接口。 2、覆盖接口中的run方法。。 3、创建Thread类的对象 4、将Runnable接口的子类对象作为参数传递给Thread类的构造函数。 5、调用Thread类的start方法开启线程。 123456789101112131415public class Demo02 &#123; public static void main(String[] args) &#123; //创建线程执行目标类对象 Runnable runn = new MyRunnable(); //将Runnable接口的子类对象作为参数传递给Thread类的构造函数 Thread thread = new Thread(runn); Thread thread2 = new Thread(runn); //开启线程 thread.start(); thread2.start(); for (int i = 0; i &lt; 10; i++) &#123; System.out.println(\"main线程：正在执行！\" + i); &#125; &#125;&#125; 自定义线程执行任务类 12345678910public class MyRunnable implements Runnable &#123; //定义线程要执行的run方法逻辑 @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(\"我的线程：正在执行！\" + i); &#125; &#125;&#125; 3.多线程两种实现方式的区别第二种方式实现Runnable接口避免了单继承的局限性，所以较为常用。实现Runnable接口的方式，更加的符合面向对象，线程分为两部分， 一部分线程对象，一部分线程任务。继承Thread类，线程对象和线程任务耦合在一起。一旦创建Thread类的子类对象，既是线程对象， 有又有线程任务。实现runnable接口，将线程任务单独分离出来封装成对象，类型就是Runnable接口类型。Runnable接口对线程对象和线程任务进行解耦。 4. 线程的匿名内部类使用方式1：创建线程对象时，直接重写Thread类中的run方法 1234567new Thread() &#123; public void run() &#123; for (int x = 0; x &lt; 40; x++) &#123; System.out.println(Thread.currentThread().getName() + \"...X....\" + x); &#125; &#125;&#125;.start(); 方式2：使用匿名内部类的方式实现Runnable接口，重新Runnable接口中的run方法 12345678Runnable r = new Runnable() &#123; public void run() &#123; for (int x = 0; x &lt; 40; x++) &#123; System.out.println(Thread.currentThread().getName() + \"...Y....\" + x); &#125; &#125;&#125;;new Thread(r).start();","categories":[{"name":"多线程","slug":"多线程","permalink":"http://blog.alterem.top/categories/多线程/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://blog.alterem.top/tags/JAVA/"},{"name":"多线程","slug":"多线程","permalink":"http://blog.alterem.top/tags/多线程/"}]},{"title":"mac资源共享","slug":"mac资源共享","date":"2019-06-10T06:50:47.000Z","updated":"2019-06-10T07:06:59.133Z","comments":true,"path":"2019/06/10/mac资源共享/","link":"","permalink":"http://blog.alterem.top/2019/06/10/mac资源共享/","excerpt":"PDFelement Pro For Mac强大的PDF编辑工具V6.8.0软件介绍： Wondershare PDFelement Pro（PDFelement 6 Pro ）是一款安全强大，简单好用的PDF解决方案。拥有您使用PDF所需的一切。 功能介绍： 特性： PDF编辑器 编辑，删除，剪切，复制，粘贴和插入PDF文本和图像。 改变字体属性（类型，大小和风格，对齐）。 插入，更新或删除自定义水印和背景。 使用高级格式应用贝茨编号。 （独家！） 插入，更新或删除页眉和页脚（包括页码和日期）。 插入和编辑超链接。 标记和注释PDF","text":"PDFelement Pro For Mac强大的PDF编辑工具V6.8.0软件介绍： Wondershare PDFelement Pro（PDFelement 6 Pro ）是一款安全强大，简单好用的PDF解决方案。拥有您使用PDF所需的一切。 功能介绍： 特性： PDF编辑器 编辑，删除，剪切，复制，粘贴和插入PDF文本和图像。 改变字体属性（类型，大小和风格，对齐）。 插入，更新或删除自定义水印和背景。 使用高级格式应用贝茨编号。 （独家！） 插入，更新或删除页眉和页脚（包括页码和日期）。 插入和编辑超链接。 标记和注释PDF 添加评论，粘滞便笺，文本框，文本呼出，邮票，添加/编辑链接，徒手画。 突出显示，强调或突破上下文。 创建和管理预建和自定义邮票库。 创建和编辑表单 填写PDF表格。 自动表单字段识别自动创建表单。 从交互式字段对象（如按钮，复选框，单选按钮，列表框和下拉列表）中创建可填写的PDF表单。 访问预先构建，可自定义的可填写表单的集合。 支持在PDF上创建，编辑和添加数字签名。 数据提取（独家！） 从数字和扫描的PDF表格中自动提取数据。 从数字和扫描的PDF格式的批量数据提取到CSV电子表格。 标记并提取扫描PDF的选定表单域中的数据。 从PDF格式导出或导入表单数据。 OCR（独家！） OCR（光学字符识别）使您能够编辑和转换扫描的PDF文件或图片中的字符。 OCR有助于从扫描的PDF表单或发票中提取数据。 PDF / A（独家！） 支持PDF / A作为一个可用的输出格式与ISO标准长期归档。 PDF转换器 除标准版支持的Word，Excel，PPT和Image等普通输出格式外，Pro版本还支持将PDF文件转换为EPUB，HTML，Text，RTF等格式。 使用OCR技术将扫描的PDF转换为可编辑和可搜索的文档。 转换后保留文本，图像，图形，字体和嵌入式元素的原始布局。 页面管理 管理文档中的页面（重新组织，插入，提取，裁剪，旋转和删除页面）。 创建和组合PDF 支持输入格式：pdf / html / webarchive / rtf / txt / jpeg / jpg / png / bmp / gif。 将不同的格式文件组合成一个新的PDF。 由PDFelement创建的文件是100％兼容和Adobe Reader和其他PDF阅读器访问。 安全并共享PDF 设置密码以防止未经授权的用户打开PDF。 应用权限。通过为文档设置权限，限制用户访问PDF打印，复制，编辑和提取。 编辑PDF中的敏感文本和图像。 （独家！） 发送PDF格式的电子邮件附件。 支持直接打印和电子邮件编辑的PDF。 将您的PDF文件保存到流行的云存储服务（Google Drive，Dropbox和Evernote）。 软件兼容性： OS X 10.12或更高版本 软件语言： 多国语言（Chinese/English） 链接: https://pan.baidu.com/s/1l8L-qN7rewdeCuWt1dSlcw 提取码: dfn2 RazorSQL For Mac支持多种数据库的数据库管理工具 V8.3.4软件介绍： RazorSQL 是一款优秀的数据库管理客户端，具有数据库连接、SQL编辑和查询、数据库管理、导入/导出数据等等功能。 功能介绍： RazorSQL 是一款优秀的数据库管理客户端，具有数据库连接、SQL编辑和查询、数据库管理、导入/导出数据等等功能。 支持主流的30多种数据库，如：Cassandra、Oracle、SQLite、MS SQL Server、MySQL、MongoDB等。 软件兼容性： OS X 10.12或更高版本 软件语言： 英文语言（English） 链接: https://pan.baidu.com/s/1_80dXs_NW0ZAp3_umhXQiw 提取码: vn9k Microsoft Office For Mac办公软件 V2019 16.25.19051201软件介绍： Office For Mac包含全新的Word，Excel,PowerPoint，Outlook和OneNote，完全支持Retina，支持中文，大量功能更新，非常强大！ 功能介绍： 全新的、富有时代气息的 Word、Excel、PowerPoint、Outlook 和 OneNote — 将熟悉的 Office 与你钟爱的独有 Mac 功能相结合，让你可以快速上手。 无论身处何处，你都能随时创建精美的文档，深入获取各类信息，从容自信地展示。 Office 应用程序功能强大，借助 Office 应用程序，你可以在平板电脑、手机和 Web 上随时完成工作。 内置工具能更好地支持团队协作，团队成员可以共享、审阅和共同编辑文档、演示文稿和笔记，让你的团队更高效紧密合作。 软件兼容性：OS X 10.12或更高版本 支持10.14系统 软件语言： 多国语言（Chinese/English） 链接: https://pan.baidu.com/s/14QibV7ruW1CJd7QADnAKog 提取码: ne4p Sketch For Mac矢量绘图工具 V54.1软件介绍： Sketch 是Mac上一个强大、创新、易使用的矢量绘图软件。Sketch 简约的设计是基于无限的规模和层次的绘图空间，丰富的调色板、面板、菜单、窗口和控件。虽然使用简单，但是它提供了功能强大的矢量绘图和文字工具，如完美的布尔运算、符号，和强大的标尺、参考线和网格。 功能介绍：简单但功能强大的接口 优化的视网膜和非Retina显示屏 强大的造型，多重阴影，多个填充，渐变，混合，模糊，噪点多… 灵活的布尔操作简单的图形组合成复杂的形状 画板及切片出口多个图像出一个单一的文件 自动@ 2X出口的视网膜图形独特的颜色（与RGB和HSB模式）和字体选择器 美丽的原生文本渲染和文本样式 向量和像素变焦，拉近与无限的矢量精度或个别像素 多站和径向渐变编辑右侧的画布中。强大的所见即所得的渲染。 PDF，EPS和SVG的进口和出口的支持 共享与链接图层样式的自动更新彼此 功能强大，易于使用的矢量工具此外，设计师在以下几个方面将享受以下功能： 为Web和UI设计 复制CSS样式到剪贴板（包括梯度！ ） 切片：将出口作为画布上的图像区域 960px网格，用更先进的网格选项的支持 多页的单个文件里面支持用于图标设计师 画板，画板每一个是自己的小帆布 iOS的图标模板 像素网格 像素效果，如高斯和运动模糊 现V53以上的版本，已经支持中文了 汉化安装说明： 点这里 汉化包下载 1.下载汉化 Sketchl18N-master 压缩包 2.找到 SketchI18N.sketchplugin 双击安装（前提你装好了 Sketch） 3.提示安装成功后点 OK 进入sketch 4.在 Sketch 中按快捷键 control command + x 实现（也可以在菜单栏中 Plugins 中找到 Sketchl 18N） 5.汉化成功 软件兼容性：OS X 10.13或更高版本 软件语言：多国语言（Chinese/English） 链接: https://pan.baidu.com/s/1PcQavpmtNZ5WdT5c4uMp_Q 提取码: 4x1n 复制这段内容后打开百度网盘手机App，操作更方便哦 OmniFocus For Mac最优秀的GTD效率工具 V3.3.2软件介绍： OmniFocus 是一款IOS 和Mac平台上最强大的书籍与事务管理方法“Getting Things Done”工具，你可以有条理有逻辑的安排好你的工作和生活。主要协助您捕捉并管理各项事务与点子，发挥生产力；您可以用它来储存、管理及处理各项动作或任务，而任务或各项目可被指派到相关的专案中，同时OmniFocus也提供了视觉提示来提醒您下一步该执行的动作。 功能介绍： OmniFocus的开发概念是来自David Allen的书籍与事务管理方法“Getting Things Done”，主要协助您捕捉并管理各项事务与点子，发挥生产力；您可以用它来储存、管理及处理各项动作或任务，而任务或各项目可被指派到相关的专案中，同时OmniFocus也提供了视觉提示来提醒您下一步该执行的动作。 OmniFocus可输入kGTD文件的资料、与iCal同步、透过Mail加入任务、使用Spotlight来存取各项任务、过滤专案与任务、支援档案附件…等等。开发人员在产品网页也提供了产品概观与示范影片，供使用者参考。Capture-快速方便记录你所有需要做的事件到你的收件箱中，直到你准备去处理和组织他们。Organize-在OmniFocus中使用强大的contexts特点进行分类的工作模式。 Sync-你在Mac上没有完成你的目标，你可以把他们一起带走。在OmniFocus里，你能够把你的任务数据库同步到服务器或者磁盘里。如果你有iPhone，那就更方便了，直接把所有Mac的任务数据直接同步在iPhone和iPad上。 软件兼容性： OS X 10.13或更高版本 软件语言： 多国语言（Chinese/English） 链接: https://pan.baidu.com/s/1eKH2kA-Z85RKe-wGz2CgnA 提取码: 81iu Launchey For Mac灵活的菜单栏快捷工具 V2.0.9b软件介绍： Launchey是一个轻量级的菜单启动程序，让你启动任何应用程序在您的Mac的菜单栏。你可以选择哪些应用程序是可见的Launchey的菜单栏菜单，选择5个最喜欢的，你就可以直接在你的Mac的菜单栏显示。Launchey让您启动您最喜爱的应用程序设置全局热键。 功能介绍： 特征： 可定制的菜单， 可定制的热键， 直接在菜单栏中显示应用， 可定制的应用程序， 在启动时启动， 快速轻巧， 使用最新的Apple技术构建， 专为OS X El Capitan设计。 软件兼容性： OS X 10.12或更高版本 软件语言： 英文语言（English） 链接: https://pan.baidu.com/s/1LwS_tKeLJ5bKxCICy1TQdA 提取码: 6rma uTools For Mac你的生产力工具集 V0.6.1-beta软件介绍： uTools是一个极简、插件化、跨平台的现代桌面软件。通过自由选配丰富的插件，打造你得心应手的工具集合。 当你熟悉它后，能够为你节约大量时间，让你可以更加专注地改变世界。 功能介绍： 快速启动 强大的快速启动，比你想象的更加深入。对中文语义的友好支持，首字母检索等。 自动识别 uTools支持多种输入源呼出插件，例如：字符输入、文件拖拽、截图粘贴，亦能够自动识别输入内容进入相应插件，如json、时间戳、base64等。 数据同步 uTools各插件产生的数据将保存到本地数据库中。为了便于在不同设备之间共享数据，或是预防重装系统造成数据丢失，我们提供云端数据备份同步服务，登录后可一键开启。 高度自由 uTools 一切皆插件的设计，可以允许你高度自由的定义自己的开发工具，现在你也可以扩展第三方插件或者开发属于自己的插件。 软件兼容性： OS X 10.12或更高版本 软件语言： 多国语言（Chinese/English） 链接: https://pan.baidu.com/s/1ZUjcSggBZrkJCrs2lVdCMA 提取码: vcwa Remote Desktop Manager For Mac优秀的远程桌面管理应用 V2019.1.3.0软件介绍： Devolutions Remote Desktop Manager是一款功能强大直观的远程桌面管理应用，使您可以在用户友好的界面中管理所有远程连接，帐户凭据和其他信息。专门针对网络和系统管理员，以及需要将所有远程连接，密码和其他凭据保存在同一屋檐下的用户。 功能介绍： 功能丰富，易于与管理应用程序一起工作 它的组织良好的界面和易于使用的功能将使您在使用远程桌面管理器之前不需要大量的时间它。 绝对使用远程桌面管理器企业版的所有条目都必须手工完成，无论我们是在谈论凭证，组还是其他更高级的设置。 但是，作为补偿，一旦配置了会话，就可以利用其批量编辑功能，使您可以跨多个会话更改设置。 轻松管理您的远程连接并保存您的所有密码和凭据 此外，远程桌面管理器企业版还支持RDP，SSH，Web，VNC，Telnet，ICA / HDX，TeamViewer，LogMeIn等大量连接，以及25种VPN类型的附加功能。 就安全性而言，远程桌面管理器企业版具有内置的密码管理器，密码分析器和SSH密钥生成器。它还使您能够保存和管理所有密码，并从其他现有密码管理器导入数据。 系统和网络管理员的综合和有用的工具 关于其管理工具，远程桌面管理器企业版集成了用于Citrix XenServer，VMware，Microsoft终端服务器和Hyper-V的控制台，以及远程关闭，局域网唤醒和库存报告功能。 考虑到所有因素，远程桌面管理器企业版提供了一个简化的管理环境和大量的功能，使其成为任何系统和网络管理员与多个远程连接和凭证工作的必备应用程序。 软件兼容性： OS X 10.12或更高版本 软件语言： 英文语言（English） 链接: https://pan.baidu.com/s/1rmHryFLYZiIh-CIh49tA1A 提取码: ihd3 Things For Mac强大的GTD效率工具 V3.9.0软件介绍： Things Mac版是MAC OS平台上的文件管理工具，在一种优雅和直观的方式来帮助组织你的任务。Things for Mac结合了强大的功能与简单的使用界面，通过使用标签和智能过滤栏来更好的为你工作。 十分简洁易用。 您会立即注意到 Things 中的所有功能是如此完美地融合在一起，从而为您带来整洁、集中的体验。没有不必要的铃声和哨声，以及检查器窗口和弹出对话框。只有您和您的待办事项。 一切都以您的待办事项为中心。 Things 中的待办事项比较特别。在列表中，它们会以最紧凑的形式显示复选框和标题。但将它们展开后，它们就会变为一张漂亮的白纸，上面有您想做的各种事情 – 并且如果您需要，还可以包括您的检查列表、标签、提醒事项以及截止日期。 一些超酷的功能。 例如“按类型查看” – 这是浏览列表和查找待办事项的极佳方式。或者自然语言日期解析器 – 只需输入“明天”、“4 天后”或“下周三”，就会跳到所有正确的结果。 一款制作相当精良的 macOS 应用。 Things 可与所有 macOS 技术完全集成： Touch Bar、今天小部件、共享扩展、 Handoff、日历、提醒事项和 AppleScript。或许还包括几项我们忘记列出的技术。 各种出色的功能数不胜数。 每个人都有自己喜欢的功能，不可能将其全部列出。 功能介绍： 如果您是初次使用 Things，请参照以下的基本工作流程： 1.收集想法 快速记录您的想法：与 Siri 交谈或者使用系统范围的键盘快捷键来启动“快速创建”。 2.分类 为您的每个目标创建一个项目。根据您的责任区域群组各项目，例如“家庭”、“工作”或“健康”。定期审查这些项目，从而顺利实现各目标。 3.计划时间 有效管理您的时间 – 同时查看您的待办事项和日历事件，并相应地对每周进行计划。创建重复的待办事项以确保始终如一。 4.充实生活每一天 每天早晨查看您的“今天”列表，然后马上行动。之前计划的待办事项会自动显示在其中。在您进行每天的工作时，这是您唯一需要查看的列表。 5.自定义工作流程 您可以利用标签为待办事项分配自定义类别：标记“重要”待办事项、“日常”待办事项、需要在“办公室”完成的待办事项以及与“凯特”一起完成的待办事项。既可以按标签轻松筛选列表，也可以在所有列表中搜索标签。 软件兼容性： OS X 10.12或更高版本 软件语言： 多国语言（Chinese/English） 链接: https://pan.baidu.com/s/17vMxzdK3yCNgIaALor7w7A 提取码: d4x9 Things For Mac强大的GTD效率工具 V3.9.1软件介绍： Things Mac版是MAC OS平台上的文件管理工具，在一种优雅和直观的方式来帮助组织你的任务。Things for Mac结合了强大的功能与简单的使用界面，通过使用标签和智能过滤栏来更好的为你工作。 十分简洁易用。 您会立即注意到 Things 中的所有功能是如此完美地融合在一起，从而为您带来整洁、集中的体验。没有不必要的铃声和哨声，以及检查器窗口和弹出对话框。只有您和您的待办事项。 一切都以您的待办事项为中心。 Things 中的待办事项比较特别。在列表中，它们会以最紧凑的形式显示复选框和标题。但将它们展开后，它们就会变为一张漂亮的白纸，上面有您想做的各种事情 – 并且如果您需要，还可以包括您的检查列表、标签、提醒事项以及截止日期。 一些超酷的功能。 例如“按类型查看” – 这是浏览列表和查找待办事项的极佳方式。或者自然语言日期解析器 – 只需输入“明天”、“4 天后”或“下周三”，就会跳到所有正确的结果。 一款制作相当精良的 macOS 应用。 Things 可与所有 macOS 技术完全集成： Touch Bar、今天小部件、共享扩展、 Handoff、日历、提醒事项和 AppleScript。或许还包括几项我们忘记列出的技术。 各种出色的功能数不胜数。 每个人都有自己喜欢的功能，不可能将其全部列出。 功能介绍： 如果您是初次使用 Things，请参照以下的基本工作流程： 1.收集想法 快速记录您的想法：与 Siri 交谈或者使用系统范围的键盘快捷键来启动“快速创建”。 2.分类 为您的每个目标创建一个项目。根据您的责任区域群组各项目，例如“家庭”、“工作”或“健康”。定期审查这些项目，从而顺利实现各目标。 3.计划时间 有效管理您的时间 – 同时查看您的待办事项和日历事件，并相应地对每周进行计划。创建重复的待办事项以确保始终如一。 4.充实生活每一天 每天早晨查看您的“今天”列表，然后马上行动。之前计划的待办事项会自动显示在其中。在您进行每天的工作时，这是您唯一需要查看的列表。 5.自定义工作流程 您可以利用标签为待办事项分配自定义类别：标记“重要”待办事项、“日常”待办事项、需要在“办公室”完成的待办事项以及与“凯特”一起完成的待办事项。既可以按标签轻松筛选列表，也可以在所有列表中搜索标签。 软件截图： 软件兼容性： OS X 10.12或更高版本 软件语言： 多国语言（Chinese/English） 下载破解版本： 链接: https://pan.baidu.com/s/1Hw0wnFeuf2RWOpRz5Z1uEw 提取码: g37n TechSmith Snagit For Mac超强截屏神器 V2019.1.3软件介绍：Snagit for mac(TechSmith Snagit)这是一款很好用的Mac OS系统截屏工具，你可以使用此工具轻松抓取图像、文本和影音等多种内容形式，内置强大编辑器，捕捉、编辑一步到位。 功能介绍：Snagit 帮助您通过视频和图像提高交流的水平和质量。您可快速提供更好的反馈，鼓励团队合作，以及改变合伙方式，从而完成工作。您可采集任何图像，然后用各种特效对其进行强化或快速创建计算机屏幕图像视频。根据需要选择特效，方便地自定义任意截屏。您可使用 Snagit 的各种标记工具加亮一个区域，或者将注意力吸引到某个特殊的点上。您也可通过录制屏幕和快速裁剪不需要的部分来快速创建视频。使用 Snagit 制作的所有内容都能方便地与任何人分享。 软件兼容性：OS X 10.12或更高版本 软件语言：英文语言（English）​ 链接: https://pan.baidu.com/s/1YsJxqDOqXvuTzpqMD9pq8Q 提取码: 7bba Better And Better For Mac一款包含很多功能等长截图的macOS工具 V1.6.63软件介绍： BetterAndBetter 是一款集合众多优秀功能的 macOS 软件。包含🖱️鼠标、⌨️键盘、触摸板、情景模式、蓝牙解锁、自动切换输入法、🔉 打字音效等功能，出色的创意和强大的功能将极大提升你的 macOS 使用体验。 功能介绍： 触摸板模块 这个模块是手势识别应用程序，在 MacBook 系列里自带的触摸板上，软件会监听你几个手指，做不同的手势动作，如果手势被识别，BetterAndBetter 将执行已经制定规则的相应操作。 目前 BetterAndBetter 可以模拟按键，执行软件预设的命令，执行 apple script。 其中有一个开关是开启二指绘图功能，意思是按住一个手指，另一个手指在左侧轻拍一下，就可以用单指绘图了，相当于按住鼠标右键做拖移动作，就会执行鼠标模块里面的某些功能。 选择手势时如果选择黑名单，就会在你选择的程序里所有的手势不起作用。 鼠标模块 这个模块是鼠标手势识别应用程序。按住右键部分是在按住鼠标右键的同时使用鼠标进行的运动。 如果手势被识别，BetterAndBetter 将执行某些操作。 组合按键部分，是指按住鼠标右键，然后配合菜单里指示的动作去自定义执行动作。 其他按键部分，是指按住其他按键，然后配合相应菜单里指示的动作去自定义执行动作。 手势相似度，意思是你鼠标画的轨迹和数据库里已经设置的轨迹比对的吻合程度，这个值一般设定为 75–95，具体可以根据自己的实际操作以后的感觉来设定。 鼠标加速度滑块，你可以根据自己的习惯调节鼠标的加速度，数值为零时就是关闭鼠标的加速度。 自动跳窗模块 这个模块类似 popclip 这个软件，按住鼠标左键，然后拖移去选择文本或者在 Finder 里面去选择文件，软件会根据不同的情况自动跳出不同的窗口，点击已经跳出的窗口，就可以执行相应的动作 因为有 2 个表格，所以先点击一个表格，然后在按“+”等按钮。表格里的内容都是可以修改的，特别提醒的是这两个表格里面的行是可以拖移的，以此来调整跳窗的先后次序。 需要特别解释的是状态栏，有 ⌘C，⌘V，⌘X和⌘，它的意思是在激活的 App 里的复制，粘贴，剪切按钮是点亮的，对应的标识才会出现在跳窗里，⌘ 表示在任何情况下都会出现在跳窗里。 在选择文本时有以下三种情况下会跳出窗口： 鼠标拖拽划选； 在文本上面双击鼠标； 鼠标没有移动的情况下，在能输入的地方隔开 0.6 秒以上的两次点击鼠标。 在选择文件时也有以下三种情况下会跳出窗口： 鼠标拖拽划选在 Finder 程序的空白处； 桌面上双击鼠标； 在鼠标没有移动的情况下，在文件或者目录上面隔开 0.6 秒以上的两次点击鼠标。 边角触发模块 这个模块是可以设定在不同的桌面时，左键或右键点击屏膜的四个角，可以分别设置一些动作，这些动作有快捷键，预设动作和 applescript 三种。 窗口管理 当你移动窗口时，会自动出来八个提示框，分别代表分屏的位置。 吸附功能：当你用鼠标把一个窗口拖移向屏膜左边或者右边，当窗口的一边接近屏膜边缘时，在相应位置会出现一条黄色的线，此时松开鼠标按键，窗口就会吸附在屏幕一侧。当鼠标移动到已经有窗口吸附的屏膜的左边或者右边时，鼠标下被吸附的窗口就会自动弹出来。鼠标离开这个窗口时，窗口又会吸附在屏幕的两边，注意：窗口宽度等于屏幕宽度的窗口是不会被吸附的。 工具箱模块 蓝牙解锁 这个模块是在需要输入系统密码时，通过检测已经配对的蓝牙设备是否能连接，能连接就自动输入密码。只有从睡眠，屏保，和关闭屏膜中恢复时需要检测蓝牙的，在其他需要系统密码时都是不经过蓝牙检测，就直接输入密码的，比如在偏好设置需要密码时。 登录时拍照，如果激活这个按钮，就是从睡眠，屏保，和关闭屏膜中恢复时一方面检测蓝牙设备，同时打开自带的摄像头进行拍照，如果最后没有检测到蓝牙设备，就把照片存储在你所选择的目录，而且你自己可以打开 icloud 同步，那样就把照片马上送到了云端了，你就能知道谁动了你的Mac。 剪切板管理 BetterAndBetter 可以记住你最近使用过的十个剪切板内容，你还可以在工具箱模块增加三个固定的剪切板内容。 有两种触发模式： 在自动跳窗里，在跳出来的窗口里点击”✄”的图标； 在快捷键模块里有一个可以自定义的快捷键。 两种模式都会弹出一个剪切板管理的窗口。 也有两种执行方式： 用鼠标点击已经跳出窗口的任意一行； 按对应的数字键，调用固定的剪切板内容需要先按住Fn键，再按相应的数字键。 更多功能….. 点击这里官方视頻教程软件兼容性： OS X 10.12或更高版本 软件语言： 多国语言（Chinese/English） 链接: https://pan.baidu.com/s/1KH1m4WsoRcRlwf9wQIPikA 提取码: yrtn SQLPro Studio For Mac数据库客户端 V2019.05.10.00软件介绍： SQLPro Studio Mac版是一款Mac上优秀的数据库客户端，SQLPro Studio支持Postgres，MySQL，Microsoft SQL Server，Oracle等主流数据库，可以方便易用的管理数据库，很不错！ 功能介绍： 功能特点 +智能感知/ SQL自动完成。 +语法与定制主题突出。 +基于选项卡的用户界面。 +快速访问表和列。 +SQL美化/格式化。 +支持的NTLMv2。 +支持Netbios的。 +主密码的支持，以提高安全性。 SQLPro Studio支持以下数据库服务器： MySQL的＆MariaDB的 +PostgreSQL +的Microsoft SQL Server（2005及以上） +甲骨文（8i和以上） 软件兼容性：OS X 10.12或更高版本 软件语言： 英文语言（English） 链接: https://pan.baidu.com/s/1haEku9VhVnpGsEM6pshVLg 提取码: zv8q NeatDownloadManager For Mac一款免费好用的多线程下载工具 V1.0软件介绍： NeatDownloadManager Mac版是Mac平台上的一款免费好用的多线程下载工具。NeatDownloadManager Mac版使用动态分段算法下载文件，支持HTTP，HTTPS和FTP协议，HTTP和代理身份验证。 功能介绍： NeatDownloadManager Mac版支持暂停/恢复功能以及更新过期下载连接，NeatDownloadManager Mac版具有浏览器扩展，可以用于随时捕获下载链接和从在线视频网站上下载视频。 软件兼容性： OS X 10.12或更高版本 软件语言： 英文语言（English） 链接: https://pan.baidu.com/s/1zgSoATpucEGD0dQcZW4Ilg 提取码: 7yy6 Dash For Mac编程文档管理工具 V4.6.3软件介绍： Dash for mac是使用与Mac OS平台的软件编程文档管理工具，可以浏览API文档，以及管理代码片段工具。Dash自带了丰富的API文档，涉及各种主流的编程语言和框架。 功能介绍： 可以浏览API文档，以及管理代码片段工具。Dash自带了丰富的API文档，涉及各种主流的编程语言和框架，包括:ActionScript, Android, C++, CAppuccino, Cocos2D, Cocos3D, Corona, CSS, Django, Groovy, HTML, Java, JavaFX, JavaScript, jQuery, Kobold2D, Lua, MySQL, Node.js, Man Pages, Perl, PHP, Python, Ruby, Ruby on Rails, Scala, Sparrow, SQLite, Unity 3D, WordPress, XSLT, XUL。 利用Dash的代码片段管理功能，你可以把日常使用频繁的代码保存起来，然后为其设置一个独一无二的缩写，这样一来原本需要一遍又一遍的敲击键盘重复录入的繁琐工作，就可以交给Dash来轻松搞定。 软件兼容性： OS X 10.12或更高版本 软件语言： 英文语言（English） 链接: https://pan.baidu.com/s/1BPILqRQPln1RdKIwr1LWDw 提取码: vn26 One Switch For Mac集合一键切换系统各项功能工具 V1.3软件介绍： One Switch是一款小巧的应用程序，旨在通过快速访问一些重要的交换机来提高您的效率。它可以从菜单栏打开，只需点击几下即可切换某些系统功能。 功能介绍： 隐藏桌面图标 只需单击一下即可隐藏凌乱的桌面。 暗模式 随时切换暗模式。 保持清醒 防止Mac睡眠或显示屏幕保护程序。 屏幕保护程序 有时您需要手动打开它。 AirPods 只需一秒钟即可将AirPods与Mac连接 软件截图： 软件兼容性： OS X 10.12或更高版本 软件语言： 多国语言（Chinese/English） 链接: https://pan.baidu.com/s/1Pagw3SkhRQ6epHiBnbr1NA 提取码: kbdr Money Pro For Mac强大的个人财务管理工具 V2.1.00软件介绍： Money for mac是一款Mac平台上好用的个人财务管理工具，可以轻松的处理收入和消费的记录和核算。号称Mac平台上最好的个人理财软件。 功能介绍： Money易于使用的个人全面财务管理应用。它将您的个人财务分类清晰管理，个人收入明细以完善的图表形式来表示。它旨在帮助你控制你的财务支出，在Mac上轻松方便的记帐还可与iphone同步。 一个漂亮的界面。 管理你不同的帐户来平衡支出。 智能调度。 提供多种高级财务报告。 简易的预算规划。 投资跟踪。 软件截图： 软件兼容性： OS X 10.12或更高版本 软件语言： 多国语言（Chinese/English） 链接: https://pan.baidu.com/s/1CLzuDlVzFgfxwysv0Hjkfw 提取码: i2wk Fantastical For Mac优雅的日历工具 V2.5.9软件介绍： Fantastical的设计者Flexibits结合了Fantastical的传统优势，实现了完整的桌面体验，给用户带来了全新的Fantastical 2。 功能介绍： Fantastical的设计者Flexibits结合了Fantastical的传统优势，实现了完整的桌面体验，给用户带来了全新的Fantastical 2。Fantastical 2与前一代的最大区别在于，Fantastical 2现在作为一个完整的App可以让用户在独立窗口中查看全天、周、月、年界面。它的界面窗口使用了智能双面板设计，左侧显示正在运行的议程，右侧显示完整的日历。且Fantastical 2还具有自定义日历这一大特色，它还同时支持Mac上已建立的iCloud、Google以及Yahoo等的日历服务。 软件截图： 软件兼容性： OS X 10.12或更高版本 软件语言： 英文语言（English） 链接: https://pan.baidu.com/s/1sSQkDDrZDI65_EAEw5TqDw 提取码: ksjx Amadeus Pro For Mac强大的音乐编辑器 V2.6.0软件介绍： Amadeus pro for mac是Mac os平台上的一款功能非常强大的Mac音乐编辑器，Amadeus Pro Version for mac是一款强大的多轨音频编辑器，支持多种格式，如MP3, AAC, Ogg Vorbis, Apple Lossless, AIFF, Wave等。 功能介绍： 【１】多轨编辑 Amadeus Pro是一个功能齐全的多轨音频编辑器。每首曲目可以分割成多个相互独立又容易拖曳的音频剪辑。此外，音频单位可以应用于实时的个别曲目，而无需任何破坏性编辑。 【２】批处理 如果你想转换成MP3文件，让Amadeus Pro来！强大的批量处理器不仅允许你转换大量任何格式的文件，还可以处理任何序列的音效。 【３】维修中心 方便的维修中心，可让您寻找并修复裂缝，只需一次简单的鼠标点击。此外，Amadeus Pro强大的降噪功能让您轻松地摆脱恼人的嘶嘶声。 【4】功能介绍 将唱片或磁带转换到CD Amadeus Pro的强大的去噪和修复功能，可以轻易将您最喜爱的录音或老唱片里恼人的嘶嘶声去除 分割成多个音轨录制 只需鼠标轻轻点击就能Amadeus Pro能将您的录音刻录到CD上 专用均衡器可以将声音做旧处理 【5】强大的批处理功能 支持转换为以下文件格式：AIFF, WAVE, Mp3, Ogg Vorbis, Mp4, M4a (AAC和Apple原声), FLAC, Apple CAF, QuickTime, SoundDesigner II, Next, Mp2 (只读)。 允许您申请任意序列的音响效果集合。 保留元数据（艺术家，歌名，专辑封面等） 【6】音效 全力支持两个音频单元和VST音频插件。扩展和定制功能能满足您的各种特殊要求。 建成程序最常用的效果（多波段图形均衡器，音量正常化，淡入/淡出，回音，速度和音调的变化等） 软件截图： 软件兼容性： OS X 10.12或更高版本 软件语言： 英文语言（English） 链接: https://pan.baidu.com/s/1HISK5fVwuKObgsJ9AxFztw 提取码: 8vyk Drive Scope For Mac硬盘检测分析工具 V1.2.5软件介绍： Drive Scope是由Micromat发布的新程序，它被定义为“SMART市场最完整的实用程序”。它与SSD和HDD（但不是RAID）兼容，并收集和分析Mac驱动器的状态。 功能介绍： Drive Scope硬盘驱动器（和固态硬盘）是Mac中最易出故障的组件。出于这个原因，事实上，驱动器制造商已经在驱动器中内置了自我监控，分析和报告技术。（a.k.a.SMART）大多数实用程序几乎不会泄露这些信息的表面，只需报告基本要素：通过或失败。通常，一旦发生整体故障，就没有足够的时间从驱动器获取重要数据。使用Drive Scope，您可以了解连接到Mac的大多数驱动器的运行状况。 Drive Health 使用Drive Scope，您可以看到Drive的健康状况的完整图片。有关驱动器正在监控的每个方面的详细信息可供查看。查看有助于驱动器运行状况的每个属性 – 详细信息。查看哪些属性导致整体故障，哪些属性仅仅是信息性的。 控制测试 通常，只要方便，驱动器就会检查它的SMART属性。使用Drive Scope，您可以手动触发驱动器的内部测试，以确保SMART数据尽可能地保持最新状态。检查驱动器上次使用驱动器测试日志进行测试的时间。 信息 首次打开Drive Scope时，将显示一个信息页面，其中汇总了有关驱动器的所有重要信息。请参阅Drive Scope的高级运行状况评估，以及遇到的错误数量，以及特定于驱动器的型号和容量信息。 软件截图： 软件兼容性： OS X 10.12或更高版本 软件语言： 英文语言（English） 链接: https://pan.baidu.com/s/1DRBX83HI7lkXEfsxaLzm7Q 提取码: 83as Downie For Mac在线视频下载超级工具 V3.7.3软件介绍：Downie for Mac是一个超级易于使用的视频下载工具，支持YouTube，Vimeo 等超过170个视频网站。它不会因为大量的选项而让用户困扰 - 它使用起来非常简单。最新破解版，实测支持国内的优酷，爱奇艺和土豆以及国外的Youtube，如果你对视频下载有强烈的需求，那么Downie 是一个简单易用的视频下载工具。 功能介绍：Downie for mac可能看起来像一个简单的拖放和拖放应用程序。它被设计为简单易用 - 只需拖放链接到Downie，它就会下载该网站上的视频。 软件截图： 软件兼容性：OS X 10.12或更高版本 软件语言：多国语言（Chinese/English） 链接: https://pan.baidu.com/s/1M5so-5pc-oMS6SsrlSowow 提取码: w9mk Squash For Mac小巧实用的是图片压缩工具 V2.0.4软件介绍： Squash是一款小巧的图片压缩软件，在不影响图片质量的前提下，可以大大的减少图片的大小。可以进行动态图片压缩、jpg图片压缩、PNG图片压缩、GIF动态图片压缩，小巧实用的一款软件！ 功能介绍： Squash (was Squish) 是降低文件大小压缩您的图片一个超级简单的应用程序！不要失去质量，或最终以颗粒状或可怕的图像。把保持他们现有的分辨率和质量，只是减少文件大小！无论你的理由，挤是伟大的优化图像： 发送电子邮件附件减少文件大小。 通过优化计算机上的大型照片集节省空间。 优化网站和电子邮件活动的形象，使他们立即加载在线。 缓慢的互联网？在挤滴图像保存时间上传到脸谱网或推特！ 软件兼容性： OS X 10.12或更高版本 软件语言： 英文语言（English） 链接: https://pan.baidu.com/s/1o8RjKaEHA3PmSxvSvaADUA 提取码: 51es PDF Squeezer For Mac压缩工具 V3.10.3软件介绍： PDF Squeezer for Mac是Mac OS平台上的一款 PDF 简易压缩工具，在PDF文件过大的时候，PDF Squeezer 可以移除不相干的信息和压缩图像的方式来缩减PDF文件的大小。可以帮助您节省带宽费用、数字存储费用以及网络传输时间。 功能介绍： 轻轻松松将 PDF 文件拖拽至应用程序窗口或图标即可 选择预设滤器，亦可以创建自定义滤器 批量压缩多个文件 支持受密码保护的 PDF 文件 一键压缩’自动压缩并存储 软件截图： 测试系统语言： macOS Sierra/macOS High Sierra简体中文 软件语言： 多国语言（Chinese/English） 链接: https://pan.baidu.com/s/1dgGOwwlxiW5GC6ftsMHuNw 提取码: rnd3 NXPowerLite Desktop For Mac多格式文档压缩工具 V8.0.7软件介绍： NXPowerLite将压缩PDF，JPEG，Microsoft PowerPoint和Word文件，简单有效，同时很容易作为电子邮件附件。 功能介绍： NXPowerLite Desktop for Mac是一款文档压缩工具，可以简单有效地压缩PDF，JPEG，Microsoft PowerPoint和Word文件，使它们易于以附件形式发送电子邮件。对于压缩不好的文件尤其有效。优化的文件保持相同的格式 – PDF仍然是一个PDF。它看起来和感觉与原始相同，只是小得多。您可以通过选择文件并使用Finder中的“优化和电子邮件”来优化和自动将文件附加到新电子邮件中。Mac或Windows注册密钥的一个关键用于NXPowerLite桌面将与Mac或Windows版本兼容，所以如果您切换平台，您可以继续使用NXPowerLite。 这也意味着，如果您购买多用户许可证，则无需事先指定每个平台的数量。 软件截图： 软件兼容性： OS X 10.12或更高版本 软件语言： 英文语言（English） 链接: https://pan.baidu.com/s/1KHvef1XlAt6RlQjrPvwwHg 提取码: 5mig UninstallPKG For Mac实用的PKG完全卸载工具 V1.1.6软件介绍： UninstallPKG是一款Mac上实用的PKG完全卸载工具，顾名思义，这是一款PKG安装包卸载工具，可以搜索扫描 Mac 上安装的所有 PKG 程序，然后完全卸载删除，节省磁盘空间，比如 Office for Mac 等软件就可以用这款软件帮助快速完全的卸载，非常的方便！ 功能介绍： UninstallPKG允许您完全删除所谓的“软件包”(文件扩展名，pkg)和所有从您的Mac上安装的内容，它可以通过删除不需要的功能，例如未使用的打印机驱动程序，或者完全删除您不再使用的应用程序来回收宝贵的磁盘空间。卸载程序还可以通过删除已经部分删除的应用程序中的遗留文件，从而保持Mac的干净。它可以一次性删除Office 2011所有37290个文件，或者完全删除Java或Flash插件之类的东西。它还可以在卸载应用程序之后，将其从Dock和LoginItems目录中删除，并删除所生成的文件(首选项等)。 软件兼容性： OS X 10.12或更高版本 软件语言： 多国语言（Chinese/English） 下载破解版本： 链接: https://pan.baidu.com/s/1edSKHjQTQu99svPMKCtAMA 提取码: 17kx Navicat Premium For Mac强大的数据库管理工具 V12.1.22软件介绍： Navicat是最优秀的数据库图形化管理客户端，支持MySQL、SQL Server、SQLite、Oracle 和 PostgreSQL 等数据库，支持数据库建模，正向和反向工程，数据同步等功能，而Premium版本是包含了Navicat所有功能的最强大版本，是首选的数据库客户端工具！ 功能介绍： Navicat Premium 结合了其他 Navicat 成员的功能。有了不同数据库类型的连接能力，Navicat Premium 支持在 MySQL、SQL Server、SQLite、Oracle 及 PostgreSQL 之间传输数据。包括存储过程，事件，触发器，函数，视图等。 Navicat Premium 适用于三种平台 - Microsoft Windows、Mac OS X 及 Linux。它可以让用户连接本机或远程服务器、提供一些实用的数据库工具如数据模型工具、数据同步、结构同步、导入、导出、备份、还原及报表以协助管理数据。 软件兼容性： OS X 10.12或更高版本 软件语言： 英文语言（English） 链接: https://pan.baidu.com/s/1DgDwQmM9Sixmw9vlQPUPcw 提取码: 899w Axure RP 9 Pro Edition For Mac交互式原型设计工具 V9.0.0.3650软件介绍： Axure RP 9 for Mac破解版是专为快速原型设计而生，它可以辅助产品经理快速设计完整的产品原型，并结合批注，说明以及流程图，框架图等元素将产品完整地表述给各方面设计人员，如UI 、UE等等，并在讨论中不断完善。 功能介绍： 强大的原型，无需编码 使用条件逻辑，动态内容，动画，数学函数和数据驱动的交互创建简单的点击图或功能强大的丰富原型，无需编写任何代码。 很容易分享单击一个按钮，axure rp将您的图表和原型发布到云端或本地的 Axure Share 。只需发送一个链接（和密码），其他人就可以在浏览器中查看您的项目。在移动设备上，使用适用于iOS和Android的浏览器或Axure Share App。 DIAGRAMMING +文档创建流程图，线框，模型，用户旅程，角色，创意板等。从内置或自定义库中快速拖放元素以创建图表。然后，使用填充，渐变，线条样式和文本格式设置样式。 注释您的图表和原型以指定功能，跟踪任务或存储项目信息。将您的笔记整理到不同的受众群体的不同字段中。选择要在HTML中或在包含屏幕截图的自动生成的Word文档中显示哪些注释。 更轻松的团队协作axure rp允许多人同时处理同一文件，使您的团队更容易协同工作。在Axure共享或SVN上创建团队项目，并使用签入和签出系统来管理更改。团队项目还会记录每次签到时的备注更改历史记录。 软件兼容性： OS X 10.12或更高版本 软件语言： 多国语言（Chinese/English） 下载破解版本： 链接: https://pan.baidu.com/s/1dLfSxialAvRSk4tXlb-a0g 提取码: d52e Polarr Photo Editor Pro For Mac泼辣修图 V5.5.1软件介绍： 泼辣修图Mac版是一款Mac OS平台上的修图软件，泼辣修图本身是一款非常出名的在线修图工具，现在泼辣修图继泼辣修图移动端之后，推出了泼辣修图Mac版。 功能介绍： 泼辣修图 Mac 版体积之小令人惊讶，仅有 4MB 的大小，却可并发出超高的性能表现，支持JPEG、带透明效果的PNG，以及大多数RAW图片，RAW图片最大可支持 4200 万像素，这样的表现还不会占用系统太多的硬件资源，而且耗电量也不高。 软件内核采用了 Webkit，方便用户对操作窗口进行随意调整，而且修图中支持 Trackpad 手势缩放控制。整个界面设计和功能都和 iOS 版一致，但并没有像 iOS 版那样提供滤镜内购包，如果你想使用这款客户端，就必须一次性买单，所有的滤镜包都会收入囊中，我觉得开发者能在这一点上再灵活一些，将滤镜包做成内购形式会更得用户支持！ 使用泼辣修图你不必像 Pixelmator 那样费劲周转，就像妹子们用的美图秀秀一样，软件所有的功能都会修图而生，你可以在最短时间内修出一张完美的图片。 软件兼容性：OS X 10.13或更高版本 软件语言： 多国语言（Chinese/English） Aimersoft Video Converter Ultimate For Mac全能视频转换工具 V11.0.1.2软件介绍：Aimersoft Video Converter Ultimate for Mac是一款Mac OS X下时尚、直观、非常迅速的一体化视频/音频转换器，DVD截取器，DVD刻录机，网页视频下载器和设备转化系统。 功能介绍：1、轻松下载，编辑和转化任何规格和高清视频格式2、在保持DVD原有质量的情况下截取，复制，编辑和刻录DVD3、将您喜欢的音频从视频和DVD中截取出来并进行编辑和格式转换4、将影音文件保存转移到各种可携式装置内，包括IPhone, Android等5、将AVI,MP4,MOV,M4V,MKV等格式的2D视频转换为3D，打造属于自己的3D世界。 软件兼容性：OS X 10.12或更高版本 软件语言： 英文语言（English） 链接: https://pan.baidu.com/s/1eb6ZoGjUrxrjVd9K1iI76Q 提取码: ettx Bettertouchtool For Mac鼠标Magic Mouse增强工具 V3.02软件介绍： Bettertouchtool for mac 这是专为Mac用户开发的 Magic Mouse 鼠标功能增强制作的软件。你可以通过 bettertouchtool for mac 对你的 Magic Mouse 设置多种手势功能，还可以对单个或者全局的软件进行操作功能定制。总体来说是一款非常强大的Magic Mouse 辅助软件。 功能介绍： 1.可实现不用点击而是触摸的方式操作。 2.支持多种手势，1个，2个，3个手指的操作。 3.支持缩放操作。 4.可以实现对全局和单个软件的操作定制。 你还可以对TouchPad可以进行相同的设置。也可以调节鼠标移动缓慢的问题。实现控制之后你会发现 Magic Mouse 的功能比MouseZoom要强大的多。 软件兼容性： OS X 10.12或更高版本 软件语言： 英文语言（English） 链接: https://pan.baidu.com/s/1RdJwPUNyk0CivSk64mHcXw 提取码: xe4s CleanMyMac X For Mac强大实用的系统清理工具 V4.4.2软件介绍： CleanMyMac 系列最新X测试版本，CleanMyMac应该是世界上最容易使用且最强大的Mac实用系统清理工具，CleanMyMac X是一款集所有功能于一身的先进程序卸载清理器，只需两个简单步骤就可以把系统里那些乱七八糟的无用文件统统清理掉，节省宝贵的磁盘空间。 功能介绍： 作为CleanMyMac的升级版，它可以流畅地与系统性能相结合，静默清理、记录更新、清洁缓存、快速和安全删除、卸载应用程序和清空回收站等重要功能。节省硬盘空间，提高电脑的速度，CleanMyMac 3会使您的Mac更出色 点击右下角的“Scan”按钮，CleanMyMac将对整个系统进行扫描. Caches：系统缓存文件，清理缓存文件后应用程序加载速度将会变得很快。 Logs：系统和应用程序的日志文件. Language Files：通过此项你可以把你应用程序里面不常用的语言全都给删除，在右下角可以选择你需要删除好的语言。 CleanMyMac为你喜欢的东西腾出空间。CleanMyMac拥有一系列巧妙的新功能，它可以让你安全、智能地扫描和清理整个系统，删除大量未使用的文件，缩小iPhoto库的大小，卸载不需要的应用程序，或者修复那些开始不正常工作的应用程序，从一个地方管理所有的扩展，并做更多的工作–所有这些都来自一个新设计的漂亮简单的界面。 链接:https://pan.baidu.com/s/1XUY3etjrfcdd0KJ-J6EMfA 密码:avj7 OnyX For Mac系统维护优化工具 V3.6.4软件介绍：OnyX 可以帮助你检视启动的磁盘信息和文件系统的结构信息，而且可以运行很多的系统维护子程序，比如配置Finder,Dock, Dashboard, Exposé, Safari, Login window中的一些隐藏的功能。 功能介绍：OnyX 是一种多功能实用的OS X，它允许您验证启动盘的系统文件的结构，运行系统维护的相关任务，配置Finder，隐藏参数对接，聚光灯，和一些苹果自己的应用程序，删除缓存，删除一定数量文件和文件夹可能成为累赘，和更多。 软件兼容性：OS X 10.13或更高版本 软件语言：多国语言（Chinese/English） 链接: https://pan.baidu.com/s/1Oqam_kPoS0MJOl-JawL72w 提取码: mcta macOS Mojave 下的破解失效或崩溃的解决方法Mac**开启关闭SIP（系统完整性保护）** 1. 如何查看SIP状态 在终端中输入csrutil status，就可以看到是enabled还是disabled。（只要显示 disabled 说明已经禁用SIP） 2. 如何关闭SIP a 重启MAC，按住cmd+R直到屏幕上出现苹果的标志和进度条，进入Recovery模式 b 在屏幕最上方的工具栏找到实用工具（左数第3个），打开终端，输入：csrutil disable c 关掉终端，重启MAC 3. 如何开启SIP 与关闭的步骤类似，只是在2b中输入csrutil enable 即可 10个 macOS 小技巧1.教你打出苹果logo 快捷键：option+shift+K 2.如何设置网红屏保 站内搜索 fliqlo,下载后双击打开即可，记得设置「开机前闲置时间」哦，如果设置为两分钟，那么你的电脑在没有任何操作的情况下，两分钟之后屏保就会自动显示了。 3.快速清除废纸篓垃圾 使用下面的快捷键可以让你不用打开废纸篓，也不用要求你是否确认删除，直接可将废纸篓垃圾清空。 快捷键:「⌘+Option+Shift+Delete」 4.更精确的调节音量和亮度 Mac上的调节音量或者亮度只有16格，精确度不够高，有时调节一个单位还是不能满足我们的需求，这时候我们就需要更高精度的调节。 快捷键：Option + Shift + 音量键（亮度键） 5.更精确的复制内容 如果你用 Mac 自带的预览复制 PDF 中的内容时，它会选中你鼠标开始到结束之间的所有内容，但是对于表格来说，我们有时不必要复制所有内容，这时我们可以按住「option」键再选择所需的内容。 6.移动或删除菜单栏图标 如果你的状态菜单栏的图标比较多的话，想要删除的话怎么办呢？这时可以按住「command」键，再拖动相应的图标，移出菜单栏即可删除。 7.放大你的屏幕 设置：点击左上角苹果logo「」-&gt;「系统偏好设置」-&gt;「辅助功能」-&gt;选择「缩放」-&gt;勾选「配合修饰键使用滚动手势来缩放」 使用：按住「control」键，两个手指在触摸板上向上或者向下移动即可进行放大或缩小 8.你可能不知道的截屏技巧 全屏截图：shift+command+3 部分截屏：shift+command+4 下面才是关键：部分截屏时配合空格还有两种截屏方式 1.shift+command+4+「空格」 选取固定窗口 2.shift+command+4后框选后按住「空格」键拖动选框 自定义选择窗口 9.开启分屏显示功能 有时候需要两个窗口同时打开协同工作时，这个功能就非常的有帮助了， 你只需要三指按压软件窗口的最大化按钮直到出现分屏即可。 10.屏幕太小？那就多开几个窗口 一个屏幕不够用的时候，我们可以再新建几个空白屏幕，这时我们只需四指在触摸板向上滑动，点击最右侧的「+号」即可。删除的话只需将鼠标移到每一个屏幕上，出现「叉号」并点击删除即可。 Mac 软件安装问题解决在 Mac 上安装非 App Store 软件时，可能会遇到一些这样或那样的问题，这篇文章就 Mac 从 .dmg 安装软件时可能遇到的问题提一些解决方法。 状况一.双击 .dmg 安装软件出现以下情况： 解决方法：这种情况可能是 .dmg 文件在下载过程中出现了未知错误或者没有下载完全，解决方法是重新下载 .dmg 安装包。 状况二.双击 .dmg 安装软件出现：打不开“XXXX”，因为它来自身份不明的开发者。 或者，“XXXX”已损坏，打不开。您应该将它移到废纸篓。 解决方法：打开 系统偏好设置 — 安全性与隐私 — 通用 点按锁按钮以进行更改（会要求输入密码）， 在 “允许从以下位置下载应用：” 选择 “任何来源” ， 最后将锁按钮锁上。 有的 Mac 在 “允许从以下位置下载的应用” 并没有 “任何来源” 这个选项， 这就需要多进行一个步骤： 找到“终端”这个应用并打开，将 sudo spctl –master-disable 这句命令复制并粘贴到终端，回车，输入密码（用户开机密码，密码是不显示的，输入完回车即可）。 再打开 系统偏好设置 — 安全性与隐私 — 通用 — 允许从以下位置下载的应用 ，系统已经选择 “任何来源” 选项。 对于 “XXXX”已损坏，打不开。您应该将它移到废纸篓。 这个问题，还有一个解决方法，不过不如上面这个彻底，还是介绍一下。 将 xattr -r -d com.apple.quarantine 命令复制粘贴到终端，同时在一旁打开 访达（Finder），在边栏里选择应用程序，然后将出现这个问题的应用往终端里拖拽，释放鼠标，回车，问题解决。","categories":[{"name":"资源","slug":"资源","permalink":"http://blog.alterem.top/categories/资源/"},{"name":"mac","slug":"资源/mac","permalink":"http://blog.alterem.top/categories/资源/mac/"}],"tags":[{"name":"资源","slug":"资源","permalink":"http://blog.alterem.top/tags/资源/"},{"name":"mac","slug":"mac","permalink":"http://blog.alterem.top/tags/mac/"}]},{"title":"随谈2","slug":"随谈2","date":"2019-03-27T04:48:35.000Z","updated":"2019-03-27T04:49:48.000Z","comments":true,"path":"2019/03/27/随谈2/","link":"","permalink":"http://blog.alterem.top/2019/03/27/随谈2/","excerpt":"年轻时总是逢人就说自己的理想 那个时候没有顾忌 随心所欲的可以高谈阔论 没有任何束缚 总觉得凭借自己的一腔热血 梦想这东西并不是遥不可及","text":"年轻时总是逢人就说自己的理想 那个时候没有顾忌 随心所欲的可以高谈阔论 没有任何束缚 总觉得凭借自己的一腔热血 梦想这东西并不是遥不可及 后来只和几个要好的朋友谈谈未来 开始有所保留 总觉得未来这事情不需要太多人知道 只要默默努力就好 总是相信只要努力 未来并不是那么遥遥无期 现在再也不和任何人讨论生活 才开始明白 其实生活是自己的 和他人无关 只会在夜深人静的时候仍然敲打这键盘 把这一天未完成的事情做完 原来生活就是每天重复做着一些琐碎的事情 从年少无知到成人的世界 从闹腾任性的个性到成熟冷静 我们终究还是变了 唯愿初心不变 年轻时候的梦依旧在心中","categories":[{"name":"文章","slug":"文章","permalink":"http://blog.alterem.top/categories/文章/"}],"tags":[{"name":"文章","slug":"文章","permalink":"http://blog.alterem.top/tags/文章/"}]},{"title":"随谈","slug":"随谈","date":"2019-03-27T04:43:17.000Z","updated":"2019-03-27T04:47:36.000Z","comments":true,"path":"2019/03/27/随谈/","link":"","permalink":"http://blog.alterem.top/2019/03/27/随谈/","excerpt":"曾经我也坐在工位笑别人， 那个人那么傻， 不就是被辞职了么，为什么要跳楼？ 笑他傻，笑他看不懂，笑他想不开， 笑他不配做一个合格的丈夫， 不配为人之父…","text":"曾经我也坐在工位笑别人， 那个人那么傻， 不就是被辞职了么，为什么要跳楼？ 笑他傻，笑他看不懂，笑他想不开， 笑他不配做一个合格的丈夫， 不配为人之父… 但是今天我才发现， 是的，被离职是一件简简单单的事情， 家里的妻儿，未出生的花蕾，年迈的父母， 我也想不出能用什么面容来面对他们， 我担心我沮丧的心情会带给妻子压力， 我担心我失落的表情让父母有压力， 我担心我没办法照顾好妻儿。 一份好的工作对我来说是多么的幸福？ 一份我喜欢的工作是对我的生活以及家庭的生活多大的保障？ 但是现在呢？ 我几乎一无所有，不对我还有我爱的和爱我的家人… 如果不是他们，哪里还有这么幸福的我呢？ 但是我怎么能保障他们的生活呢… 或许我开始慢慢懂了，慢慢懂了那跳下去的一瞬间是多么的轻松， 或许下一秒就已经后悔了， 我还有我的家人们啊， 但是已经晚了， 我没有办法选择我现在就停止在半空中等待大家救援我， 但是那一瞬间真的很轻松， 前所未有的放松， 让我很享受跳下来的这个过程， 甚至在跳下来的途中， 我能看到10楼的夫妻在争吵， 我能看到9楼的那个小伙子正在拼命的提升自己… 在下落的过程中我很享受， 享受的每一秒甚至每一毫秒… 慢慢的， 我的泪落从双眼涌出， 我爱的妻子，将承担这我遗留下的一切， 我完美的家庭就此破灭， 妻子将一辈子沉浸在悲伤中… 还有我的孩子… 我的年迈的父母亲， 我不能倒下， 我是一个七尺男儿， 我要为自己的家庭奋斗， 我要努力的照顾好这个世界上一直默默为我支持打气的他们… 我还有很多事没有做… 我不能就此倒下… 但是又有什么用呢… 我还在努力的往下掉… 直到下一刻… 我彻底摆脱了这个属于我的而且只属于我的世界… 我彻底摆脱了这个不属于我而且不属于任何人的世界…","categories":[{"name":"文章","slug":"文章","permalink":"http://blog.alterem.top/categories/文章/"}],"tags":[{"name":"文章","slug":"文章","permalink":"http://blog.alterem.top/tags/文章/"}]},{"title":"CentOS下安装FreeTDS","slug":"CentOS下安装FreeTDS","date":"2019-03-15T13:58:38.000Z","updated":"2019-03-15T15:04:24.000Z","comments":true,"path":"2019/03/15/CentOS下安装FreeTDS/","link":"","permalink":"http://blog.alterem.top/2019/03/15/CentOS下安装FreeTDS/","excerpt":"导读 官方网站：http://www.freetds.org 下载地址：http://ibiblio.org/pub/Linux/ALPHA/freetds/stable/freetds-stable.tgz 这个软件能够用Linux和Unix连接MS SQLServer和Sybase数据库 安装与配置 首先下载FreeTDS安装包到服务器 1wget -c http://ibiblio.org/pub/Linux/ALPHA/freetds/stable/freetds-stable.tgz","text":"导读 官方网站：http://www.freetds.org 下载地址：http://ibiblio.org/pub/Linux/ALPHA/freetds/stable/freetds-stable.tgz 这个软件能够用Linux和Unix连接MS SQLServer和Sybase数据库 安装与配置 首先下载FreeTDS安装包到服务器 1wget -c http://ibiblio.org/pub/Linux/ALPHA/freetds/stable/freetds-stable.tgz 解压 1tar -zxvf freetds-stable.tgz 编译安装 因为是编译安装所以确保机器有安装gcc（可使用yum进行安装） 12yum install gcc-c++yum install ncurses-devel 开始安装 123cd freetds-0.91/./configure --prefix=/usr/local/freetds --with-tdsver=8.0 --enable-msdblibmake &amp;&amp; makeinstall `解释： 安装freetds到目录/usr/local/freetds：--prefix=/usr/local/freetds 支持MSSQL2000：--with-tdsver=8.0 --enable-msdblib` FreeTDS默认安装在/usr/local/freetds目录当中，库文件在相应的lib目录下。 vim /etc/ld.so.conf加入一行 /usr/local/freetds/lib 然后运行以下指令使更改生效： 1ldconfig 测试连接 tsql -H MSSQL服务器服务IP -p 1433 -U MSSQL服务器登陆帐号 －P MSSQL服务器登陆密码 12345678910111213$ tsql -H XXXXXX-p 1433 -U sa -P XXXXXX -D test locale is \"zh_CN.utf8\" locale charset is \"UTF-8\" Default database being set to test 1&gt; select @@version 2&gt; go Microsoft SQL Server 2008 R2 (RTM) - 10.50.1600.1 (Intel X86) Apr 2 2010 15:53:02 Copyright (c) Microsoft Corporation Data Center Edition on Windows NT 5.1 &lt;X86&gt; (Build 2600: Service Pack 3) (1 row affected) 问题 Adaptive Server connection failed 123456789locale is \"en_US.UTF-8\"locale charset is \"UTF-8\"using default charset \"UTF-8\"Error 20017 (severity 9): Unexpected EOF from the server OS error 115, \"Operation now in progress\"Error 20002 (severity 9): Adaptive Server connection failedThere was a problem connecting to the server 执行tsql -C 12345678910111213[root@thinkpa freetds-0.91]# tsql -CCompile-time settings (established with the \"configure\" script) Version: freetds v0.91 freetds.conf directory: /usr/local/etc MS db-lib source compatibility: no Sybase binary compatibility: no Thread safety: yes iconv library: yes TDS version: 5.0 iODBC: no unixodbc: no SSPI \"trusted\" logins: no Kerberos: no 发现freetds的版本是5.0，考虑到可能是freetds版本的问题 两种解决方式： 修改全局TDS 版本号 找到/usr/local/etc/freetds.conf修改[global]下面的tds version为8.0 连接时修改tds版本号 TDSVER=7.0 tsql -H 整个连接命令则变为： tsql -H MSSQL服务器服务IP -p 1433 -U MSSQL服务器登陆帐号 －P MSSQL服务器登陆密码 Adaptive Server connection failed 123\"Cannot open server 'xxxxxxx' requested by the login. Client with IP address 'xxxxxxxxx' is not allowed to access the server. To enable access, use the Windows Azure Management Portal or run sp_set_firewall_rule on the master database to create a firewall rule for this IP address or address range. It may take up to five minutes for this change to take effect.\"Error 20002 (severity 9): Adaptive Server connection failed 这个毋庸置疑了，找管理员开通白名单再访问吧！","categories":[{"name":"FreeTDS","slug":"FreeTDS","permalink":"http://blog.alterem.top/categories/FreeTDS/"}],"tags":[{"name":"FreeTDS","slug":"FreeTDS","permalink":"http://blog.alterem.top/tags/FreeTDS/"}]},{"title":"Kotlin-基本数据类型","slug":"Kotlin-基本数据类型","date":"2019-03-15T03:19:27.000Z","updated":"2019-03-15T13:17:08.000Z","comments":true,"path":"2019/03/15/Kotlin-基本数据类型/","link":"","permalink":"http://blog.alterem.top/2019/03/15/Kotlin-基本数据类型/","excerpt":"Kotlin 基本数据类型 Kotlin 的基本数值类型包括 Byte、Short、Int、Long、Float、Double 等。不同于Java的是，字符不属于数值类型，是一个独立的数据类型。 类型 位宽度 Double 64 Float 32 Long 64 Int 32 Short 16 Byte 8","text":"Kotlin 基本数据类型 Kotlin 的基本数值类型包括 Byte、Short、Int、Long、Float、Double 等。不同于Java的是，字符不属于数值类型，是一个独立的数据类型。 类型 位宽度 Double 64 Float 32 Long 64 Int 32 Short 16 Byte 8 字面常量下面是所有类型的字面常量： 十进制：123 长整型以大写的 L 结尾：123L 16 进制以 0x 开头：0x0F 2 进制以 0b 开头：0b00001011 注意：8进制不支持 Kotlin 同时也支持传统符号表示的浮点数值： Doubles 默认写法: 123.5, 123.5e10 Floats 使用 f 或者 F 后缀：123.5f 你可以使用下划线使数字常量更易读： 12345val oneMillion = 1_000_000val creditCardNumber = 1234_5678_9012_3456Lval socialSecurityNumber = 999_99_9999Lval hexBytes = 0xFF_EC_DE_5Eval bytes = 0b11010010_01101001_10010100_10010010 比较两个数字Kotlin 中没有基础数据类型，只有封装的数字类型，你每定义的一个变量，其实 Kotlin 帮你封装了一个对象，这样可以保证不会出现空指针。数字类型也一样，所有在比较两个数字的时候，就有比较数据大小和比较两个对象是否相同的区别了。 在 Kotlin 中，三个等号 === 表示比较对象地址，两个 == 表示比较两个值大小。 123456789101112fun main(args: Array&lt;String&gt;) &#123; val a: Int = 10000 println(a === a) // true，值相等，对象地址相等 //经过了装箱，创建了两个不同的对象 val boxedA: Int? = a val anotherBoxedA: Int? = a //虽然经过了装箱，但是值是相等的，都是10000 println(boxedA === anotherBoxedA) // false，值相等，对象地址不一样 println(boxedA == anotherBoxedA) // true，值相等&#125; 类型转换由于不同的表示方式，较小类型并不是较大类型的子类型，较小的类型不能隐式转换为较大的类型。 这意味着在不进行显式转换的情况下我们不能把 Byte 型值赋给一个 Int 变量。 12val b: Byte = 1 // OK, 字面值是静态检测的val i: Int = b // 错误 我们可以代用其toInt()方法。 12val b: Byte = 1 // OK, 字面值是静态检测的val i: Int = b.toInt() // OK 每种数据类型都有下面的这些方法，可以转化为其它的类型： 1234567toByte(): BytetoShort(): ShorttoInt(): InttoLong(): LongtoFloat(): FloattoDouble(): DoubletoChar(): Char 有些情况下也是可以使用自动类型转化的，前提是可以根据上下文环境推断出正确的数据类型而且数学操作符会做相应的重载。例如下面是正确的： 1val l = 1L + 3 // Long + Int =&gt; Long 位操作符对于Int和Long类型，还有一系列的位操作符可以使用，分别是： 1234567shl(bits) – 左移位 (Java’s &lt;&lt;)shr(bits) – 右移位 (Java’s &gt;&gt;)ushr(bits) – 无符号右移位 (Java’s &gt;&gt;&gt;)and(bits) – 与or(bits) – 或xor(bits) – 异或inv() – 反向 字符和 Java 不一样，Kotlin 中的 Char 不能直接和数字操作，Char 必需是单引号 ‘ 包含起来的。比如普通字符 ‘0’，’a’。 12345fun check(c: Char) &#123; if (c == 1) &#123; // 错误：类型不兼容 // …… &#125;&#125; 字符字面值用单引号括起来: ‘1’。 特殊字符可以用反斜杠转义。 支持这几个转义序列：\\t、 \\b、\\n、\\r、\\’、\\”、\\ 和 \\$。 编码其他字符要用 Unicode 转义序列语法：’\\uFF00’。 我们可以显式把字符转换为 Int 数字： 12345fun decimalDigitValue(c: Char): Int &#123; if (c !in '0'..'9') throw IllegalArgumentException(\"Out of range\") return c.toInt() - '0'.toInt() // 显式转换为数字&#125; 当需要可空引用时，像数字、字符会被装箱。装箱操作不会保留同一性。 布尔布尔用 Boolean 类型表示，它有两个值：true 和 false。 若需要可空引用布尔会被装箱。 内置的布尔运算有： 123|| – 短路逻辑或&amp;&amp; – 短路逻辑与! - 逻辑非 数组数组用类 Array 实现，并且还有一个 size 属性及 get 和 set 方法，由于使用 [] 重载了 get 和 set 方法，所以我们可以通过下标很方便的获取或者设置数组对应位置的值。 数组的创建两种方式：一种是使用函数arrayOf()；另外一种是使用工厂函数。如下所示，我们分别是两种方式创建了两个数组： 12345678910fun main(args: Array&lt;String&gt;) &#123; //[1,2,3] val a = arrayOf(1, 2, 3) //[0,2,4] val b = Array(3, &#123; i -&gt; (i * 2) &#125;) //读取数组内容 println(a[0]) // 输出结果：1 println(b[1]) // 输出结果：2&#125; 如上所述，[] 运算符代表调用成员函数 get() 和 set()。 注意: 与 Java 不同的是，Kotlin 中数组是不型变的（invariant）。 除了类Array，还有ByteArray, ShortArray, IntArray，用来表示各个类型的数组，省去了装箱操作，因此效率更高，其用法同Array一样： 12val x: IntArray = intArrayOf(1, 2, 3)x[0] = x[1] + x[2] 字符串和 Java 一样，String 是不可变的。方括号 [] 语法可以很方便的获取字符串中的某个字符，也可以通过 for 循环来遍历： 123for (c in str) &#123; println(c)&#125; Kotlin 支持三个引号 “”” 扩起来的字符串，支持多行字符串，比如： 1234567fun main(args: Array&lt;String&gt;) &#123; val text = \"\"\" 多行字符串 多行字符串 \"\"\" println(text) // 输出有一些前置空格&#125; String 可以通过 trimMargin() 方法来删除多余的空白。 123456789fun main(args: Array&lt;String&gt;) &#123; val text = \"\"\" |多行字符串 |Kotlin教程 |多行字符串 |Kotlin \"\"\".trimMargin() println(text) // 前置空格删除了&#125; 默认 | 用作边界前缀，但你可以选择其他字符并作为参数传入，比如 trimMargin(“&gt;”)。 字符串模板字符串可以包含模板表达式 ，即一些小段代码，会求值并把结果合并到字符串中。 模板表达式以美元符（$）开头，由一个简单的名字构成: 12345fun main(args: Array&lt;String&gt;) &#123; val i = 10 val s = \"i = $i\" // 求值结果为 \"i = 10\" println(s)&#125; 或者用花括号扩起来的任意表达式: 12345fun main(args: Array&lt;String&gt;) &#123; val s = \"kotlin\" val str = \"$s.length is $&#123;s.length&#125;\" // 求值结果为 \"kotlin.length is 6\" println(str)&#125; 原生字符串和转义字符串内部都支持模板。 如果你需要在原生字符串中表示字面值 $ 字符（它不支持反斜杠转义），你可以用下列语法： 123456fun main(args: Array&lt;String&gt;) &#123; val price = \"\"\" $&#123;'$'&#125;9.99 \"\"\" println(price) // 求值结果为 $9.99&#125;","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://blog.alterem.top/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://blog.alterem.top/tags/Kotlin/"}]},{"title":"Kotlin-基础语法","slug":"Kotlin-基础语法","date":"2019-03-14T07:13:58.000Z","updated":"2019-03-15T13:20:18.000Z","comments":true,"path":"2019/03/14/Kotlin-基础语法/","link":"","permalink":"http://blog.alterem.top/2019/03/14/Kotlin-基础语法/","excerpt":"Kotlin基础语法Kotlin文件以.kt为后缀 Kotlin包声明代码文件的开头一般为包的声明 123456package com.kotlin01.mainimport java.util.*fun test() &#123;&#125;class Kotlin01 &#123;&#125; kotlin源文件不需要相匹配的目录和包，源文件可以放在任何文件目录。","text":"Kotlin基础语法Kotlin文件以.kt为后缀 Kotlin包声明代码文件的开头一般为包的声明 123456package com.kotlin01.mainimport java.util.*fun test() &#123;&#125;class Kotlin01 &#123;&#125; kotlin源文件不需要相匹配的目录和包，源文件可以放在任何文件目录。 以上例中 test() 的全名是 com.kotlin01.main.test、Kotlin01的全名是 com.kotlin01.main.Kotlin01。 如果没有指定包，默认为 default 包。 默认导入有多个包会默认导入到每个 Kotlin 文件中： kotlin.* kotlin.annotation.* kotlin.collections.* kotlin.comparisons.* kotlin.io.* kotlin.ranges.* kotlin.sequences.* kotlin.text.* 函数定义函数定义使用关键字 fun，参数格式为：参数 : 类型 123fun sum(a: Int, b: Int): Int &#123; // Int 参数，返回值 Int return a + b&#125; 表达式作为函数体，返回类型自动推断： 123fun sum(a: Int, b: Int) = a + bpublic fun sum(a: Int, b: Int): Int = a + b // public 方法则必须明确写出返回类型 无返回值的函数(Java中的void)： 12345678fun printSum(a: Int, b: Int): Unit &#123; print(a + b)&#125;// 如果是返回 Unit类型，则可以省略(对于public方法也是这样)：public fun printSum(a: Int, b: Int) &#123; print(a + b)&#125; 可变长参数函数函数的变长参数可以用 vararg 关键字进行标识： 12345678910fun vars(vararg v:Int)&#123; for(vt in v)&#123; print(vt) &#125;&#125;// 测试fun main(args: Array&lt;String&gt;) &#123; vars(1,2,3,4,5) // 输出12345&#125; lambda(匿名函数)lambda表达式使用实例： 12345// 测试fun main(args: Array&lt;String&gt;) &#123; val sumLambda: (Int, Int) -&gt; Int = &#123;x,y -&gt; x+y&#125; println(sumLambda(1,2)) // 输出 3&#125; 定义常量与变量可变变量定义：var 关键字 1var &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt; 不可变变量定义：val 关键字，只能赋值一次的变量(类似Java中final修饰的变量) 1val &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt; 常量与变量都可以没有初始化值,但是在引用前必须初始化 编译器支持自动类型判断,即声明时可以不指定类型,由编译器判断。 1234567val a: Int = 1val b = 1 // 系统自动推断变量类型为Intval c: Int // 如果不在声明时初始化则必须提供变量类型c = 1 // 明确赋值var x = 5 // 系统自动推断变量类型为Intx += 1 // 变量可修改 注释Kotlin 支持单行和多行注释，实例如下： 1234// 这是一个单行注释/* 这是一个多行的 块注释。 */ 与 Java 不同, Kotlin 中的块注释允许嵌套。 字符串模板$ 表示一个变量名或者变量值 $varName 表示变量值 ${varName.fun()} 表示变量的方法返回值: 1234567var a = 1// 模板中的简单名称：val s1 = \"a is $a\" a = 2// 模板中的任意表达式：val s2 = \"$&#123;s1.replace(\"is\", \"was\")&#125;, but now is $a\" NULL检查机制Kotlin的空安全设计对于声明可为空的参数，在使用时要进行空判断处理，有两种处理方式，字段后加!!像Java一样抛出空异常，另一种字段后加?可不做处理返回值为 null或配合?:做空判断处理 12345678//类型后面加?表示可为空var age: String? = \"23\" //抛出空指针异常val ages = age!!.toInt()//不做处理返回 nullval ages1 = age?.toInt()//age为空返回-1val ages2 = age?.toInt() ?: -1 当一个引用可能为 null 值时, 对应的类型声明必须明确地标记为可为 null。 当 str 中的字符串内容不是一个整数时, 返回 null: 123fun parseInt(str: String): Int? &#123; // ...&#125; 以下实例演示如何使用一个返回值可为 null 的函数: 12345678910111213fun main(args: Array&lt;String&gt;) &#123; if (args.size &lt; 2) &#123; print(\"Two integers expected\") return &#125; val x = parseInt(args[0]) val y = parseInt(args[1]) // 直接使用 `x * y` 会导致错误, 因为它们可能为 null. if (x != null &amp;&amp; y != null) &#123; // 在进行过 null 值检查之后, x 和 y 的类型会被自动转换为非 null 变量 print(x * y) &#125;&#125; 类型检测及自动类型转换我们可以使用 is 运算符检测一个表达式是否某类型的一个实例(类似于Java中的instanceof关键字)。 1234567891011121314fun getStringLength(obj: Any): Int? &#123; if (obj is String) &#123; // 做过类型判断以后，obj会被系统自动转换为String类型 return obj.length &#125; //在这里还有一种方法，与Java中instanceof不同，使用!is // if (obj !is String)&#123; // // XXX // &#125; // 这里的obj仍然是Any类型的引用 return null&#125; 或者 123456fun getStringLength(obj: Any): Int? &#123; if (obj !is String) return null // 在这个分支中, `obj` 的类型会被自动转换为 `String` return obj.length&#125; 甚至还可以 123456fun getStringLength(obj: Any): Int? &#123; // 在 `&amp;&amp;` 运算符的右侧, `obj` 的类型会被自动转换为 `String` if (obj is String &amp;&amp; obj.length &gt; 0) return obj.length return null&#125; 区间区间表达式由具有操作符形式 .. 的 rangeTo 函数辅以 in 和 !in 形成。 区间是为任何可比较类型定义的，但对于整型原生类型，它有一个优化的实现。以下是使用区间的一些示例: 1234567891011121314151617for (i in 1..4) print(i) // 输出“1234”for (i in 4..1) print(i) // 什么都不输出if (i in 1..10) &#123; // 等同于 1 &lt;= i &amp;&amp; i &lt;= 10 println(i)&#125;// 使用 step 指定步长for (i in 1..4 step 2) print(i) // 输出“13”for (i in 4 downTo 1 step 2) print(i) // 输出“42”// 使用 until 函数排除结束元素for (i in 1 until 10) &#123; // i in [1, 10) 排除了 10 println(i)&#125; 实例测试1234567891011121314151617fun main(args: Array&lt;String&gt;) &#123; print(\"循环输出：\") for (i in 1..4) print(i) // 输出“1234” println(\"\\n----------------\") print(\"设置步长：\") for (i in 1..4 step 2) print(i) // 输出“13” println(\"\\n----------------\") print(\"使用 downTo：\") for (i in 4 downTo 1 step 2) print(i) // 输出“42” println(\"\\n----------------\") print(\"使用 until：\") // 使用 until 函数排除结束元素 for (i in 1 until 4) &#123; // i in [1, 4) 排除了 4 print(i) &#125; println(\"\\n----------------\")&#125; 输出结果 12345678循环输出：1234----------------设置步长：13----------------使用 downTo：42----------------使用 until：123----------------","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://blog.alterem.top/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://blog.alterem.top/tags/Kotlin/"}]},{"title":"Kotlin-环境安装","slug":"Kotlin-开发环境搭建","date":"2019-03-14T06:31:18.000Z","updated":"2019-03-15T13:14:10.000Z","comments":true,"path":"2019/03/14/Kotlin-开发环境搭建/","link":"","permalink":"http://blog.alterem.top/2019/03/14/Kotlin-开发环境搭建/","excerpt":"Kotlin是什么？ Kotlin 是一个用于现代多平台应用的静态编程语言，由 JetBrains 开发。 Kotlin可以编译成Java字节码，也可以编译成JavaScript，方便在没有JVM的设备上运行。 Kotlin已正式成为Android官方支持开发语言。","text":"Kotlin是什么？ Kotlin 是一个用于现代多平台应用的静态编程语言，由 JetBrains 开发。 Kotlin可以编译成Java字节码，也可以编译成JavaScript，方便在没有JVM的设备上运行。 Kotlin已正式成为Android官方支持开发语言。 Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，被称之为 Android 世界的Swift，由 JetBrains 设计开发并开源。 Kotlin 可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。 在Google I/O 2017中，Google 宣布 Kotlin 成为 Android 官方开发语言。 答案来自网络😂 Kotlin开发环境搭建首先您能进来读这篇文章，就说明您已经在了解或者已经了解了Kotlin了，那更不用我来介绍怎么下载安装IntelliJ IDEA、Eclipse这类软件了。 由于我们经常使用的IntelliJ IDEA或者是Android Studio都已经自带，所以不做阐述。 当然也可以下载独立的编译器。 因为我在项目中用到比较多的还是Eclipse，所以在这里主要描述Eclipse安装Kotlin。 1、打开Eclipse，在菜单栏找到 Help -&gt; Eclipse Marketplace… 在search选项卡输入Kotlin进行搜索，然后选中第一条记录点击install安装 或者使用老套一点的方式用site来安装：找到Eclipse的help -&gt; Install New SoftWare… 在work with输入 https://dl.bintray.com/jetbrains/kotlin/eclipse-plugin/last/ 回车选中安装 重启Eclipse完成安装。 HelloWorld1、首先创建一个新的Kotlin工程：选择Eclipse的 File -&gt; New -&gt; Kotlin Project 完成！！！","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://blog.alterem.top/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://blog.alterem.top/tags/Kotlin/"}]},{"title":"成人漫画","slug":"成人漫画","date":"2019-01-14T06:04:21.000Z","updated":"2019-03-15T13:14:28.000Z","comments":true,"path":"2019/01/14/成人漫画/","link":"","permalink":"http://blog.alterem.top/2019/01/14/成人漫画/","excerpt":"欢迎来到 成人世界一份 成年人生存指南 送给你","text":"欢迎来到 成人世界一份 成年人生存指南 送给你 成年人的世界总是复杂的 人与人之间充斥着各种潜规则 希望这些道理 你现在知道还不算晚","categories":[{"name":"文章","slug":"文章","permalink":"http://blog.alterem.top/categories/文章/"}],"tags":[{"name":"成人漫画","slug":"成人漫画","permalink":"http://blog.alterem.top/tags/成人漫画/"},{"name":"十八岁","slug":"十八岁","permalink":"http://blog.alterem.top/tags/十八岁/"}]},{"title":"cola-ui的使用","slug":"cola-ui的使用","date":"2019-01-11T06:54:43.000Z","updated":"2019-03-15T13:23:30.000Z","comments":true,"path":"2019/01/11/cola-ui的使用/","link":"","permalink":"http://blog.alterem.top/2019/01/11/cola-ui的使用/","excerpt":"cola-ui 官方：http://www.cola-ui.com 教程位置：http://www.cola-ui.com/guide/model API: http://www.cola-ui.com/api/cola.html , http://legacy.cola-ui.com 组件地址：http://www.cola-ui.com/docs/button 源码地址：https://github.com/Cola-Org/cola-ui 文档修订相关 版本 内容 修改人 修改时间 V1.0 初版 刘晓东 2018-12-24 产品简介 Cola UI是支持双向数据绑定的一站式前端UI框架。采用了精简的MVVM架构，在确保灵活性的同时尽可能降低对开发者的技术要求。 Cola UI遵循Mobile First的策略，特别适合于移动设备应用开发。 Cola UI整合了jQuery和Semantic UI，同时提供更多常用的List、Table、Tree等高级控件。","text":"cola-ui 官方：http://www.cola-ui.com 教程位置：http://www.cola-ui.com/guide/model API: http://www.cola-ui.com/api/cola.html , http://legacy.cola-ui.com 组件地址：http://www.cola-ui.com/docs/button 源码地址：https://github.com/Cola-Org/cola-ui 文档修订相关 版本 内容 修改人 修改时间 V1.0 初版 刘晓东 2018-12-24 产品简介 Cola UI是支持双向数据绑定的一站式前端UI框架。采用了精简的MVVM架构，在确保灵活性的同时尽可能降低对开发者的技术要求。 Cola UI遵循Mobile First的策略，特别适合于移动设备应用开发。 Cola UI整合了jQuery和Semantic UI，同时提供更多常用的List、Table、Tree等高级控件。 开始==以上内容都是通过cola-ui官网获得的资料，绝大多数的开发内容可以参考cola-ui官网提供的API进行查阅== 本文档主要针对于camsi工程中用到的功能或特性，且可能不存在于cola-ui官网提供的API进行整理和说明 组成结构==通常要基于camsi工程在浏览器渲染出来的页面由三个部分组成，例如：simple01.jade、M.js、simple01Model.js== Jade==Jade 是一个高性能的模板引擎，它深受 Haml影响，它是用 JavaScript 实现的，并且可以供 Node 使用，你也可以在此试用，这里推荐Jade入门中文文档== 12345678910extends /_pageblock body v-box flex-box .content(style=&quot;overflow: auto&quot;) c-table(bind=&quot;simple01s&quot; dataType=&quot;Simple01&quot;) column(property=&quot;name&quot;)append scripts script(src=&quot;simple01Model.js&quot;) script(src=&quot;simple01.js&quot;) dataType的值应该与Js中定义的dataType的值以及Model.js中定义的dataType的值相等 Js==不做描述== 123456789101112131415161718cola(function(model) &#123; model.dataType($DataType.Simple01); model.describe(\"simple01s\", &#123; dataType : \"Simple01\", provider : &#123; url : \"controller/simple01Service/findPagination?from=&#123;&#123;$from&#125;&#125;&amp;limit=&#123;&#123;$limit&#125;&#125;\", pageSize : 10, sendJson : true, loadMode: 'manual' &#125; &#125;); model.set(\"title\", \"[(#&#123;simple01&#125;)]\"); model.action(&#123; test : function() &#123; cola.alert('test') &#125; &#125;);&#125;); 所有正规的操作包括事件都应该编写在==cola(function(model) { })==中，其中首先需要使用dataType定义当前Js中所有用到的DataType，使用==model.describe==交互后台数据到当前指定model，使用==model.set(“”, “”)==向model交互数据，页面所有用到的事件方法应该存在于==model.action({})==中。 Model.js==由cola-ui定义的前端模型== 1234567891011var $DataType = &#123; Simple01: &#123; name: \"Simple01\", properties : &#123; name : &#123; caption : \"[(#&#123;name&#125;)]\", dataType : \"string\" &#125; &#125; &#125;&#125;; ==caption==用来标志当前字段的前端显示文本，使用==[(#{ })]==取到当前字段对应的当前语言的国际化翻译。 表单相关表单对国际化的处理 在正常情况下，dataType可能会被公用，然后每个字段在每个不同的地方显示的文本标识不一样，这时候可以使用==caption==属性进行操作，例如：==caption=ll.l(“name”)==前面提到在Js中国际化使用的是==[(#{ })]== 表单对日期格式的处理 通常需要将当前日期字段进行格式化只需要下面代码即可： 123field(property=&quot;birthday&quot;) label c-datepicker(displayFormat=&quot;yyyy-MM-dd&quot; inputFormat=&quot;yyyy-MM-dd&quot;) 将datatype类型为Date的birthday字段的文本显示和选择的日期格式调整为”yyyy-MM-dd” 表单对枚举值的处理 我们经常会把一些常规的数据做成枚举值存放在数据库，并把页面的文本输入框改变成为下拉项 页面元素 123field(property=&quot;status&quot;) label c-dropdown(c-items=&quot;dictionary(&apos;10000&apos;)&quot;) 引入Js 1script(src=basecodeCP + &quot;controller/basecode/codeDetail/findCodeDetails?baseCodeIds=10000&quot;) 或者 1script(src=&quot;controller/basecode/codeDetail/findCodeDetails?baseCodeIds=10000&quot;) 这样页面会去加载枚举值代码为10000的对应status存放的id对应的文本显示到当前字段，并为当前字段提供下拉项 表单对文本域的处理 类似于备注，通常都是用文本框来显示 1234fields.cols-1 field(property=&quot;remark&quot;) label c-textarea(rows=&quot;3&quot;) 首先定义当前字段独占一列，使用==c-textarea(rows=”3”)==表名当前字段独占三列 表单对只读的处理 正常场景并不是表单中列出的所有的字段都是手动输入的，比如ID，我们可以使用==readOnly=”true”==对每个field进行只读控制，也可以将==readOnly=”true”==放在c-form属性里面来控制整个表单只读 表单对省市县级联的处理Jade 123456789101112field(property=&quot;country&quot; label c-dropdown(c-items=&quot;dictionary(&apos;CountryCode&apos;)&quot; onSelectData=&quot;onCountrySelect&quot;)(property=&quot;province&quot; caption=ll.l(&quot;province&quot;) c-readOnly=&quot;queryCondition.country != &apos;CHN&apos;&quot;) label c-dropdown(c-items=&quot;provinces&quot; textProperty=&quot;name&quot; assignment=&quot;province=kind&quot; onSelectData=&quot;onProvinceSel&quot;)field(property=&quot;city&quot; caption=ll.l(&quot;city&quot;) c-readOnly=&quot;queryCondition.country != &apos;CHN&apos;&quot;) label c-dropdown(c-items=&quot;cities&quot; textProperty=&quot;name&quot; assignment=&quot;city=kind&quot; beforeOpen=&quot;beforeCityOpen&quot; onSelectData=&quot;onCitySel&quot;)field(property=&quot;county&quot; caption=ll.l(&quot;county&quot;) c-readOnly=&quot;queryCondition.country != &apos;CHN&apos;&quot;) label c-dropdown(c-items=&quot;counties&quot; textProperty=&quot;name&quot; assignment=&quot;county=kind&quot; beforeOpen=&quot;beforeCountyOpen&quot;) 引入数据字典 1script(src=&quot;controller/basecode/codeDetail/findCodeDetails?baseCodeIds=CountryCode&quot;) Js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556cola(function(model) &#123; model.describe(\"provinces\", &#123; provider: &#123; url: \"controller/basecode/codeDetail/findCachedCodeDetails\", parameter: &#123; baseCodeId: \"Address\", parentId: \"NULL\" &#125; &#125; &#125;); model.set(\"title\", \"[(#&#123;simple01&#125;)]\"); model.set(\"queryCondition\", &#123;\"country\":\"CHN\"&#125;); model.action(&#123; beforeCityOpen: function () &#123; var province = model.get(\"queryCondition.province\"); $.ajax(\"controller/basecode/codeDetail/findCachedCodeDetails?baseCodeId=Address&amp;parentId=\" + province, &#123; type: \"get\", async: false &#125;).done(function (result) &#123; if (result) &#123; model.set(\"cities\", result); &#125; &#125;); &#125;, beforeCountyOpen: function () &#123; var city = model.get(\"queryCondition.city\"); $.ajax(\"controller/basecode/codeDetail/findCachedCodeDetails?baseCodeId=Address&amp;parentId=\" + city, &#123; type: \"get\", async: false &#125;).done(function (result) &#123; if (result) &#123; model.set(\"counties\", result); &#125; &#125;); &#125;, onProvinceSel: function (self, arg) &#123; var queryCondition = model.get(\"queryCondition\"); if(queryCondition.get(\"province\") != arg.data.get(\"kind\"))&#123; queryCondition.set(\"city\", \"\"); queryCondition.set(\"county\", \"\"); &#125; &#125;, onCitySel: function (self, arg) &#123; var queryCondition = model.get(\"queryCondition\"); if(queryCondition.get(\"city\") != arg.data.get(\"kind\"))&#123; queryCondition.set(\"county\", \"\"); &#125; &#125;, onCountrySelect: function (self, arg) &#123; var selectedItem = arg.data; if(\"CHN\" != selectedItem.key) &#123; model.get(\"queryCondition\").set(\"province\", \"\"); model.get(\"queryCondition\").set(\"city\", \"\"); model.get(\"queryCondition\").set(\"county\", \"\"); &#125; &#125; &#125;);&#125;); 表格相关表格对枚举值的处理 通常我们都是在表单录入数据，在表格中进行简约展示，所以在表单中录入的下拉枚举值我们需要在表格中使用的时候必须使用获取到的枚举值进行翻译 123column(property=&quot;status&quot;) template div(c-bind=&quot;translate(&apos;10000&apos;,$default)&quot;) 表格对行内编辑的处理 在对于处理一些简单数据的时候我们可以不需要弹出一个复杂的编辑框对当前行的数据进行编辑处理，可以直接在表格进行行内编辑 1c-table(bind=&quot;simple01s&quot; dataType=&quot;Simple01&quot; readOnly=&quot;false&quot;) 表格行编辑对下拉项的处理 在表单编辑我们可以去选择一个下拉项做为数据值，当然在表格行编辑也可以 123column(property=&quot;status&quot;) template(name=&quot;edit&quot;) c-dropdown(bind=&quot;$default&quot; c-items=&quot;dictionary(&apos;10000&apos;)&quot;) 最后代码整理为 12345column(property=&quot;status&quot;) template(name=&quot;edit&quot;) c-dropdown(bind=&quot;$default&quot; c-items=&quot;dictionary(&apos;10000&apos;)&quot;) template div(c-bind=&quot;translate(&apos;10000&apos;,$default)&quot;) 表格添加操作列的处理 通常我们需要在表格的最后一列添加一行操作列来处理当前行的数据 12345c-table(bind=&quot;simple in simple01s&quot; dataType=&quot;Simple01&quot;) column(caption=ll.l(&quot;operation&quot;)) template div a.cell-link(c-onclick=&quot;view(simple)&quot;)=ll.l(&quot;view&quot;) 表格联动的处理 很多场景下，我们的数据和数据都是有关联关系，比如一本书对应书籍的出版社的详细信息，这时候针对不同的书本信息联动到出版社的详细信息 因为此处是两个表的关联，所以需要定义两个dataType cModel.js 1234567891011121314151617181920var $DataType = &#123; A: &#123; name: \"A\", properties : &#123; name : &#123; caption : \"[(#&#123;name&#125;)]\", dataType : \"string\", &#125; &#125; &#125;, B : &#123; name : \"B\", properties : &#123; name : &#123; caption : \"[(#&#123;name&#125;)]\", dataType : \"string\" &#125; &#125; &#125;&#125;; c.jade 1234c-table(bind=&quot;as&quot; dataType=&quot;a&quot;) column(property=&quot;name&quot;)c-table(bind=&quot;as#.bs&quot; dataType=&quot;b&quot;) column(property=&quot;name&quot;) c.js 123456789101112131415161718192021222324252627cola(function(model) &#123; model.dataType($DataType.B); $DataType.A.properties.bs = &#123; dataType: \"B\", aggregated: true, provider: &#123; url: \"controller/B/find\", sendJson: true, parameter: &#123; \"name\": \"&#123;&#123;@name&#125;&#125;\" &#125; &#125; &#125; model.dataType($DataType.A); model.describe(\"as\", &#123; dataType : \"A\", provider : &#123; url : \"controller/C/findPagination?from=&#123;&#123;$from&#125;&#125;&amp;limit=&#123;&#123;$limit&#125;&#125;\", pageSize : 10, sendJson : true, loadMode: 'manual' &#125; &#125;); model.set(\"title\", \"[(#&#123;C&#125;)]\"); model.action(&#123; &#125;);&#125;); 在关联中可以使用==parameter:{“name”:”“}==方式拿到父表中当前选中行的name的值 表格数据加载的处理 在某些场景下我们可以让表格数据直接加载到页面，也可以使用事件来触发加载数据 1loadMode: 'manual' 可以通过loadMode来控制表单是否在页面加载的时候加载数据到页面：manual手工加载，注释掉loadMode缺省自动加载数据 面板Panel 相关在panel头位置添加按钮1234c-panel#panelDemo(caption=ll.l(&quot;panel&quot;)) template(name=&quot;tools&quot;) div c-button.primary(caption=ll.l(&quot;add&quot;) click=&quot;add&quot;) 其它预加载处理 通常我们会在页面加载完成的时候自动触发一部分方法或者set一部分数据值到指定属性 123cola.ready(function() &#123; cola.widget(&quot;panelDemo&quot;).collapse(); // 在加载完页面之后 折叠id为panelDemo的面板&#125;); 代码应该放在==cola(function (model) { })==","categories":[{"name":"Web","slug":"Web","permalink":"http://blog.alterem.top/categories/Web/"},{"name":"Ui","slug":"Web/Ui","permalink":"http://blog.alterem.top/categories/Web/Ui/"}],"tags":[{"name":"cola-ui","slug":"cola-ui","permalink":"http://blog.alterem.top/tags/cola-ui/"}]},{"title":"幂等","slug":"幂等","date":"2018-10-09T05:46:26.000Z","updated":"2019-03-15T13:14:36.000Z","comments":true,"path":"2018/10/09/幂等/","link":"","permalink":"http://blog.alterem.top/2018/10/09/幂等/","excerpt":"幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。 在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“setTrue()”函数就是一个幂等函数,无论多次执行，其结果都是一样的.更复杂的操作幂等保证是利用唯一交易号(流水号)实现.","text":"幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。 在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“setTrue()”函数就是一个幂等函数,无论多次执行，其结果都是一样的.更复杂的操作幂等保证是利用唯一交易号(流水号)实现. 定义在数学里，幂等有两种主要的定义。 在某二元运算下，幂等元素是指被自己重复运算(或对于函数是为复合)的结果等于它自己的元素。例如，乘法下唯一两个幂等实数为0和1。 某一元运算为幂等的时，其作用在任一元素两次后会和其作用一次的结果相同。例如，高斯符号便是幂等的。 一元运算的定义是二元运算定义的特例 二元运算设S为一具有作用于其自身的二元运算的集合，则S的元素s称为幂等的(相对于*)当 s *s = s. 特别的是，任一单位元都是幂等的。若S的所有元素都是幂等的话，则其二元运算*被称做是幂等的。例如，联集和交集的运算便都是幂等的。 一元运算设f为一由X映射至X的一元运算，则f为幂等的，当对于所有在X内的x， f(f(x)) = f(x). 特别的是，恒等函数一定是幂等的，且任一常数函数也都是幂等的。 注意当考虑一由X至X的所有函数所组成的集合S时。在f在一元运算下为幂等的若且唯若在二元运算下，f相对于其复合运算(标记为o)会是幂等的。这可以写成f o f = f。 一般例子函数如上述所说，恒等函数和常数函数总会是幂等的。较不当然的例子有实数或复数引数的绝对值函数，以及实数引数的高斯符号。 将一拓扑空间X内各子集U映射至U闭包的函数在X的幂集上是幂等的。这是闭包运算元的一个例子；所有个闭包运算元都会是幂等函数。 环的幂等元素定义上，环的幂等元素为一相对于环乘法为幂等的元素。可以定义一于环幂等上的偏序：若e和f为幂等的，当ef= fe= e时，标记为e≤ f。依其顺序，0会是最小幂等元素，而1为最大幂等元素。 若e在环R内为幂等的，则eRe一样会是个乘法单位元为e的环。 两个幂等元素e和f被称为正交的当ef=fe=0。在此一情形下，e+f也是幂等的，且有e ≤ e + f和f ≤ e + f。 若e在环R内为幂等的，则f = 1 − e也会是幂等的，且e和f正交。 一在R内的幂等元素e称为核心的，若对所有在R内的x，ex=xe。在此情形之下，Re会是个乘法单位元为e的环。R的核心幂等元素和R的分解为环的直和有很直接的关接。若R为环R1、…、R**n的直和，则环R**i的单位元在R内为核心幂等的，相互正交，且其总和为1。相反地，给出R内给相互正交且总和为1的核心幂等元素e1、…、e**n，则R会是环Re1、…、Re**n的直和。所有较有趣的是，每一于R内的核心幂等e都会给出一R的分解－Re和R(1 − e)的直和。 任一不等于0和1的幂等元素都是零因子(因为e(1 − e) = 0)。这表示了整环及除环都不会存在此种幂等元素。局部环也没有此种幂等元素，但理由有点不同。唯一包含于一环的雅各布森根内的幂等元素只有0。共四元数环内会有一幂等元素组成的悬链曲面。 所有元素都幂等的环称做布尔环。可证明在每一此类环内，乘法都是可交换的，且每一元素都有其各自的加法逆元。 其他例子幂等运算也可以在布林代数内找到。逻辑和与逻辑或便都是幂等运算。 在线性代数里，投射是幂等的。亦即，每一将向量投射至一子空间V(不需正交)上的线性算子，都是幂等的。 一幂等半环为其加法(非乘法)为幂等的半环。","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.alterem.top/categories/Java/"}],"tags":[{"name":"幂等","slug":"幂等","permalink":"http://blog.alterem.top/tags/幂等/"}]},{"title":"10招强化Linux安全的技能","slug":"10招强化Linux安全的技能","date":"2018-09-14T09:52:21.000Z","updated":"2019-03-27T04:45:26.000Z","comments":true,"path":"2018/09/14/10招强化Linux安全的技能/","link":"","permalink":"http://blog.alterem.top/2018/09/14/10招强化Linux安全的技能/","excerpt":"1.找出不必要的服务很明显，服务器上跑的服务，并不是每个都有用的。强烈建议检查并关掉不需要的服务，从而减少风险（多跑一个服务，就可能多几个漏洞）。 查询运行在runlevel 3的服务列表： 1[alter@alter ~]# /sbin/chkconfig --list |grep &apos;3:on&apos;","text":"1.找出不必要的服务很明显，服务器上跑的服务，并不是每个都有用的。强烈建议检查并关掉不需要的服务，从而减少风险（多跑一个服务，就可能多几个漏洞）。 查询运行在runlevel 3的服务列表： 1[alter@alter ~]# /sbin/chkconfig --list |grep &apos;3:on&apos; 关闭指定的服务： 1[alter@alter ~]# chkconfig ip6tables off 疑问：为什么查询runlevel 3的服务？Linux系统有7个运行级别(runlevel)，分别如下：runlevel 0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动；runlevel 1：单用户工作状态，root权限，用于系统维护，禁止远程登陆；runlevel 2：多用户状态(没有NFS)；runlevel 3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式。这个运行级别的服务会启动httpd，系统提供web server服务，所以主要查看这个运行级别的服务；runlevel 4：系统未使用，保留；runlevel 5：X11控制台，登陆后进入图形GUI模式；runlevel 6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动； 2.检查监听的网络端口通过netstat命名能够看到所有已经打开的端口，并且可以看到是哪些程序打开的。如果发现某些是必须要的，建议关掉： 12345[alter@alter~]# netstat -tulpnActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:2181 0.0.0.0:* LISTEN 48983/java tcp 0 0 0.0.0.0:2182 0.0.0.0:* LISTEN 49051/java 3.优化CRON任务linux的cron可以执行一些定时任务。并且还可以通过/etc/cron.allow 和 /etc/cron.deny 控制哪些用户可以运行JOB，哪位用户禁止运行JOB。例如:允许用户alter允许JOB，执行如下命令： 1echo alter &gt;&gt; /etc/cron.allow 禁止所有用户访问JOB，执行如下命令： 1echo ALL &gt;&gt;/etc/cron.deny 4.限制用户使用旧密码linux用户的旧密码保存在文件/etc/security/opasswd中： 12[root@LAPP-V1159 ~]# cat /etc/security/opasswdalter:504:4:$1$MVAi/EpJ$iXXkV5r3Hjc8AaK2b5KyQ/,$1$AbpFPYaD$ZKj12lK6qaYUqgQnEdocd0,$1$POabjmzY$F4Cp6aTwN6RRk1KjZWm8A/,$1$LoHe5GHY$QjkLGqABANpLmlQsRB4WE. 检查是否有开启限制使用旧密码，在RHEL / CentOS / Fedora系统中，查看文件：/etc/pam.d/system-auth。在Ubuntu/Debian/Linux Mint系统中，查看文件：/etc/pam.d/common-password，需要下面两行关键内容，其中remember=4，表示不能使用最后4次密码，否则会报错：Password has been already used. Choose another.： 12auth sufficient pam_unix.so nullok try_first_passpassword sufficient pam_unix.so sha512 shadow nullok try_first_pass use_authtok remember=4 5.检查密码过期密码的过期属性可以通过如下命令查看： 12345678[root@root ~]# chage -l alterLast password change : Sep 14, 2018Password expires : Nov 13, 2018Password inactive : neverAccount expires : neverMinimum number of days between password change : 0Maximum number of days between password change : 60Number of days of warning before password expires : 7 修改密码的过期属性可以执行如下命令： 1234chage -M 60 -W 7 alter说明：-M 60表示密码最大有效期是60天。-W 7 表示密码还有7天过期时给出告警提醒。 6.检查密码为空的用户密码为空意味着只要知道用户名就能访问，这非常危险。因为用户与密码信息保存在文件/etc/shadow中，且格式如下： 12admin:$6$YTSkre3DLd4SAZ$Jy9piv/gPezhLrLzMMeUleV8F5DNjP:17765:0:99:5:::alter:$6$.vMcyE9ss96$YNk2Q5qiS/SAeGCcyEFsmspkC5dr3OXfnN:17788:0:60:7::: 后面的几个数字是密码过期等属性信息，上面已经提及。 所以，检查密码为空的用户，只需要执行如下命令即可，如果发现有这样的用户，通过root用户执行passwd username强行修改它的密码： 1cat /etc/shadow | awk -F: &apos;($2==&quot;&quot;)&#123;print $1&#125;&apos; 7.锁定&amp;解锁用户和删除用户账户不一样，这个只是限制用户登录。只需要执行如下密码即可锁定&amp;解锁用户： 123456[root@root ~]# passwd -l alterLocking password for user alter.passwd: Success[root@root ~]# passwd -u alterUnlocking password for user alter.passwd: Success 说明： 参数l表示lock，即锁定用户密码； 参数u表示unlock，即解锁用户密码； 8.关闭IPv6现在IPv6基本上没有实际使用，所以我们可以关掉它，在文件/etc/sysconfig/network中增加如下两行内容即可： 12NETWORKING_IPV6=noIPV6INIT=no 9.复查日志Linux服务器上很多的行为都会有记录相应的日志，简单列举一些如下，如果有一些非法操作，就能从这些日志中造成蛛丝马迹，例如非法登陆，非法定时任务等： /var/log/message – Where whole system logs or current activity logs are available. /var/log/auth.log – Authentication logs. /var/log/kern.log – Kernel logs. /var/log/cron.log – Crond logs (cron job). /var/log/maillog – Mail server logs. /var/log/boot.log – System boot log. /var/log/mysqld.log – MySQL database server log file. /var/log/secure – Authentication log. /var/log/utmp or /var/log/wtmp : Login records file. /var/log/yum.log: Yum log files. 10.保持系统更新总是让系统更新最新发行的补丁包，因为这些补丁包会修复一些BUG： 1234sudo apt-get upgradeyum check-updateyum upgrade","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.alterem.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.alterem.top/tags/Linux/"}]},{"title":"SpringCloud的版本","slug":"SpringCloud的版本","date":"2018-09-14T01:54:29.000Z","updated":"2019-03-15T13:14:24.000Z","comments":true,"path":"2018/09/14/SpringCloud的版本/","link":"","permalink":"http://blog.alterem.top/2018/09/14/SpringCloud的版本/","excerpt":"Spring Cloud 项目目前仍然是快速迭代期，版本变化很快。这里整理一下版本相关的东西，备忘一下。 大版本版本号规则Spring Cloud并没有熟悉的数字版本号，而是对应一个开发代号。","text":"Spring Cloud 项目目前仍然是快速迭代期，版本变化很快。这里整理一下版本相关的东西，备忘一下。 大版本版本号规则Spring Cloud并没有熟悉的数字版本号，而是对应一个开发代号。 Cloud代号 Boot版本(train) Boot版本(tested) lifecycle Angle 1.2.x incompatible with 1.3 EOL in July 2017 Brixton 1.3.x 1.4.x 2017-07卒 Camden 1.4.x 1.5.x - Dalston 1.5.x not expected 2.x - Edgware 1.5.x not expected 2.x - Finchley 2.x not expected 1.5.x - 开发代号看似没有什么规律，但实际上首字母是有顺序的，比如：Dalston版本，我们可以简称 D 版本，对应的 Edgware 版本我们可以简称 E 版本。 D版本和E版本的区别二者均基于SpringBoot的1.5.x版本。但支持其他组件的版本不同，如以 Dalston.SR4 和 Edgware.RELEASE 来对比： spring-cloud-config 分别对应 1.3.3和 1.4.0;spring-cloud-netflix 分别对应 1.3.5和 1.4.0;spring-cloud-consul 分别对应 1.2.1和 1.3.0;spring-cloud-gateway 前者不支持，后者 1.0.0。 每个小版本的不同，会有细微差别。 F版本F版本是个绝对的大版本，几乎所有组件，全部同步变更版本号为2.x。 小版本Spring Cloud 小版本分为: SNAPSHOT： 快照版本，随时可能修改 M： MileStone，M1表示第1个里程碑版本，一般同时标注PRE，表示预览版版。 SR： Service Release，SR1表示第1个正式版本，一般同时标注GA：(GenerallyAvailable),表示稳定版本。 选择版本大版本 首先说明，各个版本之间组件变化不大，但细节略有不同，比如配置项名称、或者新版本增加新的配置方式。 从这一点来看，选择哪个版本都不是大问题，但提醒一下，遇到坑时，最好根据版本进行查询，否则你会发现你找到的办法不行。实际上是版本不匹配。 如果你项目需要和其他老项目交叉，以兼容为第一要务。 如果全新项目，可以考虑较新版本，如E版。如果你爱好踩坑，F拿去。 小版本小版本没啥可说的，尝鲜：SNAPSHOT，生产：GA。 Release train contents: Component Edgware.SR4 Finchley.SR1 Finchley.BUILD-SNAPSHOT spring-cloud-aws 1.2.3.RELEASE 2.0.0.RELEASE 2.0.1.BUILD-SNAPSHOT spring-cloud-bus 1.3.3.RELEASE 2.0.0.RELEASE 2.0.1.BUILD-SNAPSHOT spring-cloud-cli 1.4.1.RELEASE 2.0.0.RELEASE 2.0.1.BUILD-SNAPSHOT spring-cloud-commons 1.3.4.RELEASE 2.0.1.RELEASE 2.0.2.BUILD-SNAPSHOT spring-cloud-contract 1.2.5.RELEASE 2.0.1.RELEASE 2.0.2.BUILD-SNAPSHOT spring-cloud-config 1.4.4.RELEASE 2.0.1.RELEASE 2.0.2.BUILD-SNAPSHOT spring-cloud-netflix 1.4.5.RELEASE 2.0.1.RELEASE 2.0.2.BUILD-SNAPSHOT spring-cloud-security 1.2.3.RELEASE 2.0.0.RELEASE 2.0.1.BUILD-SNAPSHOT spring-cloud-cloudfoundry 1.1.2.RELEASE 2.0.0.RELEASE 2.0.1.BUILD-SNAPSHOT spring-cloud-consul 1.3.4.RELEASE 2.0.1.RELEASE 2.0.2.BUILD-SNAPSHOT spring-cloud-sleuth 1.3.4.RELEASE 2.0.1.RELEASE 2.0.2.BUILD-SNAPSHOT spring-cloud-stream Ditmars.SR4 Elmhurst.SR1 Elmhurst.BUILD-SNAPSHOT spring-cloud-zookeeper 1.2.2.RELEASE 2.0.0.RELEASE 2.0.1.BUILD-SNAPSHOT spring-boot 1.5.14.RELEASE 2.0.4.RELEASE 2.0.4.BUILD-SNAPSHOT spring-cloud-task 1.2.3.RELEASE 2.0.0.RELEASE 2.0.1.BUILD-SNAPSHOT spring-cloud-vault 1.1.1.RELEASE 2.0.1.RELEASE 2.0.2.BUILD-SNAPSHOT spring-cloud-gateway 1.0.2.RELEASE 2.0.1.RELEASE 2.0.2.BUILD-SNAPSHOT spring-cloud-openfeign 2.0.1.RELEASE 2.0.2.BUILD-SNAPSHOT spring-cloud-function 1.0.0.RELEASE 1.0.0.RELEASE 1.0.1.BUILD-SNAPSHOT","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.alterem.top/categories/Java/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://blog.alterem.top/tags/SpringCloud/"}]},{"title":"JAVA中通过Hibernate-Validation进行参数验证","slug":"JAVA中通过Hibernate-Validation进行参数验证","date":"2018-09-13T05:46:31.000Z","updated":"2019-03-15T13:13:58.000Z","comments":true,"path":"2018/09/13/JAVA中通过Hibernate-Validation进行参数验证/","link":"","permalink":"http://blog.alterem.top/2018/09/13/JAVA中通过Hibernate-Validation进行参数验证/","excerpt":"在开发JAVA服务器端代码时，我们会遇到对外部传来的参数合法性进行验证，而hibernate-validator提供了一些常用的参数校验注解，我们可以拿来使用。1.maven中引入hibernate-validator对应的jar： 12345&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;4.3.1.Final&lt;/version&gt; &lt;/dependency&gt;","text":"在开发JAVA服务器端代码时，我们会遇到对外部传来的参数合法性进行验证，而hibernate-validator提供了一些常用的参数校验注解，我们可以拿来使用。1.maven中引入hibernate-validator对应的jar： 12345&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;4.3.1.Final&lt;/version&gt; &lt;/dependency&gt; 2.在Model中定义要校验的字段（即该字段不能为空，并且最大长度为14）：** 1234567891011121314151617181920212223242526272829303132333435import javax.validation.constraints.Pattern;import javax.validation.constraints.Size;import org.hibernate.validator.constraints.NotEmpty; public class PayRequestDto &#123; /** * 支付完成时间 **/ @NotEmpty(message=\"支付完成时间不能空\") @Size(max=14,message=\"支付完成时间长度不能超过&#123;max&#125;位\") private String payTime; /** * 状态 **/ @Pattern(regexp = \"0[0123]\", message = \"状态只能为00或01或02或03\") private String status; public String getPayTime() &#123; return payTime; &#125; public void setPayTime(String payTime) &#123; this.payTime = payTime; &#125; public String getStatus() &#123; return status; &#125; public void setStatus(String status) &#123; this.status = status; &#125;&#125; 3.定义Validation工具类： 123456789101112131415161718192021222324252627282930313233import java.util.Set;import javax.validation.ConstraintViolation;import javax.validation.Validation;import javax.validation.Validator;import org.hibernate.validator.HibernateValidator;public class ValidationUtils &#123; /** * 使用hibernate的注解来进行验证 * */ private static Validator validator = Validation .byProvider(HibernateValidator.class).configure().failFast(true).buildValidatorFactory().getValidator(); /** * 功能描述: &lt;br&gt; * 〈注解验证参数〉 * * @param obj * @see [相关类/方法](可选) * @since [产品/模块版本](可选) */ public static &lt;T&gt; void validate(T obj) &#123; Set&lt;ConstraintViolation&lt;T&gt;&gt; constraintViolations = validator.validate(obj); // 抛出检验异常 if (constraintViolations.size() &gt; 0) &#123; throw new RuntimeException(String.format(\"参数校验失败:%s\", constraintViolations.iterator().next().getMessage())); &#125; &#125;&#125; 4.在代码中调用工具类进行参数校验： 1ValidationUtils.validate(requestDto); 以下是对hibernate-validator中部分注解进行描述： 注解 描述 @AssertTrue 用于boolean字段，该字段只能为true @AssertFalse 该字段的值只能为false @CreditCardNumber 对信用卡号进行一个大致的验证 @DecimalMax 只能小于或等于该值 @DecimalMin 只能大于或等于该值 @Digits(integer=,fraction=) 检查是否是一种数字的整数、分数,小数位数的数字 @Email 检查是否是一个有效的email地址 @Future 检查该字段的日期是否是属于将来的日期 @Length(min=,max=) 检查所属的字段的长度是否在min和max之间,只能用于字符串 @Max 该字段的值只能小于或等于该值 @Min 该字段的值只能大于或等于该值 @NotNull 不能为null @NotBlank 不能为空，检查时会将空格忽略 @NotEmpty 不能为空，这里的空是指空字符串 @Null 检查该字段为空 @Past 检查该字段的日期是在过去 @Pattern(regex=,flag=) 被注释的元素必须符合指定的正则表达式 @Range(min=,max=,message=) 被注释的元素必须在合适的范围内 @Size(min=, max=) 检查该字段的size是否在min和max之间，可以是字符串、数组、集合、Map等 @URL(protocol=,host,port) 检查是否是一个有效的URL，如果提供了protocol，host等，则该URL还需满足提供的条件 @Valid 该注解主要用于字段为一个包含其他对象的集合或map或数组的字段，或该字段直接为一个其他对象的引用，这样在检查当前对象的同时也会检查该字段所引用的对象","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.alterem.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.alterem.top/tags/Java/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://blog.alterem.top/tags/Hibernate/"},{"name":"validation","slug":"validation","permalink":"http://blog.alterem.top/tags/validation/"}]},{"title":"用JAVA写一个简易图片防篡改","slug":"用JAVA写一个简易图片防篡改","date":"2018-09-11T07:23:04.000Z","updated":"2019-03-15T13:20:54.000Z","comments":true,"path":"2018/09/11/用JAVA写一个简易图片防篡改/","link":"","permalink":"http://blog.alterem.top/2018/09/11/用JAVA写一个简易图片防篡改/","excerpt":"图片防止篡改部分 第一步，获取图片的md5字符串，并转为字节数组","text":"图片防止篡改部分 第一步，获取图片的md5字符串，并转为字节数组 123456789101112131415161718192021222324252627282930313233343536373839404142434445//将图片使用md5加密 private static byte[] img2Md5Bytes(File file,String salt) throws Exception&#123; FileInputStream inputStream=new FileInputStream(file); StringBuilder builder=new StringBuilder(); byte[] bytes=new byte[1024]; int bytesRead; while ((bytesRead=inputStream.read(bytes))!=-1)&#123; builder.append(new String(bytes,0,bytesRead)); &#125; inputStream.close(); builder.append(salt); String md5=md5(builder.toString()); return hexStringToBytes(md5); &#125; //16进制转字节数组 private static byte[] hexStringToBytes(String hexString) &#123; if (hexString == null || hexString.equals(\"\")) &#123; return null; &#125; hexString = hexString.toUpperCase(); int length = hexString.length() / 2; char[] hexChars = hexString.toCharArray(); byte[] d = new byte[length]; for (int i = 0; i &lt; length; i++) &#123; int pos = i * 2; d[i] = (byte) (charToByte(hexChars[pos]) &lt;&lt; 6 | charToByte(hexChars[pos + 1])); &#125; return d; &#125; private static byte charToByte(char c) &#123; return (byte) \"0123456789ABCDEF\".indexOf(c); &#125; //md5加密字符串 private static String md5(String str) &#123; try &#123; MessageDigest md = MessageDigest.getInstance(\"MD5\"); md.update(str.getBytes()); return new BigInteger(1, md.digest()).toString(16); &#125; catch (Exception e) &#123; return \"\"; &#125; &#125; 第二步，图片末尾加md5字节数组 12345678//图片末尾加md5字节数组 private static void imgAppendMd5Bytes(File file,byte[] md5Bytes) throws Exception&#123; RandomAccessFile accessFile=new RandomAccessFile(file,\"rw\"); long length=accessFile.length(); accessFile.seek(length); accessFile.write(md5Bytes); accessFile.close(); &#125; 第三步，封装一下 12345//防止图片被篡改 private static void preventTamper(File file,String salt) throws Exception&#123; byte[] md5bytes=img2Md5Bytes(file,salt); imgAppendMd5Bytes(file,md5bytes); &#125; 图片验证部分第一步，获取图片的末尾存储的md5字节数组 123456789101112//获取存储在图片末尾的16个md5字节 public static byte[] popMd5Bytes(File file) throws Exception&#123; RandomAccessFile accessFile=new RandomAccessFile(file,\"rw\"); byte[] bytes=new byte[16]; long length=accessFile.length(); accessFile.seek(length-16); for (int i=0;i&lt;16;i++)&#123; bytes[i]=accessFile.readByte(); &#125; accessFile.close(); return bytes; &#125; 第二步，去除图片末尾的16个md5字节后，重新计算图片的md5值 123456789//去除图片末尾的16个md5字节 private static void imgDelEndMd5Bytes(File file) throws Exception&#123; RandomAccessFile accessFile=new RandomAccessFile(file,\"rw\"); FileChannel fc = accessFile.getChannel(); fc.truncate(accessFile.length()-16); fc.close(); accessFile.close(); &#125;byte[] imgMd5=img2Md5Bytes(file,salt); 第三步，封装为方法 1234567//验证图片是否被篡改 private static boolean notTamper(File file,String salt) throws Exception&#123; byte[] storageMd5=popMd5Bytes(file);//获取存储在图片末尾的16个md5字节 imgDelEndMd5Bytes(file);//删除末尾md5字节数组 byte[] imgMd5=img2Md5Bytes(file,salt); return Arrays.equals(storageMd5,imgMd5); &#125; 简单实现，没有进行调优","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.alterem.top/categories/Java/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://blog.alterem.top/tags/JAVA/"}]},{"title":"CentOS下安装环境文档","slug":"CentOS下安装环境文档","date":"2018-09-11T07:01:34.000Z","updated":"2019-03-15T13:10:32.000Z","comments":true,"path":"2018/09/11/CentOS下安装环境文档/","link":"","permalink":"http://blog.alterem.top/2018/09/11/CentOS下安装环境文档/","excerpt":"【JDK1.7安装】 1)登录Sun的JDK官方下载网 址:http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html 2)下载jdk-7u67-linux-x64.rpm文件 》删除系统自带OpenJDK CentOs6.5 默认会安装OpenOffice之类，需要JAVA支持，系统默认安装了一个openjdk1.7版本","text":"【JDK1.7安装】 1)登录Sun的JDK官方下载网 址:http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html 2)下载jdk-7u67-linux-x64.rpm文件 》删除系统自带OpenJDK CentOs6.5 默认会安装OpenOffice之类，需要JAVA支持，系统默认安装了一个openjdk1.7版本 1234567# java -versionjava version &quot;1.7.0&quot;OpenJDK Runtime Environment (build 1.7.0-b09)OpenJDK Client VM (build 1.7.0-b09, mixed mode) 备注： 无须删除原有的openjdk;否则，与之相关的openoffice等软件，也会自动随之删除； 如果直接”应用程序-添加/删除软件–基本系统–java“删除其他相关软件也会自动删除，所以删除前，最好安装配置好新的JDK环境 1) 删除原有的JDK： 1# rpm -qa|grep jdk 查看安装的JDK，会显示多个java-1.7.0-openjdk-1.7.0相关的程序，在以下一一卸载。直到删完为止，如下： 123# rpm -e --nodeps java-1.7.0-openjdk-1.7.0.65-2.5.1.2.el6_5.x86_64# rpm -e --nodeps java-1.7.0-openjdk-devel-1.7.0.65-2.5.1.2.el6_5.x86_64# rpm -e --nodeps java-1.7.0-openjdk-demo-1.7.0.65-2.5.1.2.el6_5.x86_64 …… 1# rpm -qa|grep java 查看安装的JAVA关联程序，在以下一一卸载。直到删完为止，如下： 1# rpm -e --nodeps tzdata-java-2014h-1.el6.noarch …… 》配置新的JDK环境 1）把安装文件文件保存在/usr/java/tools下 ,并切换到root用户 123# mkdir /usr/java //创建/urs/java目录# cd /usr/java/# rpm -ivh ./tools/jdk-7u67-linux-x64.rpm 》配置jdk1.6.0_22环境变量 1234567# vi /etc/profileJAVA_HOME=/usr/java/jdk1.7.0_79JRE_HOME=/usr/java/jdk1.7.0_79/jrePATH=PATH:JAVA_HOME/bin:$JRE_HOME/binCLASSPATH=:JAVA_HOME/lib/dt.jar:JAVA_HOME/lib/tools.jar:$JRE_HOME/libexport JAVA_HOME JRE_HOME PATH CLASSPATH 》使环境变量生效： 1#source /etc/profile 》测试安装 1)查看版本号 123456# java -versionjava version &quot;1.7.0_67&quot;Java(TM) SE Runtime Environment (build 1.7.0_67-b01)Java HotSpot(TM) 64-Bit Server VM (build 24.65-b04, mixed mode)Java HotSpot(TM) Client VM (build 17.1-b03, mixed mode, sharing) 说明成功了。 【MYSQL5.5的安装】 安装方式分为rpm和源码编译安装两种，本文是采用mysql源码编译方式，编译器使用Cmake。软件需要mysql-5.5.40.tar.gz和cmake-2.8.10.2.tar.gz，请自行下载。 》下载地址： http://dev.mysql.com/get/Downloads/MySQL-5.5/mysql-5.5.40.tar.gz http://www.cmake.org/files/v2.8/cmake-2.8.10.2.tar.gz 其中mysql使用最新的稳定版本，即最新试用版的上一个版本，且非rc或者alpha的版本，Cmake直接用的最新版。 》上传mysql-5.5.40.tar.gz和cmake-2.8.10.2.tar.gz到/usr/java/tools文件夹下。 》CentOS安装g++和ncurses-devel 12# yum install gcc-c++# yum install ncurses-devel 》cmake的安装 12345678# mkdir -p /usr/java/make# cd /usr/java/make# mv ../tools/cmake-2.8.10.2.tar.gz ./# tar -zxv -f cmake-2.8.10.2.tar.gz# cd cmake-2.8.10.2# ./configure# make# make install 》将cmake永久加入系统环境变量 》用vi在文件/etc/profile文件中增加变量，使其永久有效， 1# vi /etc/profile 》在文件PATH中加入MAKE_PATH环境变量： 123456JAVA_HOME=/usr/java/jdk1.7.0_67JRE_HOME=/usr/java/jdk1.7.0_67/jreMAKE_PATH=/usr/java/cmake/cmake-2.8.10.2/binPATH=MAKE_PATH:PATH:JAVA_HOME/bin:JRE_HOME/binCLASSPATH=:JAVA_HOME/lib/dt.jar:JAVA_HOME/lib/tools.jar:$JRE_HOME/libexport JAVA_HOME JRE_HOME PATH CLASSPATH 》执行以下代码使刚才的修改生效： 1# source /etc/profile 》用 export 命令查看PATH值 1# echo $PATH 》创建mysql的安装目录及数据库存放目录 12# mkdir -p /usr/java/mysql //安装mysql# mkdir -p /usr/java/mysql/data //存放数据库 》创建mysql用户及用户组 12# groupadd mysql# useradd -r -g mysql mysql 》编译安装mysql 1234567891011121314151617# cd /usr/java/mysql# tar zxvf ../tools/mysql-5.5.40.tar.gz# cd mysql-5.5.40/# cmake -DCMAKE_INSTALL_PREFIX=/usr/java/mysql \\-DMYSQL_UNIX_ADDR=/usr/java/mysql/mysql.sock \\-DDEFAULT_CHARSET=utf8 \\-DDEFAULT_COLLATION=utf8_general_ci \\-DWITH_MYISAM_STORAGE_ENGINE=1 \\-DWITH_INNOBASE_STORAGE_ENGINE=1 \\-DWITH_MEMORY_STORAGE_ENGINE=1 \\-DWITH_READLINE=1 \\-DENABLED_LOCAL_INFILE=1 \\-DMYSQL_DATADIR=/usr/java/mysql/data \\-DMYSQL_USER=mysql \\-DMYSQL_TCP_PORT=6666# make# make install 》检验是否安装成功 1234# cd /usr/java/mysql[root@fiona mysql]# lsbin data include lib mysql-5.5.40 mysql-test scripts sql-benchCOPYING docs INSTALL-BINARY man mysql.sock README share support-files 有bin等以上文件的话，恭喜你已经成功安装了mysql。 》配置mysql 》设置mysql目录权限 123# cd /usr/java/mysql //把当前目录中所有文件的所有者设为root，所属组为mysql# chown -R root:mysql .# chown -R mysql:mysql data 》将mysql的启动服务添加到系统服务中 12# cp support-files/my-medium.cnf /etc/my.cnfcp：是否覆盖&quot;/etc/my.cnf&quot;？ y 》创建系统数据库的表 12# cd /usr/java/mysql# scripts/mysql_install_db --user=mysql 》设置环境变量 1# vi /root/.bash_profile 在修改PATH=$PATH:$HOME/bin为： 12PATH=PATH:HOME/bin:/usr/java/mysql/bin:/usr/java/mysql/lib# source /root/.bash_profile //使刚才的修改生效 》手动启动mysql 12# ./bin/mysqld_safe --user=mysql &amp; //启动MySQL，但不能停止mysqladmin -u root -p shutdown //此时root还没密码，所以为空值，提示输入密码时，直接回车即可。 》将mysql的启动服务添加到系统服务中 1# cp support-files/mysql.server /etc/init.d/mysql 》启动mysql 12# service mysql startStarting MySQL... ERROR! The server quit without updating PID file (/usr/java/mysql/data/localhost.localdomain.pid). 》启动失败： 》我这里是权限问题，先改变权限 1# chown -R mysql:mysql /usr/java/mysql 》接着启动服务器 1# /etc/init.d/mysql start 》修改MySQL的root用户的密码以及打开远程连接 12345678# mysql -u root mysqlmysql&gt; use mysql;mysql&gt; desc user;mysql&gt; GRANT ALL PRIVILEGES ON . TO root@&quot;%&quot; IDENTIFIED BY &quot;root&quot;; //为root添加远程连接的能力mysql&gt; update user set Password = password(&apos;x123456.&apos;) where User=&apos;root&apos;; //设置root用户密码mysql&gt; select Host,User,Password from user where User=&apos;root&apos;;mysql&gt; flush privileges;mysql&gt; exit 》重新登录 12# mysql -u root -penter password:x123456.000 》若还不能进行远程连接，关闭防火墙 1[root@localhost]# /etc/rc.d/init.d/iptables stop 用远程工具连接上了表示成功了。 【TOMCAT7.0的安装】 》先下载apache-tomcat-7.0.56.tar.gz 》下载地下：http://mirrors.hust.edu.cn/apache/tomcat/tomcat-7/v7.0.56/bin/apache-tomcat-7.0.56.tar.gz 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# cd /usr/java# tar -zxvf ./tools/apache-tomcat-7.0.56.tar.gz# cd /etc/rc.d/init.d# vi tomcat#----------输入以下信息---------------------## chkconfig: 345 80 15# description: Tomcat is a Servlet+JSP Engine.# Enter the jdk installation directoryjdk_File=/usr/java/jdk1.7.0_67# Enter the tomcat installation directorytomcat_File=/usr/java/apache-tomcat-7.0.56export JAVA_HOME=$jdk_File# Source function library.. /etc/rc.d/init.d/functionsstart()&#123;if [ -z $(/sbin/pidof java) ]; thenecho &quot;Starting tomcat&quot;$tomcat_File/bin/startup.shtouch /var/lock/subsys/tomcatelseecho &quot;tomcat allready running&quot;fi&#125;stop()&#123;if [ ! -z $(/sbin/pidof java) ]; thenecho &quot;Shutting down tomcat&quot;$tomcat_File/bin/shutdown.shuntil [ -z $(/sbin/pidof java) ]; do :; donerm -f /var/lock/subsys/tomcatelseecho &quot;tomcat not running&quot;fi&#125;case &quot;$1&quot; instart)start;;stop)stop;;restart)stopstart;;status)$tomcat_File/bin/catalina.sh version;;*)echo &quot;Usage: $0 &#123;start|stop|restart|status&#125;&quot;esacexit 0#----------输入以下信息---------------------:wq! #保存退出 # chmod 755 /etc/rc.d/init.d/tomcat #添加执行权限# chkconfig --add tomcat #添加服务# chkconfig tomcat on #设置开机启动# service tomcat stop #停止# service tomcat start #启动# service tomcat restart #重启# service tomcat status #查看状态信息 【nginx-1.7.6.tar.gz的安装】 》先下载nginx-1.7.6.tar.gz 》下载URL:http://nginx.org/download/nginx-1.7.6.tar.gz 》把nginx-1.7.6.tar.gz放到/usr/java/tools目录下 1234567891011# cd /usr/local/# tar -zxvf /usr/java/tools/nginx-1.7.5.tar.gz# cd nginx-1.7.6/# yum -y install pcre-devel# yum install -y zlib-devel# ./configure# make &amp;&amp; make install# cd /usr/local/nginx# cd sbin# ./nginx# /etc/rc.d/init.d/iptables stop 》配置服务器启动方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283# vi /etc/init.d/nginx#---------输入以下信息------------------# nginx Startup script for the Nginx HTTP Server# it is v.0.0.2 version.# chkconfig: - 85 15# description: Nginx is a high-performance web and proxy server.# It has a lot of features, but it&apos;s not for everyone.# processname: nginx# pidfile: /software/nginx/logs/nginx.pid# config: /software/nginx/conf/nginx.confnginxd=/usr/local/nginx/sbin/nginxnginx_config=/usr/local/nginx/conf/nginx.confnginx_pid=/usr/local/nginx/logs/nginx.pidRETVAL=0prog=&quot;nginx&quot;# Source function library.. /etc/rc.d/init.d/functions# Source networking configuration.. /etc/sysconfig/network# Check that networking is up.[ $&#123;NETWORKING&#125; = &quot;no&quot; ] &amp;&amp; exit 0[ -x $nginxd ] || exit 0# Start nginx daemons functions.start() &#123;if [ -e $nginx_pid ];thenecho &quot;nginx already running....&quot;exit 1fiecho -n &quot;Starting prog: &quot;daemon nginxd -c &#123;nginx_config&#125;RETVAL=$?echo[ $RETVAL = 0 ] &amp;&amp; touch /var/lock/subsys/nginxreturn $RETVAL&#125;# Stop nginx daemons functions.stop() &#123;echo -n &quot;Stopping prog: &quot;killproc $nginxdRETVAL=$?echo[ $RETVAL = 0 ] &amp;&amp; rm -f /var/lock/subsys/nginx /usr/local/nginx/logs/nginx.pid&#125;reload() &#123;echo -n &quot;Reloading prog: &quot;#kill -HUP cat $&#123;nginx_pid&#125;killproc $nginxd -HUPRETVAL=$?echo&#125;# See how we were called.case &quot;$1&quot; instart)start;;stop)stop;;reload)reload;;restart)stopstart;;status)status $progRETVAL=$?;;*)echo &quot;Usage: prog &#123;start|stop|restart|reload|status|help&#125;&quot;exit 1esacexit $RETVAL#---------输入以下信息------------------# chmod 755 /etc/init.d/nginx &amp;&amp; chkconfig nginx on# service nginx start# service nginx stop# service nginx restart# ps -ef | grep nginx# netstat -pant | grep 80 》测试在浏览器中输入广域网IP看看能不能看到欢迎界面，如果能就表示成功了。 【配置规则】 1# vi /etc/sysconfig/iptables 增加如下配置: -A INPUT -m state –state NEW -m tcp -p tcp –dport 80 -j ACCEPT -A INPUT -m state –state NEW -m tcp -p tcp –dport 8888 -j ACCEPT -A INPUT -m state –state NEW -m tcp -p tcp –dport 6666 -j ACCEPT 1# service iptables restart 》系统启动的方式为自启动 123# chkconfig mysql on# chkconfig nginx on# chkconfig tomcat on","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.alterem.top/categories/Linux/"},{"name":"Server","slug":"Linux/Server","permalink":"http://blog.alterem.top/categories/Linux/Server/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"http://blog.alterem.top/tags/CentOS/"},{"name":"MySQL","slug":"MySQL","permalink":"http://blog.alterem.top/tags/MySQL/"},{"name":"JDK","slug":"JDK","permalink":"http://blog.alterem.top/tags/JDK/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://blog.alterem.top/tags/Tomcat/"},{"name":"Nginx","slug":"Nginx","permalink":"http://blog.alterem.top/tags/Nginx/"}]},{"title":"CentOS 7 安装 Apache, MySQL, PHP 指南","slug":"CentOS-7-安装-Apache-MySQL-PHP-指南","date":"2018-09-11T06:59:50.000Z","updated":"2019-03-15T13:13:28.000Z","comments":true,"path":"2018/09/11/CentOS-7-安装-Apache-MySQL-PHP-指南/","link":"","permalink":"http://blog.alterem.top/2018/09/11/CentOS-7-安装-Apache-MySQL-PHP-指南/","excerpt":"一个 LAMP 软件栈通常由多个开源软件组合而成，它们合力驱动一个服务器去运行 web 站点和应用。LAMP 这个术语实际上是一个由 Linux 操作系统，Apache web 服务器，MySQL 数据库服务器，以及 PHP 编程环境组合缩略而成的。 在这篇指南中，我们将为一个搭载 CentOS 7 操作系统的服务器安装 LAMP 软件栈。CentOS 已经满足了 LAMP 软件栈的第一个需求：一个 Linux 操作系统。","text":"一个 LAMP 软件栈通常由多个开源软件组合而成，它们合力驱动一个服务器去运行 web 站点和应用。LAMP 这个术语实际上是一个由 Linux 操作系统，Apache web 服务器，MySQL 数据库服务器，以及 PHP 编程环境组合缩略而成的。 在这篇指南中，我们将为一个搭载 CentOS 7 操作系统的服务器安装 LAMP 软件栈。CentOS 已经满足了 LAMP 软件栈的第一个需求：一个 Linux 操作系统。 预备条件 在继续阅读这篇指南之前，请确认你使用具有 root 权限的用户登录了 CentOS。如果对于当前用户如何取得 root 权限存在疑问，请咨询服务器的管理人员。 第一步 —— 安装 Apache Apache 是目前世界上最广泛使用的 web 服务器，这使得它成为运行网站的绝佳选择。 利用 CentOS 的软件安装包管理系统 yum，我们可以轻易地安装 Apache。它为我们提供了无痛式地从 CentOS 维护的仓库获取并安装绝大多数软件的方式。你可以前往这里 (https://www.digitalocean.com/community/tutorials/how-to-set-up-and-use-yum-repositories-on-a-centos-6-vps) 获取更多如何使用 yum 安装包管理系统的指导。 对于我们的目的而言，安装 Apache 只需要在 CentOS 命令终端敲入这条命令就行了： 1$ sudo yum install httpd 由于使用了 sudo 命令，这些操作将以 root 权限执行。如果当前用户的身份不是 root，CentOS 将会要求你输入当前用户的密码，以验证你的意图。 不用一会儿，你的 web 服务器就安装好了。 一旦安装成功，你就可以设置服务器启动时就开启 Apache 服务： 1$ sudo systemctl enable httpd.service 你可以通过重新启动服务器，然后在命令行终端中敲入这条命令来验证 Apache 服务是否在服务器启动时自动开启了： 1$ sudo systemctl is-enabled httpd.service 如果你看到了这样的响应： 1enabled 则说明 Apache 服务已经配置为在服务器启动时自动开启了。 在服务器上启动 Apache 服务的命令为： 1$sudo systemctl start httpd.service 重新启动 Apache： 1$sudo systemctl restart httpd.service 停止 Apache： 1$sudo systemctl stop httpd.service 以及 如果你的服务器正在运行防火墙，请运行下列命令以允许它进行 HTTP 和 HTTPS 通信： 123$sudo firewall-cmd --permanent --zone=public --add-service=http$sudo firewall-cmd --permanent --zone=public --add-service=https$sudo firewall-cmd --reload 在 Apache 启动的情况下，你可以在浏览器里访问服务器的公网 IP 地址以验证一切如计划那样顺利地进行（如果你现在还不知道如何获取服务器的公网 IP 地址，请参考下一标题中的内容）： http://&lt;服务器的公网 IP 地址&gt;/ 你将会看到一个出于通知和测试目的而存在的默认 CentOS 7 Apache 网页。它应该长这样子： 如果你看到了这个页面，那么你的 web 服务器现在已经正确地安装了。 如何找到服务器的公网 IP 地址 如果你不知道服务器的公网 IP 地址是什么，你可以使用多种方式找到它。通常情况下，它就是你通过 SSH 用以连接服务器的地址。 在命令行终端中，你有多种方式找到它。首先，你可以通过下面这条命令，让 iproute2 工具帮你找出服务器的 IP 地址： 1$ ip addr show eth1 | grep inet | awk '&#123; print $2; &#125;' | sed 's/\\/.*$//' 这将会返回一到两行结果。它们都是正确的 IP 地址，但是你的计算机可能只能使用其中的一条，所以随意试试其中的每一条。 另一种方法是让一个外部组织告诉你它是怎样找到你的服务器的，你可以通过询问特定的服务器来获知自己的 IP 地址： 1$ curl http://icanhazip.com 第二步 —— 安装 MySQL MySQL 是一个 web 服务器上流行的数据库管理系统。然而，从 CentOS 7 的软件仓库不再提供 MySQL 的安装包，转而提供 MariaDB 作为默认的数据库管理系统。MariaDB 作为 MySQL 的简易替代品，足以胜任通常意义上你对的数据库系统的需求 (https://mariadb.com/kb/en/mariadb/mariadb-vs-mysql-compatibility/)。你可以前往这里 (https://www.linode.com/docs/databases/mariadb/how-to-install-mariadb-on-centos-7) 获取在 CentOS 7 上安装 MariaDB 的指导。 如果你不论如何都更需要 MySQL 作为 web 服务器上的数据管理系统，那么请继续阅读下面这部分指南，它将指引你如何在运行 CentOS 7 的服务器上安装并配置 MySQL 数据库。 开始安装 MySQL 之前，请更新系统上的软件到最新版： 1$ sudo yum update 由于 CentOS 7 的软件仓库不再提供 MySQL 的安装包，我们必须从 MySQL 社区仓库 (https://dev.mysql.com/downloads/repo/yum/) 获取 MySQL 安装包。 首先，获取 MySQL 社区仓库： 1$ wget http://repo.mysql.com/mysql57-community-release-el7-8.noarch.rpm 载入 MySQL 社区仓库： 1$ sudo yum install mysql57-community-release-el7-8.noarch.rpm 更新系统上的软件到最新版： 1$ sudo yum update 在更新过程中，你会被询问是否想接受这个 .rpm 文件 GPG 校验得出的结果，如果没有错误或者不匹配出现，请输入 y 以完成更新。 接着，我们就能一如往常一样安装 MySQL 了： 1$ sudo yum install mysql-server 接下来，请按照这里的指南，重置 MySQL root 账户的密码为你能够记住的密码: http://stackoverflow.com/questions/33510184/change-mysql-root-password-on-centos7 然后，启动 MySQL 服务： 1$ sudo systemctl start mysqld 现在 MySQL 数据库已经开始运行了。我们希望运行一个安全防御脚本，将一些危险的默认配置移除掉，并为我们的数据库系统加上一点安全机制。请在命令行终端里运行下面这一条命令： 1$ sudo mysql_secure_installation 命令行终端将会提示你输入 MySQL 内 root 用户的密码。键入上面重置 MySQL root 密码后的新密码。然后，命令行终端将会要求你更新 root 用户的密码。 1234567Enter current password for root:The existing password for the user account root has expired. Please set a new password.New password:Re-enter new password:The 'validate_password' plugin is installed on the server.The subsequent steps will run with the existing configurationof the plugin.Using existing password for root. 对于命令行终端接下来给出的选择，你应该敲击 ENTER 键选择忽略修改 root 密码，接着键入 y 同意移除掉出于示例目的而存在的用户，而后键入 y 同意禁用远程登录 root 用户，再次键入 y 同意移除测试数据库，最后键入 y 载入这些新的规则使得 MySQL 立即响应我们做的变更。 最后，如果希望 MySQL 服务在服务器启动时自动开启，那么你应该使用这一条的命令： 1$ sudo systemctl enable mysqld.service 你可以通过重新启动服务器，然后在命令行终端中敲入这条命令来验证MySQL 服务是否在服务器启动时自动开启了： 1$ sudo systemctl is-enabled mysqld.service 如果你看到了这样的响应： 1enabled 则说明 MySQL 服务已经配置为在服务器启动时自动开启了。 现在，你的数据库系统已经安装妥当，我们可以继续后面的内容了。 第三步 —— 安装 PHP 在我们的 web 软件栈中，PHP 是一个能够处理业务逻辑和数据，并动态生成内容展现给用户的软件。它可以运行脚本，连接到 MySQL 数据库以存取数据，以及将处理过的内容递交给 web 服务器来显示。 我们可以再次利用 yum 安装包管理系统来安装我们的组件。现在，我们打算将 php-mysql 也加入到我们将要安装的软件序列中： 1$ sudo yum install php php-mysql 这里安装 PHP 应该不会有任何问题。我们需要重新启动 Apache web 服务器以便它能够与 PHP 协作。你可以通过这条命令达到目的： 1$ sudo systemctl restart httpd.service 安装 PHP 模块 为了增强 PHP 的功能，我们可以选择性地安装一些额外的模块。 在命令行终端敲入这条命令，你就可以找到所有可以获取到的 PHP 模块选项和库： 1$ yum search php 响应的结果就是所有你能够选择安装的组件。其中包含了每个可选组件的描述： 12345678910php-bcmath.x86_64 : A module for PHP applications for using the bcmath libraryphp-cli.x86_64 : Command-line interface for PHPphp-common.x86_64 : Commonfiles for PHPphp-dba.x86_64 : Adatabase abstraction layer module for PHP applicationsphp-devel.x86_64 : Filesneeded for building PHP extensionsphp-embedded.x86_64 : PHPlibrary for embedding in applicationsphp-enchant.x86_64 : Enchantspelling extension for PHP applicationsphp-fpm.x86_64 : PHPFastCGI Process Managerphp-gd.x86_64 : Amodule for PHP applications for using the gd graphics library. . . 如果需要获取每个模块更多的信息，你可以通过互联网搜索，或者直接在命令行终端中敲入这条命令查看： 1$ yum info package_name 响应中将会包含许多的信息，其中一个名为 Description 的域包含了这个模块提供的功能更为详尽的描述。 举个例子，如果要获知 php-fpm 模块的功能，我们只要在命令行终端中敲入下列指令就可以了： 1$ yum info php-fpm 顺着众多其他信息往下看，你将会找到形如这样的信息： 12345678910111213. . .Summary : PHPFastCGI Process ManagerURL : http://www.php.net/License : PHPand Zend and BSDDescription : PHP-FPM (FastCGI Process Manager) is an alternative PHP FastCGI​ : implementation with some additional features useful for sites of​ : any size, especially busier sites. 在考究之后，如果你决定要安装一个模块包，你可以像我们之前安装其他软件时的做法一样，使用 yum install 命令达到目的。 如果我们决定了 php-fpm 就是我们需要的，那么我们可以在命令行终端键入： 1$ sudo yum install php-fpm 如果你想安装多于 1 个的模块包，你可以在命令行终端中键入 yum install 后，列出你想安装的每个模块包，并使用空格区分，就像下面这样子： 1$ sudo yum install package1 package2… 现在，你的 LAMP 软件栈已经安装并配置妥当了。但我们仍需要测试一下 PHP。 第四步 —— 测试你 Web 服务器上的 PHP 处理程序 为了测试系统已经配置得适合 PHP 运行，我们可以创建一个非常简易的 PHP 脚本。 我们将这个脚本命名为 info.php。为了让 Apache 能够正确地找到并为之服务，它必须保存在一个称为『web 目录』特殊的目录中。 在 CentOS 7 中，这个目录位于 /var/www/html/。我们可以通过下面这条命令在此创建一个文件： 1$ sudo vi /var/www/html/info.php 这将会打开一个空白文件，敲击小写字母 I 即可进行编辑。我们想在文件中输入下列 PHP 代码组成的文本： &lt;?php phpinfo(); ?&gt; 然后，敲击 ESC 键并键入 :wq! 即可保存并关闭这个文件。 现在我们可以测试 web 服务器是否能够正确地显示由 PHP 脚本生成的内容了。我们可以尝试通过 web 浏览器访问这个页面。你需要再次获取服务器的公网 IP 地址。 你希望访问的地址就是： http://&lt;服务器的公网 IP 地址&gt;/info.php 你看到的页面应该像下面这样子： 如果你的浏览器成功地显示了这个页面，那么你的 PHP 就像预期中的那样正常工作了。 你很可能想要在测试之后移除掉这个文件，因为它事实上可以将服务器的信息展现给未授权的用户。为此，我们需要在命令行终端中键入下面这条命令： 1$ sudo rm /var/www/html/info.php 以后若需要，你总能重新创建这个页面来获取这些信息。 结论 现在我们已经安装了 LAMP 软件栈，对于下一步需要做什么，你有许多的选择。大体上，你已经安装了一个允许你在服务器上部署各种各样网站和 web 软件的平台。 参考链接 https://www.digitalocean.com/community/tutorials/how-to-install-linux-apache-mysql-php-lamp-stack-on-centos-7 https://www.linode.com/docs/databases/mysql/how-to-install-mysql-on-centos-7 http://dev.mysql.com/doc/refman/5.7/en/linux-installation-yum-repo.html","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.alterem.top/categories/Linux/"},{"name":"Server","slug":"Linux/Server","permalink":"http://blog.alterem.top/categories/Linux/Server/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"http://blog.alterem.top/tags/CentOS/"},{"name":"Apache","slug":"Apache","permalink":"http://blog.alterem.top/tags/Apache/"},{"name":"MySQL","slug":"MySQL","permalink":"http://blog.alterem.top/tags/MySQL/"},{"name":"PHP","slug":"PHP","permalink":"http://blog.alterem.top/tags/PHP/"}]},{"title":"Postgresql 9.4.0-1 x64 win7 解压版安装步骤","slug":"Postgresql-9-4-0-1-x64-win7-解压版安装步骤","date":"2018-09-11T06:55:19.000Z","updated":"2019-03-15T13:14:18.000Z","comments":true,"path":"2018/09/11/Postgresql-9-4-0-1-x64-win7-解压版安装步骤/","link":"","permalink":"http://blog.alterem.top/2018/09/11/Postgresql-9-4-0-1-x64-win7-解压版安装步骤/","excerpt":"1、下载 32位：https://get.enterprisedb.com/postgresql/postgresql-10.2-1-windows-binaries.zip 64位：https://get.enterprisedb.com/postgresql/postgresql-10.2-1-windows-x64-binaries.zip 2、解压到：c:\\pgsql\\","text":"1、下载 32位：https://get.enterprisedb.com/postgresql/postgresql-10.2-1-windows-binaries.zip 64位：https://get.enterprisedb.com/postgresql/postgresql-10.2-1-windows-x64-binaries.zip 2、解压到：c:\\pgsql\\ 3、设置环境变量(cmd)： 12345setx PGHOME c:\\pgsqlsetx PGHOST localhostsetx PGLIB %PGHOME%\\libsetx PGDATA %PGHOME%\\datasetx Path %Path%;%PGHOME%\\bin 重新登录 4、初始化数据库 1initdb.exe -D c:\\pgsql\\data -E UTF-8 --locale=chs -U postgres -W 5、注册为系统服务（以管理员权限打开cmd） 1pg_ctl register -N PostgreSQL -D c:\\pgsql\\data 6、修改配置以支持远程连接 6.1 notepad c:\\pgsql\\data\\postgresql.conf listen_addresses = ‘*’ ​ 6.2 设置ipv4段 notepad c:\\pgsql\\data\\pg_hba.conf host all all 0.0.0.0/0 md5 7、启动服务 1net start PostgreSQL 8、关闭防火墙（视情况而定） 1netsh firewall set opmode disable","categories":[{"name":"Sql","slug":"Sql","permalink":"http://blog.alterem.top/categories/Sql/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://blog.alterem.top/tags/PostgreSQL/"},{"name":"windows","slug":"windows","permalink":"http://blog.alterem.top/tags/windows/"}]},{"title":"Linux服务器初始化设置用户和ssh公私钥登陆","slug":"Linux服务器初始化设置用户和ssh公私钥登陆","date":"2018-09-11T03:41:45.000Z","updated":"2019-03-15T13:14:14.000Z","comments":true,"path":"2018/09/11/Linux服务器初始化设置用户和ssh公私钥登陆/","link":"","permalink":"http://blog.alterem.top/2018/09/11/Linux服务器初始化设置用户和ssh公私钥登陆/","excerpt":"当我们开始使用一个新的服务器的时候，首先一定要对服务器的登陆等做一些修改工作，笔者曾经就因为对服务器登陆安全没有重视，导致服务器数据全部丢失。接下来我们按照步骤，罗列出应该做的一些事情。 修改ssh端口号第一件事情： 修改ssh端口号： 之后加上一个端口比如说50000 vi /etc/ssh/sshd_config之后在port字段加上一个端口比如说50000，原来的端口号字段可能是被注释掉的，要先解除注释。 然后执行：","text":"当我们开始使用一个新的服务器的时候，首先一定要对服务器的登陆等做一些修改工作，笔者曾经就因为对服务器登陆安全没有重视，导致服务器数据全部丢失。接下来我们按照步骤，罗列出应该做的一些事情。 修改ssh端口号第一件事情： 修改ssh端口号： 之后加上一个端口比如说50000 vi /etc/ssh/sshd_config之后在port字段加上一个端口比如说50000，原来的端口号字段可能是被注释掉的，要先解除注释。 然后执行： 1service sshd restart 这个时候可能还要重新配置一下防火墙，开放50000端口，具体如何配置也可以参考这里的后半部分。但是目前，阿里云的服务器实测是不需要再配置防火墙的，但是需要去登陆到网页后台修改安全组。 之后就可以通过这样的方式登录了：(注意登录方式一定要写对) 1ssh root@115.29.102.81 -p 50000 创建用户这个时候我们还是用root进行操作，所以我们接下来要给自己创建一个账户，比如创建一个如下的用户： 12useradd xiaotaopasswd xiaotao 可以用ls -al /home/`查看一下账户 对创建的这个用户增加sudo权限： 相关配置文件/etc/sudoers中，但是这个文件是只读的，所以要更改一下权限 1chmod u+w sudoers 然后进入这个文件在这里进行更改： 12root ALL=(ALL) ALLxiaotao ALL=(ALL) ALL 然后再改回权限： 1chmod u-w sudoers 注意一点，CentOS 7预设容许任何帐号透过ssh登入（也就是说自己根本不用改改，直接新建帐号登录即可），包括根和一般帐号，为了不受根帐号被黑客暴力入侵，我们必须禁止 root帐号的ssh功能，事实上root也没有必要ssh登入伺服器，因为只要使用su或sudo（当然需要输入root的密码）普通帐号便可以拥有root的权限。使用vim（或任何文本编辑器）开启的/ etc/ SSH/ sshd_config中，寻找： 1＃PermitRootLogin yes 修改： 1PermitRootLogin no 配置公私钥加密登录这一步骤要切换到自己新建的用户，不能再用 root 用户了，否则可能无法正常登陆。 很多时候以上所说的还是不够安全，为了更加安全方便，我们采用公私钥对称加密登录，简单的讲做法就是再客户端生成一把私钥一把公钥，私钥是在客户端的，公钥上传到服务端，对称加密进行登录。 在客户端先进到这个目录： 1cd ~/.ssh 生成公钥和私钥（实际上如果之前有的话就不用重新生成了） 1ssh-keygen -t rsa 接下来把公钥上传到服务端 1scp ~/.ssh/id_rsa.pub xiaotao@&lt;ssh_server_ip&gt;:~ 在服务端执行以下命令(如果没有相关的文件和文件夹要先进行创建，注意不要使用 sudo ) 1cat id_rsa.pub &gt;&gt; ～/.ssh/authorized_keys 配置服务器的/etc/ssh/sshd_config，下面是一些建议的配置： 1234567891011121314151617vim /etc/ssh/sshd_config# 禁用root账户登录，非必要，但为了安全性，请配置PermitRootLogin no# 是否让 sshd 去检查用户家目录或相关档案的权限数据，# 这是为了担心使用者将某些重要档案的权限设错，可能会导致一些问题所致。# 例如使用者的 ~.ssh/ 权限设错时，某些特殊情况下会不许用户登入StrictModes no# 是否允许用户自行使用成对的密钥系统进行登入行为，仅针对 version 2。# 至于自制的公钥数据就放置于用户家目录下的 .ssh/authorized_keys 内RSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile %h/.ssh/authorized_keys#有了证书登录了，就禁用密码登录吧，安全要紧PasswordAuthentication no 然后不要忘记 sudo service sshd restart 一般来讲，这样就算是成功了，我们可以在客户端尝试： 1ssh -i ~/.ssh/id_rsa remote_username@remote_ip 如果不行，可能是服务端或客户端相关 .ssh 文件权限不对，可以进行如下尝试： 123456服务端chown -R 0700 ~/.sshchown -R 0644 ~/.ssh/authorized_keys客户端改一下chmod 600 id_rsa","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.alterem.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.alterem.top/tags/Linux/"},{"name":"SSH","slug":"SSH","permalink":"http://blog.alterem.top/tags/SSH/"}]},{"title":"CentOS7下安装和配置redis","slug":"CentOS7下安装和配置redis","date":"2018-09-11T03:28:51.000Z","updated":"2019-03-15T13:13:12.000Z","comments":true,"path":"2018/09/11/CentOS7下安装和配置redis/","link":"","permalink":"http://blog.alterem.top/2018/09/11/CentOS7下安装和配置redis/","excerpt":"Redis是一个高性能的，开源key-value型数据库。是构建高性能，可扩展的Web应用的完美解决方案，可以内存存储亦可持久化存储。因为要使用跨进程，跨服务级别的数据缓存，在对比多个方案后，决定使用Redis。顺便整理下Redis的安装过程，以便查阅。 1 . 下载Redis目前，最新的Redist版本为3.0，使用wget下载，命令如下： 1# wget http://download.redis.io/releases/redis-3.0.4.tar.gz","text":"Redis是一个高性能的，开源key-value型数据库。是构建高性能，可扩展的Web应用的完美解决方案，可以内存存储亦可持久化存储。因为要使用跨进程，跨服务级别的数据缓存，在对比多个方案后，决定使用Redis。顺便整理下Redis的安装过程，以便查阅。 1 . 下载Redis目前，最新的Redist版本为3.0，使用wget下载，命令如下： 1# wget http://download.redis.io/releases/redis-3.0.4.tar.gz 2 . 解压Redis下载完成后，使用tar命令解压下载文件： 1# tar -xzvf redis-3.0.4.tar.gz 3 . 编译安装Redis切换至程序目录，并执行make命令编译： 12# cd redis-3.0.4# make 执行安装命令 1# make install make install安装完成后，会在/usr/local/bin目录下生成下面几个可执行文件，它们的作用分别是： redis-server：Redis服务器端启动程序 redis-cli：Redis客户端操作工具。也可以用telnet根据其纯文本协议来操作 redis-benchmark：Redis性能测试工具 redis-check-aof：数据修复工具 redis-check-dump：检查导出工具 备注 有的机器会出现类似以下错误： 123make[1]: Entering directory `/root/redis/src'You need tcl 8.5 or newer in order to run the Redis test…… 这是因为没有安装tcl导致，yum安装即可： 1yum install tcl 4 . 配置Redis复制配置文件到/etc/目录： 1# cp redis.conf /etc/ 为了让Redis后台运行，一般还需要修改redis.conf文件： 1vi /etc/redis.conf 修改daemonize配置项为yes，使Redis进程在后台运行： 1daemonize yes 5 . 启动Redis配置完成后，启动Redis： 12# cd /usr/local/bin# ./redis-server /etc/redis.conf 检查启动情况： 1# ps -ef | grep redis 看到类似下面的一行，表示启动成功： 1root 18443 1 0 13:05 ? 00:00:00 ./redis-server *:6379 6 . 添加开机启动项让Redis开机运行可以将其添加到rc.local文件，也可将添加为系统服务service。本文使用rc.local的方式，添加service请参考：Redis 配置为 Service 系统服务 。 为了能让Redis在服务器重启后自动启动，需要将启动命令写入开机启动项： 1echo \"/usr/local/bin/redis-server /etc/redis.conf\" &gt;&gt;/etc/rc.local 7 . Redis配置参数在 前面的操作中，我们用到了使Redis进程在后台运行的参数，下面介绍其它一些常用的Redis启动参数： daemonize：是否以后台daemon方式运行pidfile：pid文件位置port：监听的端口号timeout：请求超时时间loglevel：log信息级别logfile：log文件位置databases：开启数据库的数量save ：保存快照的频率，第一个表示多长时间，第三个表示执行多少次写操作。在一定时间内执行一定数量的写操作时，自动保存快照。可设置多个条件。rdbcompression：是否使用压缩dbfilename：数据快照文件名（只是文件名）dir：数据快照的保存目录（仅目录）appendonly：是否开启appendonlylog，开启的话每次写操作会记一条log，这会提高数据抗风险能力，但影响效率。appendfsync：appendonlylog如何同步到磁盘。三个选项，分别是每次写都强制调用fsync、每秒启用一次fsync、不调用fsync等待系统自己同步","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.alterem.top/categories/Linux/"},{"name":"Server","slug":"Linux/Server","permalink":"http://blog.alterem.top/categories/Linux/Server/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"http://blog.alterem.top/tags/CentOS/"},{"name":"Redis","slug":"Redis","permalink":"http://blog.alterem.top/tags/Redis/"}]},{"title":"CentOS安装node8.x版本","slug":"CentOS安装node8-x版本","date":"2018-09-11T03:08:49.000Z","updated":"2019-03-15T13:13:32.000Z","comments":true,"path":"2018/09/11/CentOS安装node8-x版本/","link":"","permalink":"http://blog.alterem.top/2018/09/11/CentOS安装node8-x版本/","excerpt":"由于一些原因需要给CentOS服务器安装8.0以上版本的node, 本来直接通过yum管理安装管理，但是没找到好办法，在此记录一下自己最后使用的简单过程： 安装之前删除原来的node和npm (我原来是用yum安装的，如果是第一次安装可以省略这一步): 1yum remove nodejs npm -y","text":"由于一些原因需要给CentOS服务器安装8.0以上版本的node, 本来直接通过yum管理安装管理，但是没找到好办法，在此记录一下自己最后使用的简单过程： 安装之前删除原来的node和npm (我原来是用yum安装的，如果是第一次安装可以省略这一步): 1yum remove nodejs npm -y 首先我们随便进入服务器的一个目录，然后从淘宝的源拉取内容: 1wget https://npm.taobao.org/mirrors/node/v8.0.0/node-v8.0.0-linux-x64.tar.xz 解压缩: 1sudo tar -xvf node-v8.0.0-linux-x64.tar.xz 进入解压目录下的 bin 目录，执行 ls 命令 1cd node-v8.0.0-linux-x64/bin &amp;&amp; ls 我们发现有node 和 npm 这个时候我们测试: 1./node -v 这个时候我们发现实际上已经安装好了，接下来就是要建立链接文件。 这里还是，如果我们之前已经安装过了，那么我们要先删除之前建立的链接文件： 12sudo rm -rf /usr/bin/nodesudo rm -rf /usr/bin/npm 然后建立链接文件: 12sudo ln -s /usr/share/node-v8.0.0-linux-x64/bin/node /usr/bin/nodesudo ln -s /usr/share/node-v8.0.0-linux-x64/bin/npm /usr/bin/npm 注意这里的第一个路径不要直接复制粘贴，要写当前文件的真正的路径，这个可以通过pwd获取。 然后我们可以通过node -v等测试已经安装成功。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.alterem.top/categories/Linux/"},{"name":"Server","slug":"Linux/Server","permalink":"http://blog.alterem.top/categories/Linux/Server/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"http://blog.alterem.top/tags/CentOS/"},{"name":"node","slug":"node","permalink":"http://blog.alterem.top/tags/node/"}]},{"title":"Eclipse中常用的操作单词","slug":"Eclipse中常用的操作单词","date":"2018-09-11T01:30:38.000Z","updated":"2019-03-15T13:13:50.000Z","comments":true,"path":"2018/09/11/Eclipse中常用的操作单词/","link":"","permalink":"http://blog.alterem.top/2018/09/11/Eclipse中常用的操作单词/","excerpt":"Existing Project into Workspace 现有的工程引入工作空间(加载工程) File 文件 New 新建 Project 工程 Folder 文件夹 Import 引入(加载&amp;导入) Run As 运行 Application 应用程序 copy 复制 paste 粘贴 Delete 删除 properties 属性 Java Build Path 建立java路径 Libraries 库 Add Library 添加库 User Library 用户库 Next 下一步 User Libraries 用户库 New 新建 JDBC-ODBC 桥","text":"Existing Project into Workspace 现有的工程引入工作空间(加载工程) File 文件 New 新建 Project 工程 Folder 文件夹 Import 引入(加载&amp;导入) Run As 运行 Application 应用程序 copy 复制 paste 粘贴 Delete 删除 properties 属性 Java Build Path 建立java路径 Libraries 库 Add Library 添加库 User Library 用户库 Next 下一步 User Libraries 用户库 New 新建 JDBC-ODBC 桥 需掌握的单词 overload 重载 override 重写(覆盖) 程序编写时常用的单词 package 指定文件夹 class 类 static 静态类型 TRUE 真 FALSE 假 String 字符串对象(也是一种数据类型) extends 继承 this 当前对象引用 super 父类对象引用 Math.random() 随机数 interface 接口 implements 继承接口 throw 抛出 throws 抛出 try 尝试 catch 捕获 Exception 异常 Separator 分割线 基本数据类型(返回值类型中的一部分) 英文 类型 默认值 封装类 byte 字节型 0b Byte char 字符型 ‘\\u0000’ Character short 短整型 0 Short int 整型 0 Integer long 长整型 0 Long float 单精度浮点型 0.0f Float double 双精度浮点型 0 Double boolean 布尔型 flase Boolean String 字符串 null String 访问控制修饰符 public 公有的 protected 公共的(保护的) private 私有的 类修饰符 final 最终 new 新的 abstract 抽象 finally 最终的 逻辑关键字 if 如果 else 否则 switch 开关 case 事件 default 默认 for (循环) while (循环) do-while (循环) continue 继续 break 打破 类 ArrayList 数组集合 add(Object); 添加数据 get(int); 获得数据 Thread 线程 Runnable 可捕获的 控制数据库常用 Class.forName 加载数据库驱动程序 Connection 数据库连接对象 Statement 数据库操纵对象 ResultSet 数据库结果集对象 close 关闭 DriverManager 驱动管理器 localhost 本地主机 executeQuery 执行命令 executeUpdate 执行更新 SQLException SQL数据库异常 ClassNotFoundException 类没有被找到异常 view 视图 trigger 触发器 proc 存储过程 removeAll 移除所有 rs.first() 游标移动到第一条记录 rs.last() 游标移动到最后一条记录 rs.getRow() 获得当前的行号 rs.absolute(i) 定位游标 top 最前 JavaBean 存放数据 窗体 show 展示 this.setTitle 设置标题 this.setSize(500,400); 窗体大小 this.setLocation(260,150); 窗体初始位置 this.show(); 显示窗体 this.setLocationRelativeTo(null); 居中 this.setDefaultCloseOperation(3); 关闭按扭起作用 this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); 关闭按扭起作用 JLabel lbl = new JLabel(new ImageIcon(“1.gif”)); 图片标签 getContentPane 获得窗体的内部窗格 setBackground(Color.BLUE) 设置背景颜色 setResizable() 设置是否能最大化()内 填true或false setAlwaysOnTop() 窗口在最顶端()内 填true或false Font 字体 showMessageDialog 弹出对话框 append 追加 valueChanged 改变数值 requestFocus 获得焦点 selectAll 全选 setText 设置文本域内容 getText 获得文本域内容 setEnabled() 设置控件是否可用()内 填true或false setAccelerator 设置加速器 KeyStroke 敲击键盘 getKeyStroke 获得所敲击的键盘 InputEvent 输入事件 getDocument 获得文件 addUndoableEditListener 添加撤销监听器 SimpleDateFormat 简易日期格式 setLineWrap 设置行距 addEdit 添加编辑 getEdit 获得编辑 setBorder 设置边框 Factory 工厂 createTitledBorder 创建标题边框 setVisible() 设置视窗是否隐藏()内 填true或false setCursor 设置指针 isPopupTrigger 确定点鼠标击右键 getSelectedValue 获得选中的值 toString 返回字符串 insertIcon 插入图标 getActionCommand 获得动作命令 getKeyCode 获得键盘码 KeyEvent.VK_RIGHT 键盘事件.右箭头 getIcon 获得标签 setIcon 设置标签 getSource 获得所选 charAt() 查找指定下标所对应的字符 indexOf() 查找某一字符串，首次出现的位置(从前向后) lastIndexOf() 查找某一字符串，首次出现的位置(从后向前) length() 返回字符串长度 equals() 比较两个字符串 toUpperCase() 转为大写 toLowerCase() 转为小写 split() 分割字符串 replace() 替换 .addRow(Object[]) 添加一条记录 setRowCount(0) 清空表模型 repaint 重绘 ComboBox.getSelectedItem 获得下拉框所选择的内容 ComboBox.addItem(rs.getString(1)) 重新添加下拉框内容 g.setColor(Color.RED) 设置画笔颜色 g.setFont(new Font(“隶书”,Font.BOLD,30)) 设置画笔字体 g.drawString(“早晨好”,100,200) 画字符串 g.drawLine(100,100,500,500) 画线 g.drawOval(200,200,300,150) 画椭圆 g.fillOval(200,200,300,150) 填充椭圆 g.drawRect(200,200,300,150) 画矩形 this.setUndecorated(true) 去除窗体边框 Thread.currentThread() 获得当前正在运行的线程 Graphics 画笔 t.suspend() 线程挂起 t.resume() 恢复线程 布局 FlowLayout 流式布局 LEFT 左 RIGHT 右 BorderLayout 边界布局 EAST 东 SOUTH 南 WEST 西 NORTH 北 CENTER 中 GridLayout 网格部局 (选择记忆) Container 容器 JPanel 面板 JFrame 窗体 JButton 按扭 JLabel 标签 JTextField 文本域(单行的文本框) JTextArea 文本区 JPasswordField 密码域 ButtonGroup 按扭组(单选) JRadioButton 单选按扭 JCheckBox 多选按扭 JComboBox 下拉框 JList 下拉列表 ImageIcon 图片 JMenuBar 菜单工具栏 JMenu 菜单项 JMenuItem 子菜单项 JCheckBoxMenuItem 多选按钮菜单工具栏 JRadioButtonMenuItem 单选按钮菜单工具栏 JScrollPane 滚动面板 JTextPane 文本面板 JPopupMenu 弹出菜单 JProgressBar 进度条 DefaultTableModel 默认的表模型 JTable 表格 ActionListener 监听器 ActionEvent 动作事件 actionPerformed 动作演示 KeyListener 键盘监听器 KeyEvent 键盘事件 keyPressed 按下键盘 keyReleased 释放键盘 keyTyped 点击键盘 MouseListener 鼠标监听器 MouseEvent 鼠标事件 mouseClicked 鼠标单击事件 mouseEntered 鼠标移入事件 mouseExited 鼠标离开事件 mousePressed 按下鼠标事件 mouseReleased 释放鼠标事件 MouseMotionListener 鼠标监听器 mouseDragged 拖拽鼠标 mouseMoved 移动鼠标 ListSelectionListener 下拉列表监听器 ListSelectionEvent 下拉列表选择事件 JOptionPane 有选项的面板 UndoableEditListener 撤消监听器 UndoableEditEvent 撤消事件 undoableEditHappened 撤消 包 java.awt.*; java.lang.*; java.util.*; java.text.*; javax.swing.*; java.awt.event.*; import java.sql.*; javax.swing.undo.*; java.swing.table.*; javax.swing.event.*;","categories":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://blog.alterem.top/categories/Eclipse/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://blog.alterem.top/tags/Eclipse/"},{"name":"单词","slug":"单词","permalink":"http://blog.alterem.top/tags/单词/"}]}]}